
Inventario_V2.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000c0  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00014c14  080000c0  080000c0  000100c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000750  08014cd8  08014cd8  00024cd8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08015428  08015428  00030438  2**0
                  CONTENTS
  4 .ARM          00000008  08015428  08015428  00025428  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  08015430  08015430  00030438  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08015430  08015430  00025430  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08015434  08015434  00025434  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000438  20000000  08015438  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00003010  20000438  08015870  00030438  2**2
                  ALLOC
 10 ._user_heap_stack 00000600  20003448  08015870  00033448  2**0
                  ALLOC
 11 .ARM.attributes 00000028  00000000  00000000  00030438  2**0
                  CONTENTS, READONLY
 12 .debug_info   0003e1a4  00000000  00000000  00030460  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 00004a70  00000000  00000000  0006e604  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 00001e90  00000000  00000000  00073078  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00001ca0  00000000  00000000  00074f08  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macro  0001d564  00000000  00000000  00076ba8  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_line   0001ae02  00000000  00000000  0009410c  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_str    000a8867  00000000  00000000  000aef0e  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .comment      0000007b  00000000  00000000  00157775  2**0
                  CONTENTS, READONLY
 20 .debug_frame  00007a20  00000000  00000000  001577f0  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080000c0 <__do_global_dtors_aux>:
 80000c0:	b510      	push	{r4, lr}
 80000c2:	4c06      	ldr	r4, [pc, #24]	; (80000dc <__do_global_dtors_aux+0x1c>)
 80000c4:	7823      	ldrb	r3, [r4, #0]
 80000c6:	2b00      	cmp	r3, #0
 80000c8:	d107      	bne.n	80000da <__do_global_dtors_aux+0x1a>
 80000ca:	4b05      	ldr	r3, [pc, #20]	; (80000e0 <__do_global_dtors_aux+0x20>)
 80000cc:	2b00      	cmp	r3, #0
 80000ce:	d002      	beq.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d0:	4804      	ldr	r0, [pc, #16]	; (80000e4 <__do_global_dtors_aux+0x24>)
 80000d2:	e000      	b.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d4:	bf00      	nop
 80000d6:	2301      	movs	r3, #1
 80000d8:	7023      	strb	r3, [r4, #0]
 80000da:	bd10      	pop	{r4, pc}
 80000dc:	20000438 	.word	0x20000438
 80000e0:	00000000 	.word	0x00000000
 80000e4:	08014cbc 	.word	0x08014cbc

080000e8 <frame_dummy>:
 80000e8:	4b04      	ldr	r3, [pc, #16]	; (80000fc <frame_dummy+0x14>)
 80000ea:	b510      	push	{r4, lr}
 80000ec:	2b00      	cmp	r3, #0
 80000ee:	d003      	beq.n	80000f8 <frame_dummy+0x10>
 80000f0:	4903      	ldr	r1, [pc, #12]	; (8000100 <frame_dummy+0x18>)
 80000f2:	4804      	ldr	r0, [pc, #16]	; (8000104 <frame_dummy+0x1c>)
 80000f4:	e000      	b.n	80000f8 <frame_dummy+0x10>
 80000f6:	bf00      	nop
 80000f8:	bd10      	pop	{r4, pc}
 80000fa:	46c0      	nop			; (mov r8, r8)
 80000fc:	00000000 	.word	0x00000000
 8000100:	2000043c 	.word	0x2000043c
 8000104:	08014cbc 	.word	0x08014cbc

08000108 <strlen>:
 8000108:	2300      	movs	r3, #0
 800010a:	5cc2      	ldrb	r2, [r0, r3]
 800010c:	3301      	adds	r3, #1
 800010e:	2a00      	cmp	r2, #0
 8000110:	d1fb      	bne.n	800010a <strlen+0x2>
 8000112:	1e58      	subs	r0, r3, #1
 8000114:	4770      	bx	lr
	...

08000118 <__gnu_thumb1_case_uqi>:
 8000118:	b402      	push	{r1}
 800011a:	4671      	mov	r1, lr
 800011c:	0849      	lsrs	r1, r1, #1
 800011e:	0049      	lsls	r1, r1, #1
 8000120:	5c09      	ldrb	r1, [r1, r0]
 8000122:	0049      	lsls	r1, r1, #1
 8000124:	448e      	add	lr, r1
 8000126:	bc02      	pop	{r1}
 8000128:	4770      	bx	lr
 800012a:	46c0      	nop			; (mov r8, r8)

0800012c <__udivsi3>:
 800012c:	2200      	movs	r2, #0
 800012e:	0843      	lsrs	r3, r0, #1
 8000130:	428b      	cmp	r3, r1
 8000132:	d374      	bcc.n	800021e <__udivsi3+0xf2>
 8000134:	0903      	lsrs	r3, r0, #4
 8000136:	428b      	cmp	r3, r1
 8000138:	d35f      	bcc.n	80001fa <__udivsi3+0xce>
 800013a:	0a03      	lsrs	r3, r0, #8
 800013c:	428b      	cmp	r3, r1
 800013e:	d344      	bcc.n	80001ca <__udivsi3+0x9e>
 8000140:	0b03      	lsrs	r3, r0, #12
 8000142:	428b      	cmp	r3, r1
 8000144:	d328      	bcc.n	8000198 <__udivsi3+0x6c>
 8000146:	0c03      	lsrs	r3, r0, #16
 8000148:	428b      	cmp	r3, r1
 800014a:	d30d      	bcc.n	8000168 <__udivsi3+0x3c>
 800014c:	22ff      	movs	r2, #255	; 0xff
 800014e:	0209      	lsls	r1, r1, #8
 8000150:	ba12      	rev	r2, r2
 8000152:	0c03      	lsrs	r3, r0, #16
 8000154:	428b      	cmp	r3, r1
 8000156:	d302      	bcc.n	800015e <__udivsi3+0x32>
 8000158:	1212      	asrs	r2, r2, #8
 800015a:	0209      	lsls	r1, r1, #8
 800015c:	d065      	beq.n	800022a <__udivsi3+0xfe>
 800015e:	0b03      	lsrs	r3, r0, #12
 8000160:	428b      	cmp	r3, r1
 8000162:	d319      	bcc.n	8000198 <__udivsi3+0x6c>
 8000164:	e000      	b.n	8000168 <__udivsi3+0x3c>
 8000166:	0a09      	lsrs	r1, r1, #8
 8000168:	0bc3      	lsrs	r3, r0, #15
 800016a:	428b      	cmp	r3, r1
 800016c:	d301      	bcc.n	8000172 <__udivsi3+0x46>
 800016e:	03cb      	lsls	r3, r1, #15
 8000170:	1ac0      	subs	r0, r0, r3
 8000172:	4152      	adcs	r2, r2
 8000174:	0b83      	lsrs	r3, r0, #14
 8000176:	428b      	cmp	r3, r1
 8000178:	d301      	bcc.n	800017e <__udivsi3+0x52>
 800017a:	038b      	lsls	r3, r1, #14
 800017c:	1ac0      	subs	r0, r0, r3
 800017e:	4152      	adcs	r2, r2
 8000180:	0b43      	lsrs	r3, r0, #13
 8000182:	428b      	cmp	r3, r1
 8000184:	d301      	bcc.n	800018a <__udivsi3+0x5e>
 8000186:	034b      	lsls	r3, r1, #13
 8000188:	1ac0      	subs	r0, r0, r3
 800018a:	4152      	adcs	r2, r2
 800018c:	0b03      	lsrs	r3, r0, #12
 800018e:	428b      	cmp	r3, r1
 8000190:	d301      	bcc.n	8000196 <__udivsi3+0x6a>
 8000192:	030b      	lsls	r3, r1, #12
 8000194:	1ac0      	subs	r0, r0, r3
 8000196:	4152      	adcs	r2, r2
 8000198:	0ac3      	lsrs	r3, r0, #11
 800019a:	428b      	cmp	r3, r1
 800019c:	d301      	bcc.n	80001a2 <__udivsi3+0x76>
 800019e:	02cb      	lsls	r3, r1, #11
 80001a0:	1ac0      	subs	r0, r0, r3
 80001a2:	4152      	adcs	r2, r2
 80001a4:	0a83      	lsrs	r3, r0, #10
 80001a6:	428b      	cmp	r3, r1
 80001a8:	d301      	bcc.n	80001ae <__udivsi3+0x82>
 80001aa:	028b      	lsls	r3, r1, #10
 80001ac:	1ac0      	subs	r0, r0, r3
 80001ae:	4152      	adcs	r2, r2
 80001b0:	0a43      	lsrs	r3, r0, #9
 80001b2:	428b      	cmp	r3, r1
 80001b4:	d301      	bcc.n	80001ba <__udivsi3+0x8e>
 80001b6:	024b      	lsls	r3, r1, #9
 80001b8:	1ac0      	subs	r0, r0, r3
 80001ba:	4152      	adcs	r2, r2
 80001bc:	0a03      	lsrs	r3, r0, #8
 80001be:	428b      	cmp	r3, r1
 80001c0:	d301      	bcc.n	80001c6 <__udivsi3+0x9a>
 80001c2:	020b      	lsls	r3, r1, #8
 80001c4:	1ac0      	subs	r0, r0, r3
 80001c6:	4152      	adcs	r2, r2
 80001c8:	d2cd      	bcs.n	8000166 <__udivsi3+0x3a>
 80001ca:	09c3      	lsrs	r3, r0, #7
 80001cc:	428b      	cmp	r3, r1
 80001ce:	d301      	bcc.n	80001d4 <__udivsi3+0xa8>
 80001d0:	01cb      	lsls	r3, r1, #7
 80001d2:	1ac0      	subs	r0, r0, r3
 80001d4:	4152      	adcs	r2, r2
 80001d6:	0983      	lsrs	r3, r0, #6
 80001d8:	428b      	cmp	r3, r1
 80001da:	d301      	bcc.n	80001e0 <__udivsi3+0xb4>
 80001dc:	018b      	lsls	r3, r1, #6
 80001de:	1ac0      	subs	r0, r0, r3
 80001e0:	4152      	adcs	r2, r2
 80001e2:	0943      	lsrs	r3, r0, #5
 80001e4:	428b      	cmp	r3, r1
 80001e6:	d301      	bcc.n	80001ec <__udivsi3+0xc0>
 80001e8:	014b      	lsls	r3, r1, #5
 80001ea:	1ac0      	subs	r0, r0, r3
 80001ec:	4152      	adcs	r2, r2
 80001ee:	0903      	lsrs	r3, r0, #4
 80001f0:	428b      	cmp	r3, r1
 80001f2:	d301      	bcc.n	80001f8 <__udivsi3+0xcc>
 80001f4:	010b      	lsls	r3, r1, #4
 80001f6:	1ac0      	subs	r0, r0, r3
 80001f8:	4152      	adcs	r2, r2
 80001fa:	08c3      	lsrs	r3, r0, #3
 80001fc:	428b      	cmp	r3, r1
 80001fe:	d301      	bcc.n	8000204 <__udivsi3+0xd8>
 8000200:	00cb      	lsls	r3, r1, #3
 8000202:	1ac0      	subs	r0, r0, r3
 8000204:	4152      	adcs	r2, r2
 8000206:	0883      	lsrs	r3, r0, #2
 8000208:	428b      	cmp	r3, r1
 800020a:	d301      	bcc.n	8000210 <__udivsi3+0xe4>
 800020c:	008b      	lsls	r3, r1, #2
 800020e:	1ac0      	subs	r0, r0, r3
 8000210:	4152      	adcs	r2, r2
 8000212:	0843      	lsrs	r3, r0, #1
 8000214:	428b      	cmp	r3, r1
 8000216:	d301      	bcc.n	800021c <__udivsi3+0xf0>
 8000218:	004b      	lsls	r3, r1, #1
 800021a:	1ac0      	subs	r0, r0, r3
 800021c:	4152      	adcs	r2, r2
 800021e:	1a41      	subs	r1, r0, r1
 8000220:	d200      	bcs.n	8000224 <__udivsi3+0xf8>
 8000222:	4601      	mov	r1, r0
 8000224:	4152      	adcs	r2, r2
 8000226:	4610      	mov	r0, r2
 8000228:	4770      	bx	lr
 800022a:	e7ff      	b.n	800022c <__udivsi3+0x100>
 800022c:	b501      	push	{r0, lr}
 800022e:	2000      	movs	r0, #0
 8000230:	f000 f8f0 	bl	8000414 <__aeabi_idiv0>
 8000234:	bd02      	pop	{r1, pc}
 8000236:	46c0      	nop			; (mov r8, r8)

08000238 <__aeabi_uidivmod>:
 8000238:	2900      	cmp	r1, #0
 800023a:	d0f7      	beq.n	800022c <__udivsi3+0x100>
 800023c:	e776      	b.n	800012c <__udivsi3>
 800023e:	4770      	bx	lr

08000240 <__divsi3>:
 8000240:	4603      	mov	r3, r0
 8000242:	430b      	orrs	r3, r1
 8000244:	d47f      	bmi.n	8000346 <__divsi3+0x106>
 8000246:	2200      	movs	r2, #0
 8000248:	0843      	lsrs	r3, r0, #1
 800024a:	428b      	cmp	r3, r1
 800024c:	d374      	bcc.n	8000338 <__divsi3+0xf8>
 800024e:	0903      	lsrs	r3, r0, #4
 8000250:	428b      	cmp	r3, r1
 8000252:	d35f      	bcc.n	8000314 <__divsi3+0xd4>
 8000254:	0a03      	lsrs	r3, r0, #8
 8000256:	428b      	cmp	r3, r1
 8000258:	d344      	bcc.n	80002e4 <__divsi3+0xa4>
 800025a:	0b03      	lsrs	r3, r0, #12
 800025c:	428b      	cmp	r3, r1
 800025e:	d328      	bcc.n	80002b2 <__divsi3+0x72>
 8000260:	0c03      	lsrs	r3, r0, #16
 8000262:	428b      	cmp	r3, r1
 8000264:	d30d      	bcc.n	8000282 <__divsi3+0x42>
 8000266:	22ff      	movs	r2, #255	; 0xff
 8000268:	0209      	lsls	r1, r1, #8
 800026a:	ba12      	rev	r2, r2
 800026c:	0c03      	lsrs	r3, r0, #16
 800026e:	428b      	cmp	r3, r1
 8000270:	d302      	bcc.n	8000278 <__divsi3+0x38>
 8000272:	1212      	asrs	r2, r2, #8
 8000274:	0209      	lsls	r1, r1, #8
 8000276:	d065      	beq.n	8000344 <__divsi3+0x104>
 8000278:	0b03      	lsrs	r3, r0, #12
 800027a:	428b      	cmp	r3, r1
 800027c:	d319      	bcc.n	80002b2 <__divsi3+0x72>
 800027e:	e000      	b.n	8000282 <__divsi3+0x42>
 8000280:	0a09      	lsrs	r1, r1, #8
 8000282:	0bc3      	lsrs	r3, r0, #15
 8000284:	428b      	cmp	r3, r1
 8000286:	d301      	bcc.n	800028c <__divsi3+0x4c>
 8000288:	03cb      	lsls	r3, r1, #15
 800028a:	1ac0      	subs	r0, r0, r3
 800028c:	4152      	adcs	r2, r2
 800028e:	0b83      	lsrs	r3, r0, #14
 8000290:	428b      	cmp	r3, r1
 8000292:	d301      	bcc.n	8000298 <__divsi3+0x58>
 8000294:	038b      	lsls	r3, r1, #14
 8000296:	1ac0      	subs	r0, r0, r3
 8000298:	4152      	adcs	r2, r2
 800029a:	0b43      	lsrs	r3, r0, #13
 800029c:	428b      	cmp	r3, r1
 800029e:	d301      	bcc.n	80002a4 <__divsi3+0x64>
 80002a0:	034b      	lsls	r3, r1, #13
 80002a2:	1ac0      	subs	r0, r0, r3
 80002a4:	4152      	adcs	r2, r2
 80002a6:	0b03      	lsrs	r3, r0, #12
 80002a8:	428b      	cmp	r3, r1
 80002aa:	d301      	bcc.n	80002b0 <__divsi3+0x70>
 80002ac:	030b      	lsls	r3, r1, #12
 80002ae:	1ac0      	subs	r0, r0, r3
 80002b0:	4152      	adcs	r2, r2
 80002b2:	0ac3      	lsrs	r3, r0, #11
 80002b4:	428b      	cmp	r3, r1
 80002b6:	d301      	bcc.n	80002bc <__divsi3+0x7c>
 80002b8:	02cb      	lsls	r3, r1, #11
 80002ba:	1ac0      	subs	r0, r0, r3
 80002bc:	4152      	adcs	r2, r2
 80002be:	0a83      	lsrs	r3, r0, #10
 80002c0:	428b      	cmp	r3, r1
 80002c2:	d301      	bcc.n	80002c8 <__divsi3+0x88>
 80002c4:	028b      	lsls	r3, r1, #10
 80002c6:	1ac0      	subs	r0, r0, r3
 80002c8:	4152      	adcs	r2, r2
 80002ca:	0a43      	lsrs	r3, r0, #9
 80002cc:	428b      	cmp	r3, r1
 80002ce:	d301      	bcc.n	80002d4 <__divsi3+0x94>
 80002d0:	024b      	lsls	r3, r1, #9
 80002d2:	1ac0      	subs	r0, r0, r3
 80002d4:	4152      	adcs	r2, r2
 80002d6:	0a03      	lsrs	r3, r0, #8
 80002d8:	428b      	cmp	r3, r1
 80002da:	d301      	bcc.n	80002e0 <__divsi3+0xa0>
 80002dc:	020b      	lsls	r3, r1, #8
 80002de:	1ac0      	subs	r0, r0, r3
 80002e0:	4152      	adcs	r2, r2
 80002e2:	d2cd      	bcs.n	8000280 <__divsi3+0x40>
 80002e4:	09c3      	lsrs	r3, r0, #7
 80002e6:	428b      	cmp	r3, r1
 80002e8:	d301      	bcc.n	80002ee <__divsi3+0xae>
 80002ea:	01cb      	lsls	r3, r1, #7
 80002ec:	1ac0      	subs	r0, r0, r3
 80002ee:	4152      	adcs	r2, r2
 80002f0:	0983      	lsrs	r3, r0, #6
 80002f2:	428b      	cmp	r3, r1
 80002f4:	d301      	bcc.n	80002fa <__divsi3+0xba>
 80002f6:	018b      	lsls	r3, r1, #6
 80002f8:	1ac0      	subs	r0, r0, r3
 80002fa:	4152      	adcs	r2, r2
 80002fc:	0943      	lsrs	r3, r0, #5
 80002fe:	428b      	cmp	r3, r1
 8000300:	d301      	bcc.n	8000306 <__divsi3+0xc6>
 8000302:	014b      	lsls	r3, r1, #5
 8000304:	1ac0      	subs	r0, r0, r3
 8000306:	4152      	adcs	r2, r2
 8000308:	0903      	lsrs	r3, r0, #4
 800030a:	428b      	cmp	r3, r1
 800030c:	d301      	bcc.n	8000312 <__divsi3+0xd2>
 800030e:	010b      	lsls	r3, r1, #4
 8000310:	1ac0      	subs	r0, r0, r3
 8000312:	4152      	adcs	r2, r2
 8000314:	08c3      	lsrs	r3, r0, #3
 8000316:	428b      	cmp	r3, r1
 8000318:	d301      	bcc.n	800031e <__divsi3+0xde>
 800031a:	00cb      	lsls	r3, r1, #3
 800031c:	1ac0      	subs	r0, r0, r3
 800031e:	4152      	adcs	r2, r2
 8000320:	0883      	lsrs	r3, r0, #2
 8000322:	428b      	cmp	r3, r1
 8000324:	d301      	bcc.n	800032a <__divsi3+0xea>
 8000326:	008b      	lsls	r3, r1, #2
 8000328:	1ac0      	subs	r0, r0, r3
 800032a:	4152      	adcs	r2, r2
 800032c:	0843      	lsrs	r3, r0, #1
 800032e:	428b      	cmp	r3, r1
 8000330:	d301      	bcc.n	8000336 <__divsi3+0xf6>
 8000332:	004b      	lsls	r3, r1, #1
 8000334:	1ac0      	subs	r0, r0, r3
 8000336:	4152      	adcs	r2, r2
 8000338:	1a41      	subs	r1, r0, r1
 800033a:	d200      	bcs.n	800033e <__divsi3+0xfe>
 800033c:	4601      	mov	r1, r0
 800033e:	4152      	adcs	r2, r2
 8000340:	4610      	mov	r0, r2
 8000342:	4770      	bx	lr
 8000344:	e05d      	b.n	8000402 <__divsi3+0x1c2>
 8000346:	0fca      	lsrs	r2, r1, #31
 8000348:	d000      	beq.n	800034c <__divsi3+0x10c>
 800034a:	4249      	negs	r1, r1
 800034c:	1003      	asrs	r3, r0, #32
 800034e:	d300      	bcc.n	8000352 <__divsi3+0x112>
 8000350:	4240      	negs	r0, r0
 8000352:	4053      	eors	r3, r2
 8000354:	2200      	movs	r2, #0
 8000356:	469c      	mov	ip, r3
 8000358:	0903      	lsrs	r3, r0, #4
 800035a:	428b      	cmp	r3, r1
 800035c:	d32d      	bcc.n	80003ba <__divsi3+0x17a>
 800035e:	0a03      	lsrs	r3, r0, #8
 8000360:	428b      	cmp	r3, r1
 8000362:	d312      	bcc.n	800038a <__divsi3+0x14a>
 8000364:	22fc      	movs	r2, #252	; 0xfc
 8000366:	0189      	lsls	r1, r1, #6
 8000368:	ba12      	rev	r2, r2
 800036a:	0a03      	lsrs	r3, r0, #8
 800036c:	428b      	cmp	r3, r1
 800036e:	d30c      	bcc.n	800038a <__divsi3+0x14a>
 8000370:	0189      	lsls	r1, r1, #6
 8000372:	1192      	asrs	r2, r2, #6
 8000374:	428b      	cmp	r3, r1
 8000376:	d308      	bcc.n	800038a <__divsi3+0x14a>
 8000378:	0189      	lsls	r1, r1, #6
 800037a:	1192      	asrs	r2, r2, #6
 800037c:	428b      	cmp	r3, r1
 800037e:	d304      	bcc.n	800038a <__divsi3+0x14a>
 8000380:	0189      	lsls	r1, r1, #6
 8000382:	d03a      	beq.n	80003fa <__divsi3+0x1ba>
 8000384:	1192      	asrs	r2, r2, #6
 8000386:	e000      	b.n	800038a <__divsi3+0x14a>
 8000388:	0989      	lsrs	r1, r1, #6
 800038a:	09c3      	lsrs	r3, r0, #7
 800038c:	428b      	cmp	r3, r1
 800038e:	d301      	bcc.n	8000394 <__divsi3+0x154>
 8000390:	01cb      	lsls	r3, r1, #7
 8000392:	1ac0      	subs	r0, r0, r3
 8000394:	4152      	adcs	r2, r2
 8000396:	0983      	lsrs	r3, r0, #6
 8000398:	428b      	cmp	r3, r1
 800039a:	d301      	bcc.n	80003a0 <__divsi3+0x160>
 800039c:	018b      	lsls	r3, r1, #6
 800039e:	1ac0      	subs	r0, r0, r3
 80003a0:	4152      	adcs	r2, r2
 80003a2:	0943      	lsrs	r3, r0, #5
 80003a4:	428b      	cmp	r3, r1
 80003a6:	d301      	bcc.n	80003ac <__divsi3+0x16c>
 80003a8:	014b      	lsls	r3, r1, #5
 80003aa:	1ac0      	subs	r0, r0, r3
 80003ac:	4152      	adcs	r2, r2
 80003ae:	0903      	lsrs	r3, r0, #4
 80003b0:	428b      	cmp	r3, r1
 80003b2:	d301      	bcc.n	80003b8 <__divsi3+0x178>
 80003b4:	010b      	lsls	r3, r1, #4
 80003b6:	1ac0      	subs	r0, r0, r3
 80003b8:	4152      	adcs	r2, r2
 80003ba:	08c3      	lsrs	r3, r0, #3
 80003bc:	428b      	cmp	r3, r1
 80003be:	d301      	bcc.n	80003c4 <__divsi3+0x184>
 80003c0:	00cb      	lsls	r3, r1, #3
 80003c2:	1ac0      	subs	r0, r0, r3
 80003c4:	4152      	adcs	r2, r2
 80003c6:	0883      	lsrs	r3, r0, #2
 80003c8:	428b      	cmp	r3, r1
 80003ca:	d301      	bcc.n	80003d0 <__divsi3+0x190>
 80003cc:	008b      	lsls	r3, r1, #2
 80003ce:	1ac0      	subs	r0, r0, r3
 80003d0:	4152      	adcs	r2, r2
 80003d2:	d2d9      	bcs.n	8000388 <__divsi3+0x148>
 80003d4:	0843      	lsrs	r3, r0, #1
 80003d6:	428b      	cmp	r3, r1
 80003d8:	d301      	bcc.n	80003de <__divsi3+0x19e>
 80003da:	004b      	lsls	r3, r1, #1
 80003dc:	1ac0      	subs	r0, r0, r3
 80003de:	4152      	adcs	r2, r2
 80003e0:	1a41      	subs	r1, r0, r1
 80003e2:	d200      	bcs.n	80003e6 <__divsi3+0x1a6>
 80003e4:	4601      	mov	r1, r0
 80003e6:	4663      	mov	r3, ip
 80003e8:	4152      	adcs	r2, r2
 80003ea:	105b      	asrs	r3, r3, #1
 80003ec:	4610      	mov	r0, r2
 80003ee:	d301      	bcc.n	80003f4 <__divsi3+0x1b4>
 80003f0:	4240      	negs	r0, r0
 80003f2:	2b00      	cmp	r3, #0
 80003f4:	d500      	bpl.n	80003f8 <__divsi3+0x1b8>
 80003f6:	4249      	negs	r1, r1
 80003f8:	4770      	bx	lr
 80003fa:	4663      	mov	r3, ip
 80003fc:	105b      	asrs	r3, r3, #1
 80003fe:	d300      	bcc.n	8000402 <__divsi3+0x1c2>
 8000400:	4240      	negs	r0, r0
 8000402:	b501      	push	{r0, lr}
 8000404:	2000      	movs	r0, #0
 8000406:	f000 f805 	bl	8000414 <__aeabi_idiv0>
 800040a:	bd02      	pop	{r1, pc}

0800040c <__aeabi_idivmod>:
 800040c:	2900      	cmp	r1, #0
 800040e:	d0f8      	beq.n	8000402 <__divsi3+0x1c2>
 8000410:	e716      	b.n	8000240 <__divsi3>
 8000412:	4770      	bx	lr

08000414 <__aeabi_idiv0>:
 8000414:	4770      	bx	lr
 8000416:	46c0      	nop			; (mov r8, r8)

08000418 <__aeabi_cdrcmple>:
 8000418:	4684      	mov	ip, r0
 800041a:	1c10      	adds	r0, r2, #0
 800041c:	4662      	mov	r2, ip
 800041e:	468c      	mov	ip, r1
 8000420:	1c19      	adds	r1, r3, #0
 8000422:	4663      	mov	r3, ip
 8000424:	e000      	b.n	8000428 <__aeabi_cdcmpeq>
 8000426:	46c0      	nop			; (mov r8, r8)

08000428 <__aeabi_cdcmpeq>:
 8000428:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 800042a:	f001 fcef 	bl	8001e0c <__ledf2>
 800042e:	2800      	cmp	r0, #0
 8000430:	d401      	bmi.n	8000436 <__aeabi_cdcmpeq+0xe>
 8000432:	2100      	movs	r1, #0
 8000434:	42c8      	cmn	r0, r1
 8000436:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

08000438 <__aeabi_dcmpeq>:
 8000438:	b510      	push	{r4, lr}
 800043a:	f001 fc47 	bl	8001ccc <__eqdf2>
 800043e:	4240      	negs	r0, r0
 8000440:	3001      	adds	r0, #1
 8000442:	bd10      	pop	{r4, pc}

08000444 <__aeabi_dcmplt>:
 8000444:	b510      	push	{r4, lr}
 8000446:	f001 fce1 	bl	8001e0c <__ledf2>
 800044a:	2800      	cmp	r0, #0
 800044c:	db01      	blt.n	8000452 <__aeabi_dcmplt+0xe>
 800044e:	2000      	movs	r0, #0
 8000450:	bd10      	pop	{r4, pc}
 8000452:	2001      	movs	r0, #1
 8000454:	bd10      	pop	{r4, pc}
 8000456:	46c0      	nop			; (mov r8, r8)

08000458 <__aeabi_dcmple>:
 8000458:	b510      	push	{r4, lr}
 800045a:	f001 fcd7 	bl	8001e0c <__ledf2>
 800045e:	2800      	cmp	r0, #0
 8000460:	dd01      	ble.n	8000466 <__aeabi_dcmple+0xe>
 8000462:	2000      	movs	r0, #0
 8000464:	bd10      	pop	{r4, pc}
 8000466:	2001      	movs	r0, #1
 8000468:	bd10      	pop	{r4, pc}
 800046a:	46c0      	nop			; (mov r8, r8)

0800046c <__aeabi_dcmpgt>:
 800046c:	b510      	push	{r4, lr}
 800046e:	f001 fc69 	bl	8001d44 <__gedf2>
 8000472:	2800      	cmp	r0, #0
 8000474:	dc01      	bgt.n	800047a <__aeabi_dcmpgt+0xe>
 8000476:	2000      	movs	r0, #0
 8000478:	bd10      	pop	{r4, pc}
 800047a:	2001      	movs	r0, #1
 800047c:	bd10      	pop	{r4, pc}
 800047e:	46c0      	nop			; (mov r8, r8)

08000480 <__aeabi_dcmpge>:
 8000480:	b510      	push	{r4, lr}
 8000482:	f001 fc5f 	bl	8001d44 <__gedf2>
 8000486:	2800      	cmp	r0, #0
 8000488:	da01      	bge.n	800048e <__aeabi_dcmpge+0xe>
 800048a:	2000      	movs	r0, #0
 800048c:	bd10      	pop	{r4, pc}
 800048e:	2001      	movs	r0, #1
 8000490:	bd10      	pop	{r4, pc}
 8000492:	46c0      	nop			; (mov r8, r8)

08000494 <__aeabi_uldivmod>:
 8000494:	2b00      	cmp	r3, #0
 8000496:	d111      	bne.n	80004bc <__aeabi_uldivmod+0x28>
 8000498:	2a00      	cmp	r2, #0
 800049a:	d10f      	bne.n	80004bc <__aeabi_uldivmod+0x28>
 800049c:	2900      	cmp	r1, #0
 800049e:	d100      	bne.n	80004a2 <__aeabi_uldivmod+0xe>
 80004a0:	2800      	cmp	r0, #0
 80004a2:	d002      	beq.n	80004aa <__aeabi_uldivmod+0x16>
 80004a4:	2100      	movs	r1, #0
 80004a6:	43c9      	mvns	r1, r1
 80004a8:	1c08      	adds	r0, r1, #0
 80004aa:	b407      	push	{r0, r1, r2}
 80004ac:	4802      	ldr	r0, [pc, #8]	; (80004b8 <__aeabi_uldivmod+0x24>)
 80004ae:	a102      	add	r1, pc, #8	; (adr r1, 80004b8 <__aeabi_uldivmod+0x24>)
 80004b0:	1840      	adds	r0, r0, r1
 80004b2:	9002      	str	r0, [sp, #8]
 80004b4:	bd03      	pop	{r0, r1, pc}
 80004b6:	46c0      	nop			; (mov r8, r8)
 80004b8:	ffffff5d 	.word	0xffffff5d
 80004bc:	b403      	push	{r0, r1}
 80004be:	4668      	mov	r0, sp
 80004c0:	b501      	push	{r0, lr}
 80004c2:	9802      	ldr	r0, [sp, #8]
 80004c4:	f000 f848 	bl	8000558 <__udivmoddi4>
 80004c8:	9b01      	ldr	r3, [sp, #4]
 80004ca:	469e      	mov	lr, r3
 80004cc:	b002      	add	sp, #8
 80004ce:	bc0c      	pop	{r2, r3}
 80004d0:	4770      	bx	lr
 80004d2:	46c0      	nop			; (mov r8, r8)

080004d4 <__aeabi_lmul>:
 80004d4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80004d6:	46ce      	mov	lr, r9
 80004d8:	4647      	mov	r7, r8
 80004da:	0415      	lsls	r5, r2, #16
 80004dc:	0c2d      	lsrs	r5, r5, #16
 80004de:	002e      	movs	r6, r5
 80004e0:	b580      	push	{r7, lr}
 80004e2:	0407      	lsls	r7, r0, #16
 80004e4:	0c14      	lsrs	r4, r2, #16
 80004e6:	0c3f      	lsrs	r7, r7, #16
 80004e8:	4699      	mov	r9, r3
 80004ea:	0c03      	lsrs	r3, r0, #16
 80004ec:	437e      	muls	r6, r7
 80004ee:	435d      	muls	r5, r3
 80004f0:	4367      	muls	r7, r4
 80004f2:	4363      	muls	r3, r4
 80004f4:	197f      	adds	r7, r7, r5
 80004f6:	0c34      	lsrs	r4, r6, #16
 80004f8:	19e4      	adds	r4, r4, r7
 80004fa:	469c      	mov	ip, r3
 80004fc:	42a5      	cmp	r5, r4
 80004fe:	d903      	bls.n	8000508 <__aeabi_lmul+0x34>
 8000500:	2380      	movs	r3, #128	; 0x80
 8000502:	025b      	lsls	r3, r3, #9
 8000504:	4698      	mov	r8, r3
 8000506:	44c4      	add	ip, r8
 8000508:	464b      	mov	r3, r9
 800050a:	4343      	muls	r3, r0
 800050c:	4351      	muls	r1, r2
 800050e:	0c25      	lsrs	r5, r4, #16
 8000510:	0436      	lsls	r6, r6, #16
 8000512:	4465      	add	r5, ip
 8000514:	0c36      	lsrs	r6, r6, #16
 8000516:	0424      	lsls	r4, r4, #16
 8000518:	19a4      	adds	r4, r4, r6
 800051a:	195b      	adds	r3, r3, r5
 800051c:	1859      	adds	r1, r3, r1
 800051e:	0020      	movs	r0, r4
 8000520:	bc0c      	pop	{r2, r3}
 8000522:	4690      	mov	r8, r2
 8000524:	4699      	mov	r9, r3
 8000526:	bdf0      	pop	{r4, r5, r6, r7, pc}

08000528 <__aeabi_f2uiz>:
 8000528:	219e      	movs	r1, #158	; 0x9e
 800052a:	b510      	push	{r4, lr}
 800052c:	05c9      	lsls	r1, r1, #23
 800052e:	1c04      	adds	r4, r0, #0
 8000530:	f002 fc00 	bl	8002d34 <__aeabi_fcmpge>
 8000534:	2800      	cmp	r0, #0
 8000536:	d103      	bne.n	8000540 <__aeabi_f2uiz+0x18>
 8000538:	1c20      	adds	r0, r4, #0
 800053a:	f000 fd3f 	bl	8000fbc <__aeabi_f2iz>
 800053e:	bd10      	pop	{r4, pc}
 8000540:	219e      	movs	r1, #158	; 0x9e
 8000542:	1c20      	adds	r0, r4, #0
 8000544:	05c9      	lsls	r1, r1, #23
 8000546:	f000 fb75 	bl	8000c34 <__aeabi_fsub>
 800054a:	f000 fd37 	bl	8000fbc <__aeabi_f2iz>
 800054e:	2380      	movs	r3, #128	; 0x80
 8000550:	061b      	lsls	r3, r3, #24
 8000552:	469c      	mov	ip, r3
 8000554:	4460      	add	r0, ip
 8000556:	e7f2      	b.n	800053e <__aeabi_f2uiz+0x16>

08000558 <__udivmoddi4>:
 8000558:	b5f0      	push	{r4, r5, r6, r7, lr}
 800055a:	464f      	mov	r7, r9
 800055c:	4646      	mov	r6, r8
 800055e:	46d6      	mov	lr, sl
 8000560:	b5c0      	push	{r6, r7, lr}
 8000562:	0004      	movs	r4, r0
 8000564:	b082      	sub	sp, #8
 8000566:	000d      	movs	r5, r1
 8000568:	4691      	mov	r9, r2
 800056a:	4698      	mov	r8, r3
 800056c:	428b      	cmp	r3, r1
 800056e:	d82f      	bhi.n	80005d0 <__udivmoddi4+0x78>
 8000570:	d02c      	beq.n	80005cc <__udivmoddi4+0x74>
 8000572:	4641      	mov	r1, r8
 8000574:	4648      	mov	r0, r9
 8000576:	f002 fc05 	bl	8002d84 <__clzdi2>
 800057a:	0029      	movs	r1, r5
 800057c:	0006      	movs	r6, r0
 800057e:	0020      	movs	r0, r4
 8000580:	f002 fc00 	bl	8002d84 <__clzdi2>
 8000584:	1a33      	subs	r3, r6, r0
 8000586:	469c      	mov	ip, r3
 8000588:	3b20      	subs	r3, #32
 800058a:	469a      	mov	sl, r3
 800058c:	d500      	bpl.n	8000590 <__udivmoddi4+0x38>
 800058e:	e076      	b.n	800067e <__udivmoddi4+0x126>
 8000590:	464b      	mov	r3, r9
 8000592:	4652      	mov	r2, sl
 8000594:	4093      	lsls	r3, r2
 8000596:	001f      	movs	r7, r3
 8000598:	464b      	mov	r3, r9
 800059a:	4662      	mov	r2, ip
 800059c:	4093      	lsls	r3, r2
 800059e:	001e      	movs	r6, r3
 80005a0:	42af      	cmp	r7, r5
 80005a2:	d828      	bhi.n	80005f6 <__udivmoddi4+0x9e>
 80005a4:	d025      	beq.n	80005f2 <__udivmoddi4+0x9a>
 80005a6:	4653      	mov	r3, sl
 80005a8:	1ba4      	subs	r4, r4, r6
 80005aa:	41bd      	sbcs	r5, r7
 80005ac:	2b00      	cmp	r3, #0
 80005ae:	da00      	bge.n	80005b2 <__udivmoddi4+0x5a>
 80005b0:	e07b      	b.n	80006aa <__udivmoddi4+0x152>
 80005b2:	2200      	movs	r2, #0
 80005b4:	2300      	movs	r3, #0
 80005b6:	9200      	str	r2, [sp, #0]
 80005b8:	9301      	str	r3, [sp, #4]
 80005ba:	2301      	movs	r3, #1
 80005bc:	4652      	mov	r2, sl
 80005be:	4093      	lsls	r3, r2
 80005c0:	9301      	str	r3, [sp, #4]
 80005c2:	2301      	movs	r3, #1
 80005c4:	4662      	mov	r2, ip
 80005c6:	4093      	lsls	r3, r2
 80005c8:	9300      	str	r3, [sp, #0]
 80005ca:	e018      	b.n	80005fe <__udivmoddi4+0xa6>
 80005cc:	4282      	cmp	r2, r0
 80005ce:	d9d0      	bls.n	8000572 <__udivmoddi4+0x1a>
 80005d0:	2200      	movs	r2, #0
 80005d2:	2300      	movs	r3, #0
 80005d4:	9200      	str	r2, [sp, #0]
 80005d6:	9301      	str	r3, [sp, #4]
 80005d8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80005da:	2b00      	cmp	r3, #0
 80005dc:	d001      	beq.n	80005e2 <__udivmoddi4+0x8a>
 80005de:	601c      	str	r4, [r3, #0]
 80005e0:	605d      	str	r5, [r3, #4]
 80005e2:	9800      	ldr	r0, [sp, #0]
 80005e4:	9901      	ldr	r1, [sp, #4]
 80005e6:	b002      	add	sp, #8
 80005e8:	bc1c      	pop	{r2, r3, r4}
 80005ea:	4690      	mov	r8, r2
 80005ec:	4699      	mov	r9, r3
 80005ee:	46a2      	mov	sl, r4
 80005f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80005f2:	42a3      	cmp	r3, r4
 80005f4:	d9d7      	bls.n	80005a6 <__udivmoddi4+0x4e>
 80005f6:	2200      	movs	r2, #0
 80005f8:	2300      	movs	r3, #0
 80005fa:	9200      	str	r2, [sp, #0]
 80005fc:	9301      	str	r3, [sp, #4]
 80005fe:	4663      	mov	r3, ip
 8000600:	2b00      	cmp	r3, #0
 8000602:	d0e9      	beq.n	80005d8 <__udivmoddi4+0x80>
 8000604:	07fb      	lsls	r3, r7, #31
 8000606:	4698      	mov	r8, r3
 8000608:	4641      	mov	r1, r8
 800060a:	0872      	lsrs	r2, r6, #1
 800060c:	430a      	orrs	r2, r1
 800060e:	087b      	lsrs	r3, r7, #1
 8000610:	4666      	mov	r6, ip
 8000612:	e00e      	b.n	8000632 <__udivmoddi4+0xda>
 8000614:	42ab      	cmp	r3, r5
 8000616:	d101      	bne.n	800061c <__udivmoddi4+0xc4>
 8000618:	42a2      	cmp	r2, r4
 800061a:	d80c      	bhi.n	8000636 <__udivmoddi4+0xde>
 800061c:	1aa4      	subs	r4, r4, r2
 800061e:	419d      	sbcs	r5, r3
 8000620:	2001      	movs	r0, #1
 8000622:	1924      	adds	r4, r4, r4
 8000624:	416d      	adcs	r5, r5
 8000626:	2100      	movs	r1, #0
 8000628:	3e01      	subs	r6, #1
 800062a:	1824      	adds	r4, r4, r0
 800062c:	414d      	adcs	r5, r1
 800062e:	2e00      	cmp	r6, #0
 8000630:	d006      	beq.n	8000640 <__udivmoddi4+0xe8>
 8000632:	42ab      	cmp	r3, r5
 8000634:	d9ee      	bls.n	8000614 <__udivmoddi4+0xbc>
 8000636:	3e01      	subs	r6, #1
 8000638:	1924      	adds	r4, r4, r4
 800063a:	416d      	adcs	r5, r5
 800063c:	2e00      	cmp	r6, #0
 800063e:	d1f8      	bne.n	8000632 <__udivmoddi4+0xda>
 8000640:	9800      	ldr	r0, [sp, #0]
 8000642:	9901      	ldr	r1, [sp, #4]
 8000644:	4653      	mov	r3, sl
 8000646:	1900      	adds	r0, r0, r4
 8000648:	4169      	adcs	r1, r5
 800064a:	2b00      	cmp	r3, #0
 800064c:	db23      	blt.n	8000696 <__udivmoddi4+0x13e>
 800064e:	002b      	movs	r3, r5
 8000650:	4652      	mov	r2, sl
 8000652:	40d3      	lsrs	r3, r2
 8000654:	002a      	movs	r2, r5
 8000656:	4664      	mov	r4, ip
 8000658:	40e2      	lsrs	r2, r4
 800065a:	001c      	movs	r4, r3
 800065c:	4653      	mov	r3, sl
 800065e:	0015      	movs	r5, r2
 8000660:	2b00      	cmp	r3, #0
 8000662:	db2d      	blt.n	80006c0 <__udivmoddi4+0x168>
 8000664:	0026      	movs	r6, r4
 8000666:	4657      	mov	r7, sl
 8000668:	40be      	lsls	r6, r7
 800066a:	0033      	movs	r3, r6
 800066c:	0026      	movs	r6, r4
 800066e:	4667      	mov	r7, ip
 8000670:	40be      	lsls	r6, r7
 8000672:	0032      	movs	r2, r6
 8000674:	1a80      	subs	r0, r0, r2
 8000676:	4199      	sbcs	r1, r3
 8000678:	9000      	str	r0, [sp, #0]
 800067a:	9101      	str	r1, [sp, #4]
 800067c:	e7ac      	b.n	80005d8 <__udivmoddi4+0x80>
 800067e:	4662      	mov	r2, ip
 8000680:	2320      	movs	r3, #32
 8000682:	1a9b      	subs	r3, r3, r2
 8000684:	464a      	mov	r2, r9
 8000686:	40da      	lsrs	r2, r3
 8000688:	4661      	mov	r1, ip
 800068a:	0013      	movs	r3, r2
 800068c:	4642      	mov	r2, r8
 800068e:	408a      	lsls	r2, r1
 8000690:	0017      	movs	r7, r2
 8000692:	431f      	orrs	r7, r3
 8000694:	e780      	b.n	8000598 <__udivmoddi4+0x40>
 8000696:	4662      	mov	r2, ip
 8000698:	2320      	movs	r3, #32
 800069a:	1a9b      	subs	r3, r3, r2
 800069c:	002a      	movs	r2, r5
 800069e:	4666      	mov	r6, ip
 80006a0:	409a      	lsls	r2, r3
 80006a2:	0023      	movs	r3, r4
 80006a4:	40f3      	lsrs	r3, r6
 80006a6:	4313      	orrs	r3, r2
 80006a8:	e7d4      	b.n	8000654 <__udivmoddi4+0xfc>
 80006aa:	4662      	mov	r2, ip
 80006ac:	2320      	movs	r3, #32
 80006ae:	2100      	movs	r1, #0
 80006b0:	1a9b      	subs	r3, r3, r2
 80006b2:	2200      	movs	r2, #0
 80006b4:	9100      	str	r1, [sp, #0]
 80006b6:	9201      	str	r2, [sp, #4]
 80006b8:	2201      	movs	r2, #1
 80006ba:	40da      	lsrs	r2, r3
 80006bc:	9201      	str	r2, [sp, #4]
 80006be:	e780      	b.n	80005c2 <__udivmoddi4+0x6a>
 80006c0:	2320      	movs	r3, #32
 80006c2:	4662      	mov	r2, ip
 80006c4:	0026      	movs	r6, r4
 80006c6:	1a9b      	subs	r3, r3, r2
 80006c8:	40de      	lsrs	r6, r3
 80006ca:	002f      	movs	r7, r5
 80006cc:	46b0      	mov	r8, r6
 80006ce:	4666      	mov	r6, ip
 80006d0:	40b7      	lsls	r7, r6
 80006d2:	4646      	mov	r6, r8
 80006d4:	003b      	movs	r3, r7
 80006d6:	4333      	orrs	r3, r6
 80006d8:	e7c8      	b.n	800066c <__udivmoddi4+0x114>
 80006da:	46c0      	nop			; (mov r8, r8)

080006dc <__aeabi_fadd>:
 80006dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80006de:	4647      	mov	r7, r8
 80006e0:	46ce      	mov	lr, r9
 80006e2:	0243      	lsls	r3, r0, #9
 80006e4:	0a5b      	lsrs	r3, r3, #9
 80006e6:	0044      	lsls	r4, r0, #1
 80006e8:	0fc2      	lsrs	r2, r0, #31
 80006ea:	469c      	mov	ip, r3
 80006ec:	0048      	lsls	r0, r1, #1
 80006ee:	00dd      	lsls	r5, r3, #3
 80006f0:	024b      	lsls	r3, r1, #9
 80006f2:	0e24      	lsrs	r4, r4, #24
 80006f4:	0a5b      	lsrs	r3, r3, #9
 80006f6:	0e00      	lsrs	r0, r0, #24
 80006f8:	b580      	push	{r7, lr}
 80006fa:	4698      	mov	r8, r3
 80006fc:	0026      	movs	r6, r4
 80006fe:	4691      	mov	r9, r2
 8000700:	0fc9      	lsrs	r1, r1, #31
 8000702:	00db      	lsls	r3, r3, #3
 8000704:	1a27      	subs	r7, r4, r0
 8000706:	428a      	cmp	r2, r1
 8000708:	d029      	beq.n	800075e <__aeabi_fadd+0x82>
 800070a:	2f00      	cmp	r7, #0
 800070c:	dd15      	ble.n	800073a <__aeabi_fadd+0x5e>
 800070e:	2800      	cmp	r0, #0
 8000710:	d14a      	bne.n	80007a8 <__aeabi_fadd+0xcc>
 8000712:	2b00      	cmp	r3, #0
 8000714:	d000      	beq.n	8000718 <__aeabi_fadd+0x3c>
 8000716:	e095      	b.n	8000844 <__aeabi_fadd+0x168>
 8000718:	08ed      	lsrs	r5, r5, #3
 800071a:	2cff      	cmp	r4, #255	; 0xff
 800071c:	d100      	bne.n	8000720 <__aeabi_fadd+0x44>
 800071e:	e088      	b.n	8000832 <__aeabi_fadd+0x156>
 8000720:	026b      	lsls	r3, r5, #9
 8000722:	0a5b      	lsrs	r3, r3, #9
 8000724:	b2e6      	uxtb	r6, r4
 8000726:	025b      	lsls	r3, r3, #9
 8000728:	05f6      	lsls	r6, r6, #23
 800072a:	0a58      	lsrs	r0, r3, #9
 800072c:	4330      	orrs	r0, r6
 800072e:	07d2      	lsls	r2, r2, #31
 8000730:	4310      	orrs	r0, r2
 8000732:	bc0c      	pop	{r2, r3}
 8000734:	4690      	mov	r8, r2
 8000736:	4699      	mov	r9, r3
 8000738:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800073a:	2f00      	cmp	r7, #0
 800073c:	d000      	beq.n	8000740 <__aeabi_fadd+0x64>
 800073e:	e087      	b.n	8000850 <__aeabi_fadd+0x174>
 8000740:	1c60      	adds	r0, r4, #1
 8000742:	b2c0      	uxtb	r0, r0
 8000744:	2801      	cmp	r0, #1
 8000746:	dc00      	bgt.n	800074a <__aeabi_fadd+0x6e>
 8000748:	e0b6      	b.n	80008b8 <__aeabi_fadd+0x1dc>
 800074a:	1aee      	subs	r6, r5, r3
 800074c:	0172      	lsls	r2, r6, #5
 800074e:	d500      	bpl.n	8000752 <__aeabi_fadd+0x76>
 8000750:	e0c5      	b.n	80008de <__aeabi_fadd+0x202>
 8000752:	2e00      	cmp	r6, #0
 8000754:	d13d      	bne.n	80007d2 <__aeabi_fadd+0xf6>
 8000756:	2200      	movs	r2, #0
 8000758:	2600      	movs	r6, #0
 800075a:	2300      	movs	r3, #0
 800075c:	e7e3      	b.n	8000726 <__aeabi_fadd+0x4a>
 800075e:	2f00      	cmp	r7, #0
 8000760:	dc00      	bgt.n	8000764 <__aeabi_fadd+0x88>
 8000762:	e096      	b.n	8000892 <__aeabi_fadd+0x1b6>
 8000764:	2800      	cmp	r0, #0
 8000766:	d05d      	beq.n	8000824 <__aeabi_fadd+0x148>
 8000768:	2cff      	cmp	r4, #255	; 0xff
 800076a:	d060      	beq.n	800082e <__aeabi_fadd+0x152>
 800076c:	2280      	movs	r2, #128	; 0x80
 800076e:	04d2      	lsls	r2, r2, #19
 8000770:	4313      	orrs	r3, r2
 8000772:	2f1b      	cmp	r7, #27
 8000774:	dd00      	ble.n	8000778 <__aeabi_fadd+0x9c>
 8000776:	e0ec      	b.n	8000952 <__aeabi_fadd+0x276>
 8000778:	2220      	movs	r2, #32
 800077a:	1bd2      	subs	r2, r2, r7
 800077c:	0018      	movs	r0, r3
 800077e:	4093      	lsls	r3, r2
 8000780:	40f8      	lsrs	r0, r7
 8000782:	1e5a      	subs	r2, r3, #1
 8000784:	4193      	sbcs	r3, r2
 8000786:	4303      	orrs	r3, r0
 8000788:	18ed      	adds	r5, r5, r3
 800078a:	016b      	lsls	r3, r5, #5
 800078c:	d57b      	bpl.n	8000886 <__aeabi_fadd+0x1aa>
 800078e:	3401      	adds	r4, #1
 8000790:	2cff      	cmp	r4, #255	; 0xff
 8000792:	d100      	bne.n	8000796 <__aeabi_fadd+0xba>
 8000794:	e0b7      	b.n	8000906 <__aeabi_fadd+0x22a>
 8000796:	2201      	movs	r2, #1
 8000798:	2607      	movs	r6, #7
 800079a:	402a      	ands	r2, r5
 800079c:	086b      	lsrs	r3, r5, #1
 800079e:	4d9a      	ldr	r5, [pc, #616]	; (8000a08 <__aeabi_fadd+0x32c>)
 80007a0:	401d      	ands	r5, r3
 80007a2:	4315      	orrs	r5, r2
 80007a4:	402e      	ands	r6, r5
 80007a6:	e029      	b.n	80007fc <__aeabi_fadd+0x120>
 80007a8:	2cff      	cmp	r4, #255	; 0xff
 80007aa:	d0b5      	beq.n	8000718 <__aeabi_fadd+0x3c>
 80007ac:	2280      	movs	r2, #128	; 0x80
 80007ae:	04d2      	lsls	r2, r2, #19
 80007b0:	4313      	orrs	r3, r2
 80007b2:	2f1b      	cmp	r7, #27
 80007b4:	dd00      	ble.n	80007b8 <__aeabi_fadd+0xdc>
 80007b6:	e0b2      	b.n	800091e <__aeabi_fadd+0x242>
 80007b8:	2220      	movs	r2, #32
 80007ba:	1bd2      	subs	r2, r2, r7
 80007bc:	0019      	movs	r1, r3
 80007be:	4093      	lsls	r3, r2
 80007c0:	40f9      	lsrs	r1, r7
 80007c2:	1e5a      	subs	r2, r3, #1
 80007c4:	4193      	sbcs	r3, r2
 80007c6:	430b      	orrs	r3, r1
 80007c8:	1aed      	subs	r5, r5, r3
 80007ca:	016b      	lsls	r3, r5, #5
 80007cc:	d55b      	bpl.n	8000886 <__aeabi_fadd+0x1aa>
 80007ce:	01ad      	lsls	r5, r5, #6
 80007d0:	09ae      	lsrs	r6, r5, #6
 80007d2:	0030      	movs	r0, r6
 80007d4:	f002 fab8 	bl	8002d48 <__clzsi2>
 80007d8:	3805      	subs	r0, #5
 80007da:	4086      	lsls	r6, r0
 80007dc:	4284      	cmp	r4, r0
 80007de:	dc65      	bgt.n	80008ac <__aeabi_fadd+0x1d0>
 80007e0:	1b04      	subs	r4, r0, r4
 80007e2:	0033      	movs	r3, r6
 80007e4:	2020      	movs	r0, #32
 80007e6:	3401      	adds	r4, #1
 80007e8:	40e3      	lsrs	r3, r4
 80007ea:	1b04      	subs	r4, r0, r4
 80007ec:	40a6      	lsls	r6, r4
 80007ee:	1e75      	subs	r5, r6, #1
 80007f0:	41ae      	sbcs	r6, r5
 80007f2:	4333      	orrs	r3, r6
 80007f4:	2607      	movs	r6, #7
 80007f6:	001d      	movs	r5, r3
 80007f8:	2400      	movs	r4, #0
 80007fa:	401e      	ands	r6, r3
 80007fc:	2201      	movs	r2, #1
 80007fe:	464b      	mov	r3, r9
 8000800:	401a      	ands	r2, r3
 8000802:	2e00      	cmp	r6, #0
 8000804:	d004      	beq.n	8000810 <__aeabi_fadd+0x134>
 8000806:	230f      	movs	r3, #15
 8000808:	402b      	ands	r3, r5
 800080a:	2b04      	cmp	r3, #4
 800080c:	d000      	beq.n	8000810 <__aeabi_fadd+0x134>
 800080e:	3504      	adds	r5, #4
 8000810:	016b      	lsls	r3, r5, #5
 8000812:	d400      	bmi.n	8000816 <__aeabi_fadd+0x13a>
 8000814:	e780      	b.n	8000718 <__aeabi_fadd+0x3c>
 8000816:	3401      	adds	r4, #1
 8000818:	b2e6      	uxtb	r6, r4
 800081a:	2cff      	cmp	r4, #255	; 0xff
 800081c:	d12f      	bne.n	800087e <__aeabi_fadd+0x1a2>
 800081e:	26ff      	movs	r6, #255	; 0xff
 8000820:	2300      	movs	r3, #0
 8000822:	e780      	b.n	8000726 <__aeabi_fadd+0x4a>
 8000824:	2b00      	cmp	r3, #0
 8000826:	d152      	bne.n	80008ce <__aeabi_fadd+0x1f2>
 8000828:	2cff      	cmp	r4, #255	; 0xff
 800082a:	d000      	beq.n	800082e <__aeabi_fadd+0x152>
 800082c:	e774      	b.n	8000718 <__aeabi_fadd+0x3c>
 800082e:	000a      	movs	r2, r1
 8000830:	08ed      	lsrs	r5, r5, #3
 8000832:	2d00      	cmp	r5, #0
 8000834:	d0f3      	beq.n	800081e <__aeabi_fadd+0x142>
 8000836:	2380      	movs	r3, #128	; 0x80
 8000838:	03db      	lsls	r3, r3, #15
 800083a:	432b      	orrs	r3, r5
 800083c:	025b      	lsls	r3, r3, #9
 800083e:	0a5b      	lsrs	r3, r3, #9
 8000840:	26ff      	movs	r6, #255	; 0xff
 8000842:	e770      	b.n	8000726 <__aeabi_fadd+0x4a>
 8000844:	3f01      	subs	r7, #1
 8000846:	2f00      	cmp	r7, #0
 8000848:	d0be      	beq.n	80007c8 <__aeabi_fadd+0xec>
 800084a:	2cff      	cmp	r4, #255	; 0xff
 800084c:	d1b1      	bne.n	80007b2 <__aeabi_fadd+0xd6>
 800084e:	e763      	b.n	8000718 <__aeabi_fadd+0x3c>
 8000850:	2c00      	cmp	r4, #0
 8000852:	d047      	beq.n	80008e4 <__aeabi_fadd+0x208>
 8000854:	28ff      	cmp	r0, #255	; 0xff
 8000856:	d069      	beq.n	800092c <__aeabi_fadd+0x250>
 8000858:	2480      	movs	r4, #128	; 0x80
 800085a:	04e4      	lsls	r4, r4, #19
 800085c:	427a      	negs	r2, r7
 800085e:	4325      	orrs	r5, r4
 8000860:	2a1b      	cmp	r2, #27
 8000862:	dd00      	ble.n	8000866 <__aeabi_fadd+0x18a>
 8000864:	e0c5      	b.n	80009f2 <__aeabi_fadd+0x316>
 8000866:	002c      	movs	r4, r5
 8000868:	2620      	movs	r6, #32
 800086a:	40d4      	lsrs	r4, r2
 800086c:	1ab2      	subs	r2, r6, r2
 800086e:	4095      	lsls	r5, r2
 8000870:	1e6a      	subs	r2, r5, #1
 8000872:	4195      	sbcs	r5, r2
 8000874:	4325      	orrs	r5, r4
 8000876:	1b5d      	subs	r5, r3, r5
 8000878:	0004      	movs	r4, r0
 800087a:	4689      	mov	r9, r1
 800087c:	e7a5      	b.n	80007ca <__aeabi_fadd+0xee>
 800087e:	01ab      	lsls	r3, r5, #6
 8000880:	0a5b      	lsrs	r3, r3, #9
 8000882:	e750      	b.n	8000726 <__aeabi_fadd+0x4a>
 8000884:	2400      	movs	r4, #0
 8000886:	2201      	movs	r2, #1
 8000888:	464b      	mov	r3, r9
 800088a:	401a      	ands	r2, r3
 800088c:	076b      	lsls	r3, r5, #29
 800088e:	d1ba      	bne.n	8000806 <__aeabi_fadd+0x12a>
 8000890:	e742      	b.n	8000718 <__aeabi_fadd+0x3c>
 8000892:	2f00      	cmp	r7, #0
 8000894:	d13b      	bne.n	800090e <__aeabi_fadd+0x232>
 8000896:	3401      	adds	r4, #1
 8000898:	b2e0      	uxtb	r0, r4
 800089a:	2801      	cmp	r0, #1
 800089c:	dd4a      	ble.n	8000934 <__aeabi_fadd+0x258>
 800089e:	2cff      	cmp	r4, #255	; 0xff
 80008a0:	d0bd      	beq.n	800081e <__aeabi_fadd+0x142>
 80008a2:	2607      	movs	r6, #7
 80008a4:	18ed      	adds	r5, r5, r3
 80008a6:	086d      	lsrs	r5, r5, #1
 80008a8:	402e      	ands	r6, r5
 80008aa:	e7a7      	b.n	80007fc <__aeabi_fadd+0x120>
 80008ac:	2307      	movs	r3, #7
 80008ae:	4d57      	ldr	r5, [pc, #348]	; (8000a0c <__aeabi_fadd+0x330>)
 80008b0:	1a24      	subs	r4, r4, r0
 80008b2:	4035      	ands	r5, r6
 80008b4:	401e      	ands	r6, r3
 80008b6:	e7a1      	b.n	80007fc <__aeabi_fadd+0x120>
 80008b8:	2c00      	cmp	r4, #0
 80008ba:	d11b      	bne.n	80008f4 <__aeabi_fadd+0x218>
 80008bc:	2d00      	cmp	r5, #0
 80008be:	d16e      	bne.n	800099e <__aeabi_fadd+0x2c2>
 80008c0:	2b00      	cmp	r3, #0
 80008c2:	d100      	bne.n	80008c6 <__aeabi_fadd+0x1ea>
 80008c4:	e09a      	b.n	80009fc <__aeabi_fadd+0x320>
 80008c6:	000a      	movs	r2, r1
 80008c8:	001d      	movs	r5, r3
 80008ca:	003c      	movs	r4, r7
 80008cc:	e724      	b.n	8000718 <__aeabi_fadd+0x3c>
 80008ce:	3f01      	subs	r7, #1
 80008d0:	2f00      	cmp	r7, #0
 80008d2:	d100      	bne.n	80008d6 <__aeabi_fadd+0x1fa>
 80008d4:	e758      	b.n	8000788 <__aeabi_fadd+0xac>
 80008d6:	2cff      	cmp	r4, #255	; 0xff
 80008d8:	d000      	beq.n	80008dc <__aeabi_fadd+0x200>
 80008da:	e74a      	b.n	8000772 <__aeabi_fadd+0x96>
 80008dc:	e7a7      	b.n	800082e <__aeabi_fadd+0x152>
 80008de:	1b5e      	subs	r6, r3, r5
 80008e0:	4689      	mov	r9, r1
 80008e2:	e776      	b.n	80007d2 <__aeabi_fadd+0xf6>
 80008e4:	2d00      	cmp	r5, #0
 80008e6:	d11c      	bne.n	8000922 <__aeabi_fadd+0x246>
 80008e8:	000a      	movs	r2, r1
 80008ea:	28ff      	cmp	r0, #255	; 0xff
 80008ec:	d01f      	beq.n	800092e <__aeabi_fadd+0x252>
 80008ee:	0004      	movs	r4, r0
 80008f0:	001d      	movs	r5, r3
 80008f2:	e711      	b.n	8000718 <__aeabi_fadd+0x3c>
 80008f4:	2d00      	cmp	r5, #0
 80008f6:	d15d      	bne.n	80009b4 <__aeabi_fadd+0x2d8>
 80008f8:	2b00      	cmp	r3, #0
 80008fa:	d117      	bne.n	800092c <__aeabi_fadd+0x250>
 80008fc:	2380      	movs	r3, #128	; 0x80
 80008fe:	2200      	movs	r2, #0
 8000900:	03db      	lsls	r3, r3, #15
 8000902:	26ff      	movs	r6, #255	; 0xff
 8000904:	e70f      	b.n	8000726 <__aeabi_fadd+0x4a>
 8000906:	000a      	movs	r2, r1
 8000908:	26ff      	movs	r6, #255	; 0xff
 800090a:	2300      	movs	r3, #0
 800090c:	e70b      	b.n	8000726 <__aeabi_fadd+0x4a>
 800090e:	2c00      	cmp	r4, #0
 8000910:	d121      	bne.n	8000956 <__aeabi_fadd+0x27a>
 8000912:	2d00      	cmp	r5, #0
 8000914:	d166      	bne.n	80009e4 <__aeabi_fadd+0x308>
 8000916:	28ff      	cmp	r0, #255	; 0xff
 8000918:	d1e9      	bne.n	80008ee <__aeabi_fadd+0x212>
 800091a:	001d      	movs	r5, r3
 800091c:	e787      	b.n	800082e <__aeabi_fadd+0x152>
 800091e:	2301      	movs	r3, #1
 8000920:	e752      	b.n	80007c8 <__aeabi_fadd+0xec>
 8000922:	1c7a      	adds	r2, r7, #1
 8000924:	d0a7      	beq.n	8000876 <__aeabi_fadd+0x19a>
 8000926:	43fa      	mvns	r2, r7
 8000928:	28ff      	cmp	r0, #255	; 0xff
 800092a:	d199      	bne.n	8000860 <__aeabi_fadd+0x184>
 800092c:	000a      	movs	r2, r1
 800092e:	001d      	movs	r5, r3
 8000930:	24ff      	movs	r4, #255	; 0xff
 8000932:	e6f1      	b.n	8000718 <__aeabi_fadd+0x3c>
 8000934:	2e00      	cmp	r6, #0
 8000936:	d121      	bne.n	800097c <__aeabi_fadd+0x2a0>
 8000938:	2d00      	cmp	r5, #0
 800093a:	d04f      	beq.n	80009dc <__aeabi_fadd+0x300>
 800093c:	2b00      	cmp	r3, #0
 800093e:	d04c      	beq.n	80009da <__aeabi_fadd+0x2fe>
 8000940:	18ed      	adds	r5, r5, r3
 8000942:	016b      	lsls	r3, r5, #5
 8000944:	d59e      	bpl.n	8000884 <__aeabi_fadd+0x1a8>
 8000946:	4b31      	ldr	r3, [pc, #196]	; (8000a0c <__aeabi_fadd+0x330>)
 8000948:	3607      	adds	r6, #7
 800094a:	402e      	ands	r6, r5
 800094c:	2401      	movs	r4, #1
 800094e:	401d      	ands	r5, r3
 8000950:	e754      	b.n	80007fc <__aeabi_fadd+0x120>
 8000952:	2301      	movs	r3, #1
 8000954:	e718      	b.n	8000788 <__aeabi_fadd+0xac>
 8000956:	28ff      	cmp	r0, #255	; 0xff
 8000958:	d0df      	beq.n	800091a <__aeabi_fadd+0x23e>
 800095a:	2480      	movs	r4, #128	; 0x80
 800095c:	04e4      	lsls	r4, r4, #19
 800095e:	427f      	negs	r7, r7
 8000960:	4325      	orrs	r5, r4
 8000962:	2f1b      	cmp	r7, #27
 8000964:	dc4d      	bgt.n	8000a02 <__aeabi_fadd+0x326>
 8000966:	2620      	movs	r6, #32
 8000968:	1bf6      	subs	r6, r6, r7
 800096a:	002c      	movs	r4, r5
 800096c:	40b5      	lsls	r5, r6
 800096e:	40fc      	lsrs	r4, r7
 8000970:	1e6a      	subs	r2, r5, #1
 8000972:	4195      	sbcs	r5, r2
 8000974:	4325      	orrs	r5, r4
 8000976:	18ed      	adds	r5, r5, r3
 8000978:	0004      	movs	r4, r0
 800097a:	e706      	b.n	800078a <__aeabi_fadd+0xae>
 800097c:	2d00      	cmp	r5, #0
 800097e:	d0cc      	beq.n	800091a <__aeabi_fadd+0x23e>
 8000980:	2b00      	cmp	r3, #0
 8000982:	d100      	bne.n	8000986 <__aeabi_fadd+0x2aa>
 8000984:	e753      	b.n	800082e <__aeabi_fadd+0x152>
 8000986:	2180      	movs	r1, #128	; 0x80
 8000988:	4660      	mov	r0, ip
 800098a:	03c9      	lsls	r1, r1, #15
 800098c:	4208      	tst	r0, r1
 800098e:	d003      	beq.n	8000998 <__aeabi_fadd+0x2bc>
 8000990:	4640      	mov	r0, r8
 8000992:	4208      	tst	r0, r1
 8000994:	d100      	bne.n	8000998 <__aeabi_fadd+0x2bc>
 8000996:	001d      	movs	r5, r3
 8000998:	2101      	movs	r1, #1
 800099a:	4011      	ands	r1, r2
 800099c:	e747      	b.n	800082e <__aeabi_fadd+0x152>
 800099e:	2b00      	cmp	r3, #0
 80009a0:	d100      	bne.n	80009a4 <__aeabi_fadd+0x2c8>
 80009a2:	e6b9      	b.n	8000718 <__aeabi_fadd+0x3c>
 80009a4:	1aea      	subs	r2, r5, r3
 80009a6:	0150      	lsls	r0, r2, #5
 80009a8:	d525      	bpl.n	80009f6 <__aeabi_fadd+0x31a>
 80009aa:	2607      	movs	r6, #7
 80009ac:	1b5d      	subs	r5, r3, r5
 80009ae:	402e      	ands	r6, r5
 80009b0:	4689      	mov	r9, r1
 80009b2:	e723      	b.n	80007fc <__aeabi_fadd+0x120>
 80009b4:	24ff      	movs	r4, #255	; 0xff
 80009b6:	2b00      	cmp	r3, #0
 80009b8:	d100      	bne.n	80009bc <__aeabi_fadd+0x2e0>
 80009ba:	e6ad      	b.n	8000718 <__aeabi_fadd+0x3c>
 80009bc:	2280      	movs	r2, #128	; 0x80
 80009be:	4660      	mov	r0, ip
 80009c0:	03d2      	lsls	r2, r2, #15
 80009c2:	4210      	tst	r0, r2
 80009c4:	d004      	beq.n	80009d0 <__aeabi_fadd+0x2f4>
 80009c6:	4640      	mov	r0, r8
 80009c8:	4210      	tst	r0, r2
 80009ca:	d101      	bne.n	80009d0 <__aeabi_fadd+0x2f4>
 80009cc:	001d      	movs	r5, r3
 80009ce:	4689      	mov	r9, r1
 80009d0:	2201      	movs	r2, #1
 80009d2:	464b      	mov	r3, r9
 80009d4:	24ff      	movs	r4, #255	; 0xff
 80009d6:	401a      	ands	r2, r3
 80009d8:	e69e      	b.n	8000718 <__aeabi_fadd+0x3c>
 80009da:	002b      	movs	r3, r5
 80009dc:	08dd      	lsrs	r5, r3, #3
 80009de:	000a      	movs	r2, r1
 80009e0:	2400      	movs	r4, #0
 80009e2:	e69d      	b.n	8000720 <__aeabi_fadd+0x44>
 80009e4:	1c7a      	adds	r2, r7, #1
 80009e6:	d0c6      	beq.n	8000976 <__aeabi_fadd+0x29a>
 80009e8:	43ff      	mvns	r7, r7
 80009ea:	28ff      	cmp	r0, #255	; 0xff
 80009ec:	d1b9      	bne.n	8000962 <__aeabi_fadd+0x286>
 80009ee:	001d      	movs	r5, r3
 80009f0:	e71d      	b.n	800082e <__aeabi_fadd+0x152>
 80009f2:	2501      	movs	r5, #1
 80009f4:	e73f      	b.n	8000876 <__aeabi_fadd+0x19a>
 80009f6:	1e15      	subs	r5, r2, #0
 80009f8:	d000      	beq.n	80009fc <__aeabi_fadd+0x320>
 80009fa:	e744      	b.n	8000886 <__aeabi_fadd+0x1aa>
 80009fc:	2200      	movs	r2, #0
 80009fe:	2300      	movs	r3, #0
 8000a00:	e691      	b.n	8000726 <__aeabi_fadd+0x4a>
 8000a02:	2501      	movs	r5, #1
 8000a04:	e7b7      	b.n	8000976 <__aeabi_fadd+0x29a>
 8000a06:	46c0      	nop			; (mov r8, r8)
 8000a08:	7dffffff 	.word	0x7dffffff
 8000a0c:	fbffffff 	.word	0xfbffffff

08000a10 <__aeabi_fdiv>:
 8000a10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000a12:	4657      	mov	r7, sl
 8000a14:	464e      	mov	r6, r9
 8000a16:	4645      	mov	r5, r8
 8000a18:	46de      	mov	lr, fp
 8000a1a:	0244      	lsls	r4, r0, #9
 8000a1c:	b5e0      	push	{r5, r6, r7, lr}
 8000a1e:	0046      	lsls	r6, r0, #1
 8000a20:	4688      	mov	r8, r1
 8000a22:	0a64      	lsrs	r4, r4, #9
 8000a24:	0e36      	lsrs	r6, r6, #24
 8000a26:	0fc7      	lsrs	r7, r0, #31
 8000a28:	2e00      	cmp	r6, #0
 8000a2a:	d063      	beq.n	8000af4 <__aeabi_fdiv+0xe4>
 8000a2c:	2eff      	cmp	r6, #255	; 0xff
 8000a2e:	d024      	beq.n	8000a7a <__aeabi_fdiv+0x6a>
 8000a30:	2380      	movs	r3, #128	; 0x80
 8000a32:	00e4      	lsls	r4, r4, #3
 8000a34:	04db      	lsls	r3, r3, #19
 8000a36:	431c      	orrs	r4, r3
 8000a38:	2300      	movs	r3, #0
 8000a3a:	4699      	mov	r9, r3
 8000a3c:	469b      	mov	fp, r3
 8000a3e:	3e7f      	subs	r6, #127	; 0x7f
 8000a40:	4643      	mov	r3, r8
 8000a42:	4642      	mov	r2, r8
 8000a44:	025d      	lsls	r5, r3, #9
 8000a46:	0fd2      	lsrs	r2, r2, #31
 8000a48:	005b      	lsls	r3, r3, #1
 8000a4a:	0a6d      	lsrs	r5, r5, #9
 8000a4c:	0e1b      	lsrs	r3, r3, #24
 8000a4e:	4690      	mov	r8, r2
 8000a50:	4692      	mov	sl, r2
 8000a52:	d065      	beq.n	8000b20 <__aeabi_fdiv+0x110>
 8000a54:	2bff      	cmp	r3, #255	; 0xff
 8000a56:	d055      	beq.n	8000b04 <__aeabi_fdiv+0xf4>
 8000a58:	2280      	movs	r2, #128	; 0x80
 8000a5a:	2100      	movs	r1, #0
 8000a5c:	00ed      	lsls	r5, r5, #3
 8000a5e:	04d2      	lsls	r2, r2, #19
 8000a60:	3b7f      	subs	r3, #127	; 0x7f
 8000a62:	4315      	orrs	r5, r2
 8000a64:	1af6      	subs	r6, r6, r3
 8000a66:	4643      	mov	r3, r8
 8000a68:	464a      	mov	r2, r9
 8000a6a:	407b      	eors	r3, r7
 8000a6c:	2a0f      	cmp	r2, #15
 8000a6e:	d900      	bls.n	8000a72 <__aeabi_fdiv+0x62>
 8000a70:	e08d      	b.n	8000b8e <__aeabi_fdiv+0x17e>
 8000a72:	486d      	ldr	r0, [pc, #436]	; (8000c28 <__aeabi_fdiv+0x218>)
 8000a74:	0092      	lsls	r2, r2, #2
 8000a76:	5882      	ldr	r2, [r0, r2]
 8000a78:	4697      	mov	pc, r2
 8000a7a:	2c00      	cmp	r4, #0
 8000a7c:	d154      	bne.n	8000b28 <__aeabi_fdiv+0x118>
 8000a7e:	2308      	movs	r3, #8
 8000a80:	4699      	mov	r9, r3
 8000a82:	3b06      	subs	r3, #6
 8000a84:	26ff      	movs	r6, #255	; 0xff
 8000a86:	469b      	mov	fp, r3
 8000a88:	e7da      	b.n	8000a40 <__aeabi_fdiv+0x30>
 8000a8a:	2500      	movs	r5, #0
 8000a8c:	4653      	mov	r3, sl
 8000a8e:	2902      	cmp	r1, #2
 8000a90:	d01b      	beq.n	8000aca <__aeabi_fdiv+0xba>
 8000a92:	2903      	cmp	r1, #3
 8000a94:	d100      	bne.n	8000a98 <__aeabi_fdiv+0x88>
 8000a96:	e0bf      	b.n	8000c18 <__aeabi_fdiv+0x208>
 8000a98:	2901      	cmp	r1, #1
 8000a9a:	d028      	beq.n	8000aee <__aeabi_fdiv+0xde>
 8000a9c:	0030      	movs	r0, r6
 8000a9e:	307f      	adds	r0, #127	; 0x7f
 8000aa0:	2800      	cmp	r0, #0
 8000aa2:	dd20      	ble.n	8000ae6 <__aeabi_fdiv+0xd6>
 8000aa4:	076a      	lsls	r2, r5, #29
 8000aa6:	d004      	beq.n	8000ab2 <__aeabi_fdiv+0xa2>
 8000aa8:	220f      	movs	r2, #15
 8000aaa:	402a      	ands	r2, r5
 8000aac:	2a04      	cmp	r2, #4
 8000aae:	d000      	beq.n	8000ab2 <__aeabi_fdiv+0xa2>
 8000ab0:	3504      	adds	r5, #4
 8000ab2:	012a      	lsls	r2, r5, #4
 8000ab4:	d503      	bpl.n	8000abe <__aeabi_fdiv+0xae>
 8000ab6:	0030      	movs	r0, r6
 8000ab8:	4a5c      	ldr	r2, [pc, #368]	; (8000c2c <__aeabi_fdiv+0x21c>)
 8000aba:	3080      	adds	r0, #128	; 0x80
 8000abc:	4015      	ands	r5, r2
 8000abe:	28fe      	cmp	r0, #254	; 0xfe
 8000ac0:	dc03      	bgt.n	8000aca <__aeabi_fdiv+0xba>
 8000ac2:	01ac      	lsls	r4, r5, #6
 8000ac4:	0a64      	lsrs	r4, r4, #9
 8000ac6:	b2c2      	uxtb	r2, r0
 8000ac8:	e001      	b.n	8000ace <__aeabi_fdiv+0xbe>
 8000aca:	22ff      	movs	r2, #255	; 0xff
 8000acc:	2400      	movs	r4, #0
 8000ace:	0264      	lsls	r4, r4, #9
 8000ad0:	05d2      	lsls	r2, r2, #23
 8000ad2:	0a60      	lsrs	r0, r4, #9
 8000ad4:	07db      	lsls	r3, r3, #31
 8000ad6:	4310      	orrs	r0, r2
 8000ad8:	4318      	orrs	r0, r3
 8000ada:	bc3c      	pop	{r2, r3, r4, r5}
 8000adc:	4690      	mov	r8, r2
 8000ade:	4699      	mov	r9, r3
 8000ae0:	46a2      	mov	sl, r4
 8000ae2:	46ab      	mov	fp, r5
 8000ae4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000ae6:	2201      	movs	r2, #1
 8000ae8:	1a10      	subs	r0, r2, r0
 8000aea:	281b      	cmp	r0, #27
 8000aec:	dd7c      	ble.n	8000be8 <__aeabi_fdiv+0x1d8>
 8000aee:	2200      	movs	r2, #0
 8000af0:	2400      	movs	r4, #0
 8000af2:	e7ec      	b.n	8000ace <__aeabi_fdiv+0xbe>
 8000af4:	2c00      	cmp	r4, #0
 8000af6:	d11d      	bne.n	8000b34 <__aeabi_fdiv+0x124>
 8000af8:	2304      	movs	r3, #4
 8000afa:	4699      	mov	r9, r3
 8000afc:	3b03      	subs	r3, #3
 8000afe:	2600      	movs	r6, #0
 8000b00:	469b      	mov	fp, r3
 8000b02:	e79d      	b.n	8000a40 <__aeabi_fdiv+0x30>
 8000b04:	3eff      	subs	r6, #255	; 0xff
 8000b06:	2d00      	cmp	r5, #0
 8000b08:	d120      	bne.n	8000b4c <__aeabi_fdiv+0x13c>
 8000b0a:	2102      	movs	r1, #2
 8000b0c:	4643      	mov	r3, r8
 8000b0e:	464a      	mov	r2, r9
 8000b10:	407b      	eors	r3, r7
 8000b12:	430a      	orrs	r2, r1
 8000b14:	2a0f      	cmp	r2, #15
 8000b16:	d8d8      	bhi.n	8000aca <__aeabi_fdiv+0xba>
 8000b18:	4845      	ldr	r0, [pc, #276]	; (8000c30 <__aeabi_fdiv+0x220>)
 8000b1a:	0092      	lsls	r2, r2, #2
 8000b1c:	5882      	ldr	r2, [r0, r2]
 8000b1e:	4697      	mov	pc, r2
 8000b20:	2d00      	cmp	r5, #0
 8000b22:	d119      	bne.n	8000b58 <__aeabi_fdiv+0x148>
 8000b24:	2101      	movs	r1, #1
 8000b26:	e7f1      	b.n	8000b0c <__aeabi_fdiv+0xfc>
 8000b28:	230c      	movs	r3, #12
 8000b2a:	4699      	mov	r9, r3
 8000b2c:	3b09      	subs	r3, #9
 8000b2e:	26ff      	movs	r6, #255	; 0xff
 8000b30:	469b      	mov	fp, r3
 8000b32:	e785      	b.n	8000a40 <__aeabi_fdiv+0x30>
 8000b34:	0020      	movs	r0, r4
 8000b36:	f002 f907 	bl	8002d48 <__clzsi2>
 8000b3a:	2676      	movs	r6, #118	; 0x76
 8000b3c:	1f43      	subs	r3, r0, #5
 8000b3e:	409c      	lsls	r4, r3
 8000b40:	2300      	movs	r3, #0
 8000b42:	4276      	negs	r6, r6
 8000b44:	1a36      	subs	r6, r6, r0
 8000b46:	4699      	mov	r9, r3
 8000b48:	469b      	mov	fp, r3
 8000b4a:	e779      	b.n	8000a40 <__aeabi_fdiv+0x30>
 8000b4c:	464a      	mov	r2, r9
 8000b4e:	2303      	movs	r3, #3
 8000b50:	431a      	orrs	r2, r3
 8000b52:	4691      	mov	r9, r2
 8000b54:	2103      	movs	r1, #3
 8000b56:	e786      	b.n	8000a66 <__aeabi_fdiv+0x56>
 8000b58:	0028      	movs	r0, r5
 8000b5a:	f002 f8f5 	bl	8002d48 <__clzsi2>
 8000b5e:	1f43      	subs	r3, r0, #5
 8000b60:	1836      	adds	r6, r6, r0
 8000b62:	409d      	lsls	r5, r3
 8000b64:	3676      	adds	r6, #118	; 0x76
 8000b66:	2100      	movs	r1, #0
 8000b68:	e77d      	b.n	8000a66 <__aeabi_fdiv+0x56>
 8000b6a:	2480      	movs	r4, #128	; 0x80
 8000b6c:	2300      	movs	r3, #0
 8000b6e:	03e4      	lsls	r4, r4, #15
 8000b70:	22ff      	movs	r2, #255	; 0xff
 8000b72:	e7ac      	b.n	8000ace <__aeabi_fdiv+0xbe>
 8000b74:	2500      	movs	r5, #0
 8000b76:	2380      	movs	r3, #128	; 0x80
 8000b78:	03db      	lsls	r3, r3, #15
 8000b7a:	421c      	tst	r4, r3
 8000b7c:	d028      	beq.n	8000bd0 <__aeabi_fdiv+0x1c0>
 8000b7e:	421d      	tst	r5, r3
 8000b80:	d126      	bne.n	8000bd0 <__aeabi_fdiv+0x1c0>
 8000b82:	432b      	orrs	r3, r5
 8000b84:	025c      	lsls	r4, r3, #9
 8000b86:	0a64      	lsrs	r4, r4, #9
 8000b88:	4643      	mov	r3, r8
 8000b8a:	22ff      	movs	r2, #255	; 0xff
 8000b8c:	e79f      	b.n	8000ace <__aeabi_fdiv+0xbe>
 8000b8e:	0162      	lsls	r2, r4, #5
 8000b90:	016c      	lsls	r4, r5, #5
 8000b92:	42a2      	cmp	r2, r4
 8000b94:	d224      	bcs.n	8000be0 <__aeabi_fdiv+0x1d0>
 8000b96:	211b      	movs	r1, #27
 8000b98:	2500      	movs	r5, #0
 8000b9a:	3e01      	subs	r6, #1
 8000b9c:	2701      	movs	r7, #1
 8000b9e:	0010      	movs	r0, r2
 8000ba0:	006d      	lsls	r5, r5, #1
 8000ba2:	0052      	lsls	r2, r2, #1
 8000ba4:	2800      	cmp	r0, #0
 8000ba6:	db01      	blt.n	8000bac <__aeabi_fdiv+0x19c>
 8000ba8:	4294      	cmp	r4, r2
 8000baa:	d801      	bhi.n	8000bb0 <__aeabi_fdiv+0x1a0>
 8000bac:	1b12      	subs	r2, r2, r4
 8000bae:	433d      	orrs	r5, r7
 8000bb0:	3901      	subs	r1, #1
 8000bb2:	2900      	cmp	r1, #0
 8000bb4:	d1f3      	bne.n	8000b9e <__aeabi_fdiv+0x18e>
 8000bb6:	0014      	movs	r4, r2
 8000bb8:	1e62      	subs	r2, r4, #1
 8000bba:	4194      	sbcs	r4, r2
 8000bbc:	4325      	orrs	r5, r4
 8000bbe:	e76d      	b.n	8000a9c <__aeabi_fdiv+0x8c>
 8000bc0:	46ba      	mov	sl, r7
 8000bc2:	4659      	mov	r1, fp
 8000bc4:	0025      	movs	r5, r4
 8000bc6:	4653      	mov	r3, sl
 8000bc8:	2902      	cmp	r1, #2
 8000bca:	d000      	beq.n	8000bce <__aeabi_fdiv+0x1be>
 8000bcc:	e761      	b.n	8000a92 <__aeabi_fdiv+0x82>
 8000bce:	e77c      	b.n	8000aca <__aeabi_fdiv+0xba>
 8000bd0:	2380      	movs	r3, #128	; 0x80
 8000bd2:	03db      	lsls	r3, r3, #15
 8000bd4:	431c      	orrs	r4, r3
 8000bd6:	0264      	lsls	r4, r4, #9
 8000bd8:	0a64      	lsrs	r4, r4, #9
 8000bda:	003b      	movs	r3, r7
 8000bdc:	22ff      	movs	r2, #255	; 0xff
 8000bde:	e776      	b.n	8000ace <__aeabi_fdiv+0xbe>
 8000be0:	1b12      	subs	r2, r2, r4
 8000be2:	211a      	movs	r1, #26
 8000be4:	2501      	movs	r5, #1
 8000be6:	e7d9      	b.n	8000b9c <__aeabi_fdiv+0x18c>
 8000be8:	369e      	adds	r6, #158	; 0x9e
 8000bea:	002a      	movs	r2, r5
 8000bec:	40b5      	lsls	r5, r6
 8000bee:	002c      	movs	r4, r5
 8000bf0:	40c2      	lsrs	r2, r0
 8000bf2:	1e65      	subs	r5, r4, #1
 8000bf4:	41ac      	sbcs	r4, r5
 8000bf6:	4314      	orrs	r4, r2
 8000bf8:	0762      	lsls	r2, r4, #29
 8000bfa:	d004      	beq.n	8000c06 <__aeabi_fdiv+0x1f6>
 8000bfc:	220f      	movs	r2, #15
 8000bfe:	4022      	ands	r2, r4
 8000c00:	2a04      	cmp	r2, #4
 8000c02:	d000      	beq.n	8000c06 <__aeabi_fdiv+0x1f6>
 8000c04:	3404      	adds	r4, #4
 8000c06:	0162      	lsls	r2, r4, #5
 8000c08:	d403      	bmi.n	8000c12 <__aeabi_fdiv+0x202>
 8000c0a:	01a4      	lsls	r4, r4, #6
 8000c0c:	0a64      	lsrs	r4, r4, #9
 8000c0e:	2200      	movs	r2, #0
 8000c10:	e75d      	b.n	8000ace <__aeabi_fdiv+0xbe>
 8000c12:	2201      	movs	r2, #1
 8000c14:	2400      	movs	r4, #0
 8000c16:	e75a      	b.n	8000ace <__aeabi_fdiv+0xbe>
 8000c18:	2480      	movs	r4, #128	; 0x80
 8000c1a:	03e4      	lsls	r4, r4, #15
 8000c1c:	432c      	orrs	r4, r5
 8000c1e:	0264      	lsls	r4, r4, #9
 8000c20:	0a64      	lsrs	r4, r4, #9
 8000c22:	22ff      	movs	r2, #255	; 0xff
 8000c24:	e753      	b.n	8000ace <__aeabi_fdiv+0xbe>
 8000c26:	46c0      	nop			; (mov r8, r8)
 8000c28:	08014d44 	.word	0x08014d44
 8000c2c:	f7ffffff 	.word	0xf7ffffff
 8000c30:	08014d84 	.word	0x08014d84

08000c34 <__aeabi_fsub>:
 8000c34:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000c36:	4647      	mov	r7, r8
 8000c38:	46ce      	mov	lr, r9
 8000c3a:	0044      	lsls	r4, r0, #1
 8000c3c:	0fc2      	lsrs	r2, r0, #31
 8000c3e:	b580      	push	{r7, lr}
 8000c40:	0247      	lsls	r7, r0, #9
 8000c42:	0248      	lsls	r0, r1, #9
 8000c44:	0a40      	lsrs	r0, r0, #9
 8000c46:	4684      	mov	ip, r0
 8000c48:	4666      	mov	r6, ip
 8000c4a:	0048      	lsls	r0, r1, #1
 8000c4c:	0a7f      	lsrs	r7, r7, #9
 8000c4e:	0e24      	lsrs	r4, r4, #24
 8000c50:	00f6      	lsls	r6, r6, #3
 8000c52:	0025      	movs	r5, r4
 8000c54:	4690      	mov	r8, r2
 8000c56:	00fb      	lsls	r3, r7, #3
 8000c58:	0e00      	lsrs	r0, r0, #24
 8000c5a:	0fc9      	lsrs	r1, r1, #31
 8000c5c:	46b1      	mov	r9, r6
 8000c5e:	28ff      	cmp	r0, #255	; 0xff
 8000c60:	d100      	bne.n	8000c64 <__aeabi_fsub+0x30>
 8000c62:	e085      	b.n	8000d70 <__aeabi_fsub+0x13c>
 8000c64:	2601      	movs	r6, #1
 8000c66:	4071      	eors	r1, r6
 8000c68:	1a26      	subs	r6, r4, r0
 8000c6a:	4291      	cmp	r1, r2
 8000c6c:	d057      	beq.n	8000d1e <__aeabi_fsub+0xea>
 8000c6e:	2e00      	cmp	r6, #0
 8000c70:	dd43      	ble.n	8000cfa <__aeabi_fsub+0xc6>
 8000c72:	2800      	cmp	r0, #0
 8000c74:	d000      	beq.n	8000c78 <__aeabi_fsub+0x44>
 8000c76:	e07f      	b.n	8000d78 <__aeabi_fsub+0x144>
 8000c78:	4649      	mov	r1, r9
 8000c7a:	2900      	cmp	r1, #0
 8000c7c:	d100      	bne.n	8000c80 <__aeabi_fsub+0x4c>
 8000c7e:	e0aa      	b.n	8000dd6 <__aeabi_fsub+0x1a2>
 8000c80:	3e01      	subs	r6, #1
 8000c82:	2e00      	cmp	r6, #0
 8000c84:	d000      	beq.n	8000c88 <__aeabi_fsub+0x54>
 8000c86:	e0f7      	b.n	8000e78 <__aeabi_fsub+0x244>
 8000c88:	1a5b      	subs	r3, r3, r1
 8000c8a:	015a      	lsls	r2, r3, #5
 8000c8c:	d400      	bmi.n	8000c90 <__aeabi_fsub+0x5c>
 8000c8e:	e08b      	b.n	8000da8 <__aeabi_fsub+0x174>
 8000c90:	019b      	lsls	r3, r3, #6
 8000c92:	099c      	lsrs	r4, r3, #6
 8000c94:	0020      	movs	r0, r4
 8000c96:	f002 f857 	bl	8002d48 <__clzsi2>
 8000c9a:	3805      	subs	r0, #5
 8000c9c:	4084      	lsls	r4, r0
 8000c9e:	4285      	cmp	r5, r0
 8000ca0:	dd00      	ble.n	8000ca4 <__aeabi_fsub+0x70>
 8000ca2:	e0d3      	b.n	8000e4c <__aeabi_fsub+0x218>
 8000ca4:	1b45      	subs	r5, r0, r5
 8000ca6:	0023      	movs	r3, r4
 8000ca8:	2020      	movs	r0, #32
 8000caa:	3501      	adds	r5, #1
 8000cac:	40eb      	lsrs	r3, r5
 8000cae:	1b45      	subs	r5, r0, r5
 8000cb0:	40ac      	lsls	r4, r5
 8000cb2:	1e62      	subs	r2, r4, #1
 8000cb4:	4194      	sbcs	r4, r2
 8000cb6:	4323      	orrs	r3, r4
 8000cb8:	2407      	movs	r4, #7
 8000cba:	2500      	movs	r5, #0
 8000cbc:	401c      	ands	r4, r3
 8000cbe:	2201      	movs	r2, #1
 8000cc0:	4641      	mov	r1, r8
 8000cc2:	400a      	ands	r2, r1
 8000cc4:	2c00      	cmp	r4, #0
 8000cc6:	d004      	beq.n	8000cd2 <__aeabi_fsub+0x9e>
 8000cc8:	210f      	movs	r1, #15
 8000cca:	4019      	ands	r1, r3
 8000ccc:	2904      	cmp	r1, #4
 8000cce:	d000      	beq.n	8000cd2 <__aeabi_fsub+0x9e>
 8000cd0:	3304      	adds	r3, #4
 8000cd2:	0159      	lsls	r1, r3, #5
 8000cd4:	d400      	bmi.n	8000cd8 <__aeabi_fsub+0xa4>
 8000cd6:	e080      	b.n	8000dda <__aeabi_fsub+0x1a6>
 8000cd8:	3501      	adds	r5, #1
 8000cda:	b2ec      	uxtb	r4, r5
 8000cdc:	2dff      	cmp	r5, #255	; 0xff
 8000cde:	d000      	beq.n	8000ce2 <__aeabi_fsub+0xae>
 8000ce0:	e0a3      	b.n	8000e2a <__aeabi_fsub+0x1f6>
 8000ce2:	24ff      	movs	r4, #255	; 0xff
 8000ce4:	2300      	movs	r3, #0
 8000ce6:	025b      	lsls	r3, r3, #9
 8000ce8:	05e4      	lsls	r4, r4, #23
 8000cea:	0a58      	lsrs	r0, r3, #9
 8000cec:	07d2      	lsls	r2, r2, #31
 8000cee:	4320      	orrs	r0, r4
 8000cf0:	4310      	orrs	r0, r2
 8000cf2:	bc0c      	pop	{r2, r3}
 8000cf4:	4690      	mov	r8, r2
 8000cf6:	4699      	mov	r9, r3
 8000cf8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000cfa:	2e00      	cmp	r6, #0
 8000cfc:	d174      	bne.n	8000de8 <__aeabi_fsub+0x1b4>
 8000cfe:	1c60      	adds	r0, r4, #1
 8000d00:	b2c0      	uxtb	r0, r0
 8000d02:	2801      	cmp	r0, #1
 8000d04:	dc00      	bgt.n	8000d08 <__aeabi_fsub+0xd4>
 8000d06:	e0a7      	b.n	8000e58 <__aeabi_fsub+0x224>
 8000d08:	464a      	mov	r2, r9
 8000d0a:	1a9c      	subs	r4, r3, r2
 8000d0c:	0162      	lsls	r2, r4, #5
 8000d0e:	d500      	bpl.n	8000d12 <__aeabi_fsub+0xde>
 8000d10:	e0b6      	b.n	8000e80 <__aeabi_fsub+0x24c>
 8000d12:	2c00      	cmp	r4, #0
 8000d14:	d1be      	bne.n	8000c94 <__aeabi_fsub+0x60>
 8000d16:	2200      	movs	r2, #0
 8000d18:	2400      	movs	r4, #0
 8000d1a:	2300      	movs	r3, #0
 8000d1c:	e7e3      	b.n	8000ce6 <__aeabi_fsub+0xb2>
 8000d1e:	2e00      	cmp	r6, #0
 8000d20:	dc00      	bgt.n	8000d24 <__aeabi_fsub+0xf0>
 8000d22:	e085      	b.n	8000e30 <__aeabi_fsub+0x1fc>
 8000d24:	2800      	cmp	r0, #0
 8000d26:	d046      	beq.n	8000db6 <__aeabi_fsub+0x182>
 8000d28:	2cff      	cmp	r4, #255	; 0xff
 8000d2a:	d049      	beq.n	8000dc0 <__aeabi_fsub+0x18c>
 8000d2c:	2280      	movs	r2, #128	; 0x80
 8000d2e:	4648      	mov	r0, r9
 8000d30:	04d2      	lsls	r2, r2, #19
 8000d32:	4310      	orrs	r0, r2
 8000d34:	4681      	mov	r9, r0
 8000d36:	2201      	movs	r2, #1
 8000d38:	2e1b      	cmp	r6, #27
 8000d3a:	dc09      	bgt.n	8000d50 <__aeabi_fsub+0x11c>
 8000d3c:	2020      	movs	r0, #32
 8000d3e:	464c      	mov	r4, r9
 8000d40:	1b80      	subs	r0, r0, r6
 8000d42:	4084      	lsls	r4, r0
 8000d44:	464a      	mov	r2, r9
 8000d46:	0020      	movs	r0, r4
 8000d48:	40f2      	lsrs	r2, r6
 8000d4a:	1e44      	subs	r4, r0, #1
 8000d4c:	41a0      	sbcs	r0, r4
 8000d4e:	4302      	orrs	r2, r0
 8000d50:	189b      	adds	r3, r3, r2
 8000d52:	015a      	lsls	r2, r3, #5
 8000d54:	d528      	bpl.n	8000da8 <__aeabi_fsub+0x174>
 8000d56:	3501      	adds	r5, #1
 8000d58:	2dff      	cmp	r5, #255	; 0xff
 8000d5a:	d100      	bne.n	8000d5e <__aeabi_fsub+0x12a>
 8000d5c:	e0a8      	b.n	8000eb0 <__aeabi_fsub+0x27c>
 8000d5e:	2201      	movs	r2, #1
 8000d60:	2407      	movs	r4, #7
 8000d62:	4994      	ldr	r1, [pc, #592]	; (8000fb4 <__aeabi_fsub+0x380>)
 8000d64:	401a      	ands	r2, r3
 8000d66:	085b      	lsrs	r3, r3, #1
 8000d68:	400b      	ands	r3, r1
 8000d6a:	4313      	orrs	r3, r2
 8000d6c:	401c      	ands	r4, r3
 8000d6e:	e7a6      	b.n	8000cbe <__aeabi_fsub+0x8a>
 8000d70:	2e00      	cmp	r6, #0
 8000d72:	d000      	beq.n	8000d76 <__aeabi_fsub+0x142>
 8000d74:	e778      	b.n	8000c68 <__aeabi_fsub+0x34>
 8000d76:	e775      	b.n	8000c64 <__aeabi_fsub+0x30>
 8000d78:	2cff      	cmp	r4, #255	; 0xff
 8000d7a:	d054      	beq.n	8000e26 <__aeabi_fsub+0x1f2>
 8000d7c:	2280      	movs	r2, #128	; 0x80
 8000d7e:	4649      	mov	r1, r9
 8000d80:	04d2      	lsls	r2, r2, #19
 8000d82:	4311      	orrs	r1, r2
 8000d84:	4689      	mov	r9, r1
 8000d86:	2201      	movs	r2, #1
 8000d88:	2e1b      	cmp	r6, #27
 8000d8a:	dc09      	bgt.n	8000da0 <__aeabi_fsub+0x16c>
 8000d8c:	2120      	movs	r1, #32
 8000d8e:	4648      	mov	r0, r9
 8000d90:	1b89      	subs	r1, r1, r6
 8000d92:	4088      	lsls	r0, r1
 8000d94:	464a      	mov	r2, r9
 8000d96:	0001      	movs	r1, r0
 8000d98:	40f2      	lsrs	r2, r6
 8000d9a:	1e48      	subs	r0, r1, #1
 8000d9c:	4181      	sbcs	r1, r0
 8000d9e:	430a      	orrs	r2, r1
 8000da0:	1a9b      	subs	r3, r3, r2
 8000da2:	015a      	lsls	r2, r3, #5
 8000da4:	d500      	bpl.n	8000da8 <__aeabi_fsub+0x174>
 8000da6:	e773      	b.n	8000c90 <__aeabi_fsub+0x5c>
 8000da8:	2201      	movs	r2, #1
 8000daa:	4641      	mov	r1, r8
 8000dac:	400a      	ands	r2, r1
 8000dae:	0759      	lsls	r1, r3, #29
 8000db0:	d000      	beq.n	8000db4 <__aeabi_fsub+0x180>
 8000db2:	e789      	b.n	8000cc8 <__aeabi_fsub+0x94>
 8000db4:	e011      	b.n	8000dda <__aeabi_fsub+0x1a6>
 8000db6:	4648      	mov	r0, r9
 8000db8:	2800      	cmp	r0, #0
 8000dba:	d158      	bne.n	8000e6e <__aeabi_fsub+0x23a>
 8000dbc:	2cff      	cmp	r4, #255	; 0xff
 8000dbe:	d10c      	bne.n	8000dda <__aeabi_fsub+0x1a6>
 8000dc0:	08db      	lsrs	r3, r3, #3
 8000dc2:	2b00      	cmp	r3, #0
 8000dc4:	d100      	bne.n	8000dc8 <__aeabi_fsub+0x194>
 8000dc6:	e78c      	b.n	8000ce2 <__aeabi_fsub+0xae>
 8000dc8:	2080      	movs	r0, #128	; 0x80
 8000dca:	03c0      	lsls	r0, r0, #15
 8000dcc:	4303      	orrs	r3, r0
 8000dce:	025b      	lsls	r3, r3, #9
 8000dd0:	0a5b      	lsrs	r3, r3, #9
 8000dd2:	24ff      	movs	r4, #255	; 0xff
 8000dd4:	e787      	b.n	8000ce6 <__aeabi_fsub+0xb2>
 8000dd6:	2cff      	cmp	r4, #255	; 0xff
 8000dd8:	d025      	beq.n	8000e26 <__aeabi_fsub+0x1f2>
 8000dda:	08db      	lsrs	r3, r3, #3
 8000ddc:	2dff      	cmp	r5, #255	; 0xff
 8000dde:	d0f0      	beq.n	8000dc2 <__aeabi_fsub+0x18e>
 8000de0:	025b      	lsls	r3, r3, #9
 8000de2:	0a5b      	lsrs	r3, r3, #9
 8000de4:	b2ec      	uxtb	r4, r5
 8000de6:	e77e      	b.n	8000ce6 <__aeabi_fsub+0xb2>
 8000de8:	2c00      	cmp	r4, #0
 8000dea:	d04d      	beq.n	8000e88 <__aeabi_fsub+0x254>
 8000dec:	28ff      	cmp	r0, #255	; 0xff
 8000dee:	d018      	beq.n	8000e22 <__aeabi_fsub+0x1ee>
 8000df0:	2480      	movs	r4, #128	; 0x80
 8000df2:	04e4      	lsls	r4, r4, #19
 8000df4:	4272      	negs	r2, r6
 8000df6:	4323      	orrs	r3, r4
 8000df8:	2a1b      	cmp	r2, #27
 8000dfa:	dd00      	ble.n	8000dfe <__aeabi_fsub+0x1ca>
 8000dfc:	e0c4      	b.n	8000f88 <__aeabi_fsub+0x354>
 8000dfe:	001c      	movs	r4, r3
 8000e00:	2520      	movs	r5, #32
 8000e02:	40d4      	lsrs	r4, r2
 8000e04:	1aaa      	subs	r2, r5, r2
 8000e06:	4093      	lsls	r3, r2
 8000e08:	1e5a      	subs	r2, r3, #1
 8000e0a:	4193      	sbcs	r3, r2
 8000e0c:	4323      	orrs	r3, r4
 8000e0e:	464a      	mov	r2, r9
 8000e10:	0005      	movs	r5, r0
 8000e12:	1ad3      	subs	r3, r2, r3
 8000e14:	4688      	mov	r8, r1
 8000e16:	e738      	b.n	8000c8a <__aeabi_fsub+0x56>
 8000e18:	1c72      	adds	r2, r6, #1
 8000e1a:	d0f8      	beq.n	8000e0e <__aeabi_fsub+0x1da>
 8000e1c:	43f2      	mvns	r2, r6
 8000e1e:	28ff      	cmp	r0, #255	; 0xff
 8000e20:	d1ea      	bne.n	8000df8 <__aeabi_fsub+0x1c4>
 8000e22:	000a      	movs	r2, r1
 8000e24:	464b      	mov	r3, r9
 8000e26:	25ff      	movs	r5, #255	; 0xff
 8000e28:	e7d7      	b.n	8000dda <__aeabi_fsub+0x1a6>
 8000e2a:	019b      	lsls	r3, r3, #6
 8000e2c:	0a5b      	lsrs	r3, r3, #9
 8000e2e:	e75a      	b.n	8000ce6 <__aeabi_fsub+0xb2>
 8000e30:	2e00      	cmp	r6, #0
 8000e32:	d141      	bne.n	8000eb8 <__aeabi_fsub+0x284>
 8000e34:	1c65      	adds	r5, r4, #1
 8000e36:	b2e9      	uxtb	r1, r5
 8000e38:	2901      	cmp	r1, #1
 8000e3a:	dd45      	ble.n	8000ec8 <__aeabi_fsub+0x294>
 8000e3c:	2dff      	cmp	r5, #255	; 0xff
 8000e3e:	d100      	bne.n	8000e42 <__aeabi_fsub+0x20e>
 8000e40:	e74f      	b.n	8000ce2 <__aeabi_fsub+0xae>
 8000e42:	2407      	movs	r4, #7
 8000e44:	444b      	add	r3, r9
 8000e46:	085b      	lsrs	r3, r3, #1
 8000e48:	401c      	ands	r4, r3
 8000e4a:	e738      	b.n	8000cbe <__aeabi_fsub+0x8a>
 8000e4c:	2207      	movs	r2, #7
 8000e4e:	4b5a      	ldr	r3, [pc, #360]	; (8000fb8 <__aeabi_fsub+0x384>)
 8000e50:	1a2d      	subs	r5, r5, r0
 8000e52:	4023      	ands	r3, r4
 8000e54:	4014      	ands	r4, r2
 8000e56:	e732      	b.n	8000cbe <__aeabi_fsub+0x8a>
 8000e58:	2c00      	cmp	r4, #0
 8000e5a:	d11d      	bne.n	8000e98 <__aeabi_fsub+0x264>
 8000e5c:	2b00      	cmp	r3, #0
 8000e5e:	d17a      	bne.n	8000f56 <__aeabi_fsub+0x322>
 8000e60:	464b      	mov	r3, r9
 8000e62:	2b00      	cmp	r3, #0
 8000e64:	d100      	bne.n	8000e68 <__aeabi_fsub+0x234>
 8000e66:	e091      	b.n	8000f8c <__aeabi_fsub+0x358>
 8000e68:	000a      	movs	r2, r1
 8000e6a:	2500      	movs	r5, #0
 8000e6c:	e7b5      	b.n	8000dda <__aeabi_fsub+0x1a6>
 8000e6e:	3e01      	subs	r6, #1
 8000e70:	2e00      	cmp	r6, #0
 8000e72:	d119      	bne.n	8000ea8 <__aeabi_fsub+0x274>
 8000e74:	444b      	add	r3, r9
 8000e76:	e76c      	b.n	8000d52 <__aeabi_fsub+0x11e>
 8000e78:	2cff      	cmp	r4, #255	; 0xff
 8000e7a:	d184      	bne.n	8000d86 <__aeabi_fsub+0x152>
 8000e7c:	25ff      	movs	r5, #255	; 0xff
 8000e7e:	e7ac      	b.n	8000dda <__aeabi_fsub+0x1a6>
 8000e80:	464a      	mov	r2, r9
 8000e82:	4688      	mov	r8, r1
 8000e84:	1ad4      	subs	r4, r2, r3
 8000e86:	e705      	b.n	8000c94 <__aeabi_fsub+0x60>
 8000e88:	2b00      	cmp	r3, #0
 8000e8a:	d1c5      	bne.n	8000e18 <__aeabi_fsub+0x1e4>
 8000e8c:	000a      	movs	r2, r1
 8000e8e:	28ff      	cmp	r0, #255	; 0xff
 8000e90:	d0c8      	beq.n	8000e24 <__aeabi_fsub+0x1f0>
 8000e92:	0005      	movs	r5, r0
 8000e94:	464b      	mov	r3, r9
 8000e96:	e7a0      	b.n	8000dda <__aeabi_fsub+0x1a6>
 8000e98:	2b00      	cmp	r3, #0
 8000e9a:	d149      	bne.n	8000f30 <__aeabi_fsub+0x2fc>
 8000e9c:	464b      	mov	r3, r9
 8000e9e:	2b00      	cmp	r3, #0
 8000ea0:	d077      	beq.n	8000f92 <__aeabi_fsub+0x35e>
 8000ea2:	000a      	movs	r2, r1
 8000ea4:	25ff      	movs	r5, #255	; 0xff
 8000ea6:	e798      	b.n	8000dda <__aeabi_fsub+0x1a6>
 8000ea8:	2cff      	cmp	r4, #255	; 0xff
 8000eaa:	d000      	beq.n	8000eae <__aeabi_fsub+0x27a>
 8000eac:	e743      	b.n	8000d36 <__aeabi_fsub+0x102>
 8000eae:	e787      	b.n	8000dc0 <__aeabi_fsub+0x18c>
 8000eb0:	000a      	movs	r2, r1
 8000eb2:	24ff      	movs	r4, #255	; 0xff
 8000eb4:	2300      	movs	r3, #0
 8000eb6:	e716      	b.n	8000ce6 <__aeabi_fsub+0xb2>
 8000eb8:	2c00      	cmp	r4, #0
 8000eba:	d115      	bne.n	8000ee8 <__aeabi_fsub+0x2b4>
 8000ebc:	2b00      	cmp	r3, #0
 8000ebe:	d157      	bne.n	8000f70 <__aeabi_fsub+0x33c>
 8000ec0:	28ff      	cmp	r0, #255	; 0xff
 8000ec2:	d1e6      	bne.n	8000e92 <__aeabi_fsub+0x25e>
 8000ec4:	464b      	mov	r3, r9
 8000ec6:	e77b      	b.n	8000dc0 <__aeabi_fsub+0x18c>
 8000ec8:	2c00      	cmp	r4, #0
 8000eca:	d120      	bne.n	8000f0e <__aeabi_fsub+0x2da>
 8000ecc:	2b00      	cmp	r3, #0
 8000ece:	d057      	beq.n	8000f80 <__aeabi_fsub+0x34c>
 8000ed0:	4649      	mov	r1, r9
 8000ed2:	2900      	cmp	r1, #0
 8000ed4:	d053      	beq.n	8000f7e <__aeabi_fsub+0x34a>
 8000ed6:	444b      	add	r3, r9
 8000ed8:	015a      	lsls	r2, r3, #5
 8000eda:	d568      	bpl.n	8000fae <__aeabi_fsub+0x37a>
 8000edc:	2407      	movs	r4, #7
 8000ede:	4a36      	ldr	r2, [pc, #216]	; (8000fb8 <__aeabi_fsub+0x384>)
 8000ee0:	401c      	ands	r4, r3
 8000ee2:	2501      	movs	r5, #1
 8000ee4:	4013      	ands	r3, r2
 8000ee6:	e6ea      	b.n	8000cbe <__aeabi_fsub+0x8a>
 8000ee8:	28ff      	cmp	r0, #255	; 0xff
 8000eea:	d0eb      	beq.n	8000ec4 <__aeabi_fsub+0x290>
 8000eec:	2280      	movs	r2, #128	; 0x80
 8000eee:	04d2      	lsls	r2, r2, #19
 8000ef0:	4276      	negs	r6, r6
 8000ef2:	4313      	orrs	r3, r2
 8000ef4:	2e1b      	cmp	r6, #27
 8000ef6:	dc53      	bgt.n	8000fa0 <__aeabi_fsub+0x36c>
 8000ef8:	2520      	movs	r5, #32
 8000efa:	1bad      	subs	r5, r5, r6
 8000efc:	001a      	movs	r2, r3
 8000efe:	40ab      	lsls	r3, r5
 8000f00:	40f2      	lsrs	r2, r6
 8000f02:	1e5c      	subs	r4, r3, #1
 8000f04:	41a3      	sbcs	r3, r4
 8000f06:	4313      	orrs	r3, r2
 8000f08:	444b      	add	r3, r9
 8000f0a:	0005      	movs	r5, r0
 8000f0c:	e721      	b.n	8000d52 <__aeabi_fsub+0x11e>
 8000f0e:	2b00      	cmp	r3, #0
 8000f10:	d0d8      	beq.n	8000ec4 <__aeabi_fsub+0x290>
 8000f12:	4649      	mov	r1, r9
 8000f14:	2900      	cmp	r1, #0
 8000f16:	d100      	bne.n	8000f1a <__aeabi_fsub+0x2e6>
 8000f18:	e752      	b.n	8000dc0 <__aeabi_fsub+0x18c>
 8000f1a:	2180      	movs	r1, #128	; 0x80
 8000f1c:	03c9      	lsls	r1, r1, #15
 8000f1e:	420f      	tst	r7, r1
 8000f20:	d100      	bne.n	8000f24 <__aeabi_fsub+0x2f0>
 8000f22:	e74d      	b.n	8000dc0 <__aeabi_fsub+0x18c>
 8000f24:	4660      	mov	r0, ip
 8000f26:	4208      	tst	r0, r1
 8000f28:	d000      	beq.n	8000f2c <__aeabi_fsub+0x2f8>
 8000f2a:	e749      	b.n	8000dc0 <__aeabi_fsub+0x18c>
 8000f2c:	464b      	mov	r3, r9
 8000f2e:	e747      	b.n	8000dc0 <__aeabi_fsub+0x18c>
 8000f30:	4648      	mov	r0, r9
 8000f32:	25ff      	movs	r5, #255	; 0xff
 8000f34:	2800      	cmp	r0, #0
 8000f36:	d100      	bne.n	8000f3a <__aeabi_fsub+0x306>
 8000f38:	e74f      	b.n	8000dda <__aeabi_fsub+0x1a6>
 8000f3a:	2280      	movs	r2, #128	; 0x80
 8000f3c:	03d2      	lsls	r2, r2, #15
 8000f3e:	4217      	tst	r7, r2
 8000f40:	d004      	beq.n	8000f4c <__aeabi_fsub+0x318>
 8000f42:	4660      	mov	r0, ip
 8000f44:	4210      	tst	r0, r2
 8000f46:	d101      	bne.n	8000f4c <__aeabi_fsub+0x318>
 8000f48:	464b      	mov	r3, r9
 8000f4a:	4688      	mov	r8, r1
 8000f4c:	2201      	movs	r2, #1
 8000f4e:	4641      	mov	r1, r8
 8000f50:	25ff      	movs	r5, #255	; 0xff
 8000f52:	400a      	ands	r2, r1
 8000f54:	e741      	b.n	8000dda <__aeabi_fsub+0x1a6>
 8000f56:	4648      	mov	r0, r9
 8000f58:	2800      	cmp	r0, #0
 8000f5a:	d01f      	beq.n	8000f9c <__aeabi_fsub+0x368>
 8000f5c:	1a1a      	subs	r2, r3, r0
 8000f5e:	0150      	lsls	r0, r2, #5
 8000f60:	d520      	bpl.n	8000fa4 <__aeabi_fsub+0x370>
 8000f62:	464a      	mov	r2, r9
 8000f64:	2407      	movs	r4, #7
 8000f66:	1ad3      	subs	r3, r2, r3
 8000f68:	401c      	ands	r4, r3
 8000f6a:	4688      	mov	r8, r1
 8000f6c:	2500      	movs	r5, #0
 8000f6e:	e6a6      	b.n	8000cbe <__aeabi_fsub+0x8a>
 8000f70:	1c74      	adds	r4, r6, #1
 8000f72:	d0c9      	beq.n	8000f08 <__aeabi_fsub+0x2d4>
 8000f74:	43f6      	mvns	r6, r6
 8000f76:	28ff      	cmp	r0, #255	; 0xff
 8000f78:	d1bc      	bne.n	8000ef4 <__aeabi_fsub+0x2c0>
 8000f7a:	464b      	mov	r3, r9
 8000f7c:	e720      	b.n	8000dc0 <__aeabi_fsub+0x18c>
 8000f7e:	4699      	mov	r9, r3
 8000f80:	464b      	mov	r3, r9
 8000f82:	2500      	movs	r5, #0
 8000f84:	08db      	lsrs	r3, r3, #3
 8000f86:	e72b      	b.n	8000de0 <__aeabi_fsub+0x1ac>
 8000f88:	2301      	movs	r3, #1
 8000f8a:	e740      	b.n	8000e0e <__aeabi_fsub+0x1da>
 8000f8c:	2200      	movs	r2, #0
 8000f8e:	2300      	movs	r3, #0
 8000f90:	e6a9      	b.n	8000ce6 <__aeabi_fsub+0xb2>
 8000f92:	2380      	movs	r3, #128	; 0x80
 8000f94:	2200      	movs	r2, #0
 8000f96:	03db      	lsls	r3, r3, #15
 8000f98:	24ff      	movs	r4, #255	; 0xff
 8000f9a:	e6a4      	b.n	8000ce6 <__aeabi_fsub+0xb2>
 8000f9c:	2500      	movs	r5, #0
 8000f9e:	e71c      	b.n	8000dda <__aeabi_fsub+0x1a6>
 8000fa0:	2301      	movs	r3, #1
 8000fa2:	e7b1      	b.n	8000f08 <__aeabi_fsub+0x2d4>
 8000fa4:	2a00      	cmp	r2, #0
 8000fa6:	d0f1      	beq.n	8000f8c <__aeabi_fsub+0x358>
 8000fa8:	0013      	movs	r3, r2
 8000faa:	2500      	movs	r5, #0
 8000fac:	e6fc      	b.n	8000da8 <__aeabi_fsub+0x174>
 8000fae:	2500      	movs	r5, #0
 8000fb0:	e6fa      	b.n	8000da8 <__aeabi_fsub+0x174>
 8000fb2:	46c0      	nop			; (mov r8, r8)
 8000fb4:	7dffffff 	.word	0x7dffffff
 8000fb8:	fbffffff 	.word	0xfbffffff

08000fbc <__aeabi_f2iz>:
 8000fbc:	0241      	lsls	r1, r0, #9
 8000fbe:	0042      	lsls	r2, r0, #1
 8000fc0:	0fc3      	lsrs	r3, r0, #31
 8000fc2:	0a49      	lsrs	r1, r1, #9
 8000fc4:	0e12      	lsrs	r2, r2, #24
 8000fc6:	2000      	movs	r0, #0
 8000fc8:	2a7e      	cmp	r2, #126	; 0x7e
 8000fca:	d90d      	bls.n	8000fe8 <__aeabi_f2iz+0x2c>
 8000fcc:	2a9d      	cmp	r2, #157	; 0x9d
 8000fce:	d80c      	bhi.n	8000fea <__aeabi_f2iz+0x2e>
 8000fd0:	2080      	movs	r0, #128	; 0x80
 8000fd2:	0400      	lsls	r0, r0, #16
 8000fd4:	4301      	orrs	r1, r0
 8000fd6:	2a95      	cmp	r2, #149	; 0x95
 8000fd8:	dc0a      	bgt.n	8000ff0 <__aeabi_f2iz+0x34>
 8000fda:	2096      	movs	r0, #150	; 0x96
 8000fdc:	1a82      	subs	r2, r0, r2
 8000fde:	40d1      	lsrs	r1, r2
 8000fe0:	4248      	negs	r0, r1
 8000fe2:	2b00      	cmp	r3, #0
 8000fe4:	d100      	bne.n	8000fe8 <__aeabi_f2iz+0x2c>
 8000fe6:	0008      	movs	r0, r1
 8000fe8:	4770      	bx	lr
 8000fea:	4a03      	ldr	r2, [pc, #12]	; (8000ff8 <__aeabi_f2iz+0x3c>)
 8000fec:	1898      	adds	r0, r3, r2
 8000fee:	e7fb      	b.n	8000fe8 <__aeabi_f2iz+0x2c>
 8000ff0:	3a96      	subs	r2, #150	; 0x96
 8000ff2:	4091      	lsls	r1, r2
 8000ff4:	e7f4      	b.n	8000fe0 <__aeabi_f2iz+0x24>
 8000ff6:	46c0      	nop			; (mov r8, r8)
 8000ff8:	7fffffff 	.word	0x7fffffff

08000ffc <__aeabi_i2f>:
 8000ffc:	b570      	push	{r4, r5, r6, lr}
 8000ffe:	2800      	cmp	r0, #0
 8001000:	d03d      	beq.n	800107e <__aeabi_i2f+0x82>
 8001002:	17c3      	asrs	r3, r0, #31
 8001004:	18c5      	adds	r5, r0, r3
 8001006:	405d      	eors	r5, r3
 8001008:	0fc4      	lsrs	r4, r0, #31
 800100a:	0028      	movs	r0, r5
 800100c:	f001 fe9c 	bl	8002d48 <__clzsi2>
 8001010:	229e      	movs	r2, #158	; 0x9e
 8001012:	1a12      	subs	r2, r2, r0
 8001014:	2a96      	cmp	r2, #150	; 0x96
 8001016:	dc07      	bgt.n	8001028 <__aeabi_i2f+0x2c>
 8001018:	b2d2      	uxtb	r2, r2
 800101a:	2808      	cmp	r0, #8
 800101c:	dd33      	ble.n	8001086 <__aeabi_i2f+0x8a>
 800101e:	3808      	subs	r0, #8
 8001020:	4085      	lsls	r5, r0
 8001022:	0268      	lsls	r0, r5, #9
 8001024:	0a40      	lsrs	r0, r0, #9
 8001026:	e023      	b.n	8001070 <__aeabi_i2f+0x74>
 8001028:	2a99      	cmp	r2, #153	; 0x99
 800102a:	dd0b      	ble.n	8001044 <__aeabi_i2f+0x48>
 800102c:	2305      	movs	r3, #5
 800102e:	0029      	movs	r1, r5
 8001030:	1a1b      	subs	r3, r3, r0
 8001032:	40d9      	lsrs	r1, r3
 8001034:	0003      	movs	r3, r0
 8001036:	331b      	adds	r3, #27
 8001038:	409d      	lsls	r5, r3
 800103a:	002b      	movs	r3, r5
 800103c:	1e5d      	subs	r5, r3, #1
 800103e:	41ab      	sbcs	r3, r5
 8001040:	4319      	orrs	r1, r3
 8001042:	000d      	movs	r5, r1
 8001044:	2805      	cmp	r0, #5
 8001046:	dd01      	ble.n	800104c <__aeabi_i2f+0x50>
 8001048:	1f43      	subs	r3, r0, #5
 800104a:	409d      	lsls	r5, r3
 800104c:	002b      	movs	r3, r5
 800104e:	490f      	ldr	r1, [pc, #60]	; (800108c <__aeabi_i2f+0x90>)
 8001050:	400b      	ands	r3, r1
 8001052:	076e      	lsls	r6, r5, #29
 8001054:	d009      	beq.n	800106a <__aeabi_i2f+0x6e>
 8001056:	260f      	movs	r6, #15
 8001058:	4035      	ands	r5, r6
 800105a:	2d04      	cmp	r5, #4
 800105c:	d005      	beq.n	800106a <__aeabi_i2f+0x6e>
 800105e:	3304      	adds	r3, #4
 8001060:	015d      	lsls	r5, r3, #5
 8001062:	d502      	bpl.n	800106a <__aeabi_i2f+0x6e>
 8001064:	229f      	movs	r2, #159	; 0x9f
 8001066:	400b      	ands	r3, r1
 8001068:	1a12      	subs	r2, r2, r0
 800106a:	019b      	lsls	r3, r3, #6
 800106c:	0a58      	lsrs	r0, r3, #9
 800106e:	b2d2      	uxtb	r2, r2
 8001070:	0240      	lsls	r0, r0, #9
 8001072:	05d2      	lsls	r2, r2, #23
 8001074:	0a40      	lsrs	r0, r0, #9
 8001076:	07e4      	lsls	r4, r4, #31
 8001078:	4310      	orrs	r0, r2
 800107a:	4320      	orrs	r0, r4
 800107c:	bd70      	pop	{r4, r5, r6, pc}
 800107e:	2400      	movs	r4, #0
 8001080:	2200      	movs	r2, #0
 8001082:	2000      	movs	r0, #0
 8001084:	e7f4      	b.n	8001070 <__aeabi_i2f+0x74>
 8001086:	0268      	lsls	r0, r5, #9
 8001088:	0a40      	lsrs	r0, r0, #9
 800108a:	e7f1      	b.n	8001070 <__aeabi_i2f+0x74>
 800108c:	fbffffff 	.word	0xfbffffff

08001090 <__aeabi_dadd>:
 8001090:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001092:	464f      	mov	r7, r9
 8001094:	4646      	mov	r6, r8
 8001096:	46d6      	mov	lr, sl
 8001098:	000c      	movs	r4, r1
 800109a:	0309      	lsls	r1, r1, #12
 800109c:	b5c0      	push	{r6, r7, lr}
 800109e:	0a49      	lsrs	r1, r1, #9
 80010a0:	0f47      	lsrs	r7, r0, #29
 80010a2:	005e      	lsls	r6, r3, #1
 80010a4:	4339      	orrs	r1, r7
 80010a6:	031f      	lsls	r7, r3, #12
 80010a8:	0fdb      	lsrs	r3, r3, #31
 80010aa:	469c      	mov	ip, r3
 80010ac:	0065      	lsls	r5, r4, #1
 80010ae:	0a7b      	lsrs	r3, r7, #9
 80010b0:	0f57      	lsrs	r7, r2, #29
 80010b2:	431f      	orrs	r7, r3
 80010b4:	0d6d      	lsrs	r5, r5, #21
 80010b6:	0fe4      	lsrs	r4, r4, #31
 80010b8:	0d76      	lsrs	r6, r6, #21
 80010ba:	46a1      	mov	r9, r4
 80010bc:	00c0      	lsls	r0, r0, #3
 80010be:	46b8      	mov	r8, r7
 80010c0:	00d2      	lsls	r2, r2, #3
 80010c2:	1bab      	subs	r3, r5, r6
 80010c4:	4564      	cmp	r4, ip
 80010c6:	d07b      	beq.n	80011c0 <__aeabi_dadd+0x130>
 80010c8:	2b00      	cmp	r3, #0
 80010ca:	dd5f      	ble.n	800118c <__aeabi_dadd+0xfc>
 80010cc:	2e00      	cmp	r6, #0
 80010ce:	d000      	beq.n	80010d2 <__aeabi_dadd+0x42>
 80010d0:	e0a4      	b.n	800121c <__aeabi_dadd+0x18c>
 80010d2:	003e      	movs	r6, r7
 80010d4:	4316      	orrs	r6, r2
 80010d6:	d100      	bne.n	80010da <__aeabi_dadd+0x4a>
 80010d8:	e112      	b.n	8001300 <__aeabi_dadd+0x270>
 80010da:	1e5e      	subs	r6, r3, #1
 80010dc:	2e00      	cmp	r6, #0
 80010de:	d000      	beq.n	80010e2 <__aeabi_dadd+0x52>
 80010e0:	e19e      	b.n	8001420 <__aeabi_dadd+0x390>
 80010e2:	1a87      	subs	r7, r0, r2
 80010e4:	4643      	mov	r3, r8
 80010e6:	42b8      	cmp	r0, r7
 80010e8:	4180      	sbcs	r0, r0
 80010ea:	2501      	movs	r5, #1
 80010ec:	1ac9      	subs	r1, r1, r3
 80010ee:	4240      	negs	r0, r0
 80010f0:	1a09      	subs	r1, r1, r0
 80010f2:	020b      	lsls	r3, r1, #8
 80010f4:	d400      	bmi.n	80010f8 <__aeabi_dadd+0x68>
 80010f6:	e131      	b.n	800135c <__aeabi_dadd+0x2cc>
 80010f8:	0249      	lsls	r1, r1, #9
 80010fa:	0a4e      	lsrs	r6, r1, #9
 80010fc:	2e00      	cmp	r6, #0
 80010fe:	d100      	bne.n	8001102 <__aeabi_dadd+0x72>
 8001100:	e16e      	b.n	80013e0 <__aeabi_dadd+0x350>
 8001102:	0030      	movs	r0, r6
 8001104:	f001 fe20 	bl	8002d48 <__clzsi2>
 8001108:	0003      	movs	r3, r0
 800110a:	3b08      	subs	r3, #8
 800110c:	2b1f      	cmp	r3, #31
 800110e:	dd00      	ble.n	8001112 <__aeabi_dadd+0x82>
 8001110:	e161      	b.n	80013d6 <__aeabi_dadd+0x346>
 8001112:	2220      	movs	r2, #32
 8001114:	0039      	movs	r1, r7
 8001116:	1ad2      	subs	r2, r2, r3
 8001118:	409e      	lsls	r6, r3
 800111a:	40d1      	lsrs	r1, r2
 800111c:	409f      	lsls	r7, r3
 800111e:	430e      	orrs	r6, r1
 8001120:	429d      	cmp	r5, r3
 8001122:	dd00      	ble.n	8001126 <__aeabi_dadd+0x96>
 8001124:	e151      	b.n	80013ca <__aeabi_dadd+0x33a>
 8001126:	1b5d      	subs	r5, r3, r5
 8001128:	1c6b      	adds	r3, r5, #1
 800112a:	2b1f      	cmp	r3, #31
 800112c:	dd00      	ble.n	8001130 <__aeabi_dadd+0xa0>
 800112e:	e17c      	b.n	800142a <__aeabi_dadd+0x39a>
 8001130:	2120      	movs	r1, #32
 8001132:	1ac9      	subs	r1, r1, r3
 8001134:	003d      	movs	r5, r7
 8001136:	0030      	movs	r0, r6
 8001138:	408f      	lsls	r7, r1
 800113a:	4088      	lsls	r0, r1
 800113c:	40dd      	lsrs	r5, r3
 800113e:	1e79      	subs	r1, r7, #1
 8001140:	418f      	sbcs	r7, r1
 8001142:	0031      	movs	r1, r6
 8001144:	2207      	movs	r2, #7
 8001146:	4328      	orrs	r0, r5
 8001148:	40d9      	lsrs	r1, r3
 800114a:	2500      	movs	r5, #0
 800114c:	4307      	orrs	r7, r0
 800114e:	403a      	ands	r2, r7
 8001150:	2a00      	cmp	r2, #0
 8001152:	d009      	beq.n	8001168 <__aeabi_dadd+0xd8>
 8001154:	230f      	movs	r3, #15
 8001156:	403b      	ands	r3, r7
 8001158:	2b04      	cmp	r3, #4
 800115a:	d005      	beq.n	8001168 <__aeabi_dadd+0xd8>
 800115c:	1d3b      	adds	r3, r7, #4
 800115e:	42bb      	cmp	r3, r7
 8001160:	41bf      	sbcs	r7, r7
 8001162:	427f      	negs	r7, r7
 8001164:	19c9      	adds	r1, r1, r7
 8001166:	001f      	movs	r7, r3
 8001168:	020b      	lsls	r3, r1, #8
 800116a:	d400      	bmi.n	800116e <__aeabi_dadd+0xde>
 800116c:	e226      	b.n	80015bc <__aeabi_dadd+0x52c>
 800116e:	1c6a      	adds	r2, r5, #1
 8001170:	4bc6      	ldr	r3, [pc, #792]	; (800148c <__aeabi_dadd+0x3fc>)
 8001172:	0555      	lsls	r5, r2, #21
 8001174:	0d6d      	lsrs	r5, r5, #21
 8001176:	429a      	cmp	r2, r3
 8001178:	d100      	bne.n	800117c <__aeabi_dadd+0xec>
 800117a:	e106      	b.n	800138a <__aeabi_dadd+0x2fa>
 800117c:	4ac4      	ldr	r2, [pc, #784]	; (8001490 <__aeabi_dadd+0x400>)
 800117e:	08ff      	lsrs	r7, r7, #3
 8001180:	400a      	ands	r2, r1
 8001182:	0753      	lsls	r3, r2, #29
 8001184:	0252      	lsls	r2, r2, #9
 8001186:	433b      	orrs	r3, r7
 8001188:	0b12      	lsrs	r2, r2, #12
 800118a:	e08e      	b.n	80012aa <__aeabi_dadd+0x21a>
 800118c:	2b00      	cmp	r3, #0
 800118e:	d000      	beq.n	8001192 <__aeabi_dadd+0x102>
 8001190:	e0b8      	b.n	8001304 <__aeabi_dadd+0x274>
 8001192:	1c6b      	adds	r3, r5, #1
 8001194:	055b      	lsls	r3, r3, #21
 8001196:	0d5b      	lsrs	r3, r3, #21
 8001198:	2b01      	cmp	r3, #1
 800119a:	dc00      	bgt.n	800119e <__aeabi_dadd+0x10e>
 800119c:	e130      	b.n	8001400 <__aeabi_dadd+0x370>
 800119e:	1a87      	subs	r7, r0, r2
 80011a0:	4643      	mov	r3, r8
 80011a2:	42b8      	cmp	r0, r7
 80011a4:	41b6      	sbcs	r6, r6
 80011a6:	1acb      	subs	r3, r1, r3
 80011a8:	4276      	negs	r6, r6
 80011aa:	1b9e      	subs	r6, r3, r6
 80011ac:	0233      	lsls	r3, r6, #8
 80011ae:	d500      	bpl.n	80011b2 <__aeabi_dadd+0x122>
 80011b0:	e14c      	b.n	800144c <__aeabi_dadd+0x3bc>
 80011b2:	003b      	movs	r3, r7
 80011b4:	4333      	orrs	r3, r6
 80011b6:	d1a1      	bne.n	80010fc <__aeabi_dadd+0x6c>
 80011b8:	2200      	movs	r2, #0
 80011ba:	2400      	movs	r4, #0
 80011bc:	2500      	movs	r5, #0
 80011be:	e070      	b.n	80012a2 <__aeabi_dadd+0x212>
 80011c0:	2b00      	cmp	r3, #0
 80011c2:	dc00      	bgt.n	80011c6 <__aeabi_dadd+0x136>
 80011c4:	e0e5      	b.n	8001392 <__aeabi_dadd+0x302>
 80011c6:	2e00      	cmp	r6, #0
 80011c8:	d100      	bne.n	80011cc <__aeabi_dadd+0x13c>
 80011ca:	e083      	b.n	80012d4 <__aeabi_dadd+0x244>
 80011cc:	4eaf      	ldr	r6, [pc, #700]	; (800148c <__aeabi_dadd+0x3fc>)
 80011ce:	42b5      	cmp	r5, r6
 80011d0:	d060      	beq.n	8001294 <__aeabi_dadd+0x204>
 80011d2:	2680      	movs	r6, #128	; 0x80
 80011d4:	0436      	lsls	r6, r6, #16
 80011d6:	4337      	orrs	r7, r6
 80011d8:	46b8      	mov	r8, r7
 80011da:	2b38      	cmp	r3, #56	; 0x38
 80011dc:	dc00      	bgt.n	80011e0 <__aeabi_dadd+0x150>
 80011de:	e13e      	b.n	800145e <__aeabi_dadd+0x3ce>
 80011e0:	4643      	mov	r3, r8
 80011e2:	4313      	orrs	r3, r2
 80011e4:	001f      	movs	r7, r3
 80011e6:	1e7a      	subs	r2, r7, #1
 80011e8:	4197      	sbcs	r7, r2
 80011ea:	183f      	adds	r7, r7, r0
 80011ec:	4287      	cmp	r7, r0
 80011ee:	4180      	sbcs	r0, r0
 80011f0:	4240      	negs	r0, r0
 80011f2:	1809      	adds	r1, r1, r0
 80011f4:	020b      	lsls	r3, r1, #8
 80011f6:	d400      	bmi.n	80011fa <__aeabi_dadd+0x16a>
 80011f8:	e0b0      	b.n	800135c <__aeabi_dadd+0x2cc>
 80011fa:	4ba4      	ldr	r3, [pc, #656]	; (800148c <__aeabi_dadd+0x3fc>)
 80011fc:	3501      	adds	r5, #1
 80011fe:	429d      	cmp	r5, r3
 8001200:	d100      	bne.n	8001204 <__aeabi_dadd+0x174>
 8001202:	e0c3      	b.n	800138c <__aeabi_dadd+0x2fc>
 8001204:	4aa2      	ldr	r2, [pc, #648]	; (8001490 <__aeabi_dadd+0x400>)
 8001206:	087b      	lsrs	r3, r7, #1
 8001208:	400a      	ands	r2, r1
 800120a:	2101      	movs	r1, #1
 800120c:	400f      	ands	r7, r1
 800120e:	431f      	orrs	r7, r3
 8001210:	0851      	lsrs	r1, r2, #1
 8001212:	07d3      	lsls	r3, r2, #31
 8001214:	2207      	movs	r2, #7
 8001216:	431f      	orrs	r7, r3
 8001218:	403a      	ands	r2, r7
 800121a:	e799      	b.n	8001150 <__aeabi_dadd+0xc0>
 800121c:	4e9b      	ldr	r6, [pc, #620]	; (800148c <__aeabi_dadd+0x3fc>)
 800121e:	42b5      	cmp	r5, r6
 8001220:	d038      	beq.n	8001294 <__aeabi_dadd+0x204>
 8001222:	2680      	movs	r6, #128	; 0x80
 8001224:	0436      	lsls	r6, r6, #16
 8001226:	4337      	orrs	r7, r6
 8001228:	46b8      	mov	r8, r7
 800122a:	2b38      	cmp	r3, #56	; 0x38
 800122c:	dd00      	ble.n	8001230 <__aeabi_dadd+0x1a0>
 800122e:	e0dc      	b.n	80013ea <__aeabi_dadd+0x35a>
 8001230:	2b1f      	cmp	r3, #31
 8001232:	dc00      	bgt.n	8001236 <__aeabi_dadd+0x1a6>
 8001234:	e130      	b.n	8001498 <__aeabi_dadd+0x408>
 8001236:	001e      	movs	r6, r3
 8001238:	4647      	mov	r7, r8
 800123a:	3e20      	subs	r6, #32
 800123c:	40f7      	lsrs	r7, r6
 800123e:	46bc      	mov	ip, r7
 8001240:	2b20      	cmp	r3, #32
 8001242:	d004      	beq.n	800124e <__aeabi_dadd+0x1be>
 8001244:	2640      	movs	r6, #64	; 0x40
 8001246:	1af3      	subs	r3, r6, r3
 8001248:	4646      	mov	r6, r8
 800124a:	409e      	lsls	r6, r3
 800124c:	4332      	orrs	r2, r6
 800124e:	0017      	movs	r7, r2
 8001250:	4663      	mov	r3, ip
 8001252:	1e7a      	subs	r2, r7, #1
 8001254:	4197      	sbcs	r7, r2
 8001256:	431f      	orrs	r7, r3
 8001258:	e0cc      	b.n	80013f4 <__aeabi_dadd+0x364>
 800125a:	2b00      	cmp	r3, #0
 800125c:	d100      	bne.n	8001260 <__aeabi_dadd+0x1d0>
 800125e:	e204      	b.n	800166a <__aeabi_dadd+0x5da>
 8001260:	4643      	mov	r3, r8
 8001262:	4313      	orrs	r3, r2
 8001264:	d100      	bne.n	8001268 <__aeabi_dadd+0x1d8>
 8001266:	e159      	b.n	800151c <__aeabi_dadd+0x48c>
 8001268:	074b      	lsls	r3, r1, #29
 800126a:	08c0      	lsrs	r0, r0, #3
 800126c:	4318      	orrs	r0, r3
 800126e:	2380      	movs	r3, #128	; 0x80
 8001270:	08c9      	lsrs	r1, r1, #3
 8001272:	031b      	lsls	r3, r3, #12
 8001274:	4219      	tst	r1, r3
 8001276:	d008      	beq.n	800128a <__aeabi_dadd+0x1fa>
 8001278:	4645      	mov	r5, r8
 800127a:	08ed      	lsrs	r5, r5, #3
 800127c:	421d      	tst	r5, r3
 800127e:	d104      	bne.n	800128a <__aeabi_dadd+0x1fa>
 8001280:	4643      	mov	r3, r8
 8001282:	08d0      	lsrs	r0, r2, #3
 8001284:	0759      	lsls	r1, r3, #29
 8001286:	4308      	orrs	r0, r1
 8001288:	0029      	movs	r1, r5
 800128a:	0f42      	lsrs	r2, r0, #29
 800128c:	00c9      	lsls	r1, r1, #3
 800128e:	4d7f      	ldr	r5, [pc, #508]	; (800148c <__aeabi_dadd+0x3fc>)
 8001290:	4311      	orrs	r1, r2
 8001292:	00c0      	lsls	r0, r0, #3
 8001294:	074b      	lsls	r3, r1, #29
 8001296:	08ca      	lsrs	r2, r1, #3
 8001298:	497c      	ldr	r1, [pc, #496]	; (800148c <__aeabi_dadd+0x3fc>)
 800129a:	08c0      	lsrs	r0, r0, #3
 800129c:	4303      	orrs	r3, r0
 800129e:	428d      	cmp	r5, r1
 80012a0:	d068      	beq.n	8001374 <__aeabi_dadd+0x2e4>
 80012a2:	0312      	lsls	r2, r2, #12
 80012a4:	056d      	lsls	r5, r5, #21
 80012a6:	0b12      	lsrs	r2, r2, #12
 80012a8:	0d6d      	lsrs	r5, r5, #21
 80012aa:	2100      	movs	r1, #0
 80012ac:	0312      	lsls	r2, r2, #12
 80012ae:	0018      	movs	r0, r3
 80012b0:	0b13      	lsrs	r3, r2, #12
 80012b2:	0d0a      	lsrs	r2, r1, #20
 80012b4:	0512      	lsls	r2, r2, #20
 80012b6:	431a      	orrs	r2, r3
 80012b8:	4b76      	ldr	r3, [pc, #472]	; (8001494 <__aeabi_dadd+0x404>)
 80012ba:	052d      	lsls	r5, r5, #20
 80012bc:	4013      	ands	r3, r2
 80012be:	432b      	orrs	r3, r5
 80012c0:	005b      	lsls	r3, r3, #1
 80012c2:	07e4      	lsls	r4, r4, #31
 80012c4:	085b      	lsrs	r3, r3, #1
 80012c6:	4323      	orrs	r3, r4
 80012c8:	0019      	movs	r1, r3
 80012ca:	bc1c      	pop	{r2, r3, r4}
 80012cc:	4690      	mov	r8, r2
 80012ce:	4699      	mov	r9, r3
 80012d0:	46a2      	mov	sl, r4
 80012d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80012d4:	003e      	movs	r6, r7
 80012d6:	4316      	orrs	r6, r2
 80012d8:	d012      	beq.n	8001300 <__aeabi_dadd+0x270>
 80012da:	1e5e      	subs	r6, r3, #1
 80012dc:	2e00      	cmp	r6, #0
 80012de:	d000      	beq.n	80012e2 <__aeabi_dadd+0x252>
 80012e0:	e100      	b.n	80014e4 <__aeabi_dadd+0x454>
 80012e2:	1887      	adds	r7, r0, r2
 80012e4:	4287      	cmp	r7, r0
 80012e6:	4180      	sbcs	r0, r0
 80012e8:	4441      	add	r1, r8
 80012ea:	4240      	negs	r0, r0
 80012ec:	1809      	adds	r1, r1, r0
 80012ee:	2501      	movs	r5, #1
 80012f0:	020b      	lsls	r3, r1, #8
 80012f2:	d533      	bpl.n	800135c <__aeabi_dadd+0x2cc>
 80012f4:	2502      	movs	r5, #2
 80012f6:	e785      	b.n	8001204 <__aeabi_dadd+0x174>
 80012f8:	4664      	mov	r4, ip
 80012fa:	0033      	movs	r3, r6
 80012fc:	4641      	mov	r1, r8
 80012fe:	0010      	movs	r0, r2
 8001300:	001d      	movs	r5, r3
 8001302:	e7c7      	b.n	8001294 <__aeabi_dadd+0x204>
 8001304:	2d00      	cmp	r5, #0
 8001306:	d000      	beq.n	800130a <__aeabi_dadd+0x27a>
 8001308:	e0da      	b.n	80014c0 <__aeabi_dadd+0x430>
 800130a:	000c      	movs	r4, r1
 800130c:	4304      	orrs	r4, r0
 800130e:	d0f3      	beq.n	80012f8 <__aeabi_dadd+0x268>
 8001310:	1c5c      	adds	r4, r3, #1
 8001312:	d100      	bne.n	8001316 <__aeabi_dadd+0x286>
 8001314:	e19f      	b.n	8001656 <__aeabi_dadd+0x5c6>
 8001316:	4c5d      	ldr	r4, [pc, #372]	; (800148c <__aeabi_dadd+0x3fc>)
 8001318:	42a6      	cmp	r6, r4
 800131a:	d100      	bne.n	800131e <__aeabi_dadd+0x28e>
 800131c:	e12f      	b.n	800157e <__aeabi_dadd+0x4ee>
 800131e:	43db      	mvns	r3, r3
 8001320:	2b38      	cmp	r3, #56	; 0x38
 8001322:	dd00      	ble.n	8001326 <__aeabi_dadd+0x296>
 8001324:	e166      	b.n	80015f4 <__aeabi_dadd+0x564>
 8001326:	2b1f      	cmp	r3, #31
 8001328:	dd00      	ble.n	800132c <__aeabi_dadd+0x29c>
 800132a:	e183      	b.n	8001634 <__aeabi_dadd+0x5a4>
 800132c:	2420      	movs	r4, #32
 800132e:	0005      	movs	r5, r0
 8001330:	1ae4      	subs	r4, r4, r3
 8001332:	000f      	movs	r7, r1
 8001334:	40dd      	lsrs	r5, r3
 8001336:	40d9      	lsrs	r1, r3
 8001338:	40a0      	lsls	r0, r4
 800133a:	4643      	mov	r3, r8
 800133c:	40a7      	lsls	r7, r4
 800133e:	1a5b      	subs	r3, r3, r1
 8001340:	1e44      	subs	r4, r0, #1
 8001342:	41a0      	sbcs	r0, r4
 8001344:	4698      	mov	r8, r3
 8001346:	432f      	orrs	r7, r5
 8001348:	4338      	orrs	r0, r7
 800134a:	1a17      	subs	r7, r2, r0
 800134c:	42ba      	cmp	r2, r7
 800134e:	4192      	sbcs	r2, r2
 8001350:	4643      	mov	r3, r8
 8001352:	4252      	negs	r2, r2
 8001354:	1a99      	subs	r1, r3, r2
 8001356:	4664      	mov	r4, ip
 8001358:	0035      	movs	r5, r6
 800135a:	e6ca      	b.n	80010f2 <__aeabi_dadd+0x62>
 800135c:	2207      	movs	r2, #7
 800135e:	403a      	ands	r2, r7
 8001360:	2a00      	cmp	r2, #0
 8001362:	d000      	beq.n	8001366 <__aeabi_dadd+0x2d6>
 8001364:	e6f6      	b.n	8001154 <__aeabi_dadd+0xc4>
 8001366:	074b      	lsls	r3, r1, #29
 8001368:	08ca      	lsrs	r2, r1, #3
 800136a:	4948      	ldr	r1, [pc, #288]	; (800148c <__aeabi_dadd+0x3fc>)
 800136c:	08ff      	lsrs	r7, r7, #3
 800136e:	433b      	orrs	r3, r7
 8001370:	428d      	cmp	r5, r1
 8001372:	d196      	bne.n	80012a2 <__aeabi_dadd+0x212>
 8001374:	0019      	movs	r1, r3
 8001376:	4311      	orrs	r1, r2
 8001378:	d100      	bne.n	800137c <__aeabi_dadd+0x2ec>
 800137a:	e19e      	b.n	80016ba <__aeabi_dadd+0x62a>
 800137c:	2180      	movs	r1, #128	; 0x80
 800137e:	0309      	lsls	r1, r1, #12
 8001380:	430a      	orrs	r2, r1
 8001382:	0312      	lsls	r2, r2, #12
 8001384:	0b12      	lsrs	r2, r2, #12
 8001386:	4d41      	ldr	r5, [pc, #260]	; (800148c <__aeabi_dadd+0x3fc>)
 8001388:	e78f      	b.n	80012aa <__aeabi_dadd+0x21a>
 800138a:	0015      	movs	r5, r2
 800138c:	2200      	movs	r2, #0
 800138e:	2300      	movs	r3, #0
 8001390:	e78b      	b.n	80012aa <__aeabi_dadd+0x21a>
 8001392:	2b00      	cmp	r3, #0
 8001394:	d000      	beq.n	8001398 <__aeabi_dadd+0x308>
 8001396:	e0c7      	b.n	8001528 <__aeabi_dadd+0x498>
 8001398:	1c6b      	adds	r3, r5, #1
 800139a:	055f      	lsls	r7, r3, #21
 800139c:	0d7f      	lsrs	r7, r7, #21
 800139e:	2f01      	cmp	r7, #1
 80013a0:	dc00      	bgt.n	80013a4 <__aeabi_dadd+0x314>
 80013a2:	e0f1      	b.n	8001588 <__aeabi_dadd+0x4f8>
 80013a4:	4d39      	ldr	r5, [pc, #228]	; (800148c <__aeabi_dadd+0x3fc>)
 80013a6:	42ab      	cmp	r3, r5
 80013a8:	d100      	bne.n	80013ac <__aeabi_dadd+0x31c>
 80013aa:	e0b9      	b.n	8001520 <__aeabi_dadd+0x490>
 80013ac:	1885      	adds	r5, r0, r2
 80013ae:	000a      	movs	r2, r1
 80013b0:	4285      	cmp	r5, r0
 80013b2:	4189      	sbcs	r1, r1
 80013b4:	4442      	add	r2, r8
 80013b6:	4249      	negs	r1, r1
 80013b8:	1851      	adds	r1, r2, r1
 80013ba:	2207      	movs	r2, #7
 80013bc:	07cf      	lsls	r7, r1, #31
 80013be:	086d      	lsrs	r5, r5, #1
 80013c0:	432f      	orrs	r7, r5
 80013c2:	0849      	lsrs	r1, r1, #1
 80013c4:	403a      	ands	r2, r7
 80013c6:	001d      	movs	r5, r3
 80013c8:	e6c2      	b.n	8001150 <__aeabi_dadd+0xc0>
 80013ca:	2207      	movs	r2, #7
 80013cc:	4930      	ldr	r1, [pc, #192]	; (8001490 <__aeabi_dadd+0x400>)
 80013ce:	1aed      	subs	r5, r5, r3
 80013d0:	4031      	ands	r1, r6
 80013d2:	403a      	ands	r2, r7
 80013d4:	e6bc      	b.n	8001150 <__aeabi_dadd+0xc0>
 80013d6:	003e      	movs	r6, r7
 80013d8:	3828      	subs	r0, #40	; 0x28
 80013da:	4086      	lsls	r6, r0
 80013dc:	2700      	movs	r7, #0
 80013de:	e69f      	b.n	8001120 <__aeabi_dadd+0x90>
 80013e0:	0038      	movs	r0, r7
 80013e2:	f001 fcb1 	bl	8002d48 <__clzsi2>
 80013e6:	3020      	adds	r0, #32
 80013e8:	e68e      	b.n	8001108 <__aeabi_dadd+0x78>
 80013ea:	4643      	mov	r3, r8
 80013ec:	4313      	orrs	r3, r2
 80013ee:	001f      	movs	r7, r3
 80013f0:	1e7a      	subs	r2, r7, #1
 80013f2:	4197      	sbcs	r7, r2
 80013f4:	1bc7      	subs	r7, r0, r7
 80013f6:	42b8      	cmp	r0, r7
 80013f8:	4180      	sbcs	r0, r0
 80013fa:	4240      	negs	r0, r0
 80013fc:	1a09      	subs	r1, r1, r0
 80013fe:	e678      	b.n	80010f2 <__aeabi_dadd+0x62>
 8001400:	000e      	movs	r6, r1
 8001402:	003b      	movs	r3, r7
 8001404:	4306      	orrs	r6, r0
 8001406:	4313      	orrs	r3, r2
 8001408:	2d00      	cmp	r5, #0
 800140a:	d161      	bne.n	80014d0 <__aeabi_dadd+0x440>
 800140c:	2e00      	cmp	r6, #0
 800140e:	d000      	beq.n	8001412 <__aeabi_dadd+0x382>
 8001410:	e0f4      	b.n	80015fc <__aeabi_dadd+0x56c>
 8001412:	2b00      	cmp	r3, #0
 8001414:	d100      	bne.n	8001418 <__aeabi_dadd+0x388>
 8001416:	e11b      	b.n	8001650 <__aeabi_dadd+0x5c0>
 8001418:	4664      	mov	r4, ip
 800141a:	0039      	movs	r1, r7
 800141c:	0010      	movs	r0, r2
 800141e:	e739      	b.n	8001294 <__aeabi_dadd+0x204>
 8001420:	4f1a      	ldr	r7, [pc, #104]	; (800148c <__aeabi_dadd+0x3fc>)
 8001422:	42bb      	cmp	r3, r7
 8001424:	d07a      	beq.n	800151c <__aeabi_dadd+0x48c>
 8001426:	0033      	movs	r3, r6
 8001428:	e6ff      	b.n	800122a <__aeabi_dadd+0x19a>
 800142a:	0030      	movs	r0, r6
 800142c:	3d1f      	subs	r5, #31
 800142e:	40e8      	lsrs	r0, r5
 8001430:	2b20      	cmp	r3, #32
 8001432:	d003      	beq.n	800143c <__aeabi_dadd+0x3ac>
 8001434:	2140      	movs	r1, #64	; 0x40
 8001436:	1acb      	subs	r3, r1, r3
 8001438:	409e      	lsls	r6, r3
 800143a:	4337      	orrs	r7, r6
 800143c:	1e7b      	subs	r3, r7, #1
 800143e:	419f      	sbcs	r7, r3
 8001440:	2207      	movs	r2, #7
 8001442:	4307      	orrs	r7, r0
 8001444:	403a      	ands	r2, r7
 8001446:	2100      	movs	r1, #0
 8001448:	2500      	movs	r5, #0
 800144a:	e789      	b.n	8001360 <__aeabi_dadd+0x2d0>
 800144c:	1a17      	subs	r7, r2, r0
 800144e:	4643      	mov	r3, r8
 8001450:	42ba      	cmp	r2, r7
 8001452:	41b6      	sbcs	r6, r6
 8001454:	1a59      	subs	r1, r3, r1
 8001456:	4276      	negs	r6, r6
 8001458:	1b8e      	subs	r6, r1, r6
 800145a:	4664      	mov	r4, ip
 800145c:	e64e      	b.n	80010fc <__aeabi_dadd+0x6c>
 800145e:	2b1f      	cmp	r3, #31
 8001460:	dd00      	ble.n	8001464 <__aeabi_dadd+0x3d4>
 8001462:	e0ad      	b.n	80015c0 <__aeabi_dadd+0x530>
 8001464:	2620      	movs	r6, #32
 8001466:	4647      	mov	r7, r8
 8001468:	1af6      	subs	r6, r6, r3
 800146a:	40b7      	lsls	r7, r6
 800146c:	46b9      	mov	r9, r7
 800146e:	0017      	movs	r7, r2
 8001470:	46b2      	mov	sl, r6
 8001472:	40df      	lsrs	r7, r3
 8001474:	464e      	mov	r6, r9
 8001476:	433e      	orrs	r6, r7
 8001478:	0037      	movs	r7, r6
 800147a:	4656      	mov	r6, sl
 800147c:	40b2      	lsls	r2, r6
 800147e:	1e56      	subs	r6, r2, #1
 8001480:	41b2      	sbcs	r2, r6
 8001482:	4317      	orrs	r7, r2
 8001484:	4642      	mov	r2, r8
 8001486:	40da      	lsrs	r2, r3
 8001488:	1889      	adds	r1, r1, r2
 800148a:	e6ae      	b.n	80011ea <__aeabi_dadd+0x15a>
 800148c:	000007ff 	.word	0x000007ff
 8001490:	ff7fffff 	.word	0xff7fffff
 8001494:	800fffff 	.word	0x800fffff
 8001498:	2620      	movs	r6, #32
 800149a:	4647      	mov	r7, r8
 800149c:	1af6      	subs	r6, r6, r3
 800149e:	40b7      	lsls	r7, r6
 80014a0:	46b9      	mov	r9, r7
 80014a2:	0017      	movs	r7, r2
 80014a4:	46b2      	mov	sl, r6
 80014a6:	40df      	lsrs	r7, r3
 80014a8:	464e      	mov	r6, r9
 80014aa:	433e      	orrs	r6, r7
 80014ac:	0037      	movs	r7, r6
 80014ae:	4656      	mov	r6, sl
 80014b0:	40b2      	lsls	r2, r6
 80014b2:	1e56      	subs	r6, r2, #1
 80014b4:	41b2      	sbcs	r2, r6
 80014b6:	4317      	orrs	r7, r2
 80014b8:	4642      	mov	r2, r8
 80014ba:	40da      	lsrs	r2, r3
 80014bc:	1a89      	subs	r1, r1, r2
 80014be:	e799      	b.n	80013f4 <__aeabi_dadd+0x364>
 80014c0:	4c7f      	ldr	r4, [pc, #508]	; (80016c0 <__aeabi_dadd+0x630>)
 80014c2:	42a6      	cmp	r6, r4
 80014c4:	d05b      	beq.n	800157e <__aeabi_dadd+0x4ee>
 80014c6:	2480      	movs	r4, #128	; 0x80
 80014c8:	0424      	lsls	r4, r4, #16
 80014ca:	425b      	negs	r3, r3
 80014cc:	4321      	orrs	r1, r4
 80014ce:	e727      	b.n	8001320 <__aeabi_dadd+0x290>
 80014d0:	2e00      	cmp	r6, #0
 80014d2:	d10c      	bne.n	80014ee <__aeabi_dadd+0x45e>
 80014d4:	2b00      	cmp	r3, #0
 80014d6:	d100      	bne.n	80014da <__aeabi_dadd+0x44a>
 80014d8:	e0cb      	b.n	8001672 <__aeabi_dadd+0x5e2>
 80014da:	4664      	mov	r4, ip
 80014dc:	0039      	movs	r1, r7
 80014de:	0010      	movs	r0, r2
 80014e0:	4d77      	ldr	r5, [pc, #476]	; (80016c0 <__aeabi_dadd+0x630>)
 80014e2:	e6d7      	b.n	8001294 <__aeabi_dadd+0x204>
 80014e4:	4f76      	ldr	r7, [pc, #472]	; (80016c0 <__aeabi_dadd+0x630>)
 80014e6:	42bb      	cmp	r3, r7
 80014e8:	d018      	beq.n	800151c <__aeabi_dadd+0x48c>
 80014ea:	0033      	movs	r3, r6
 80014ec:	e675      	b.n	80011da <__aeabi_dadd+0x14a>
 80014ee:	2b00      	cmp	r3, #0
 80014f0:	d014      	beq.n	800151c <__aeabi_dadd+0x48c>
 80014f2:	074b      	lsls	r3, r1, #29
 80014f4:	08c0      	lsrs	r0, r0, #3
 80014f6:	4318      	orrs	r0, r3
 80014f8:	2380      	movs	r3, #128	; 0x80
 80014fa:	08c9      	lsrs	r1, r1, #3
 80014fc:	031b      	lsls	r3, r3, #12
 80014fe:	4219      	tst	r1, r3
 8001500:	d007      	beq.n	8001512 <__aeabi_dadd+0x482>
 8001502:	08fc      	lsrs	r4, r7, #3
 8001504:	421c      	tst	r4, r3
 8001506:	d104      	bne.n	8001512 <__aeabi_dadd+0x482>
 8001508:	0779      	lsls	r1, r7, #29
 800150a:	08d0      	lsrs	r0, r2, #3
 800150c:	4308      	orrs	r0, r1
 800150e:	46e1      	mov	r9, ip
 8001510:	0021      	movs	r1, r4
 8001512:	464c      	mov	r4, r9
 8001514:	0f42      	lsrs	r2, r0, #29
 8001516:	00c9      	lsls	r1, r1, #3
 8001518:	4311      	orrs	r1, r2
 800151a:	00c0      	lsls	r0, r0, #3
 800151c:	4d68      	ldr	r5, [pc, #416]	; (80016c0 <__aeabi_dadd+0x630>)
 800151e:	e6b9      	b.n	8001294 <__aeabi_dadd+0x204>
 8001520:	001d      	movs	r5, r3
 8001522:	2200      	movs	r2, #0
 8001524:	2300      	movs	r3, #0
 8001526:	e6c0      	b.n	80012aa <__aeabi_dadd+0x21a>
 8001528:	2d00      	cmp	r5, #0
 800152a:	d15b      	bne.n	80015e4 <__aeabi_dadd+0x554>
 800152c:	000d      	movs	r5, r1
 800152e:	4305      	orrs	r5, r0
 8001530:	d100      	bne.n	8001534 <__aeabi_dadd+0x4a4>
 8001532:	e6e2      	b.n	80012fa <__aeabi_dadd+0x26a>
 8001534:	1c5d      	adds	r5, r3, #1
 8001536:	d100      	bne.n	800153a <__aeabi_dadd+0x4aa>
 8001538:	e0b0      	b.n	800169c <__aeabi_dadd+0x60c>
 800153a:	4d61      	ldr	r5, [pc, #388]	; (80016c0 <__aeabi_dadd+0x630>)
 800153c:	42ae      	cmp	r6, r5
 800153e:	d01f      	beq.n	8001580 <__aeabi_dadd+0x4f0>
 8001540:	43db      	mvns	r3, r3
 8001542:	2b38      	cmp	r3, #56	; 0x38
 8001544:	dc71      	bgt.n	800162a <__aeabi_dadd+0x59a>
 8001546:	2b1f      	cmp	r3, #31
 8001548:	dd00      	ble.n	800154c <__aeabi_dadd+0x4bc>
 800154a:	e096      	b.n	800167a <__aeabi_dadd+0x5ea>
 800154c:	2520      	movs	r5, #32
 800154e:	000f      	movs	r7, r1
 8001550:	1aed      	subs	r5, r5, r3
 8001552:	40af      	lsls	r7, r5
 8001554:	46b9      	mov	r9, r7
 8001556:	0007      	movs	r7, r0
 8001558:	46aa      	mov	sl, r5
 800155a:	40df      	lsrs	r7, r3
 800155c:	464d      	mov	r5, r9
 800155e:	433d      	orrs	r5, r7
 8001560:	002f      	movs	r7, r5
 8001562:	4655      	mov	r5, sl
 8001564:	40a8      	lsls	r0, r5
 8001566:	40d9      	lsrs	r1, r3
 8001568:	1e45      	subs	r5, r0, #1
 800156a:	41a8      	sbcs	r0, r5
 800156c:	4488      	add	r8, r1
 800156e:	4307      	orrs	r7, r0
 8001570:	18bf      	adds	r7, r7, r2
 8001572:	4297      	cmp	r7, r2
 8001574:	4192      	sbcs	r2, r2
 8001576:	4251      	negs	r1, r2
 8001578:	4441      	add	r1, r8
 800157a:	0035      	movs	r5, r6
 800157c:	e63a      	b.n	80011f4 <__aeabi_dadd+0x164>
 800157e:	4664      	mov	r4, ip
 8001580:	0035      	movs	r5, r6
 8001582:	4641      	mov	r1, r8
 8001584:	0010      	movs	r0, r2
 8001586:	e685      	b.n	8001294 <__aeabi_dadd+0x204>
 8001588:	000b      	movs	r3, r1
 800158a:	4303      	orrs	r3, r0
 800158c:	2d00      	cmp	r5, #0
 800158e:	d000      	beq.n	8001592 <__aeabi_dadd+0x502>
 8001590:	e663      	b.n	800125a <__aeabi_dadd+0x1ca>
 8001592:	2b00      	cmp	r3, #0
 8001594:	d0f5      	beq.n	8001582 <__aeabi_dadd+0x4f2>
 8001596:	4643      	mov	r3, r8
 8001598:	4313      	orrs	r3, r2
 800159a:	d100      	bne.n	800159e <__aeabi_dadd+0x50e>
 800159c:	e67a      	b.n	8001294 <__aeabi_dadd+0x204>
 800159e:	1887      	adds	r7, r0, r2
 80015a0:	4287      	cmp	r7, r0
 80015a2:	4180      	sbcs	r0, r0
 80015a4:	2207      	movs	r2, #7
 80015a6:	4441      	add	r1, r8
 80015a8:	4240      	negs	r0, r0
 80015aa:	1809      	adds	r1, r1, r0
 80015ac:	403a      	ands	r2, r7
 80015ae:	020b      	lsls	r3, r1, #8
 80015b0:	d400      	bmi.n	80015b4 <__aeabi_dadd+0x524>
 80015b2:	e6d5      	b.n	8001360 <__aeabi_dadd+0x2d0>
 80015b4:	4b43      	ldr	r3, [pc, #268]	; (80016c4 <__aeabi_dadd+0x634>)
 80015b6:	3501      	adds	r5, #1
 80015b8:	4019      	ands	r1, r3
 80015ba:	e5c9      	b.n	8001150 <__aeabi_dadd+0xc0>
 80015bc:	0038      	movs	r0, r7
 80015be:	e669      	b.n	8001294 <__aeabi_dadd+0x204>
 80015c0:	001e      	movs	r6, r3
 80015c2:	4647      	mov	r7, r8
 80015c4:	3e20      	subs	r6, #32
 80015c6:	40f7      	lsrs	r7, r6
 80015c8:	46bc      	mov	ip, r7
 80015ca:	2b20      	cmp	r3, #32
 80015cc:	d004      	beq.n	80015d8 <__aeabi_dadd+0x548>
 80015ce:	2640      	movs	r6, #64	; 0x40
 80015d0:	1af3      	subs	r3, r6, r3
 80015d2:	4646      	mov	r6, r8
 80015d4:	409e      	lsls	r6, r3
 80015d6:	4332      	orrs	r2, r6
 80015d8:	0017      	movs	r7, r2
 80015da:	4663      	mov	r3, ip
 80015dc:	1e7a      	subs	r2, r7, #1
 80015de:	4197      	sbcs	r7, r2
 80015e0:	431f      	orrs	r7, r3
 80015e2:	e602      	b.n	80011ea <__aeabi_dadd+0x15a>
 80015e4:	4d36      	ldr	r5, [pc, #216]	; (80016c0 <__aeabi_dadd+0x630>)
 80015e6:	42ae      	cmp	r6, r5
 80015e8:	d0ca      	beq.n	8001580 <__aeabi_dadd+0x4f0>
 80015ea:	2580      	movs	r5, #128	; 0x80
 80015ec:	042d      	lsls	r5, r5, #16
 80015ee:	425b      	negs	r3, r3
 80015f0:	4329      	orrs	r1, r5
 80015f2:	e7a6      	b.n	8001542 <__aeabi_dadd+0x4b2>
 80015f4:	4308      	orrs	r0, r1
 80015f6:	1e41      	subs	r1, r0, #1
 80015f8:	4188      	sbcs	r0, r1
 80015fa:	e6a6      	b.n	800134a <__aeabi_dadd+0x2ba>
 80015fc:	2b00      	cmp	r3, #0
 80015fe:	d100      	bne.n	8001602 <__aeabi_dadd+0x572>
 8001600:	e648      	b.n	8001294 <__aeabi_dadd+0x204>
 8001602:	1a87      	subs	r7, r0, r2
 8001604:	4643      	mov	r3, r8
 8001606:	42b8      	cmp	r0, r7
 8001608:	41b6      	sbcs	r6, r6
 800160a:	1acb      	subs	r3, r1, r3
 800160c:	4276      	negs	r6, r6
 800160e:	1b9e      	subs	r6, r3, r6
 8001610:	0233      	lsls	r3, r6, #8
 8001612:	d54b      	bpl.n	80016ac <__aeabi_dadd+0x61c>
 8001614:	1a17      	subs	r7, r2, r0
 8001616:	4643      	mov	r3, r8
 8001618:	42ba      	cmp	r2, r7
 800161a:	4192      	sbcs	r2, r2
 800161c:	1a59      	subs	r1, r3, r1
 800161e:	4252      	negs	r2, r2
 8001620:	1a89      	subs	r1, r1, r2
 8001622:	2207      	movs	r2, #7
 8001624:	4664      	mov	r4, ip
 8001626:	403a      	ands	r2, r7
 8001628:	e592      	b.n	8001150 <__aeabi_dadd+0xc0>
 800162a:	4301      	orrs	r1, r0
 800162c:	000f      	movs	r7, r1
 800162e:	1e79      	subs	r1, r7, #1
 8001630:	418f      	sbcs	r7, r1
 8001632:	e79d      	b.n	8001570 <__aeabi_dadd+0x4e0>
 8001634:	001c      	movs	r4, r3
 8001636:	000f      	movs	r7, r1
 8001638:	3c20      	subs	r4, #32
 800163a:	40e7      	lsrs	r7, r4
 800163c:	2b20      	cmp	r3, #32
 800163e:	d003      	beq.n	8001648 <__aeabi_dadd+0x5b8>
 8001640:	2440      	movs	r4, #64	; 0x40
 8001642:	1ae3      	subs	r3, r4, r3
 8001644:	4099      	lsls	r1, r3
 8001646:	4308      	orrs	r0, r1
 8001648:	1e41      	subs	r1, r0, #1
 800164a:	4188      	sbcs	r0, r1
 800164c:	4338      	orrs	r0, r7
 800164e:	e67c      	b.n	800134a <__aeabi_dadd+0x2ba>
 8001650:	2200      	movs	r2, #0
 8001652:	2400      	movs	r4, #0
 8001654:	e625      	b.n	80012a2 <__aeabi_dadd+0x212>
 8001656:	1a17      	subs	r7, r2, r0
 8001658:	4643      	mov	r3, r8
 800165a:	42ba      	cmp	r2, r7
 800165c:	4192      	sbcs	r2, r2
 800165e:	1a59      	subs	r1, r3, r1
 8001660:	4252      	negs	r2, r2
 8001662:	1a89      	subs	r1, r1, r2
 8001664:	4664      	mov	r4, ip
 8001666:	0035      	movs	r5, r6
 8001668:	e543      	b.n	80010f2 <__aeabi_dadd+0x62>
 800166a:	4641      	mov	r1, r8
 800166c:	0010      	movs	r0, r2
 800166e:	4d14      	ldr	r5, [pc, #80]	; (80016c0 <__aeabi_dadd+0x630>)
 8001670:	e610      	b.n	8001294 <__aeabi_dadd+0x204>
 8001672:	2280      	movs	r2, #128	; 0x80
 8001674:	2400      	movs	r4, #0
 8001676:	0312      	lsls	r2, r2, #12
 8001678:	e680      	b.n	800137c <__aeabi_dadd+0x2ec>
 800167a:	001d      	movs	r5, r3
 800167c:	000f      	movs	r7, r1
 800167e:	3d20      	subs	r5, #32
 8001680:	40ef      	lsrs	r7, r5
 8001682:	46bc      	mov	ip, r7
 8001684:	2b20      	cmp	r3, #32
 8001686:	d003      	beq.n	8001690 <__aeabi_dadd+0x600>
 8001688:	2540      	movs	r5, #64	; 0x40
 800168a:	1aeb      	subs	r3, r5, r3
 800168c:	4099      	lsls	r1, r3
 800168e:	4308      	orrs	r0, r1
 8001690:	0007      	movs	r7, r0
 8001692:	4663      	mov	r3, ip
 8001694:	1e78      	subs	r0, r7, #1
 8001696:	4187      	sbcs	r7, r0
 8001698:	431f      	orrs	r7, r3
 800169a:	e769      	b.n	8001570 <__aeabi_dadd+0x4e0>
 800169c:	1887      	adds	r7, r0, r2
 800169e:	4297      	cmp	r7, r2
 80016a0:	419b      	sbcs	r3, r3
 80016a2:	4441      	add	r1, r8
 80016a4:	425b      	negs	r3, r3
 80016a6:	18c9      	adds	r1, r1, r3
 80016a8:	0035      	movs	r5, r6
 80016aa:	e5a3      	b.n	80011f4 <__aeabi_dadd+0x164>
 80016ac:	003b      	movs	r3, r7
 80016ae:	4333      	orrs	r3, r6
 80016b0:	d0ce      	beq.n	8001650 <__aeabi_dadd+0x5c0>
 80016b2:	2207      	movs	r2, #7
 80016b4:	0031      	movs	r1, r6
 80016b6:	403a      	ands	r2, r7
 80016b8:	e652      	b.n	8001360 <__aeabi_dadd+0x2d0>
 80016ba:	2300      	movs	r3, #0
 80016bc:	001a      	movs	r2, r3
 80016be:	e5f4      	b.n	80012aa <__aeabi_dadd+0x21a>
 80016c0:	000007ff 	.word	0x000007ff
 80016c4:	ff7fffff 	.word	0xff7fffff

080016c8 <__aeabi_ddiv>:
 80016c8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80016ca:	4657      	mov	r7, sl
 80016cc:	46de      	mov	lr, fp
 80016ce:	464e      	mov	r6, r9
 80016d0:	4645      	mov	r5, r8
 80016d2:	b5e0      	push	{r5, r6, r7, lr}
 80016d4:	4683      	mov	fp, r0
 80016d6:	0007      	movs	r7, r0
 80016d8:	030e      	lsls	r6, r1, #12
 80016da:	0048      	lsls	r0, r1, #1
 80016dc:	b085      	sub	sp, #20
 80016de:	4692      	mov	sl, r2
 80016e0:	001c      	movs	r4, r3
 80016e2:	0b36      	lsrs	r6, r6, #12
 80016e4:	0d40      	lsrs	r0, r0, #21
 80016e6:	0fcd      	lsrs	r5, r1, #31
 80016e8:	2800      	cmp	r0, #0
 80016ea:	d100      	bne.n	80016ee <__aeabi_ddiv+0x26>
 80016ec:	e09d      	b.n	800182a <__aeabi_ddiv+0x162>
 80016ee:	4b95      	ldr	r3, [pc, #596]	; (8001944 <__aeabi_ddiv+0x27c>)
 80016f0:	4298      	cmp	r0, r3
 80016f2:	d039      	beq.n	8001768 <__aeabi_ddiv+0xa0>
 80016f4:	2380      	movs	r3, #128	; 0x80
 80016f6:	00f6      	lsls	r6, r6, #3
 80016f8:	041b      	lsls	r3, r3, #16
 80016fa:	431e      	orrs	r6, r3
 80016fc:	4a92      	ldr	r2, [pc, #584]	; (8001948 <__aeabi_ddiv+0x280>)
 80016fe:	0f7b      	lsrs	r3, r7, #29
 8001700:	4333      	orrs	r3, r6
 8001702:	4699      	mov	r9, r3
 8001704:	4694      	mov	ip, r2
 8001706:	0003      	movs	r3, r0
 8001708:	4463      	add	r3, ip
 800170a:	9300      	str	r3, [sp, #0]
 800170c:	2300      	movs	r3, #0
 800170e:	2600      	movs	r6, #0
 8001710:	00ff      	lsls	r7, r7, #3
 8001712:	9302      	str	r3, [sp, #8]
 8001714:	0323      	lsls	r3, r4, #12
 8001716:	0b1b      	lsrs	r3, r3, #12
 8001718:	4698      	mov	r8, r3
 800171a:	0063      	lsls	r3, r4, #1
 800171c:	0fe4      	lsrs	r4, r4, #31
 800171e:	4652      	mov	r2, sl
 8001720:	0d5b      	lsrs	r3, r3, #21
 8001722:	9401      	str	r4, [sp, #4]
 8001724:	d100      	bne.n	8001728 <__aeabi_ddiv+0x60>
 8001726:	e0b3      	b.n	8001890 <__aeabi_ddiv+0x1c8>
 8001728:	4986      	ldr	r1, [pc, #536]	; (8001944 <__aeabi_ddiv+0x27c>)
 800172a:	428b      	cmp	r3, r1
 800172c:	d100      	bne.n	8001730 <__aeabi_ddiv+0x68>
 800172e:	e09e      	b.n	800186e <__aeabi_ddiv+0x1a6>
 8001730:	4642      	mov	r2, r8
 8001732:	00d1      	lsls	r1, r2, #3
 8001734:	2280      	movs	r2, #128	; 0x80
 8001736:	0412      	lsls	r2, r2, #16
 8001738:	430a      	orrs	r2, r1
 800173a:	4651      	mov	r1, sl
 800173c:	0f49      	lsrs	r1, r1, #29
 800173e:	4311      	orrs	r1, r2
 8001740:	468b      	mov	fp, r1
 8001742:	4981      	ldr	r1, [pc, #516]	; (8001948 <__aeabi_ddiv+0x280>)
 8001744:	4652      	mov	r2, sl
 8001746:	468c      	mov	ip, r1
 8001748:	9900      	ldr	r1, [sp, #0]
 800174a:	4463      	add	r3, ip
 800174c:	1acb      	subs	r3, r1, r3
 800174e:	2100      	movs	r1, #0
 8001750:	00d2      	lsls	r2, r2, #3
 8001752:	9300      	str	r3, [sp, #0]
 8001754:	002b      	movs	r3, r5
 8001756:	4063      	eors	r3, r4
 8001758:	469a      	mov	sl, r3
 800175a:	2e0f      	cmp	r6, #15
 800175c:	d900      	bls.n	8001760 <__aeabi_ddiv+0x98>
 800175e:	e105      	b.n	800196c <__aeabi_ddiv+0x2a4>
 8001760:	4b7a      	ldr	r3, [pc, #488]	; (800194c <__aeabi_ddiv+0x284>)
 8001762:	00b6      	lsls	r6, r6, #2
 8001764:	599b      	ldr	r3, [r3, r6]
 8001766:	469f      	mov	pc, r3
 8001768:	465b      	mov	r3, fp
 800176a:	4333      	orrs	r3, r6
 800176c:	4699      	mov	r9, r3
 800176e:	d000      	beq.n	8001772 <__aeabi_ddiv+0xaa>
 8001770:	e0b8      	b.n	80018e4 <__aeabi_ddiv+0x21c>
 8001772:	2302      	movs	r3, #2
 8001774:	2608      	movs	r6, #8
 8001776:	2700      	movs	r7, #0
 8001778:	9000      	str	r0, [sp, #0]
 800177a:	9302      	str	r3, [sp, #8]
 800177c:	e7ca      	b.n	8001714 <__aeabi_ddiv+0x4c>
 800177e:	46cb      	mov	fp, r9
 8001780:	003a      	movs	r2, r7
 8001782:	9902      	ldr	r1, [sp, #8]
 8001784:	9501      	str	r5, [sp, #4]
 8001786:	9b01      	ldr	r3, [sp, #4]
 8001788:	469a      	mov	sl, r3
 800178a:	2902      	cmp	r1, #2
 800178c:	d027      	beq.n	80017de <__aeabi_ddiv+0x116>
 800178e:	2903      	cmp	r1, #3
 8001790:	d100      	bne.n	8001794 <__aeabi_ddiv+0xcc>
 8001792:	e280      	b.n	8001c96 <__aeabi_ddiv+0x5ce>
 8001794:	2901      	cmp	r1, #1
 8001796:	d044      	beq.n	8001822 <__aeabi_ddiv+0x15a>
 8001798:	496d      	ldr	r1, [pc, #436]	; (8001950 <__aeabi_ddiv+0x288>)
 800179a:	9b00      	ldr	r3, [sp, #0]
 800179c:	468c      	mov	ip, r1
 800179e:	4463      	add	r3, ip
 80017a0:	001c      	movs	r4, r3
 80017a2:	2c00      	cmp	r4, #0
 80017a4:	dd38      	ble.n	8001818 <__aeabi_ddiv+0x150>
 80017a6:	0753      	lsls	r3, r2, #29
 80017a8:	d000      	beq.n	80017ac <__aeabi_ddiv+0xe4>
 80017aa:	e213      	b.n	8001bd4 <__aeabi_ddiv+0x50c>
 80017ac:	08d2      	lsrs	r2, r2, #3
 80017ae:	465b      	mov	r3, fp
 80017b0:	01db      	lsls	r3, r3, #7
 80017b2:	d509      	bpl.n	80017c8 <__aeabi_ddiv+0x100>
 80017b4:	4659      	mov	r1, fp
 80017b6:	4b67      	ldr	r3, [pc, #412]	; (8001954 <__aeabi_ddiv+0x28c>)
 80017b8:	4019      	ands	r1, r3
 80017ba:	468b      	mov	fp, r1
 80017bc:	2180      	movs	r1, #128	; 0x80
 80017be:	00c9      	lsls	r1, r1, #3
 80017c0:	468c      	mov	ip, r1
 80017c2:	9b00      	ldr	r3, [sp, #0]
 80017c4:	4463      	add	r3, ip
 80017c6:	001c      	movs	r4, r3
 80017c8:	4b63      	ldr	r3, [pc, #396]	; (8001958 <__aeabi_ddiv+0x290>)
 80017ca:	429c      	cmp	r4, r3
 80017cc:	dc07      	bgt.n	80017de <__aeabi_ddiv+0x116>
 80017ce:	465b      	mov	r3, fp
 80017d0:	0564      	lsls	r4, r4, #21
 80017d2:	075f      	lsls	r7, r3, #29
 80017d4:	025b      	lsls	r3, r3, #9
 80017d6:	4317      	orrs	r7, r2
 80017d8:	0b1b      	lsrs	r3, r3, #12
 80017da:	0d62      	lsrs	r2, r4, #21
 80017dc:	e002      	b.n	80017e4 <__aeabi_ddiv+0x11c>
 80017de:	2300      	movs	r3, #0
 80017e0:	2700      	movs	r7, #0
 80017e2:	4a58      	ldr	r2, [pc, #352]	; (8001944 <__aeabi_ddiv+0x27c>)
 80017e4:	2100      	movs	r1, #0
 80017e6:	031b      	lsls	r3, r3, #12
 80017e8:	0b1c      	lsrs	r4, r3, #12
 80017ea:	0d0b      	lsrs	r3, r1, #20
 80017ec:	051b      	lsls	r3, r3, #20
 80017ee:	4323      	orrs	r3, r4
 80017f0:	0514      	lsls	r4, r2, #20
 80017f2:	4a5a      	ldr	r2, [pc, #360]	; (800195c <__aeabi_ddiv+0x294>)
 80017f4:	0038      	movs	r0, r7
 80017f6:	4013      	ands	r3, r2
 80017f8:	431c      	orrs	r4, r3
 80017fa:	4653      	mov	r3, sl
 80017fc:	0064      	lsls	r4, r4, #1
 80017fe:	07db      	lsls	r3, r3, #31
 8001800:	0864      	lsrs	r4, r4, #1
 8001802:	431c      	orrs	r4, r3
 8001804:	0021      	movs	r1, r4
 8001806:	b005      	add	sp, #20
 8001808:	bc3c      	pop	{r2, r3, r4, r5}
 800180a:	4690      	mov	r8, r2
 800180c:	4699      	mov	r9, r3
 800180e:	46a2      	mov	sl, r4
 8001810:	46ab      	mov	fp, r5
 8001812:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001814:	2201      	movs	r2, #1
 8001816:	4252      	negs	r2, r2
 8001818:	2301      	movs	r3, #1
 800181a:	1b1b      	subs	r3, r3, r4
 800181c:	2b38      	cmp	r3, #56	; 0x38
 800181e:	dc00      	bgt.n	8001822 <__aeabi_ddiv+0x15a>
 8001820:	e1ad      	b.n	8001b7e <__aeabi_ddiv+0x4b6>
 8001822:	2200      	movs	r2, #0
 8001824:	2300      	movs	r3, #0
 8001826:	2700      	movs	r7, #0
 8001828:	e7dc      	b.n	80017e4 <__aeabi_ddiv+0x11c>
 800182a:	465b      	mov	r3, fp
 800182c:	4333      	orrs	r3, r6
 800182e:	4699      	mov	r9, r3
 8001830:	d05e      	beq.n	80018f0 <__aeabi_ddiv+0x228>
 8001832:	2e00      	cmp	r6, #0
 8001834:	d100      	bne.n	8001838 <__aeabi_ddiv+0x170>
 8001836:	e18a      	b.n	8001b4e <__aeabi_ddiv+0x486>
 8001838:	0030      	movs	r0, r6
 800183a:	f001 fa85 	bl	8002d48 <__clzsi2>
 800183e:	0003      	movs	r3, r0
 8001840:	3b0b      	subs	r3, #11
 8001842:	2b1c      	cmp	r3, #28
 8001844:	dd00      	ble.n	8001848 <__aeabi_ddiv+0x180>
 8001846:	e17b      	b.n	8001b40 <__aeabi_ddiv+0x478>
 8001848:	221d      	movs	r2, #29
 800184a:	1ad3      	subs	r3, r2, r3
 800184c:	465a      	mov	r2, fp
 800184e:	0001      	movs	r1, r0
 8001850:	40da      	lsrs	r2, r3
 8001852:	3908      	subs	r1, #8
 8001854:	408e      	lsls	r6, r1
 8001856:	0013      	movs	r3, r2
 8001858:	465f      	mov	r7, fp
 800185a:	4333      	orrs	r3, r6
 800185c:	4699      	mov	r9, r3
 800185e:	408f      	lsls	r7, r1
 8001860:	4b3f      	ldr	r3, [pc, #252]	; (8001960 <__aeabi_ddiv+0x298>)
 8001862:	2600      	movs	r6, #0
 8001864:	1a1b      	subs	r3, r3, r0
 8001866:	9300      	str	r3, [sp, #0]
 8001868:	2300      	movs	r3, #0
 800186a:	9302      	str	r3, [sp, #8]
 800186c:	e752      	b.n	8001714 <__aeabi_ddiv+0x4c>
 800186e:	4641      	mov	r1, r8
 8001870:	4653      	mov	r3, sl
 8001872:	430b      	orrs	r3, r1
 8001874:	493b      	ldr	r1, [pc, #236]	; (8001964 <__aeabi_ddiv+0x29c>)
 8001876:	469b      	mov	fp, r3
 8001878:	468c      	mov	ip, r1
 800187a:	9b00      	ldr	r3, [sp, #0]
 800187c:	4463      	add	r3, ip
 800187e:	9300      	str	r3, [sp, #0]
 8001880:	465b      	mov	r3, fp
 8001882:	2b00      	cmp	r3, #0
 8001884:	d13b      	bne.n	80018fe <__aeabi_ddiv+0x236>
 8001886:	2302      	movs	r3, #2
 8001888:	2200      	movs	r2, #0
 800188a:	431e      	orrs	r6, r3
 800188c:	2102      	movs	r1, #2
 800188e:	e761      	b.n	8001754 <__aeabi_ddiv+0x8c>
 8001890:	4643      	mov	r3, r8
 8001892:	4313      	orrs	r3, r2
 8001894:	469b      	mov	fp, r3
 8001896:	d037      	beq.n	8001908 <__aeabi_ddiv+0x240>
 8001898:	4643      	mov	r3, r8
 800189a:	2b00      	cmp	r3, #0
 800189c:	d100      	bne.n	80018a0 <__aeabi_ddiv+0x1d8>
 800189e:	e162      	b.n	8001b66 <__aeabi_ddiv+0x49e>
 80018a0:	4640      	mov	r0, r8
 80018a2:	f001 fa51 	bl	8002d48 <__clzsi2>
 80018a6:	0003      	movs	r3, r0
 80018a8:	3b0b      	subs	r3, #11
 80018aa:	2b1c      	cmp	r3, #28
 80018ac:	dd00      	ble.n	80018b0 <__aeabi_ddiv+0x1e8>
 80018ae:	e153      	b.n	8001b58 <__aeabi_ddiv+0x490>
 80018b0:	0002      	movs	r2, r0
 80018b2:	4641      	mov	r1, r8
 80018b4:	3a08      	subs	r2, #8
 80018b6:	4091      	lsls	r1, r2
 80018b8:	4688      	mov	r8, r1
 80018ba:	211d      	movs	r1, #29
 80018bc:	1acb      	subs	r3, r1, r3
 80018be:	4651      	mov	r1, sl
 80018c0:	40d9      	lsrs	r1, r3
 80018c2:	000b      	movs	r3, r1
 80018c4:	4641      	mov	r1, r8
 80018c6:	430b      	orrs	r3, r1
 80018c8:	469b      	mov	fp, r3
 80018ca:	4653      	mov	r3, sl
 80018cc:	4093      	lsls	r3, r2
 80018ce:	001a      	movs	r2, r3
 80018d0:	9b00      	ldr	r3, [sp, #0]
 80018d2:	4925      	ldr	r1, [pc, #148]	; (8001968 <__aeabi_ddiv+0x2a0>)
 80018d4:	469c      	mov	ip, r3
 80018d6:	4460      	add	r0, ip
 80018d8:	0003      	movs	r3, r0
 80018da:	468c      	mov	ip, r1
 80018dc:	4463      	add	r3, ip
 80018de:	9300      	str	r3, [sp, #0]
 80018e0:	2100      	movs	r1, #0
 80018e2:	e737      	b.n	8001754 <__aeabi_ddiv+0x8c>
 80018e4:	2303      	movs	r3, #3
 80018e6:	46b1      	mov	r9, r6
 80018e8:	9000      	str	r0, [sp, #0]
 80018ea:	260c      	movs	r6, #12
 80018ec:	9302      	str	r3, [sp, #8]
 80018ee:	e711      	b.n	8001714 <__aeabi_ddiv+0x4c>
 80018f0:	2300      	movs	r3, #0
 80018f2:	9300      	str	r3, [sp, #0]
 80018f4:	3301      	adds	r3, #1
 80018f6:	2604      	movs	r6, #4
 80018f8:	2700      	movs	r7, #0
 80018fa:	9302      	str	r3, [sp, #8]
 80018fc:	e70a      	b.n	8001714 <__aeabi_ddiv+0x4c>
 80018fe:	2303      	movs	r3, #3
 8001900:	46c3      	mov	fp, r8
 8001902:	431e      	orrs	r6, r3
 8001904:	2103      	movs	r1, #3
 8001906:	e725      	b.n	8001754 <__aeabi_ddiv+0x8c>
 8001908:	3301      	adds	r3, #1
 800190a:	431e      	orrs	r6, r3
 800190c:	2200      	movs	r2, #0
 800190e:	2101      	movs	r1, #1
 8001910:	e720      	b.n	8001754 <__aeabi_ddiv+0x8c>
 8001912:	2300      	movs	r3, #0
 8001914:	469a      	mov	sl, r3
 8001916:	2380      	movs	r3, #128	; 0x80
 8001918:	2700      	movs	r7, #0
 800191a:	031b      	lsls	r3, r3, #12
 800191c:	4a09      	ldr	r2, [pc, #36]	; (8001944 <__aeabi_ddiv+0x27c>)
 800191e:	e761      	b.n	80017e4 <__aeabi_ddiv+0x11c>
 8001920:	2380      	movs	r3, #128	; 0x80
 8001922:	4649      	mov	r1, r9
 8001924:	031b      	lsls	r3, r3, #12
 8001926:	4219      	tst	r1, r3
 8001928:	d100      	bne.n	800192c <__aeabi_ddiv+0x264>
 800192a:	e0e2      	b.n	8001af2 <__aeabi_ddiv+0x42a>
 800192c:	4659      	mov	r1, fp
 800192e:	4219      	tst	r1, r3
 8001930:	d000      	beq.n	8001934 <__aeabi_ddiv+0x26c>
 8001932:	e0de      	b.n	8001af2 <__aeabi_ddiv+0x42a>
 8001934:	430b      	orrs	r3, r1
 8001936:	031b      	lsls	r3, r3, #12
 8001938:	0017      	movs	r7, r2
 800193a:	0b1b      	lsrs	r3, r3, #12
 800193c:	46a2      	mov	sl, r4
 800193e:	4a01      	ldr	r2, [pc, #4]	; (8001944 <__aeabi_ddiv+0x27c>)
 8001940:	e750      	b.n	80017e4 <__aeabi_ddiv+0x11c>
 8001942:	46c0      	nop			; (mov r8, r8)
 8001944:	000007ff 	.word	0x000007ff
 8001948:	fffffc01 	.word	0xfffffc01
 800194c:	08014dc4 	.word	0x08014dc4
 8001950:	000003ff 	.word	0x000003ff
 8001954:	feffffff 	.word	0xfeffffff
 8001958:	000007fe 	.word	0x000007fe
 800195c:	800fffff 	.word	0x800fffff
 8001960:	fffffc0d 	.word	0xfffffc0d
 8001964:	fffff801 	.word	0xfffff801
 8001968:	000003f3 	.word	0x000003f3
 800196c:	45d9      	cmp	r9, fp
 800196e:	d900      	bls.n	8001972 <__aeabi_ddiv+0x2aa>
 8001970:	e0cb      	b.n	8001b0a <__aeabi_ddiv+0x442>
 8001972:	d100      	bne.n	8001976 <__aeabi_ddiv+0x2ae>
 8001974:	e0c6      	b.n	8001b04 <__aeabi_ddiv+0x43c>
 8001976:	003c      	movs	r4, r7
 8001978:	4648      	mov	r0, r9
 800197a:	2700      	movs	r7, #0
 800197c:	9b00      	ldr	r3, [sp, #0]
 800197e:	3b01      	subs	r3, #1
 8001980:	9300      	str	r3, [sp, #0]
 8001982:	465b      	mov	r3, fp
 8001984:	0e16      	lsrs	r6, r2, #24
 8001986:	021b      	lsls	r3, r3, #8
 8001988:	431e      	orrs	r6, r3
 800198a:	0213      	lsls	r3, r2, #8
 800198c:	4698      	mov	r8, r3
 800198e:	0433      	lsls	r3, r6, #16
 8001990:	0c1b      	lsrs	r3, r3, #16
 8001992:	4699      	mov	r9, r3
 8001994:	0c31      	lsrs	r1, r6, #16
 8001996:	9101      	str	r1, [sp, #4]
 8001998:	f7fe fc4e 	bl	8000238 <__aeabi_uidivmod>
 800199c:	464a      	mov	r2, r9
 800199e:	4342      	muls	r2, r0
 80019a0:	040b      	lsls	r3, r1, #16
 80019a2:	0c21      	lsrs	r1, r4, #16
 80019a4:	0005      	movs	r5, r0
 80019a6:	4319      	orrs	r1, r3
 80019a8:	428a      	cmp	r2, r1
 80019aa:	d907      	bls.n	80019bc <__aeabi_ddiv+0x2f4>
 80019ac:	1989      	adds	r1, r1, r6
 80019ae:	3d01      	subs	r5, #1
 80019b0:	428e      	cmp	r6, r1
 80019b2:	d803      	bhi.n	80019bc <__aeabi_ddiv+0x2f4>
 80019b4:	428a      	cmp	r2, r1
 80019b6:	d901      	bls.n	80019bc <__aeabi_ddiv+0x2f4>
 80019b8:	1e85      	subs	r5, r0, #2
 80019ba:	1989      	adds	r1, r1, r6
 80019bc:	1a88      	subs	r0, r1, r2
 80019be:	9901      	ldr	r1, [sp, #4]
 80019c0:	f7fe fc3a 	bl	8000238 <__aeabi_uidivmod>
 80019c4:	0409      	lsls	r1, r1, #16
 80019c6:	468c      	mov	ip, r1
 80019c8:	464a      	mov	r2, r9
 80019ca:	0421      	lsls	r1, r4, #16
 80019cc:	4664      	mov	r4, ip
 80019ce:	4342      	muls	r2, r0
 80019d0:	0c09      	lsrs	r1, r1, #16
 80019d2:	0003      	movs	r3, r0
 80019d4:	4321      	orrs	r1, r4
 80019d6:	428a      	cmp	r2, r1
 80019d8:	d904      	bls.n	80019e4 <__aeabi_ddiv+0x31c>
 80019da:	1989      	adds	r1, r1, r6
 80019dc:	3b01      	subs	r3, #1
 80019de:	428e      	cmp	r6, r1
 80019e0:	d800      	bhi.n	80019e4 <__aeabi_ddiv+0x31c>
 80019e2:	e0f1      	b.n	8001bc8 <__aeabi_ddiv+0x500>
 80019e4:	042d      	lsls	r5, r5, #16
 80019e6:	431d      	orrs	r5, r3
 80019e8:	46ab      	mov	fp, r5
 80019ea:	4643      	mov	r3, r8
 80019ec:	1a89      	subs	r1, r1, r2
 80019ee:	4642      	mov	r2, r8
 80019f0:	0c28      	lsrs	r0, r5, #16
 80019f2:	0412      	lsls	r2, r2, #16
 80019f4:	0c1d      	lsrs	r5, r3, #16
 80019f6:	465b      	mov	r3, fp
 80019f8:	0c14      	lsrs	r4, r2, #16
 80019fa:	0022      	movs	r2, r4
 80019fc:	041b      	lsls	r3, r3, #16
 80019fe:	0c1b      	lsrs	r3, r3, #16
 8001a00:	435a      	muls	r2, r3
 8001a02:	9403      	str	r4, [sp, #12]
 8001a04:	436b      	muls	r3, r5
 8001a06:	4344      	muls	r4, r0
 8001a08:	9502      	str	r5, [sp, #8]
 8001a0a:	4368      	muls	r0, r5
 8001a0c:	191b      	adds	r3, r3, r4
 8001a0e:	0c15      	lsrs	r5, r2, #16
 8001a10:	18eb      	adds	r3, r5, r3
 8001a12:	429c      	cmp	r4, r3
 8001a14:	d903      	bls.n	8001a1e <__aeabi_ddiv+0x356>
 8001a16:	2480      	movs	r4, #128	; 0x80
 8001a18:	0264      	lsls	r4, r4, #9
 8001a1a:	46a4      	mov	ip, r4
 8001a1c:	4460      	add	r0, ip
 8001a1e:	0c1c      	lsrs	r4, r3, #16
 8001a20:	0415      	lsls	r5, r2, #16
 8001a22:	041b      	lsls	r3, r3, #16
 8001a24:	0c2d      	lsrs	r5, r5, #16
 8001a26:	1820      	adds	r0, r4, r0
 8001a28:	195d      	adds	r5, r3, r5
 8001a2a:	4281      	cmp	r1, r0
 8001a2c:	d377      	bcc.n	8001b1e <__aeabi_ddiv+0x456>
 8001a2e:	d073      	beq.n	8001b18 <__aeabi_ddiv+0x450>
 8001a30:	1a0c      	subs	r4, r1, r0
 8001a32:	4aa2      	ldr	r2, [pc, #648]	; (8001cbc <__aeabi_ddiv+0x5f4>)
 8001a34:	1b7d      	subs	r5, r7, r5
 8001a36:	42af      	cmp	r7, r5
 8001a38:	41bf      	sbcs	r7, r7
 8001a3a:	4694      	mov	ip, r2
 8001a3c:	9b00      	ldr	r3, [sp, #0]
 8001a3e:	427f      	negs	r7, r7
 8001a40:	4463      	add	r3, ip
 8001a42:	1be0      	subs	r0, r4, r7
 8001a44:	001c      	movs	r4, r3
 8001a46:	4286      	cmp	r6, r0
 8001a48:	d100      	bne.n	8001a4c <__aeabi_ddiv+0x384>
 8001a4a:	e0db      	b.n	8001c04 <__aeabi_ddiv+0x53c>
 8001a4c:	9901      	ldr	r1, [sp, #4]
 8001a4e:	f7fe fbf3 	bl	8000238 <__aeabi_uidivmod>
 8001a52:	464a      	mov	r2, r9
 8001a54:	4342      	muls	r2, r0
 8001a56:	040b      	lsls	r3, r1, #16
 8001a58:	0c29      	lsrs	r1, r5, #16
 8001a5a:	0007      	movs	r7, r0
 8001a5c:	4319      	orrs	r1, r3
 8001a5e:	428a      	cmp	r2, r1
 8001a60:	d907      	bls.n	8001a72 <__aeabi_ddiv+0x3aa>
 8001a62:	1989      	adds	r1, r1, r6
 8001a64:	3f01      	subs	r7, #1
 8001a66:	428e      	cmp	r6, r1
 8001a68:	d803      	bhi.n	8001a72 <__aeabi_ddiv+0x3aa>
 8001a6a:	428a      	cmp	r2, r1
 8001a6c:	d901      	bls.n	8001a72 <__aeabi_ddiv+0x3aa>
 8001a6e:	1e87      	subs	r7, r0, #2
 8001a70:	1989      	adds	r1, r1, r6
 8001a72:	1a88      	subs	r0, r1, r2
 8001a74:	9901      	ldr	r1, [sp, #4]
 8001a76:	f7fe fbdf 	bl	8000238 <__aeabi_uidivmod>
 8001a7a:	0409      	lsls	r1, r1, #16
 8001a7c:	464a      	mov	r2, r9
 8001a7e:	4689      	mov	r9, r1
 8001a80:	0429      	lsls	r1, r5, #16
 8001a82:	464d      	mov	r5, r9
 8001a84:	4342      	muls	r2, r0
 8001a86:	0c09      	lsrs	r1, r1, #16
 8001a88:	0003      	movs	r3, r0
 8001a8a:	4329      	orrs	r1, r5
 8001a8c:	428a      	cmp	r2, r1
 8001a8e:	d907      	bls.n	8001aa0 <__aeabi_ddiv+0x3d8>
 8001a90:	1989      	adds	r1, r1, r6
 8001a92:	3b01      	subs	r3, #1
 8001a94:	428e      	cmp	r6, r1
 8001a96:	d803      	bhi.n	8001aa0 <__aeabi_ddiv+0x3d8>
 8001a98:	428a      	cmp	r2, r1
 8001a9a:	d901      	bls.n	8001aa0 <__aeabi_ddiv+0x3d8>
 8001a9c:	1e83      	subs	r3, r0, #2
 8001a9e:	1989      	adds	r1, r1, r6
 8001aa0:	043f      	lsls	r7, r7, #16
 8001aa2:	1a89      	subs	r1, r1, r2
 8001aa4:	003a      	movs	r2, r7
 8001aa6:	9f03      	ldr	r7, [sp, #12]
 8001aa8:	431a      	orrs	r2, r3
 8001aaa:	0038      	movs	r0, r7
 8001aac:	0413      	lsls	r3, r2, #16
 8001aae:	0c1b      	lsrs	r3, r3, #16
 8001ab0:	4358      	muls	r0, r3
 8001ab2:	4681      	mov	r9, r0
 8001ab4:	9802      	ldr	r0, [sp, #8]
 8001ab6:	0c15      	lsrs	r5, r2, #16
 8001ab8:	436f      	muls	r7, r5
 8001aba:	4343      	muls	r3, r0
 8001abc:	4345      	muls	r5, r0
 8001abe:	4648      	mov	r0, r9
 8001ac0:	0c00      	lsrs	r0, r0, #16
 8001ac2:	4684      	mov	ip, r0
 8001ac4:	19db      	adds	r3, r3, r7
 8001ac6:	4463      	add	r3, ip
 8001ac8:	429f      	cmp	r7, r3
 8001aca:	d903      	bls.n	8001ad4 <__aeabi_ddiv+0x40c>
 8001acc:	2080      	movs	r0, #128	; 0x80
 8001ace:	0240      	lsls	r0, r0, #9
 8001ad0:	4684      	mov	ip, r0
 8001ad2:	4465      	add	r5, ip
 8001ad4:	4648      	mov	r0, r9
 8001ad6:	0c1f      	lsrs	r7, r3, #16
 8001ad8:	0400      	lsls	r0, r0, #16
 8001ada:	041b      	lsls	r3, r3, #16
 8001adc:	0c00      	lsrs	r0, r0, #16
 8001ade:	197d      	adds	r5, r7, r5
 8001ae0:	1818      	adds	r0, r3, r0
 8001ae2:	42a9      	cmp	r1, r5
 8001ae4:	d200      	bcs.n	8001ae8 <__aeabi_ddiv+0x420>
 8001ae6:	e084      	b.n	8001bf2 <__aeabi_ddiv+0x52a>
 8001ae8:	d100      	bne.n	8001aec <__aeabi_ddiv+0x424>
 8001aea:	e07f      	b.n	8001bec <__aeabi_ddiv+0x524>
 8001aec:	2301      	movs	r3, #1
 8001aee:	431a      	orrs	r2, r3
 8001af0:	e657      	b.n	80017a2 <__aeabi_ddiv+0xda>
 8001af2:	2380      	movs	r3, #128	; 0x80
 8001af4:	464a      	mov	r2, r9
 8001af6:	031b      	lsls	r3, r3, #12
 8001af8:	4313      	orrs	r3, r2
 8001afa:	031b      	lsls	r3, r3, #12
 8001afc:	0b1b      	lsrs	r3, r3, #12
 8001afe:	46aa      	mov	sl, r5
 8001b00:	4a6f      	ldr	r2, [pc, #444]	; (8001cc0 <__aeabi_ddiv+0x5f8>)
 8001b02:	e66f      	b.n	80017e4 <__aeabi_ddiv+0x11c>
 8001b04:	42ba      	cmp	r2, r7
 8001b06:	d900      	bls.n	8001b0a <__aeabi_ddiv+0x442>
 8001b08:	e735      	b.n	8001976 <__aeabi_ddiv+0x2ae>
 8001b0a:	464b      	mov	r3, r9
 8001b0c:	07dc      	lsls	r4, r3, #31
 8001b0e:	0858      	lsrs	r0, r3, #1
 8001b10:	087b      	lsrs	r3, r7, #1
 8001b12:	431c      	orrs	r4, r3
 8001b14:	07ff      	lsls	r7, r7, #31
 8001b16:	e734      	b.n	8001982 <__aeabi_ddiv+0x2ba>
 8001b18:	2400      	movs	r4, #0
 8001b1a:	42af      	cmp	r7, r5
 8001b1c:	d289      	bcs.n	8001a32 <__aeabi_ddiv+0x36a>
 8001b1e:	4447      	add	r7, r8
 8001b20:	4547      	cmp	r7, r8
 8001b22:	41a4      	sbcs	r4, r4
 8001b24:	465b      	mov	r3, fp
 8001b26:	4264      	negs	r4, r4
 8001b28:	19a4      	adds	r4, r4, r6
 8001b2a:	1864      	adds	r4, r4, r1
 8001b2c:	3b01      	subs	r3, #1
 8001b2e:	42a6      	cmp	r6, r4
 8001b30:	d21e      	bcs.n	8001b70 <__aeabi_ddiv+0x4a8>
 8001b32:	42a0      	cmp	r0, r4
 8001b34:	d86d      	bhi.n	8001c12 <__aeabi_ddiv+0x54a>
 8001b36:	d100      	bne.n	8001b3a <__aeabi_ddiv+0x472>
 8001b38:	e0b6      	b.n	8001ca8 <__aeabi_ddiv+0x5e0>
 8001b3a:	1a24      	subs	r4, r4, r0
 8001b3c:	469b      	mov	fp, r3
 8001b3e:	e778      	b.n	8001a32 <__aeabi_ddiv+0x36a>
 8001b40:	0003      	movs	r3, r0
 8001b42:	465a      	mov	r2, fp
 8001b44:	3b28      	subs	r3, #40	; 0x28
 8001b46:	409a      	lsls	r2, r3
 8001b48:	2700      	movs	r7, #0
 8001b4a:	4691      	mov	r9, r2
 8001b4c:	e688      	b.n	8001860 <__aeabi_ddiv+0x198>
 8001b4e:	4658      	mov	r0, fp
 8001b50:	f001 f8fa 	bl	8002d48 <__clzsi2>
 8001b54:	3020      	adds	r0, #32
 8001b56:	e672      	b.n	800183e <__aeabi_ddiv+0x176>
 8001b58:	0003      	movs	r3, r0
 8001b5a:	4652      	mov	r2, sl
 8001b5c:	3b28      	subs	r3, #40	; 0x28
 8001b5e:	409a      	lsls	r2, r3
 8001b60:	4693      	mov	fp, r2
 8001b62:	2200      	movs	r2, #0
 8001b64:	e6b4      	b.n	80018d0 <__aeabi_ddiv+0x208>
 8001b66:	4650      	mov	r0, sl
 8001b68:	f001 f8ee 	bl	8002d48 <__clzsi2>
 8001b6c:	3020      	adds	r0, #32
 8001b6e:	e69a      	b.n	80018a6 <__aeabi_ddiv+0x1de>
 8001b70:	42a6      	cmp	r6, r4
 8001b72:	d1e2      	bne.n	8001b3a <__aeabi_ddiv+0x472>
 8001b74:	45b8      	cmp	r8, r7
 8001b76:	d9dc      	bls.n	8001b32 <__aeabi_ddiv+0x46a>
 8001b78:	1a34      	subs	r4, r6, r0
 8001b7a:	469b      	mov	fp, r3
 8001b7c:	e759      	b.n	8001a32 <__aeabi_ddiv+0x36a>
 8001b7e:	2b1f      	cmp	r3, #31
 8001b80:	dc65      	bgt.n	8001c4e <__aeabi_ddiv+0x586>
 8001b82:	4c50      	ldr	r4, [pc, #320]	; (8001cc4 <__aeabi_ddiv+0x5fc>)
 8001b84:	9900      	ldr	r1, [sp, #0]
 8001b86:	46a4      	mov	ip, r4
 8001b88:	465c      	mov	r4, fp
 8001b8a:	4461      	add	r1, ip
 8001b8c:	0008      	movs	r0, r1
 8001b8e:	408c      	lsls	r4, r1
 8001b90:	0011      	movs	r1, r2
 8001b92:	4082      	lsls	r2, r0
 8001b94:	40d9      	lsrs	r1, r3
 8001b96:	1e50      	subs	r0, r2, #1
 8001b98:	4182      	sbcs	r2, r0
 8001b9a:	430c      	orrs	r4, r1
 8001b9c:	4314      	orrs	r4, r2
 8001b9e:	465a      	mov	r2, fp
 8001ba0:	40da      	lsrs	r2, r3
 8001ba2:	0013      	movs	r3, r2
 8001ba4:	0762      	lsls	r2, r4, #29
 8001ba6:	d009      	beq.n	8001bbc <__aeabi_ddiv+0x4f4>
 8001ba8:	220f      	movs	r2, #15
 8001baa:	4022      	ands	r2, r4
 8001bac:	2a04      	cmp	r2, #4
 8001bae:	d005      	beq.n	8001bbc <__aeabi_ddiv+0x4f4>
 8001bb0:	0022      	movs	r2, r4
 8001bb2:	1d14      	adds	r4, r2, #4
 8001bb4:	4294      	cmp	r4, r2
 8001bb6:	4189      	sbcs	r1, r1
 8001bb8:	4249      	negs	r1, r1
 8001bba:	185b      	adds	r3, r3, r1
 8001bbc:	021a      	lsls	r2, r3, #8
 8001bbe:	d562      	bpl.n	8001c86 <__aeabi_ddiv+0x5be>
 8001bc0:	2201      	movs	r2, #1
 8001bc2:	2300      	movs	r3, #0
 8001bc4:	2700      	movs	r7, #0
 8001bc6:	e60d      	b.n	80017e4 <__aeabi_ddiv+0x11c>
 8001bc8:	428a      	cmp	r2, r1
 8001bca:	d800      	bhi.n	8001bce <__aeabi_ddiv+0x506>
 8001bcc:	e70a      	b.n	80019e4 <__aeabi_ddiv+0x31c>
 8001bce:	1e83      	subs	r3, r0, #2
 8001bd0:	1989      	adds	r1, r1, r6
 8001bd2:	e707      	b.n	80019e4 <__aeabi_ddiv+0x31c>
 8001bd4:	230f      	movs	r3, #15
 8001bd6:	4013      	ands	r3, r2
 8001bd8:	2b04      	cmp	r3, #4
 8001bda:	d100      	bne.n	8001bde <__aeabi_ddiv+0x516>
 8001bdc:	e5e6      	b.n	80017ac <__aeabi_ddiv+0xe4>
 8001bde:	1d17      	adds	r7, r2, #4
 8001be0:	4297      	cmp	r7, r2
 8001be2:	4192      	sbcs	r2, r2
 8001be4:	4253      	negs	r3, r2
 8001be6:	449b      	add	fp, r3
 8001be8:	08fa      	lsrs	r2, r7, #3
 8001bea:	e5e0      	b.n	80017ae <__aeabi_ddiv+0xe6>
 8001bec:	2800      	cmp	r0, #0
 8001bee:	d100      	bne.n	8001bf2 <__aeabi_ddiv+0x52a>
 8001bf0:	e5d7      	b.n	80017a2 <__aeabi_ddiv+0xda>
 8001bf2:	1871      	adds	r1, r6, r1
 8001bf4:	1e53      	subs	r3, r2, #1
 8001bf6:	42b1      	cmp	r1, r6
 8001bf8:	d327      	bcc.n	8001c4a <__aeabi_ddiv+0x582>
 8001bfa:	42a9      	cmp	r1, r5
 8001bfc:	d315      	bcc.n	8001c2a <__aeabi_ddiv+0x562>
 8001bfe:	d058      	beq.n	8001cb2 <__aeabi_ddiv+0x5ea>
 8001c00:	001a      	movs	r2, r3
 8001c02:	e773      	b.n	8001aec <__aeabi_ddiv+0x424>
 8001c04:	2b00      	cmp	r3, #0
 8001c06:	dc00      	bgt.n	8001c0a <__aeabi_ddiv+0x542>
 8001c08:	e604      	b.n	8001814 <__aeabi_ddiv+0x14c>
 8001c0a:	2301      	movs	r3, #1
 8001c0c:	2200      	movs	r2, #0
 8001c0e:	449b      	add	fp, r3
 8001c10:	e5cd      	b.n	80017ae <__aeabi_ddiv+0xe6>
 8001c12:	2302      	movs	r3, #2
 8001c14:	4447      	add	r7, r8
 8001c16:	4547      	cmp	r7, r8
 8001c18:	4189      	sbcs	r1, r1
 8001c1a:	425b      	negs	r3, r3
 8001c1c:	469c      	mov	ip, r3
 8001c1e:	4249      	negs	r1, r1
 8001c20:	1989      	adds	r1, r1, r6
 8001c22:	190c      	adds	r4, r1, r4
 8001c24:	44e3      	add	fp, ip
 8001c26:	1a24      	subs	r4, r4, r0
 8001c28:	e703      	b.n	8001a32 <__aeabi_ddiv+0x36a>
 8001c2a:	4643      	mov	r3, r8
 8001c2c:	005f      	lsls	r7, r3, #1
 8001c2e:	4547      	cmp	r7, r8
 8001c30:	419b      	sbcs	r3, r3
 8001c32:	46b8      	mov	r8, r7
 8001c34:	425b      	negs	r3, r3
 8001c36:	199e      	adds	r6, r3, r6
 8001c38:	3a02      	subs	r2, #2
 8001c3a:	1989      	adds	r1, r1, r6
 8001c3c:	42a9      	cmp	r1, r5
 8001c3e:	d000      	beq.n	8001c42 <__aeabi_ddiv+0x57a>
 8001c40:	e754      	b.n	8001aec <__aeabi_ddiv+0x424>
 8001c42:	4540      	cmp	r0, r8
 8001c44:	d000      	beq.n	8001c48 <__aeabi_ddiv+0x580>
 8001c46:	e751      	b.n	8001aec <__aeabi_ddiv+0x424>
 8001c48:	e5ab      	b.n	80017a2 <__aeabi_ddiv+0xda>
 8001c4a:	001a      	movs	r2, r3
 8001c4c:	e7f6      	b.n	8001c3c <__aeabi_ddiv+0x574>
 8001c4e:	211f      	movs	r1, #31
 8001c50:	465f      	mov	r7, fp
 8001c52:	4249      	negs	r1, r1
 8001c54:	1b0c      	subs	r4, r1, r4
 8001c56:	40e7      	lsrs	r7, r4
 8001c58:	2b20      	cmp	r3, #32
 8001c5a:	d007      	beq.n	8001c6c <__aeabi_ddiv+0x5a4>
 8001c5c:	491a      	ldr	r1, [pc, #104]	; (8001cc8 <__aeabi_ddiv+0x600>)
 8001c5e:	9b00      	ldr	r3, [sp, #0]
 8001c60:	468c      	mov	ip, r1
 8001c62:	4463      	add	r3, ip
 8001c64:	0018      	movs	r0, r3
 8001c66:	465b      	mov	r3, fp
 8001c68:	4083      	lsls	r3, r0
 8001c6a:	431a      	orrs	r2, r3
 8001c6c:	1e50      	subs	r0, r2, #1
 8001c6e:	4182      	sbcs	r2, r0
 8001c70:	433a      	orrs	r2, r7
 8001c72:	2707      	movs	r7, #7
 8001c74:	2300      	movs	r3, #0
 8001c76:	4017      	ands	r7, r2
 8001c78:	d009      	beq.n	8001c8e <__aeabi_ddiv+0x5c6>
 8001c7a:	210f      	movs	r1, #15
 8001c7c:	2300      	movs	r3, #0
 8001c7e:	4011      	ands	r1, r2
 8001c80:	0014      	movs	r4, r2
 8001c82:	2904      	cmp	r1, #4
 8001c84:	d195      	bne.n	8001bb2 <__aeabi_ddiv+0x4ea>
 8001c86:	0022      	movs	r2, r4
 8001c88:	075f      	lsls	r7, r3, #29
 8001c8a:	025b      	lsls	r3, r3, #9
 8001c8c:	0b1b      	lsrs	r3, r3, #12
 8001c8e:	08d2      	lsrs	r2, r2, #3
 8001c90:	4317      	orrs	r7, r2
 8001c92:	2200      	movs	r2, #0
 8001c94:	e5a6      	b.n	80017e4 <__aeabi_ddiv+0x11c>
 8001c96:	2380      	movs	r3, #128	; 0x80
 8001c98:	4659      	mov	r1, fp
 8001c9a:	031b      	lsls	r3, r3, #12
 8001c9c:	430b      	orrs	r3, r1
 8001c9e:	031b      	lsls	r3, r3, #12
 8001ca0:	0017      	movs	r7, r2
 8001ca2:	0b1b      	lsrs	r3, r3, #12
 8001ca4:	4a06      	ldr	r2, [pc, #24]	; (8001cc0 <__aeabi_ddiv+0x5f8>)
 8001ca6:	e59d      	b.n	80017e4 <__aeabi_ddiv+0x11c>
 8001ca8:	42bd      	cmp	r5, r7
 8001caa:	d8b2      	bhi.n	8001c12 <__aeabi_ddiv+0x54a>
 8001cac:	469b      	mov	fp, r3
 8001cae:	2400      	movs	r4, #0
 8001cb0:	e6bf      	b.n	8001a32 <__aeabi_ddiv+0x36a>
 8001cb2:	4580      	cmp	r8, r0
 8001cb4:	d3b9      	bcc.n	8001c2a <__aeabi_ddiv+0x562>
 8001cb6:	001a      	movs	r2, r3
 8001cb8:	e7c3      	b.n	8001c42 <__aeabi_ddiv+0x57a>
 8001cba:	46c0      	nop			; (mov r8, r8)
 8001cbc:	000003ff 	.word	0x000003ff
 8001cc0:	000007ff 	.word	0x000007ff
 8001cc4:	0000041e 	.word	0x0000041e
 8001cc8:	0000043e 	.word	0x0000043e

08001ccc <__eqdf2>:
 8001ccc:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001cce:	464f      	mov	r7, r9
 8001cd0:	4646      	mov	r6, r8
 8001cd2:	46d6      	mov	lr, sl
 8001cd4:	4684      	mov	ip, r0
 8001cd6:	b5c0      	push	{r6, r7, lr}
 8001cd8:	4680      	mov	r8, r0
 8001cda:	4e19      	ldr	r6, [pc, #100]	; (8001d40 <__eqdf2+0x74>)
 8001cdc:	0318      	lsls	r0, r3, #12
 8001cde:	030f      	lsls	r7, r1, #12
 8001ce0:	004d      	lsls	r5, r1, #1
 8001ce2:	0b00      	lsrs	r0, r0, #12
 8001ce4:	005c      	lsls	r4, r3, #1
 8001ce6:	4682      	mov	sl, r0
 8001ce8:	0b3f      	lsrs	r7, r7, #12
 8001cea:	0d6d      	lsrs	r5, r5, #21
 8001cec:	0fc9      	lsrs	r1, r1, #31
 8001cee:	4691      	mov	r9, r2
 8001cf0:	0d64      	lsrs	r4, r4, #21
 8001cf2:	0fdb      	lsrs	r3, r3, #31
 8001cf4:	2001      	movs	r0, #1
 8001cf6:	42b5      	cmp	r5, r6
 8001cf8:	d00a      	beq.n	8001d10 <__eqdf2+0x44>
 8001cfa:	42b4      	cmp	r4, r6
 8001cfc:	d003      	beq.n	8001d06 <__eqdf2+0x3a>
 8001cfe:	42a5      	cmp	r5, r4
 8001d00:	d101      	bne.n	8001d06 <__eqdf2+0x3a>
 8001d02:	4557      	cmp	r7, sl
 8001d04:	d00c      	beq.n	8001d20 <__eqdf2+0x54>
 8001d06:	bc1c      	pop	{r2, r3, r4}
 8001d08:	4690      	mov	r8, r2
 8001d0a:	4699      	mov	r9, r3
 8001d0c:	46a2      	mov	sl, r4
 8001d0e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001d10:	4666      	mov	r6, ip
 8001d12:	433e      	orrs	r6, r7
 8001d14:	d1f7      	bne.n	8001d06 <__eqdf2+0x3a>
 8001d16:	42ac      	cmp	r4, r5
 8001d18:	d1f5      	bne.n	8001d06 <__eqdf2+0x3a>
 8001d1a:	4654      	mov	r4, sl
 8001d1c:	4314      	orrs	r4, r2
 8001d1e:	d1f2      	bne.n	8001d06 <__eqdf2+0x3a>
 8001d20:	2001      	movs	r0, #1
 8001d22:	45c8      	cmp	r8, r9
 8001d24:	d1ef      	bne.n	8001d06 <__eqdf2+0x3a>
 8001d26:	4299      	cmp	r1, r3
 8001d28:	d007      	beq.n	8001d3a <__eqdf2+0x6e>
 8001d2a:	2d00      	cmp	r5, #0
 8001d2c:	d1eb      	bne.n	8001d06 <__eqdf2+0x3a>
 8001d2e:	4663      	mov	r3, ip
 8001d30:	431f      	orrs	r7, r3
 8001d32:	0038      	movs	r0, r7
 8001d34:	1e47      	subs	r7, r0, #1
 8001d36:	41b8      	sbcs	r0, r7
 8001d38:	e7e5      	b.n	8001d06 <__eqdf2+0x3a>
 8001d3a:	2000      	movs	r0, #0
 8001d3c:	e7e3      	b.n	8001d06 <__eqdf2+0x3a>
 8001d3e:	46c0      	nop			; (mov r8, r8)
 8001d40:	000007ff 	.word	0x000007ff

08001d44 <__gedf2>:
 8001d44:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001d46:	464f      	mov	r7, r9
 8001d48:	4646      	mov	r6, r8
 8001d4a:	46d6      	mov	lr, sl
 8001d4c:	004d      	lsls	r5, r1, #1
 8001d4e:	b5c0      	push	{r6, r7, lr}
 8001d50:	030e      	lsls	r6, r1, #12
 8001d52:	0fc9      	lsrs	r1, r1, #31
 8001d54:	468a      	mov	sl, r1
 8001d56:	492c      	ldr	r1, [pc, #176]	; (8001e08 <__gedf2+0xc4>)
 8001d58:	031f      	lsls	r7, r3, #12
 8001d5a:	005c      	lsls	r4, r3, #1
 8001d5c:	4680      	mov	r8, r0
 8001d5e:	0b36      	lsrs	r6, r6, #12
 8001d60:	0d6d      	lsrs	r5, r5, #21
 8001d62:	4691      	mov	r9, r2
 8001d64:	0b3f      	lsrs	r7, r7, #12
 8001d66:	0d64      	lsrs	r4, r4, #21
 8001d68:	0fdb      	lsrs	r3, r3, #31
 8001d6a:	428d      	cmp	r5, r1
 8001d6c:	d01e      	beq.n	8001dac <__gedf2+0x68>
 8001d6e:	428c      	cmp	r4, r1
 8001d70:	d016      	beq.n	8001da0 <__gedf2+0x5c>
 8001d72:	2d00      	cmp	r5, #0
 8001d74:	d11e      	bne.n	8001db4 <__gedf2+0x70>
 8001d76:	4330      	orrs	r0, r6
 8001d78:	4684      	mov	ip, r0
 8001d7a:	2c00      	cmp	r4, #0
 8001d7c:	d101      	bne.n	8001d82 <__gedf2+0x3e>
 8001d7e:	433a      	orrs	r2, r7
 8001d80:	d023      	beq.n	8001dca <__gedf2+0x86>
 8001d82:	4662      	mov	r2, ip
 8001d84:	2a00      	cmp	r2, #0
 8001d86:	d01a      	beq.n	8001dbe <__gedf2+0x7a>
 8001d88:	459a      	cmp	sl, r3
 8001d8a:	d029      	beq.n	8001de0 <__gedf2+0x9c>
 8001d8c:	4651      	mov	r1, sl
 8001d8e:	2002      	movs	r0, #2
 8001d90:	3901      	subs	r1, #1
 8001d92:	4008      	ands	r0, r1
 8001d94:	3801      	subs	r0, #1
 8001d96:	bc1c      	pop	{r2, r3, r4}
 8001d98:	4690      	mov	r8, r2
 8001d9a:	4699      	mov	r9, r3
 8001d9c:	46a2      	mov	sl, r4
 8001d9e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001da0:	0039      	movs	r1, r7
 8001da2:	4311      	orrs	r1, r2
 8001da4:	d0e5      	beq.n	8001d72 <__gedf2+0x2e>
 8001da6:	2002      	movs	r0, #2
 8001da8:	4240      	negs	r0, r0
 8001daa:	e7f4      	b.n	8001d96 <__gedf2+0x52>
 8001dac:	4330      	orrs	r0, r6
 8001dae:	d1fa      	bne.n	8001da6 <__gedf2+0x62>
 8001db0:	42ac      	cmp	r4, r5
 8001db2:	d00f      	beq.n	8001dd4 <__gedf2+0x90>
 8001db4:	2c00      	cmp	r4, #0
 8001db6:	d10f      	bne.n	8001dd8 <__gedf2+0x94>
 8001db8:	433a      	orrs	r2, r7
 8001dba:	d0e7      	beq.n	8001d8c <__gedf2+0x48>
 8001dbc:	e00c      	b.n	8001dd8 <__gedf2+0x94>
 8001dbe:	2201      	movs	r2, #1
 8001dc0:	3b01      	subs	r3, #1
 8001dc2:	4393      	bics	r3, r2
 8001dc4:	0018      	movs	r0, r3
 8001dc6:	3001      	adds	r0, #1
 8001dc8:	e7e5      	b.n	8001d96 <__gedf2+0x52>
 8001dca:	4663      	mov	r3, ip
 8001dcc:	2000      	movs	r0, #0
 8001dce:	2b00      	cmp	r3, #0
 8001dd0:	d0e1      	beq.n	8001d96 <__gedf2+0x52>
 8001dd2:	e7db      	b.n	8001d8c <__gedf2+0x48>
 8001dd4:	433a      	orrs	r2, r7
 8001dd6:	d1e6      	bne.n	8001da6 <__gedf2+0x62>
 8001dd8:	459a      	cmp	sl, r3
 8001dda:	d1d7      	bne.n	8001d8c <__gedf2+0x48>
 8001ddc:	42a5      	cmp	r5, r4
 8001dde:	dcd5      	bgt.n	8001d8c <__gedf2+0x48>
 8001de0:	42a5      	cmp	r5, r4
 8001de2:	db05      	blt.n	8001df0 <__gedf2+0xac>
 8001de4:	42be      	cmp	r6, r7
 8001de6:	d8d1      	bhi.n	8001d8c <__gedf2+0x48>
 8001de8:	d008      	beq.n	8001dfc <__gedf2+0xb8>
 8001dea:	2000      	movs	r0, #0
 8001dec:	42be      	cmp	r6, r7
 8001dee:	d2d2      	bcs.n	8001d96 <__gedf2+0x52>
 8001df0:	4650      	mov	r0, sl
 8001df2:	2301      	movs	r3, #1
 8001df4:	3801      	subs	r0, #1
 8001df6:	4398      	bics	r0, r3
 8001df8:	3001      	adds	r0, #1
 8001dfa:	e7cc      	b.n	8001d96 <__gedf2+0x52>
 8001dfc:	45c8      	cmp	r8, r9
 8001dfe:	d8c5      	bhi.n	8001d8c <__gedf2+0x48>
 8001e00:	2000      	movs	r0, #0
 8001e02:	45c8      	cmp	r8, r9
 8001e04:	d3f4      	bcc.n	8001df0 <__gedf2+0xac>
 8001e06:	e7c6      	b.n	8001d96 <__gedf2+0x52>
 8001e08:	000007ff 	.word	0x000007ff

08001e0c <__ledf2>:
 8001e0c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001e0e:	464f      	mov	r7, r9
 8001e10:	4646      	mov	r6, r8
 8001e12:	46d6      	mov	lr, sl
 8001e14:	004d      	lsls	r5, r1, #1
 8001e16:	b5c0      	push	{r6, r7, lr}
 8001e18:	030e      	lsls	r6, r1, #12
 8001e1a:	0fc9      	lsrs	r1, r1, #31
 8001e1c:	468a      	mov	sl, r1
 8001e1e:	492e      	ldr	r1, [pc, #184]	; (8001ed8 <__ledf2+0xcc>)
 8001e20:	031f      	lsls	r7, r3, #12
 8001e22:	005c      	lsls	r4, r3, #1
 8001e24:	4680      	mov	r8, r0
 8001e26:	0b36      	lsrs	r6, r6, #12
 8001e28:	0d6d      	lsrs	r5, r5, #21
 8001e2a:	4691      	mov	r9, r2
 8001e2c:	0b3f      	lsrs	r7, r7, #12
 8001e2e:	0d64      	lsrs	r4, r4, #21
 8001e30:	0fdb      	lsrs	r3, r3, #31
 8001e32:	428d      	cmp	r5, r1
 8001e34:	d018      	beq.n	8001e68 <__ledf2+0x5c>
 8001e36:	428c      	cmp	r4, r1
 8001e38:	d011      	beq.n	8001e5e <__ledf2+0x52>
 8001e3a:	2d00      	cmp	r5, #0
 8001e3c:	d118      	bne.n	8001e70 <__ledf2+0x64>
 8001e3e:	4330      	orrs	r0, r6
 8001e40:	4684      	mov	ip, r0
 8001e42:	2c00      	cmp	r4, #0
 8001e44:	d11e      	bne.n	8001e84 <__ledf2+0x78>
 8001e46:	433a      	orrs	r2, r7
 8001e48:	d11c      	bne.n	8001e84 <__ledf2+0x78>
 8001e4a:	4663      	mov	r3, ip
 8001e4c:	2000      	movs	r0, #0
 8001e4e:	2b00      	cmp	r3, #0
 8001e50:	d030      	beq.n	8001eb4 <__ledf2+0xa8>
 8001e52:	4651      	mov	r1, sl
 8001e54:	2002      	movs	r0, #2
 8001e56:	3901      	subs	r1, #1
 8001e58:	4008      	ands	r0, r1
 8001e5a:	3801      	subs	r0, #1
 8001e5c:	e02a      	b.n	8001eb4 <__ledf2+0xa8>
 8001e5e:	0039      	movs	r1, r7
 8001e60:	4311      	orrs	r1, r2
 8001e62:	d0ea      	beq.n	8001e3a <__ledf2+0x2e>
 8001e64:	2002      	movs	r0, #2
 8001e66:	e025      	b.n	8001eb4 <__ledf2+0xa8>
 8001e68:	4330      	orrs	r0, r6
 8001e6a:	d1fb      	bne.n	8001e64 <__ledf2+0x58>
 8001e6c:	42ac      	cmp	r4, r5
 8001e6e:	d026      	beq.n	8001ebe <__ledf2+0xb2>
 8001e70:	2c00      	cmp	r4, #0
 8001e72:	d126      	bne.n	8001ec2 <__ledf2+0xb6>
 8001e74:	433a      	orrs	r2, r7
 8001e76:	d124      	bne.n	8001ec2 <__ledf2+0xb6>
 8001e78:	4651      	mov	r1, sl
 8001e7a:	2002      	movs	r0, #2
 8001e7c:	3901      	subs	r1, #1
 8001e7e:	4008      	ands	r0, r1
 8001e80:	3801      	subs	r0, #1
 8001e82:	e017      	b.n	8001eb4 <__ledf2+0xa8>
 8001e84:	4662      	mov	r2, ip
 8001e86:	2a00      	cmp	r2, #0
 8001e88:	d00f      	beq.n	8001eaa <__ledf2+0x9e>
 8001e8a:	459a      	cmp	sl, r3
 8001e8c:	d1e1      	bne.n	8001e52 <__ledf2+0x46>
 8001e8e:	42a5      	cmp	r5, r4
 8001e90:	db05      	blt.n	8001e9e <__ledf2+0x92>
 8001e92:	42be      	cmp	r6, r7
 8001e94:	d8dd      	bhi.n	8001e52 <__ledf2+0x46>
 8001e96:	d019      	beq.n	8001ecc <__ledf2+0xc0>
 8001e98:	2000      	movs	r0, #0
 8001e9a:	42be      	cmp	r6, r7
 8001e9c:	d20a      	bcs.n	8001eb4 <__ledf2+0xa8>
 8001e9e:	4650      	mov	r0, sl
 8001ea0:	2301      	movs	r3, #1
 8001ea2:	3801      	subs	r0, #1
 8001ea4:	4398      	bics	r0, r3
 8001ea6:	3001      	adds	r0, #1
 8001ea8:	e004      	b.n	8001eb4 <__ledf2+0xa8>
 8001eaa:	2201      	movs	r2, #1
 8001eac:	3b01      	subs	r3, #1
 8001eae:	4393      	bics	r3, r2
 8001eb0:	0018      	movs	r0, r3
 8001eb2:	3001      	adds	r0, #1
 8001eb4:	bc1c      	pop	{r2, r3, r4}
 8001eb6:	4690      	mov	r8, r2
 8001eb8:	4699      	mov	r9, r3
 8001eba:	46a2      	mov	sl, r4
 8001ebc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001ebe:	433a      	orrs	r2, r7
 8001ec0:	d1d0      	bne.n	8001e64 <__ledf2+0x58>
 8001ec2:	459a      	cmp	sl, r3
 8001ec4:	d1c5      	bne.n	8001e52 <__ledf2+0x46>
 8001ec6:	42a5      	cmp	r5, r4
 8001ec8:	dcc3      	bgt.n	8001e52 <__ledf2+0x46>
 8001eca:	e7e0      	b.n	8001e8e <__ledf2+0x82>
 8001ecc:	45c8      	cmp	r8, r9
 8001ece:	d8c0      	bhi.n	8001e52 <__ledf2+0x46>
 8001ed0:	2000      	movs	r0, #0
 8001ed2:	45c8      	cmp	r8, r9
 8001ed4:	d3e3      	bcc.n	8001e9e <__ledf2+0x92>
 8001ed6:	e7ed      	b.n	8001eb4 <__ledf2+0xa8>
 8001ed8:	000007ff 	.word	0x000007ff

08001edc <__aeabi_dmul>:
 8001edc:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001ede:	4657      	mov	r7, sl
 8001ee0:	46de      	mov	lr, fp
 8001ee2:	464e      	mov	r6, r9
 8001ee4:	4645      	mov	r5, r8
 8001ee6:	b5e0      	push	{r5, r6, r7, lr}
 8001ee8:	4683      	mov	fp, r0
 8001eea:	0006      	movs	r6, r0
 8001eec:	030f      	lsls	r7, r1, #12
 8001eee:	0048      	lsls	r0, r1, #1
 8001ef0:	b087      	sub	sp, #28
 8001ef2:	4692      	mov	sl, r2
 8001ef4:	001d      	movs	r5, r3
 8001ef6:	0b3f      	lsrs	r7, r7, #12
 8001ef8:	0d40      	lsrs	r0, r0, #21
 8001efa:	0fcc      	lsrs	r4, r1, #31
 8001efc:	2800      	cmp	r0, #0
 8001efe:	d100      	bne.n	8001f02 <__aeabi_dmul+0x26>
 8001f00:	e06f      	b.n	8001fe2 <__aeabi_dmul+0x106>
 8001f02:	4bde      	ldr	r3, [pc, #888]	; (800227c <__aeabi_dmul+0x3a0>)
 8001f04:	4298      	cmp	r0, r3
 8001f06:	d038      	beq.n	8001f7a <__aeabi_dmul+0x9e>
 8001f08:	2380      	movs	r3, #128	; 0x80
 8001f0a:	00ff      	lsls	r7, r7, #3
 8001f0c:	041b      	lsls	r3, r3, #16
 8001f0e:	431f      	orrs	r7, r3
 8001f10:	0f73      	lsrs	r3, r6, #29
 8001f12:	433b      	orrs	r3, r7
 8001f14:	9301      	str	r3, [sp, #4]
 8001f16:	4bda      	ldr	r3, [pc, #872]	; (8002280 <__aeabi_dmul+0x3a4>)
 8001f18:	2700      	movs	r7, #0
 8001f1a:	4699      	mov	r9, r3
 8001f1c:	2300      	movs	r3, #0
 8001f1e:	469b      	mov	fp, r3
 8001f20:	00f6      	lsls	r6, r6, #3
 8001f22:	4481      	add	r9, r0
 8001f24:	032b      	lsls	r3, r5, #12
 8001f26:	0069      	lsls	r1, r5, #1
 8001f28:	0b1b      	lsrs	r3, r3, #12
 8001f2a:	4652      	mov	r2, sl
 8001f2c:	4698      	mov	r8, r3
 8001f2e:	0d49      	lsrs	r1, r1, #21
 8001f30:	0fed      	lsrs	r5, r5, #31
 8001f32:	2900      	cmp	r1, #0
 8001f34:	d100      	bne.n	8001f38 <__aeabi_dmul+0x5c>
 8001f36:	e085      	b.n	8002044 <__aeabi_dmul+0x168>
 8001f38:	4bd0      	ldr	r3, [pc, #832]	; (800227c <__aeabi_dmul+0x3a0>)
 8001f3a:	4299      	cmp	r1, r3
 8001f3c:	d100      	bne.n	8001f40 <__aeabi_dmul+0x64>
 8001f3e:	e073      	b.n	8002028 <__aeabi_dmul+0x14c>
 8001f40:	4643      	mov	r3, r8
 8001f42:	00da      	lsls	r2, r3, #3
 8001f44:	2380      	movs	r3, #128	; 0x80
 8001f46:	041b      	lsls	r3, r3, #16
 8001f48:	4313      	orrs	r3, r2
 8001f4a:	4652      	mov	r2, sl
 8001f4c:	48cc      	ldr	r0, [pc, #816]	; (8002280 <__aeabi_dmul+0x3a4>)
 8001f4e:	0f52      	lsrs	r2, r2, #29
 8001f50:	4684      	mov	ip, r0
 8001f52:	4313      	orrs	r3, r2
 8001f54:	4652      	mov	r2, sl
 8001f56:	2000      	movs	r0, #0
 8001f58:	4461      	add	r1, ip
 8001f5a:	00d2      	lsls	r2, r2, #3
 8001f5c:	4489      	add	r9, r1
 8001f5e:	0021      	movs	r1, r4
 8001f60:	4069      	eors	r1, r5
 8001f62:	9100      	str	r1, [sp, #0]
 8001f64:	468c      	mov	ip, r1
 8001f66:	2101      	movs	r1, #1
 8001f68:	4449      	add	r1, r9
 8001f6a:	468a      	mov	sl, r1
 8001f6c:	2f0f      	cmp	r7, #15
 8001f6e:	d900      	bls.n	8001f72 <__aeabi_dmul+0x96>
 8001f70:	e090      	b.n	8002094 <__aeabi_dmul+0x1b8>
 8001f72:	49c4      	ldr	r1, [pc, #784]	; (8002284 <__aeabi_dmul+0x3a8>)
 8001f74:	00bf      	lsls	r7, r7, #2
 8001f76:	59cf      	ldr	r7, [r1, r7]
 8001f78:	46bf      	mov	pc, r7
 8001f7a:	465b      	mov	r3, fp
 8001f7c:	433b      	orrs	r3, r7
 8001f7e:	9301      	str	r3, [sp, #4]
 8001f80:	d000      	beq.n	8001f84 <__aeabi_dmul+0xa8>
 8001f82:	e16a      	b.n	800225a <__aeabi_dmul+0x37e>
 8001f84:	2302      	movs	r3, #2
 8001f86:	2708      	movs	r7, #8
 8001f88:	2600      	movs	r6, #0
 8001f8a:	4681      	mov	r9, r0
 8001f8c:	469b      	mov	fp, r3
 8001f8e:	e7c9      	b.n	8001f24 <__aeabi_dmul+0x48>
 8001f90:	0032      	movs	r2, r6
 8001f92:	4658      	mov	r0, fp
 8001f94:	9b01      	ldr	r3, [sp, #4]
 8001f96:	4661      	mov	r1, ip
 8001f98:	9100      	str	r1, [sp, #0]
 8001f9a:	2802      	cmp	r0, #2
 8001f9c:	d100      	bne.n	8001fa0 <__aeabi_dmul+0xc4>
 8001f9e:	e075      	b.n	800208c <__aeabi_dmul+0x1b0>
 8001fa0:	2803      	cmp	r0, #3
 8001fa2:	d100      	bne.n	8001fa6 <__aeabi_dmul+0xca>
 8001fa4:	e1fe      	b.n	80023a4 <__aeabi_dmul+0x4c8>
 8001fa6:	2801      	cmp	r0, #1
 8001fa8:	d000      	beq.n	8001fac <__aeabi_dmul+0xd0>
 8001faa:	e12c      	b.n	8002206 <__aeabi_dmul+0x32a>
 8001fac:	2300      	movs	r3, #0
 8001fae:	2700      	movs	r7, #0
 8001fb0:	2600      	movs	r6, #0
 8001fb2:	2500      	movs	r5, #0
 8001fb4:	033f      	lsls	r7, r7, #12
 8001fb6:	0d2a      	lsrs	r2, r5, #20
 8001fb8:	0b3f      	lsrs	r7, r7, #12
 8001fba:	48b3      	ldr	r0, [pc, #716]	; (8002288 <__aeabi_dmul+0x3ac>)
 8001fbc:	0512      	lsls	r2, r2, #20
 8001fbe:	433a      	orrs	r2, r7
 8001fc0:	4002      	ands	r2, r0
 8001fc2:	051b      	lsls	r3, r3, #20
 8001fc4:	4313      	orrs	r3, r2
 8001fc6:	9a00      	ldr	r2, [sp, #0]
 8001fc8:	005b      	lsls	r3, r3, #1
 8001fca:	07d1      	lsls	r1, r2, #31
 8001fcc:	085b      	lsrs	r3, r3, #1
 8001fce:	430b      	orrs	r3, r1
 8001fd0:	0030      	movs	r0, r6
 8001fd2:	0019      	movs	r1, r3
 8001fd4:	b007      	add	sp, #28
 8001fd6:	bc3c      	pop	{r2, r3, r4, r5}
 8001fd8:	4690      	mov	r8, r2
 8001fda:	4699      	mov	r9, r3
 8001fdc:	46a2      	mov	sl, r4
 8001fde:	46ab      	mov	fp, r5
 8001fe0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001fe2:	465b      	mov	r3, fp
 8001fe4:	433b      	orrs	r3, r7
 8001fe6:	9301      	str	r3, [sp, #4]
 8001fe8:	d100      	bne.n	8001fec <__aeabi_dmul+0x110>
 8001fea:	e12f      	b.n	800224c <__aeabi_dmul+0x370>
 8001fec:	2f00      	cmp	r7, #0
 8001fee:	d100      	bne.n	8001ff2 <__aeabi_dmul+0x116>
 8001ff0:	e1a5      	b.n	800233e <__aeabi_dmul+0x462>
 8001ff2:	0038      	movs	r0, r7
 8001ff4:	f000 fea8 	bl	8002d48 <__clzsi2>
 8001ff8:	0003      	movs	r3, r0
 8001ffa:	3b0b      	subs	r3, #11
 8001ffc:	2b1c      	cmp	r3, #28
 8001ffe:	dd00      	ble.n	8002002 <__aeabi_dmul+0x126>
 8002000:	e196      	b.n	8002330 <__aeabi_dmul+0x454>
 8002002:	221d      	movs	r2, #29
 8002004:	1ad3      	subs	r3, r2, r3
 8002006:	465a      	mov	r2, fp
 8002008:	0001      	movs	r1, r0
 800200a:	40da      	lsrs	r2, r3
 800200c:	465e      	mov	r6, fp
 800200e:	3908      	subs	r1, #8
 8002010:	408f      	lsls	r7, r1
 8002012:	0013      	movs	r3, r2
 8002014:	408e      	lsls	r6, r1
 8002016:	433b      	orrs	r3, r7
 8002018:	9301      	str	r3, [sp, #4]
 800201a:	4b9c      	ldr	r3, [pc, #624]	; (800228c <__aeabi_dmul+0x3b0>)
 800201c:	2700      	movs	r7, #0
 800201e:	1a1b      	subs	r3, r3, r0
 8002020:	4699      	mov	r9, r3
 8002022:	2300      	movs	r3, #0
 8002024:	469b      	mov	fp, r3
 8002026:	e77d      	b.n	8001f24 <__aeabi_dmul+0x48>
 8002028:	4641      	mov	r1, r8
 800202a:	4653      	mov	r3, sl
 800202c:	430b      	orrs	r3, r1
 800202e:	4993      	ldr	r1, [pc, #588]	; (800227c <__aeabi_dmul+0x3a0>)
 8002030:	468c      	mov	ip, r1
 8002032:	44e1      	add	r9, ip
 8002034:	2b00      	cmp	r3, #0
 8002036:	d000      	beq.n	800203a <__aeabi_dmul+0x15e>
 8002038:	e11a      	b.n	8002270 <__aeabi_dmul+0x394>
 800203a:	2202      	movs	r2, #2
 800203c:	2002      	movs	r0, #2
 800203e:	4317      	orrs	r7, r2
 8002040:	2200      	movs	r2, #0
 8002042:	e78c      	b.n	8001f5e <__aeabi_dmul+0x82>
 8002044:	4313      	orrs	r3, r2
 8002046:	d100      	bne.n	800204a <__aeabi_dmul+0x16e>
 8002048:	e10d      	b.n	8002266 <__aeabi_dmul+0x38a>
 800204a:	4643      	mov	r3, r8
 800204c:	2b00      	cmp	r3, #0
 800204e:	d100      	bne.n	8002052 <__aeabi_dmul+0x176>
 8002050:	e181      	b.n	8002356 <__aeabi_dmul+0x47a>
 8002052:	4640      	mov	r0, r8
 8002054:	f000 fe78 	bl	8002d48 <__clzsi2>
 8002058:	0002      	movs	r2, r0
 800205a:	3a0b      	subs	r2, #11
 800205c:	2a1c      	cmp	r2, #28
 800205e:	dd00      	ble.n	8002062 <__aeabi_dmul+0x186>
 8002060:	e172      	b.n	8002348 <__aeabi_dmul+0x46c>
 8002062:	0001      	movs	r1, r0
 8002064:	4643      	mov	r3, r8
 8002066:	3908      	subs	r1, #8
 8002068:	408b      	lsls	r3, r1
 800206a:	4698      	mov	r8, r3
 800206c:	231d      	movs	r3, #29
 800206e:	1a9a      	subs	r2, r3, r2
 8002070:	4653      	mov	r3, sl
 8002072:	40d3      	lsrs	r3, r2
 8002074:	001a      	movs	r2, r3
 8002076:	4643      	mov	r3, r8
 8002078:	4313      	orrs	r3, r2
 800207a:	4652      	mov	r2, sl
 800207c:	408a      	lsls	r2, r1
 800207e:	4649      	mov	r1, r9
 8002080:	1a08      	subs	r0, r1, r0
 8002082:	4982      	ldr	r1, [pc, #520]	; (800228c <__aeabi_dmul+0x3b0>)
 8002084:	4689      	mov	r9, r1
 8002086:	4481      	add	r9, r0
 8002088:	2000      	movs	r0, #0
 800208a:	e768      	b.n	8001f5e <__aeabi_dmul+0x82>
 800208c:	4b7b      	ldr	r3, [pc, #492]	; (800227c <__aeabi_dmul+0x3a0>)
 800208e:	2700      	movs	r7, #0
 8002090:	2600      	movs	r6, #0
 8002092:	e78e      	b.n	8001fb2 <__aeabi_dmul+0xd6>
 8002094:	0c14      	lsrs	r4, r2, #16
 8002096:	0412      	lsls	r2, r2, #16
 8002098:	0c12      	lsrs	r2, r2, #16
 800209a:	0011      	movs	r1, r2
 800209c:	0c37      	lsrs	r7, r6, #16
 800209e:	0436      	lsls	r6, r6, #16
 80020a0:	0c35      	lsrs	r5, r6, #16
 80020a2:	4379      	muls	r1, r7
 80020a4:	0028      	movs	r0, r5
 80020a6:	468c      	mov	ip, r1
 80020a8:	002e      	movs	r6, r5
 80020aa:	4360      	muls	r0, r4
 80020ac:	4460      	add	r0, ip
 80020ae:	4683      	mov	fp, r0
 80020b0:	4356      	muls	r6, r2
 80020b2:	0021      	movs	r1, r4
 80020b4:	0c30      	lsrs	r0, r6, #16
 80020b6:	4680      	mov	r8, r0
 80020b8:	4658      	mov	r0, fp
 80020ba:	4379      	muls	r1, r7
 80020bc:	4440      	add	r0, r8
 80020be:	9102      	str	r1, [sp, #8]
 80020c0:	4584      	cmp	ip, r0
 80020c2:	d906      	bls.n	80020d2 <__aeabi_dmul+0x1f6>
 80020c4:	4688      	mov	r8, r1
 80020c6:	2180      	movs	r1, #128	; 0x80
 80020c8:	0249      	lsls	r1, r1, #9
 80020ca:	468c      	mov	ip, r1
 80020cc:	44e0      	add	r8, ip
 80020ce:	4641      	mov	r1, r8
 80020d0:	9102      	str	r1, [sp, #8]
 80020d2:	0436      	lsls	r6, r6, #16
 80020d4:	0c01      	lsrs	r1, r0, #16
 80020d6:	0c36      	lsrs	r6, r6, #16
 80020d8:	0400      	lsls	r0, r0, #16
 80020da:	468b      	mov	fp, r1
 80020dc:	1981      	adds	r1, r0, r6
 80020de:	0c1e      	lsrs	r6, r3, #16
 80020e0:	041b      	lsls	r3, r3, #16
 80020e2:	0c1b      	lsrs	r3, r3, #16
 80020e4:	9103      	str	r1, [sp, #12]
 80020e6:	0019      	movs	r1, r3
 80020e8:	4379      	muls	r1, r7
 80020ea:	468c      	mov	ip, r1
 80020ec:	0028      	movs	r0, r5
 80020ee:	4375      	muls	r5, r6
 80020f0:	4465      	add	r5, ip
 80020f2:	46a8      	mov	r8, r5
 80020f4:	4358      	muls	r0, r3
 80020f6:	0c05      	lsrs	r5, r0, #16
 80020f8:	4445      	add	r5, r8
 80020fa:	4377      	muls	r7, r6
 80020fc:	42a9      	cmp	r1, r5
 80020fe:	d903      	bls.n	8002108 <__aeabi_dmul+0x22c>
 8002100:	2180      	movs	r1, #128	; 0x80
 8002102:	0249      	lsls	r1, r1, #9
 8002104:	468c      	mov	ip, r1
 8002106:	4467      	add	r7, ip
 8002108:	0c29      	lsrs	r1, r5, #16
 800210a:	468c      	mov	ip, r1
 800210c:	0039      	movs	r1, r7
 800210e:	0400      	lsls	r0, r0, #16
 8002110:	0c00      	lsrs	r0, r0, #16
 8002112:	042d      	lsls	r5, r5, #16
 8002114:	182d      	adds	r5, r5, r0
 8002116:	4461      	add	r1, ip
 8002118:	44ab      	add	fp, r5
 800211a:	9105      	str	r1, [sp, #20]
 800211c:	4659      	mov	r1, fp
 800211e:	9104      	str	r1, [sp, #16]
 8002120:	9901      	ldr	r1, [sp, #4]
 8002122:	040f      	lsls	r7, r1, #16
 8002124:	0c3f      	lsrs	r7, r7, #16
 8002126:	0c08      	lsrs	r0, r1, #16
 8002128:	0039      	movs	r1, r7
 800212a:	4351      	muls	r1, r2
 800212c:	4342      	muls	r2, r0
 800212e:	4690      	mov	r8, r2
 8002130:	0002      	movs	r2, r0
 8002132:	468c      	mov	ip, r1
 8002134:	0c09      	lsrs	r1, r1, #16
 8002136:	468b      	mov	fp, r1
 8002138:	4362      	muls	r2, r4
 800213a:	437c      	muls	r4, r7
 800213c:	4444      	add	r4, r8
 800213e:	445c      	add	r4, fp
 8002140:	45a0      	cmp	r8, r4
 8002142:	d903      	bls.n	800214c <__aeabi_dmul+0x270>
 8002144:	2180      	movs	r1, #128	; 0x80
 8002146:	0249      	lsls	r1, r1, #9
 8002148:	4688      	mov	r8, r1
 800214a:	4442      	add	r2, r8
 800214c:	0c21      	lsrs	r1, r4, #16
 800214e:	4688      	mov	r8, r1
 8002150:	4661      	mov	r1, ip
 8002152:	0409      	lsls	r1, r1, #16
 8002154:	0c09      	lsrs	r1, r1, #16
 8002156:	468c      	mov	ip, r1
 8002158:	0039      	movs	r1, r7
 800215a:	4359      	muls	r1, r3
 800215c:	4343      	muls	r3, r0
 800215e:	4370      	muls	r0, r6
 8002160:	437e      	muls	r6, r7
 8002162:	0c0f      	lsrs	r7, r1, #16
 8002164:	18f6      	adds	r6, r6, r3
 8002166:	0424      	lsls	r4, r4, #16
 8002168:	19be      	adds	r6, r7, r6
 800216a:	4464      	add	r4, ip
 800216c:	4442      	add	r2, r8
 800216e:	468c      	mov	ip, r1
 8002170:	42b3      	cmp	r3, r6
 8002172:	d903      	bls.n	800217c <__aeabi_dmul+0x2a0>
 8002174:	2380      	movs	r3, #128	; 0x80
 8002176:	025b      	lsls	r3, r3, #9
 8002178:	4698      	mov	r8, r3
 800217a:	4440      	add	r0, r8
 800217c:	9b02      	ldr	r3, [sp, #8]
 800217e:	4661      	mov	r1, ip
 8002180:	4698      	mov	r8, r3
 8002182:	9b04      	ldr	r3, [sp, #16]
 8002184:	0437      	lsls	r7, r6, #16
 8002186:	4443      	add	r3, r8
 8002188:	469b      	mov	fp, r3
 800218a:	45ab      	cmp	fp, r5
 800218c:	41ad      	sbcs	r5, r5
 800218e:	426b      	negs	r3, r5
 8002190:	040d      	lsls	r5, r1, #16
 8002192:	9905      	ldr	r1, [sp, #20]
 8002194:	0c2d      	lsrs	r5, r5, #16
 8002196:	468c      	mov	ip, r1
 8002198:	197f      	adds	r7, r7, r5
 800219a:	4467      	add	r7, ip
 800219c:	18fd      	adds	r5, r7, r3
 800219e:	46a8      	mov	r8, r5
 80021a0:	465d      	mov	r5, fp
 80021a2:	192d      	adds	r5, r5, r4
 80021a4:	42a5      	cmp	r5, r4
 80021a6:	41a4      	sbcs	r4, r4
 80021a8:	4693      	mov	fp, r2
 80021aa:	4264      	negs	r4, r4
 80021ac:	46a4      	mov	ip, r4
 80021ae:	44c3      	add	fp, r8
 80021b0:	44dc      	add	ip, fp
 80021b2:	428f      	cmp	r7, r1
 80021b4:	41bf      	sbcs	r7, r7
 80021b6:	4598      	cmp	r8, r3
 80021b8:	419b      	sbcs	r3, r3
 80021ba:	4593      	cmp	fp, r2
 80021bc:	4192      	sbcs	r2, r2
 80021be:	45a4      	cmp	ip, r4
 80021c0:	41a4      	sbcs	r4, r4
 80021c2:	425b      	negs	r3, r3
 80021c4:	427f      	negs	r7, r7
 80021c6:	431f      	orrs	r7, r3
 80021c8:	0c36      	lsrs	r6, r6, #16
 80021ca:	4252      	negs	r2, r2
 80021cc:	4264      	negs	r4, r4
 80021ce:	19bf      	adds	r7, r7, r6
 80021d0:	4322      	orrs	r2, r4
 80021d2:	18bf      	adds	r7, r7, r2
 80021d4:	4662      	mov	r2, ip
 80021d6:	1838      	adds	r0, r7, r0
 80021d8:	0243      	lsls	r3, r0, #9
 80021da:	0dd2      	lsrs	r2, r2, #23
 80021dc:	9903      	ldr	r1, [sp, #12]
 80021de:	4313      	orrs	r3, r2
 80021e0:	026a      	lsls	r2, r5, #9
 80021e2:	430a      	orrs	r2, r1
 80021e4:	1e50      	subs	r0, r2, #1
 80021e6:	4182      	sbcs	r2, r0
 80021e8:	4661      	mov	r1, ip
 80021ea:	0ded      	lsrs	r5, r5, #23
 80021ec:	432a      	orrs	r2, r5
 80021ee:	024e      	lsls	r6, r1, #9
 80021f0:	4332      	orrs	r2, r6
 80021f2:	01d9      	lsls	r1, r3, #7
 80021f4:	d400      	bmi.n	80021f8 <__aeabi_dmul+0x31c>
 80021f6:	e0b3      	b.n	8002360 <__aeabi_dmul+0x484>
 80021f8:	2601      	movs	r6, #1
 80021fa:	0850      	lsrs	r0, r2, #1
 80021fc:	4032      	ands	r2, r6
 80021fe:	4302      	orrs	r2, r0
 8002200:	07de      	lsls	r6, r3, #31
 8002202:	4332      	orrs	r2, r6
 8002204:	085b      	lsrs	r3, r3, #1
 8002206:	4c22      	ldr	r4, [pc, #136]	; (8002290 <__aeabi_dmul+0x3b4>)
 8002208:	4454      	add	r4, sl
 800220a:	2c00      	cmp	r4, #0
 800220c:	dd62      	ble.n	80022d4 <__aeabi_dmul+0x3f8>
 800220e:	0751      	lsls	r1, r2, #29
 8002210:	d009      	beq.n	8002226 <__aeabi_dmul+0x34a>
 8002212:	200f      	movs	r0, #15
 8002214:	4010      	ands	r0, r2
 8002216:	2804      	cmp	r0, #4
 8002218:	d005      	beq.n	8002226 <__aeabi_dmul+0x34a>
 800221a:	1d10      	adds	r0, r2, #4
 800221c:	4290      	cmp	r0, r2
 800221e:	4192      	sbcs	r2, r2
 8002220:	4252      	negs	r2, r2
 8002222:	189b      	adds	r3, r3, r2
 8002224:	0002      	movs	r2, r0
 8002226:	01d9      	lsls	r1, r3, #7
 8002228:	d504      	bpl.n	8002234 <__aeabi_dmul+0x358>
 800222a:	2480      	movs	r4, #128	; 0x80
 800222c:	4819      	ldr	r0, [pc, #100]	; (8002294 <__aeabi_dmul+0x3b8>)
 800222e:	00e4      	lsls	r4, r4, #3
 8002230:	4003      	ands	r3, r0
 8002232:	4454      	add	r4, sl
 8002234:	4818      	ldr	r0, [pc, #96]	; (8002298 <__aeabi_dmul+0x3bc>)
 8002236:	4284      	cmp	r4, r0
 8002238:	dd00      	ble.n	800223c <__aeabi_dmul+0x360>
 800223a:	e727      	b.n	800208c <__aeabi_dmul+0x1b0>
 800223c:	075e      	lsls	r6, r3, #29
 800223e:	025b      	lsls	r3, r3, #9
 8002240:	08d2      	lsrs	r2, r2, #3
 8002242:	0b1f      	lsrs	r7, r3, #12
 8002244:	0563      	lsls	r3, r4, #21
 8002246:	4316      	orrs	r6, r2
 8002248:	0d5b      	lsrs	r3, r3, #21
 800224a:	e6b2      	b.n	8001fb2 <__aeabi_dmul+0xd6>
 800224c:	2300      	movs	r3, #0
 800224e:	4699      	mov	r9, r3
 8002250:	3301      	adds	r3, #1
 8002252:	2704      	movs	r7, #4
 8002254:	2600      	movs	r6, #0
 8002256:	469b      	mov	fp, r3
 8002258:	e664      	b.n	8001f24 <__aeabi_dmul+0x48>
 800225a:	2303      	movs	r3, #3
 800225c:	9701      	str	r7, [sp, #4]
 800225e:	4681      	mov	r9, r0
 8002260:	270c      	movs	r7, #12
 8002262:	469b      	mov	fp, r3
 8002264:	e65e      	b.n	8001f24 <__aeabi_dmul+0x48>
 8002266:	2201      	movs	r2, #1
 8002268:	2001      	movs	r0, #1
 800226a:	4317      	orrs	r7, r2
 800226c:	2200      	movs	r2, #0
 800226e:	e676      	b.n	8001f5e <__aeabi_dmul+0x82>
 8002270:	2303      	movs	r3, #3
 8002272:	2003      	movs	r0, #3
 8002274:	431f      	orrs	r7, r3
 8002276:	4643      	mov	r3, r8
 8002278:	e671      	b.n	8001f5e <__aeabi_dmul+0x82>
 800227a:	46c0      	nop			; (mov r8, r8)
 800227c:	000007ff 	.word	0x000007ff
 8002280:	fffffc01 	.word	0xfffffc01
 8002284:	08014e04 	.word	0x08014e04
 8002288:	800fffff 	.word	0x800fffff
 800228c:	fffffc0d 	.word	0xfffffc0d
 8002290:	000003ff 	.word	0x000003ff
 8002294:	feffffff 	.word	0xfeffffff
 8002298:	000007fe 	.word	0x000007fe
 800229c:	2300      	movs	r3, #0
 800229e:	2780      	movs	r7, #128	; 0x80
 80022a0:	9300      	str	r3, [sp, #0]
 80022a2:	033f      	lsls	r7, r7, #12
 80022a4:	2600      	movs	r6, #0
 80022a6:	4b43      	ldr	r3, [pc, #268]	; (80023b4 <__aeabi_dmul+0x4d8>)
 80022a8:	e683      	b.n	8001fb2 <__aeabi_dmul+0xd6>
 80022aa:	9b01      	ldr	r3, [sp, #4]
 80022ac:	0032      	movs	r2, r6
 80022ae:	46a4      	mov	ip, r4
 80022b0:	4658      	mov	r0, fp
 80022b2:	e670      	b.n	8001f96 <__aeabi_dmul+0xba>
 80022b4:	46ac      	mov	ip, r5
 80022b6:	e66e      	b.n	8001f96 <__aeabi_dmul+0xba>
 80022b8:	2780      	movs	r7, #128	; 0x80
 80022ba:	9901      	ldr	r1, [sp, #4]
 80022bc:	033f      	lsls	r7, r7, #12
 80022be:	4239      	tst	r1, r7
 80022c0:	d02d      	beq.n	800231e <__aeabi_dmul+0x442>
 80022c2:	423b      	tst	r3, r7
 80022c4:	d12b      	bne.n	800231e <__aeabi_dmul+0x442>
 80022c6:	431f      	orrs	r7, r3
 80022c8:	033f      	lsls	r7, r7, #12
 80022ca:	0b3f      	lsrs	r7, r7, #12
 80022cc:	9500      	str	r5, [sp, #0]
 80022ce:	0016      	movs	r6, r2
 80022d0:	4b38      	ldr	r3, [pc, #224]	; (80023b4 <__aeabi_dmul+0x4d8>)
 80022d2:	e66e      	b.n	8001fb2 <__aeabi_dmul+0xd6>
 80022d4:	2501      	movs	r5, #1
 80022d6:	1b2d      	subs	r5, r5, r4
 80022d8:	2d38      	cmp	r5, #56	; 0x38
 80022da:	dd00      	ble.n	80022de <__aeabi_dmul+0x402>
 80022dc:	e666      	b.n	8001fac <__aeabi_dmul+0xd0>
 80022de:	2d1f      	cmp	r5, #31
 80022e0:	dc40      	bgt.n	8002364 <__aeabi_dmul+0x488>
 80022e2:	4835      	ldr	r0, [pc, #212]	; (80023b8 <__aeabi_dmul+0x4dc>)
 80022e4:	001c      	movs	r4, r3
 80022e6:	4450      	add	r0, sl
 80022e8:	0016      	movs	r6, r2
 80022ea:	4082      	lsls	r2, r0
 80022ec:	4084      	lsls	r4, r0
 80022ee:	40ee      	lsrs	r6, r5
 80022f0:	1e50      	subs	r0, r2, #1
 80022f2:	4182      	sbcs	r2, r0
 80022f4:	4334      	orrs	r4, r6
 80022f6:	4314      	orrs	r4, r2
 80022f8:	40eb      	lsrs	r3, r5
 80022fa:	0762      	lsls	r2, r4, #29
 80022fc:	d009      	beq.n	8002312 <__aeabi_dmul+0x436>
 80022fe:	220f      	movs	r2, #15
 8002300:	4022      	ands	r2, r4
 8002302:	2a04      	cmp	r2, #4
 8002304:	d005      	beq.n	8002312 <__aeabi_dmul+0x436>
 8002306:	0022      	movs	r2, r4
 8002308:	1d14      	adds	r4, r2, #4
 800230a:	4294      	cmp	r4, r2
 800230c:	4180      	sbcs	r0, r0
 800230e:	4240      	negs	r0, r0
 8002310:	181b      	adds	r3, r3, r0
 8002312:	021a      	lsls	r2, r3, #8
 8002314:	d53e      	bpl.n	8002394 <__aeabi_dmul+0x4b8>
 8002316:	2301      	movs	r3, #1
 8002318:	2700      	movs	r7, #0
 800231a:	2600      	movs	r6, #0
 800231c:	e649      	b.n	8001fb2 <__aeabi_dmul+0xd6>
 800231e:	2780      	movs	r7, #128	; 0x80
 8002320:	9b01      	ldr	r3, [sp, #4]
 8002322:	033f      	lsls	r7, r7, #12
 8002324:	431f      	orrs	r7, r3
 8002326:	033f      	lsls	r7, r7, #12
 8002328:	0b3f      	lsrs	r7, r7, #12
 800232a:	9400      	str	r4, [sp, #0]
 800232c:	4b21      	ldr	r3, [pc, #132]	; (80023b4 <__aeabi_dmul+0x4d8>)
 800232e:	e640      	b.n	8001fb2 <__aeabi_dmul+0xd6>
 8002330:	0003      	movs	r3, r0
 8002332:	465a      	mov	r2, fp
 8002334:	3b28      	subs	r3, #40	; 0x28
 8002336:	409a      	lsls	r2, r3
 8002338:	2600      	movs	r6, #0
 800233a:	9201      	str	r2, [sp, #4]
 800233c:	e66d      	b.n	800201a <__aeabi_dmul+0x13e>
 800233e:	4658      	mov	r0, fp
 8002340:	f000 fd02 	bl	8002d48 <__clzsi2>
 8002344:	3020      	adds	r0, #32
 8002346:	e657      	b.n	8001ff8 <__aeabi_dmul+0x11c>
 8002348:	0003      	movs	r3, r0
 800234a:	4652      	mov	r2, sl
 800234c:	3b28      	subs	r3, #40	; 0x28
 800234e:	409a      	lsls	r2, r3
 8002350:	0013      	movs	r3, r2
 8002352:	2200      	movs	r2, #0
 8002354:	e693      	b.n	800207e <__aeabi_dmul+0x1a2>
 8002356:	4650      	mov	r0, sl
 8002358:	f000 fcf6 	bl	8002d48 <__clzsi2>
 800235c:	3020      	adds	r0, #32
 800235e:	e67b      	b.n	8002058 <__aeabi_dmul+0x17c>
 8002360:	46ca      	mov	sl, r9
 8002362:	e750      	b.n	8002206 <__aeabi_dmul+0x32a>
 8002364:	201f      	movs	r0, #31
 8002366:	001e      	movs	r6, r3
 8002368:	4240      	negs	r0, r0
 800236a:	1b04      	subs	r4, r0, r4
 800236c:	40e6      	lsrs	r6, r4
 800236e:	2d20      	cmp	r5, #32
 8002370:	d003      	beq.n	800237a <__aeabi_dmul+0x49e>
 8002372:	4c12      	ldr	r4, [pc, #72]	; (80023bc <__aeabi_dmul+0x4e0>)
 8002374:	4454      	add	r4, sl
 8002376:	40a3      	lsls	r3, r4
 8002378:	431a      	orrs	r2, r3
 800237a:	1e50      	subs	r0, r2, #1
 800237c:	4182      	sbcs	r2, r0
 800237e:	4332      	orrs	r2, r6
 8002380:	2607      	movs	r6, #7
 8002382:	2700      	movs	r7, #0
 8002384:	4016      	ands	r6, r2
 8002386:	d009      	beq.n	800239c <__aeabi_dmul+0x4c0>
 8002388:	200f      	movs	r0, #15
 800238a:	2300      	movs	r3, #0
 800238c:	4010      	ands	r0, r2
 800238e:	0014      	movs	r4, r2
 8002390:	2804      	cmp	r0, #4
 8002392:	d1b9      	bne.n	8002308 <__aeabi_dmul+0x42c>
 8002394:	0022      	movs	r2, r4
 8002396:	075e      	lsls	r6, r3, #29
 8002398:	025b      	lsls	r3, r3, #9
 800239a:	0b1f      	lsrs	r7, r3, #12
 800239c:	08d2      	lsrs	r2, r2, #3
 800239e:	4316      	orrs	r6, r2
 80023a0:	2300      	movs	r3, #0
 80023a2:	e606      	b.n	8001fb2 <__aeabi_dmul+0xd6>
 80023a4:	2780      	movs	r7, #128	; 0x80
 80023a6:	033f      	lsls	r7, r7, #12
 80023a8:	431f      	orrs	r7, r3
 80023aa:	033f      	lsls	r7, r7, #12
 80023ac:	0b3f      	lsrs	r7, r7, #12
 80023ae:	0016      	movs	r6, r2
 80023b0:	4b00      	ldr	r3, [pc, #0]	; (80023b4 <__aeabi_dmul+0x4d8>)
 80023b2:	e5fe      	b.n	8001fb2 <__aeabi_dmul+0xd6>
 80023b4:	000007ff 	.word	0x000007ff
 80023b8:	0000041e 	.word	0x0000041e
 80023bc:	0000043e 	.word	0x0000043e

080023c0 <__aeabi_dsub>:
 80023c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80023c2:	4657      	mov	r7, sl
 80023c4:	464e      	mov	r6, r9
 80023c6:	4645      	mov	r5, r8
 80023c8:	46de      	mov	lr, fp
 80023ca:	000c      	movs	r4, r1
 80023cc:	0309      	lsls	r1, r1, #12
 80023ce:	b5e0      	push	{r5, r6, r7, lr}
 80023d0:	0a49      	lsrs	r1, r1, #9
 80023d2:	0f46      	lsrs	r6, r0, #29
 80023d4:	005f      	lsls	r7, r3, #1
 80023d6:	4331      	orrs	r1, r6
 80023d8:	031e      	lsls	r6, r3, #12
 80023da:	0fdb      	lsrs	r3, r3, #31
 80023dc:	0a76      	lsrs	r6, r6, #9
 80023de:	469b      	mov	fp, r3
 80023e0:	0f53      	lsrs	r3, r2, #29
 80023e2:	4333      	orrs	r3, r6
 80023e4:	4ec8      	ldr	r6, [pc, #800]	; (8002708 <__aeabi_dsub+0x348>)
 80023e6:	0065      	lsls	r5, r4, #1
 80023e8:	00c0      	lsls	r0, r0, #3
 80023ea:	0fe4      	lsrs	r4, r4, #31
 80023ec:	00d2      	lsls	r2, r2, #3
 80023ee:	0d6d      	lsrs	r5, r5, #21
 80023f0:	46a2      	mov	sl, r4
 80023f2:	4681      	mov	r9, r0
 80023f4:	0d7f      	lsrs	r7, r7, #21
 80023f6:	469c      	mov	ip, r3
 80023f8:	4690      	mov	r8, r2
 80023fa:	42b7      	cmp	r7, r6
 80023fc:	d100      	bne.n	8002400 <__aeabi_dsub+0x40>
 80023fe:	e0b9      	b.n	8002574 <__aeabi_dsub+0x1b4>
 8002400:	465b      	mov	r3, fp
 8002402:	2601      	movs	r6, #1
 8002404:	4073      	eors	r3, r6
 8002406:	469b      	mov	fp, r3
 8002408:	1bee      	subs	r6, r5, r7
 800240a:	45a3      	cmp	fp, r4
 800240c:	d100      	bne.n	8002410 <__aeabi_dsub+0x50>
 800240e:	e083      	b.n	8002518 <__aeabi_dsub+0x158>
 8002410:	2e00      	cmp	r6, #0
 8002412:	dd63      	ble.n	80024dc <__aeabi_dsub+0x11c>
 8002414:	2f00      	cmp	r7, #0
 8002416:	d000      	beq.n	800241a <__aeabi_dsub+0x5a>
 8002418:	e0b1      	b.n	800257e <__aeabi_dsub+0x1be>
 800241a:	4663      	mov	r3, ip
 800241c:	4313      	orrs	r3, r2
 800241e:	d100      	bne.n	8002422 <__aeabi_dsub+0x62>
 8002420:	e123      	b.n	800266a <__aeabi_dsub+0x2aa>
 8002422:	1e73      	subs	r3, r6, #1
 8002424:	2b00      	cmp	r3, #0
 8002426:	d000      	beq.n	800242a <__aeabi_dsub+0x6a>
 8002428:	e1ba      	b.n	80027a0 <__aeabi_dsub+0x3e0>
 800242a:	1a86      	subs	r6, r0, r2
 800242c:	4663      	mov	r3, ip
 800242e:	42b0      	cmp	r0, r6
 8002430:	4180      	sbcs	r0, r0
 8002432:	2501      	movs	r5, #1
 8002434:	1ac9      	subs	r1, r1, r3
 8002436:	4240      	negs	r0, r0
 8002438:	1a09      	subs	r1, r1, r0
 800243a:	020b      	lsls	r3, r1, #8
 800243c:	d400      	bmi.n	8002440 <__aeabi_dsub+0x80>
 800243e:	e147      	b.n	80026d0 <__aeabi_dsub+0x310>
 8002440:	0249      	lsls	r1, r1, #9
 8002442:	0a4b      	lsrs	r3, r1, #9
 8002444:	4698      	mov	r8, r3
 8002446:	4643      	mov	r3, r8
 8002448:	2b00      	cmp	r3, #0
 800244a:	d100      	bne.n	800244e <__aeabi_dsub+0x8e>
 800244c:	e189      	b.n	8002762 <__aeabi_dsub+0x3a2>
 800244e:	4640      	mov	r0, r8
 8002450:	f000 fc7a 	bl	8002d48 <__clzsi2>
 8002454:	0003      	movs	r3, r0
 8002456:	3b08      	subs	r3, #8
 8002458:	2b1f      	cmp	r3, #31
 800245a:	dd00      	ble.n	800245e <__aeabi_dsub+0x9e>
 800245c:	e17c      	b.n	8002758 <__aeabi_dsub+0x398>
 800245e:	2220      	movs	r2, #32
 8002460:	0030      	movs	r0, r6
 8002462:	1ad2      	subs	r2, r2, r3
 8002464:	4641      	mov	r1, r8
 8002466:	40d0      	lsrs	r0, r2
 8002468:	4099      	lsls	r1, r3
 800246a:	0002      	movs	r2, r0
 800246c:	409e      	lsls	r6, r3
 800246e:	430a      	orrs	r2, r1
 8002470:	429d      	cmp	r5, r3
 8002472:	dd00      	ble.n	8002476 <__aeabi_dsub+0xb6>
 8002474:	e16a      	b.n	800274c <__aeabi_dsub+0x38c>
 8002476:	1b5d      	subs	r5, r3, r5
 8002478:	1c6b      	adds	r3, r5, #1
 800247a:	2b1f      	cmp	r3, #31
 800247c:	dd00      	ble.n	8002480 <__aeabi_dsub+0xc0>
 800247e:	e194      	b.n	80027aa <__aeabi_dsub+0x3ea>
 8002480:	2120      	movs	r1, #32
 8002482:	0010      	movs	r0, r2
 8002484:	0035      	movs	r5, r6
 8002486:	1ac9      	subs	r1, r1, r3
 8002488:	408e      	lsls	r6, r1
 800248a:	40da      	lsrs	r2, r3
 800248c:	4088      	lsls	r0, r1
 800248e:	40dd      	lsrs	r5, r3
 8002490:	1e71      	subs	r1, r6, #1
 8002492:	418e      	sbcs	r6, r1
 8002494:	0011      	movs	r1, r2
 8002496:	2207      	movs	r2, #7
 8002498:	4328      	orrs	r0, r5
 800249a:	2500      	movs	r5, #0
 800249c:	4306      	orrs	r6, r0
 800249e:	4032      	ands	r2, r6
 80024a0:	2a00      	cmp	r2, #0
 80024a2:	d009      	beq.n	80024b8 <__aeabi_dsub+0xf8>
 80024a4:	230f      	movs	r3, #15
 80024a6:	4033      	ands	r3, r6
 80024a8:	2b04      	cmp	r3, #4
 80024aa:	d005      	beq.n	80024b8 <__aeabi_dsub+0xf8>
 80024ac:	1d33      	adds	r3, r6, #4
 80024ae:	42b3      	cmp	r3, r6
 80024b0:	41b6      	sbcs	r6, r6
 80024b2:	4276      	negs	r6, r6
 80024b4:	1989      	adds	r1, r1, r6
 80024b6:	001e      	movs	r6, r3
 80024b8:	020b      	lsls	r3, r1, #8
 80024ba:	d400      	bmi.n	80024be <__aeabi_dsub+0xfe>
 80024bc:	e23d      	b.n	800293a <__aeabi_dsub+0x57a>
 80024be:	1c6a      	adds	r2, r5, #1
 80024c0:	4b91      	ldr	r3, [pc, #580]	; (8002708 <__aeabi_dsub+0x348>)
 80024c2:	0555      	lsls	r5, r2, #21
 80024c4:	0d6d      	lsrs	r5, r5, #21
 80024c6:	429a      	cmp	r2, r3
 80024c8:	d100      	bne.n	80024cc <__aeabi_dsub+0x10c>
 80024ca:	e119      	b.n	8002700 <__aeabi_dsub+0x340>
 80024cc:	4a8f      	ldr	r2, [pc, #572]	; (800270c <__aeabi_dsub+0x34c>)
 80024ce:	08f6      	lsrs	r6, r6, #3
 80024d0:	400a      	ands	r2, r1
 80024d2:	0757      	lsls	r7, r2, #29
 80024d4:	0252      	lsls	r2, r2, #9
 80024d6:	4337      	orrs	r7, r6
 80024d8:	0b12      	lsrs	r2, r2, #12
 80024da:	e09b      	b.n	8002614 <__aeabi_dsub+0x254>
 80024dc:	2e00      	cmp	r6, #0
 80024de:	d000      	beq.n	80024e2 <__aeabi_dsub+0x122>
 80024e0:	e0c5      	b.n	800266e <__aeabi_dsub+0x2ae>
 80024e2:	1c6e      	adds	r6, r5, #1
 80024e4:	0576      	lsls	r6, r6, #21
 80024e6:	0d76      	lsrs	r6, r6, #21
 80024e8:	2e01      	cmp	r6, #1
 80024ea:	dc00      	bgt.n	80024ee <__aeabi_dsub+0x12e>
 80024ec:	e148      	b.n	8002780 <__aeabi_dsub+0x3c0>
 80024ee:	4667      	mov	r7, ip
 80024f0:	1a86      	subs	r6, r0, r2
 80024f2:	1bcb      	subs	r3, r1, r7
 80024f4:	42b0      	cmp	r0, r6
 80024f6:	41bf      	sbcs	r7, r7
 80024f8:	427f      	negs	r7, r7
 80024fa:	46b8      	mov	r8, r7
 80024fc:	001f      	movs	r7, r3
 80024fe:	4643      	mov	r3, r8
 8002500:	1aff      	subs	r7, r7, r3
 8002502:	003b      	movs	r3, r7
 8002504:	46b8      	mov	r8, r7
 8002506:	021b      	lsls	r3, r3, #8
 8002508:	d500      	bpl.n	800250c <__aeabi_dsub+0x14c>
 800250a:	e15f      	b.n	80027cc <__aeabi_dsub+0x40c>
 800250c:	4337      	orrs	r7, r6
 800250e:	d19a      	bne.n	8002446 <__aeabi_dsub+0x86>
 8002510:	2200      	movs	r2, #0
 8002512:	2400      	movs	r4, #0
 8002514:	2500      	movs	r5, #0
 8002516:	e079      	b.n	800260c <__aeabi_dsub+0x24c>
 8002518:	2e00      	cmp	r6, #0
 800251a:	dc00      	bgt.n	800251e <__aeabi_dsub+0x15e>
 800251c:	e0fa      	b.n	8002714 <__aeabi_dsub+0x354>
 800251e:	2f00      	cmp	r7, #0
 8002520:	d100      	bne.n	8002524 <__aeabi_dsub+0x164>
 8002522:	e08d      	b.n	8002640 <__aeabi_dsub+0x280>
 8002524:	4b78      	ldr	r3, [pc, #480]	; (8002708 <__aeabi_dsub+0x348>)
 8002526:	429d      	cmp	r5, r3
 8002528:	d067      	beq.n	80025fa <__aeabi_dsub+0x23a>
 800252a:	2380      	movs	r3, #128	; 0x80
 800252c:	4667      	mov	r7, ip
 800252e:	041b      	lsls	r3, r3, #16
 8002530:	431f      	orrs	r7, r3
 8002532:	46bc      	mov	ip, r7
 8002534:	2e38      	cmp	r6, #56	; 0x38
 8002536:	dc00      	bgt.n	800253a <__aeabi_dsub+0x17a>
 8002538:	e152      	b.n	80027e0 <__aeabi_dsub+0x420>
 800253a:	4663      	mov	r3, ip
 800253c:	4313      	orrs	r3, r2
 800253e:	1e5a      	subs	r2, r3, #1
 8002540:	4193      	sbcs	r3, r2
 8002542:	181e      	adds	r6, r3, r0
 8002544:	4286      	cmp	r6, r0
 8002546:	4180      	sbcs	r0, r0
 8002548:	4240      	negs	r0, r0
 800254a:	1809      	adds	r1, r1, r0
 800254c:	020b      	lsls	r3, r1, #8
 800254e:	d400      	bmi.n	8002552 <__aeabi_dsub+0x192>
 8002550:	e0be      	b.n	80026d0 <__aeabi_dsub+0x310>
 8002552:	4b6d      	ldr	r3, [pc, #436]	; (8002708 <__aeabi_dsub+0x348>)
 8002554:	3501      	adds	r5, #1
 8002556:	429d      	cmp	r5, r3
 8002558:	d100      	bne.n	800255c <__aeabi_dsub+0x19c>
 800255a:	e0d2      	b.n	8002702 <__aeabi_dsub+0x342>
 800255c:	4a6b      	ldr	r2, [pc, #428]	; (800270c <__aeabi_dsub+0x34c>)
 800255e:	0873      	lsrs	r3, r6, #1
 8002560:	400a      	ands	r2, r1
 8002562:	2101      	movs	r1, #1
 8002564:	400e      	ands	r6, r1
 8002566:	431e      	orrs	r6, r3
 8002568:	0851      	lsrs	r1, r2, #1
 800256a:	07d3      	lsls	r3, r2, #31
 800256c:	2207      	movs	r2, #7
 800256e:	431e      	orrs	r6, r3
 8002570:	4032      	ands	r2, r6
 8002572:	e795      	b.n	80024a0 <__aeabi_dsub+0xe0>
 8002574:	001e      	movs	r6, r3
 8002576:	4316      	orrs	r6, r2
 8002578:	d000      	beq.n	800257c <__aeabi_dsub+0x1bc>
 800257a:	e745      	b.n	8002408 <__aeabi_dsub+0x48>
 800257c:	e740      	b.n	8002400 <__aeabi_dsub+0x40>
 800257e:	4b62      	ldr	r3, [pc, #392]	; (8002708 <__aeabi_dsub+0x348>)
 8002580:	429d      	cmp	r5, r3
 8002582:	d03a      	beq.n	80025fa <__aeabi_dsub+0x23a>
 8002584:	2380      	movs	r3, #128	; 0x80
 8002586:	4667      	mov	r7, ip
 8002588:	041b      	lsls	r3, r3, #16
 800258a:	431f      	orrs	r7, r3
 800258c:	46bc      	mov	ip, r7
 800258e:	2e38      	cmp	r6, #56	; 0x38
 8002590:	dd00      	ble.n	8002594 <__aeabi_dsub+0x1d4>
 8002592:	e0eb      	b.n	800276c <__aeabi_dsub+0x3ac>
 8002594:	2e1f      	cmp	r6, #31
 8002596:	dc00      	bgt.n	800259a <__aeabi_dsub+0x1da>
 8002598:	e13a      	b.n	8002810 <__aeabi_dsub+0x450>
 800259a:	0033      	movs	r3, r6
 800259c:	4667      	mov	r7, ip
 800259e:	3b20      	subs	r3, #32
 80025a0:	40df      	lsrs	r7, r3
 80025a2:	003b      	movs	r3, r7
 80025a4:	2e20      	cmp	r6, #32
 80025a6:	d005      	beq.n	80025b4 <__aeabi_dsub+0x1f4>
 80025a8:	2740      	movs	r7, #64	; 0x40
 80025aa:	1bbf      	subs	r7, r7, r6
 80025ac:	4666      	mov	r6, ip
 80025ae:	40be      	lsls	r6, r7
 80025b0:	4332      	orrs	r2, r6
 80025b2:	4690      	mov	r8, r2
 80025b4:	4646      	mov	r6, r8
 80025b6:	1e72      	subs	r2, r6, #1
 80025b8:	4196      	sbcs	r6, r2
 80025ba:	4333      	orrs	r3, r6
 80025bc:	e0da      	b.n	8002774 <__aeabi_dsub+0x3b4>
 80025be:	2b00      	cmp	r3, #0
 80025c0:	d100      	bne.n	80025c4 <__aeabi_dsub+0x204>
 80025c2:	e214      	b.n	80029ee <__aeabi_dsub+0x62e>
 80025c4:	4663      	mov	r3, ip
 80025c6:	4313      	orrs	r3, r2
 80025c8:	d100      	bne.n	80025cc <__aeabi_dsub+0x20c>
 80025ca:	e168      	b.n	800289e <__aeabi_dsub+0x4de>
 80025cc:	2380      	movs	r3, #128	; 0x80
 80025ce:	074e      	lsls	r6, r1, #29
 80025d0:	08c0      	lsrs	r0, r0, #3
 80025d2:	08c9      	lsrs	r1, r1, #3
 80025d4:	031b      	lsls	r3, r3, #12
 80025d6:	4306      	orrs	r6, r0
 80025d8:	4219      	tst	r1, r3
 80025da:	d008      	beq.n	80025ee <__aeabi_dsub+0x22e>
 80025dc:	4660      	mov	r0, ip
 80025de:	08c0      	lsrs	r0, r0, #3
 80025e0:	4218      	tst	r0, r3
 80025e2:	d104      	bne.n	80025ee <__aeabi_dsub+0x22e>
 80025e4:	4663      	mov	r3, ip
 80025e6:	0001      	movs	r1, r0
 80025e8:	08d2      	lsrs	r2, r2, #3
 80025ea:	075e      	lsls	r6, r3, #29
 80025ec:	4316      	orrs	r6, r2
 80025ee:	00f3      	lsls	r3, r6, #3
 80025f0:	4699      	mov	r9, r3
 80025f2:	00c9      	lsls	r1, r1, #3
 80025f4:	0f72      	lsrs	r2, r6, #29
 80025f6:	4d44      	ldr	r5, [pc, #272]	; (8002708 <__aeabi_dsub+0x348>)
 80025f8:	4311      	orrs	r1, r2
 80025fa:	464b      	mov	r3, r9
 80025fc:	08de      	lsrs	r6, r3, #3
 80025fe:	4b42      	ldr	r3, [pc, #264]	; (8002708 <__aeabi_dsub+0x348>)
 8002600:	074f      	lsls	r7, r1, #29
 8002602:	4337      	orrs	r7, r6
 8002604:	08ca      	lsrs	r2, r1, #3
 8002606:	429d      	cmp	r5, r3
 8002608:	d100      	bne.n	800260c <__aeabi_dsub+0x24c>
 800260a:	e06e      	b.n	80026ea <__aeabi_dsub+0x32a>
 800260c:	0312      	lsls	r2, r2, #12
 800260e:	056d      	lsls	r5, r5, #21
 8002610:	0b12      	lsrs	r2, r2, #12
 8002612:	0d6d      	lsrs	r5, r5, #21
 8002614:	2100      	movs	r1, #0
 8002616:	0312      	lsls	r2, r2, #12
 8002618:	0b13      	lsrs	r3, r2, #12
 800261a:	0d0a      	lsrs	r2, r1, #20
 800261c:	0512      	lsls	r2, r2, #20
 800261e:	431a      	orrs	r2, r3
 8002620:	4b3b      	ldr	r3, [pc, #236]	; (8002710 <__aeabi_dsub+0x350>)
 8002622:	052d      	lsls	r5, r5, #20
 8002624:	4013      	ands	r3, r2
 8002626:	432b      	orrs	r3, r5
 8002628:	005b      	lsls	r3, r3, #1
 800262a:	07e4      	lsls	r4, r4, #31
 800262c:	085b      	lsrs	r3, r3, #1
 800262e:	4323      	orrs	r3, r4
 8002630:	0038      	movs	r0, r7
 8002632:	0019      	movs	r1, r3
 8002634:	bc3c      	pop	{r2, r3, r4, r5}
 8002636:	4690      	mov	r8, r2
 8002638:	4699      	mov	r9, r3
 800263a:	46a2      	mov	sl, r4
 800263c:	46ab      	mov	fp, r5
 800263e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002640:	4663      	mov	r3, ip
 8002642:	4313      	orrs	r3, r2
 8002644:	d011      	beq.n	800266a <__aeabi_dsub+0x2aa>
 8002646:	1e73      	subs	r3, r6, #1
 8002648:	2b00      	cmp	r3, #0
 800264a:	d000      	beq.n	800264e <__aeabi_dsub+0x28e>
 800264c:	e107      	b.n	800285e <__aeabi_dsub+0x49e>
 800264e:	1886      	adds	r6, r0, r2
 8002650:	4286      	cmp	r6, r0
 8002652:	4180      	sbcs	r0, r0
 8002654:	4461      	add	r1, ip
 8002656:	4240      	negs	r0, r0
 8002658:	1809      	adds	r1, r1, r0
 800265a:	2501      	movs	r5, #1
 800265c:	020b      	lsls	r3, r1, #8
 800265e:	d537      	bpl.n	80026d0 <__aeabi_dsub+0x310>
 8002660:	2502      	movs	r5, #2
 8002662:	e77b      	b.n	800255c <__aeabi_dsub+0x19c>
 8002664:	003e      	movs	r6, r7
 8002666:	4661      	mov	r1, ip
 8002668:	4691      	mov	r9, r2
 800266a:	0035      	movs	r5, r6
 800266c:	e7c5      	b.n	80025fa <__aeabi_dsub+0x23a>
 800266e:	465c      	mov	r4, fp
 8002670:	2d00      	cmp	r5, #0
 8002672:	d000      	beq.n	8002676 <__aeabi_dsub+0x2b6>
 8002674:	e0e1      	b.n	800283a <__aeabi_dsub+0x47a>
 8002676:	000b      	movs	r3, r1
 8002678:	4303      	orrs	r3, r0
 800267a:	d0f3      	beq.n	8002664 <__aeabi_dsub+0x2a4>
 800267c:	1c73      	adds	r3, r6, #1
 800267e:	d100      	bne.n	8002682 <__aeabi_dsub+0x2c2>
 8002680:	e1ac      	b.n	80029dc <__aeabi_dsub+0x61c>
 8002682:	4b21      	ldr	r3, [pc, #132]	; (8002708 <__aeabi_dsub+0x348>)
 8002684:	429f      	cmp	r7, r3
 8002686:	d100      	bne.n	800268a <__aeabi_dsub+0x2ca>
 8002688:	e13a      	b.n	8002900 <__aeabi_dsub+0x540>
 800268a:	43f3      	mvns	r3, r6
 800268c:	2b38      	cmp	r3, #56	; 0x38
 800268e:	dd00      	ble.n	8002692 <__aeabi_dsub+0x2d2>
 8002690:	e16f      	b.n	8002972 <__aeabi_dsub+0x5b2>
 8002692:	2b1f      	cmp	r3, #31
 8002694:	dd00      	ble.n	8002698 <__aeabi_dsub+0x2d8>
 8002696:	e18c      	b.n	80029b2 <__aeabi_dsub+0x5f2>
 8002698:	2520      	movs	r5, #32
 800269a:	000e      	movs	r6, r1
 800269c:	1aed      	subs	r5, r5, r3
 800269e:	40ae      	lsls	r6, r5
 80026a0:	46b0      	mov	r8, r6
 80026a2:	0006      	movs	r6, r0
 80026a4:	46aa      	mov	sl, r5
 80026a6:	40de      	lsrs	r6, r3
 80026a8:	4645      	mov	r5, r8
 80026aa:	4335      	orrs	r5, r6
 80026ac:	002e      	movs	r6, r5
 80026ae:	4655      	mov	r5, sl
 80026b0:	40d9      	lsrs	r1, r3
 80026b2:	40a8      	lsls	r0, r5
 80026b4:	4663      	mov	r3, ip
 80026b6:	1e45      	subs	r5, r0, #1
 80026b8:	41a8      	sbcs	r0, r5
 80026ba:	1a5b      	subs	r3, r3, r1
 80026bc:	469c      	mov	ip, r3
 80026be:	4330      	orrs	r0, r6
 80026c0:	1a16      	subs	r6, r2, r0
 80026c2:	42b2      	cmp	r2, r6
 80026c4:	4192      	sbcs	r2, r2
 80026c6:	4663      	mov	r3, ip
 80026c8:	4252      	negs	r2, r2
 80026ca:	1a99      	subs	r1, r3, r2
 80026cc:	003d      	movs	r5, r7
 80026ce:	e6b4      	b.n	800243a <__aeabi_dsub+0x7a>
 80026d0:	2207      	movs	r2, #7
 80026d2:	4032      	ands	r2, r6
 80026d4:	2a00      	cmp	r2, #0
 80026d6:	d000      	beq.n	80026da <__aeabi_dsub+0x31a>
 80026d8:	e6e4      	b.n	80024a4 <__aeabi_dsub+0xe4>
 80026da:	4b0b      	ldr	r3, [pc, #44]	; (8002708 <__aeabi_dsub+0x348>)
 80026dc:	08f6      	lsrs	r6, r6, #3
 80026de:	074f      	lsls	r7, r1, #29
 80026e0:	4337      	orrs	r7, r6
 80026e2:	08ca      	lsrs	r2, r1, #3
 80026e4:	429d      	cmp	r5, r3
 80026e6:	d000      	beq.n	80026ea <__aeabi_dsub+0x32a>
 80026e8:	e790      	b.n	800260c <__aeabi_dsub+0x24c>
 80026ea:	003b      	movs	r3, r7
 80026ec:	4313      	orrs	r3, r2
 80026ee:	d100      	bne.n	80026f2 <__aeabi_dsub+0x332>
 80026f0:	e1a6      	b.n	8002a40 <__aeabi_dsub+0x680>
 80026f2:	2380      	movs	r3, #128	; 0x80
 80026f4:	031b      	lsls	r3, r3, #12
 80026f6:	431a      	orrs	r2, r3
 80026f8:	0312      	lsls	r2, r2, #12
 80026fa:	0b12      	lsrs	r2, r2, #12
 80026fc:	4d02      	ldr	r5, [pc, #8]	; (8002708 <__aeabi_dsub+0x348>)
 80026fe:	e789      	b.n	8002614 <__aeabi_dsub+0x254>
 8002700:	0015      	movs	r5, r2
 8002702:	2200      	movs	r2, #0
 8002704:	2700      	movs	r7, #0
 8002706:	e785      	b.n	8002614 <__aeabi_dsub+0x254>
 8002708:	000007ff 	.word	0x000007ff
 800270c:	ff7fffff 	.word	0xff7fffff
 8002710:	800fffff 	.word	0x800fffff
 8002714:	2e00      	cmp	r6, #0
 8002716:	d000      	beq.n	800271a <__aeabi_dsub+0x35a>
 8002718:	e0c7      	b.n	80028aa <__aeabi_dsub+0x4ea>
 800271a:	1c6b      	adds	r3, r5, #1
 800271c:	055e      	lsls	r6, r3, #21
 800271e:	0d76      	lsrs	r6, r6, #21
 8002720:	2e01      	cmp	r6, #1
 8002722:	dc00      	bgt.n	8002726 <__aeabi_dsub+0x366>
 8002724:	e0f0      	b.n	8002908 <__aeabi_dsub+0x548>
 8002726:	4dc8      	ldr	r5, [pc, #800]	; (8002a48 <__aeabi_dsub+0x688>)
 8002728:	42ab      	cmp	r3, r5
 800272a:	d100      	bne.n	800272e <__aeabi_dsub+0x36e>
 800272c:	e0b9      	b.n	80028a2 <__aeabi_dsub+0x4e2>
 800272e:	1885      	adds	r5, r0, r2
 8002730:	000a      	movs	r2, r1
 8002732:	4285      	cmp	r5, r0
 8002734:	4189      	sbcs	r1, r1
 8002736:	4462      	add	r2, ip
 8002738:	4249      	negs	r1, r1
 800273a:	1851      	adds	r1, r2, r1
 800273c:	2207      	movs	r2, #7
 800273e:	07ce      	lsls	r6, r1, #31
 8002740:	086d      	lsrs	r5, r5, #1
 8002742:	432e      	orrs	r6, r5
 8002744:	0849      	lsrs	r1, r1, #1
 8002746:	4032      	ands	r2, r6
 8002748:	001d      	movs	r5, r3
 800274a:	e6a9      	b.n	80024a0 <__aeabi_dsub+0xe0>
 800274c:	49bf      	ldr	r1, [pc, #764]	; (8002a4c <__aeabi_dsub+0x68c>)
 800274e:	1aed      	subs	r5, r5, r3
 8002750:	4011      	ands	r1, r2
 8002752:	2207      	movs	r2, #7
 8002754:	4032      	ands	r2, r6
 8002756:	e6a3      	b.n	80024a0 <__aeabi_dsub+0xe0>
 8002758:	0032      	movs	r2, r6
 800275a:	3828      	subs	r0, #40	; 0x28
 800275c:	4082      	lsls	r2, r0
 800275e:	2600      	movs	r6, #0
 8002760:	e686      	b.n	8002470 <__aeabi_dsub+0xb0>
 8002762:	0030      	movs	r0, r6
 8002764:	f000 faf0 	bl	8002d48 <__clzsi2>
 8002768:	3020      	adds	r0, #32
 800276a:	e673      	b.n	8002454 <__aeabi_dsub+0x94>
 800276c:	4663      	mov	r3, ip
 800276e:	4313      	orrs	r3, r2
 8002770:	1e5a      	subs	r2, r3, #1
 8002772:	4193      	sbcs	r3, r2
 8002774:	1ac6      	subs	r6, r0, r3
 8002776:	42b0      	cmp	r0, r6
 8002778:	4180      	sbcs	r0, r0
 800277a:	4240      	negs	r0, r0
 800277c:	1a09      	subs	r1, r1, r0
 800277e:	e65c      	b.n	800243a <__aeabi_dsub+0x7a>
 8002780:	000e      	movs	r6, r1
 8002782:	4667      	mov	r7, ip
 8002784:	4306      	orrs	r6, r0
 8002786:	4317      	orrs	r7, r2
 8002788:	2d00      	cmp	r5, #0
 800278a:	d15e      	bne.n	800284a <__aeabi_dsub+0x48a>
 800278c:	2e00      	cmp	r6, #0
 800278e:	d000      	beq.n	8002792 <__aeabi_dsub+0x3d2>
 8002790:	e0f3      	b.n	800297a <__aeabi_dsub+0x5ba>
 8002792:	2f00      	cmp	r7, #0
 8002794:	d100      	bne.n	8002798 <__aeabi_dsub+0x3d8>
 8002796:	e11e      	b.n	80029d6 <__aeabi_dsub+0x616>
 8002798:	465c      	mov	r4, fp
 800279a:	4661      	mov	r1, ip
 800279c:	4691      	mov	r9, r2
 800279e:	e72c      	b.n	80025fa <__aeabi_dsub+0x23a>
 80027a0:	4fa9      	ldr	r7, [pc, #676]	; (8002a48 <__aeabi_dsub+0x688>)
 80027a2:	42be      	cmp	r6, r7
 80027a4:	d07b      	beq.n	800289e <__aeabi_dsub+0x4de>
 80027a6:	001e      	movs	r6, r3
 80027a8:	e6f1      	b.n	800258e <__aeabi_dsub+0x1ce>
 80027aa:	0010      	movs	r0, r2
 80027ac:	3d1f      	subs	r5, #31
 80027ae:	40e8      	lsrs	r0, r5
 80027b0:	2b20      	cmp	r3, #32
 80027b2:	d003      	beq.n	80027bc <__aeabi_dsub+0x3fc>
 80027b4:	2140      	movs	r1, #64	; 0x40
 80027b6:	1acb      	subs	r3, r1, r3
 80027b8:	409a      	lsls	r2, r3
 80027ba:	4316      	orrs	r6, r2
 80027bc:	1e73      	subs	r3, r6, #1
 80027be:	419e      	sbcs	r6, r3
 80027c0:	2207      	movs	r2, #7
 80027c2:	4306      	orrs	r6, r0
 80027c4:	4032      	ands	r2, r6
 80027c6:	2100      	movs	r1, #0
 80027c8:	2500      	movs	r5, #0
 80027ca:	e783      	b.n	80026d4 <__aeabi_dsub+0x314>
 80027cc:	1a16      	subs	r6, r2, r0
 80027ce:	4663      	mov	r3, ip
 80027d0:	42b2      	cmp	r2, r6
 80027d2:	4180      	sbcs	r0, r0
 80027d4:	1a59      	subs	r1, r3, r1
 80027d6:	4240      	negs	r0, r0
 80027d8:	1a0b      	subs	r3, r1, r0
 80027da:	4698      	mov	r8, r3
 80027dc:	465c      	mov	r4, fp
 80027de:	e632      	b.n	8002446 <__aeabi_dsub+0x86>
 80027e0:	2e1f      	cmp	r6, #31
 80027e2:	dd00      	ble.n	80027e6 <__aeabi_dsub+0x426>
 80027e4:	e0ab      	b.n	800293e <__aeabi_dsub+0x57e>
 80027e6:	2720      	movs	r7, #32
 80027e8:	1bbb      	subs	r3, r7, r6
 80027ea:	469a      	mov	sl, r3
 80027ec:	4663      	mov	r3, ip
 80027ee:	4657      	mov	r7, sl
 80027f0:	40bb      	lsls	r3, r7
 80027f2:	4699      	mov	r9, r3
 80027f4:	0013      	movs	r3, r2
 80027f6:	464f      	mov	r7, r9
 80027f8:	40f3      	lsrs	r3, r6
 80027fa:	431f      	orrs	r7, r3
 80027fc:	003b      	movs	r3, r7
 80027fe:	4657      	mov	r7, sl
 8002800:	40ba      	lsls	r2, r7
 8002802:	1e57      	subs	r7, r2, #1
 8002804:	41ba      	sbcs	r2, r7
 8002806:	4313      	orrs	r3, r2
 8002808:	4662      	mov	r2, ip
 800280a:	40f2      	lsrs	r2, r6
 800280c:	1889      	adds	r1, r1, r2
 800280e:	e698      	b.n	8002542 <__aeabi_dsub+0x182>
 8002810:	2720      	movs	r7, #32
 8002812:	1bbb      	subs	r3, r7, r6
 8002814:	469a      	mov	sl, r3
 8002816:	4663      	mov	r3, ip
 8002818:	4657      	mov	r7, sl
 800281a:	40bb      	lsls	r3, r7
 800281c:	4699      	mov	r9, r3
 800281e:	0013      	movs	r3, r2
 8002820:	464f      	mov	r7, r9
 8002822:	40f3      	lsrs	r3, r6
 8002824:	431f      	orrs	r7, r3
 8002826:	003b      	movs	r3, r7
 8002828:	4657      	mov	r7, sl
 800282a:	40ba      	lsls	r2, r7
 800282c:	1e57      	subs	r7, r2, #1
 800282e:	41ba      	sbcs	r2, r7
 8002830:	4313      	orrs	r3, r2
 8002832:	4662      	mov	r2, ip
 8002834:	40f2      	lsrs	r2, r6
 8002836:	1a89      	subs	r1, r1, r2
 8002838:	e79c      	b.n	8002774 <__aeabi_dsub+0x3b4>
 800283a:	4b83      	ldr	r3, [pc, #524]	; (8002a48 <__aeabi_dsub+0x688>)
 800283c:	429f      	cmp	r7, r3
 800283e:	d05f      	beq.n	8002900 <__aeabi_dsub+0x540>
 8002840:	2580      	movs	r5, #128	; 0x80
 8002842:	042d      	lsls	r5, r5, #16
 8002844:	4273      	negs	r3, r6
 8002846:	4329      	orrs	r1, r5
 8002848:	e720      	b.n	800268c <__aeabi_dsub+0x2cc>
 800284a:	2e00      	cmp	r6, #0
 800284c:	d10c      	bne.n	8002868 <__aeabi_dsub+0x4a8>
 800284e:	2f00      	cmp	r7, #0
 8002850:	d100      	bne.n	8002854 <__aeabi_dsub+0x494>
 8002852:	e0d0      	b.n	80029f6 <__aeabi_dsub+0x636>
 8002854:	465c      	mov	r4, fp
 8002856:	4661      	mov	r1, ip
 8002858:	4691      	mov	r9, r2
 800285a:	4d7b      	ldr	r5, [pc, #492]	; (8002a48 <__aeabi_dsub+0x688>)
 800285c:	e6cd      	b.n	80025fa <__aeabi_dsub+0x23a>
 800285e:	4f7a      	ldr	r7, [pc, #488]	; (8002a48 <__aeabi_dsub+0x688>)
 8002860:	42be      	cmp	r6, r7
 8002862:	d01c      	beq.n	800289e <__aeabi_dsub+0x4de>
 8002864:	001e      	movs	r6, r3
 8002866:	e665      	b.n	8002534 <__aeabi_dsub+0x174>
 8002868:	2f00      	cmp	r7, #0
 800286a:	d018      	beq.n	800289e <__aeabi_dsub+0x4de>
 800286c:	08c0      	lsrs	r0, r0, #3
 800286e:	074e      	lsls	r6, r1, #29
 8002870:	4306      	orrs	r6, r0
 8002872:	2080      	movs	r0, #128	; 0x80
 8002874:	08c9      	lsrs	r1, r1, #3
 8002876:	0300      	lsls	r0, r0, #12
 8002878:	4201      	tst	r1, r0
 800287a:	d008      	beq.n	800288e <__aeabi_dsub+0x4ce>
 800287c:	4663      	mov	r3, ip
 800287e:	08dc      	lsrs	r4, r3, #3
 8002880:	4204      	tst	r4, r0
 8002882:	d104      	bne.n	800288e <__aeabi_dsub+0x4ce>
 8002884:	0021      	movs	r1, r4
 8002886:	46da      	mov	sl, fp
 8002888:	08d2      	lsrs	r2, r2, #3
 800288a:	075e      	lsls	r6, r3, #29
 800288c:	4316      	orrs	r6, r2
 800288e:	00f3      	lsls	r3, r6, #3
 8002890:	4699      	mov	r9, r3
 8002892:	2401      	movs	r4, #1
 8002894:	4653      	mov	r3, sl
 8002896:	00c9      	lsls	r1, r1, #3
 8002898:	0f72      	lsrs	r2, r6, #29
 800289a:	4311      	orrs	r1, r2
 800289c:	401c      	ands	r4, r3
 800289e:	4d6a      	ldr	r5, [pc, #424]	; (8002a48 <__aeabi_dsub+0x688>)
 80028a0:	e6ab      	b.n	80025fa <__aeabi_dsub+0x23a>
 80028a2:	001d      	movs	r5, r3
 80028a4:	2200      	movs	r2, #0
 80028a6:	2700      	movs	r7, #0
 80028a8:	e6b4      	b.n	8002614 <__aeabi_dsub+0x254>
 80028aa:	2d00      	cmp	r5, #0
 80028ac:	d159      	bne.n	8002962 <__aeabi_dsub+0x5a2>
 80028ae:	000b      	movs	r3, r1
 80028b0:	4303      	orrs	r3, r0
 80028b2:	d100      	bne.n	80028b6 <__aeabi_dsub+0x4f6>
 80028b4:	e6d6      	b.n	8002664 <__aeabi_dsub+0x2a4>
 80028b6:	1c73      	adds	r3, r6, #1
 80028b8:	d100      	bne.n	80028bc <__aeabi_dsub+0x4fc>
 80028ba:	e0b2      	b.n	8002a22 <__aeabi_dsub+0x662>
 80028bc:	4b62      	ldr	r3, [pc, #392]	; (8002a48 <__aeabi_dsub+0x688>)
 80028be:	429f      	cmp	r7, r3
 80028c0:	d01e      	beq.n	8002900 <__aeabi_dsub+0x540>
 80028c2:	43f3      	mvns	r3, r6
 80028c4:	2b38      	cmp	r3, #56	; 0x38
 80028c6:	dc6f      	bgt.n	80029a8 <__aeabi_dsub+0x5e8>
 80028c8:	2b1f      	cmp	r3, #31
 80028ca:	dd00      	ble.n	80028ce <__aeabi_dsub+0x50e>
 80028cc:	e097      	b.n	80029fe <__aeabi_dsub+0x63e>
 80028ce:	2520      	movs	r5, #32
 80028d0:	000e      	movs	r6, r1
 80028d2:	1aed      	subs	r5, r5, r3
 80028d4:	40ae      	lsls	r6, r5
 80028d6:	46b0      	mov	r8, r6
 80028d8:	0006      	movs	r6, r0
 80028da:	46aa      	mov	sl, r5
 80028dc:	40de      	lsrs	r6, r3
 80028de:	4645      	mov	r5, r8
 80028e0:	4335      	orrs	r5, r6
 80028e2:	002e      	movs	r6, r5
 80028e4:	4655      	mov	r5, sl
 80028e6:	40a8      	lsls	r0, r5
 80028e8:	40d9      	lsrs	r1, r3
 80028ea:	1e45      	subs	r5, r0, #1
 80028ec:	41a8      	sbcs	r0, r5
 80028ee:	448c      	add	ip, r1
 80028f0:	4306      	orrs	r6, r0
 80028f2:	18b6      	adds	r6, r6, r2
 80028f4:	4296      	cmp	r6, r2
 80028f6:	4192      	sbcs	r2, r2
 80028f8:	4251      	negs	r1, r2
 80028fa:	4461      	add	r1, ip
 80028fc:	003d      	movs	r5, r7
 80028fe:	e625      	b.n	800254c <__aeabi_dsub+0x18c>
 8002900:	003d      	movs	r5, r7
 8002902:	4661      	mov	r1, ip
 8002904:	4691      	mov	r9, r2
 8002906:	e678      	b.n	80025fa <__aeabi_dsub+0x23a>
 8002908:	000b      	movs	r3, r1
 800290a:	4303      	orrs	r3, r0
 800290c:	2d00      	cmp	r5, #0
 800290e:	d000      	beq.n	8002912 <__aeabi_dsub+0x552>
 8002910:	e655      	b.n	80025be <__aeabi_dsub+0x1fe>
 8002912:	2b00      	cmp	r3, #0
 8002914:	d0f5      	beq.n	8002902 <__aeabi_dsub+0x542>
 8002916:	4663      	mov	r3, ip
 8002918:	4313      	orrs	r3, r2
 800291a:	d100      	bne.n	800291e <__aeabi_dsub+0x55e>
 800291c:	e66d      	b.n	80025fa <__aeabi_dsub+0x23a>
 800291e:	1886      	adds	r6, r0, r2
 8002920:	4286      	cmp	r6, r0
 8002922:	4180      	sbcs	r0, r0
 8002924:	4461      	add	r1, ip
 8002926:	4240      	negs	r0, r0
 8002928:	1809      	adds	r1, r1, r0
 800292a:	2200      	movs	r2, #0
 800292c:	020b      	lsls	r3, r1, #8
 800292e:	d400      	bmi.n	8002932 <__aeabi_dsub+0x572>
 8002930:	e6d0      	b.n	80026d4 <__aeabi_dsub+0x314>
 8002932:	4b46      	ldr	r3, [pc, #280]	; (8002a4c <__aeabi_dsub+0x68c>)
 8002934:	3501      	adds	r5, #1
 8002936:	4019      	ands	r1, r3
 8002938:	e5b2      	b.n	80024a0 <__aeabi_dsub+0xe0>
 800293a:	46b1      	mov	r9, r6
 800293c:	e65d      	b.n	80025fa <__aeabi_dsub+0x23a>
 800293e:	0033      	movs	r3, r6
 8002940:	4667      	mov	r7, ip
 8002942:	3b20      	subs	r3, #32
 8002944:	40df      	lsrs	r7, r3
 8002946:	003b      	movs	r3, r7
 8002948:	2e20      	cmp	r6, #32
 800294a:	d005      	beq.n	8002958 <__aeabi_dsub+0x598>
 800294c:	2740      	movs	r7, #64	; 0x40
 800294e:	1bbf      	subs	r7, r7, r6
 8002950:	4666      	mov	r6, ip
 8002952:	40be      	lsls	r6, r7
 8002954:	4332      	orrs	r2, r6
 8002956:	4690      	mov	r8, r2
 8002958:	4646      	mov	r6, r8
 800295a:	1e72      	subs	r2, r6, #1
 800295c:	4196      	sbcs	r6, r2
 800295e:	4333      	orrs	r3, r6
 8002960:	e5ef      	b.n	8002542 <__aeabi_dsub+0x182>
 8002962:	4b39      	ldr	r3, [pc, #228]	; (8002a48 <__aeabi_dsub+0x688>)
 8002964:	429f      	cmp	r7, r3
 8002966:	d0cb      	beq.n	8002900 <__aeabi_dsub+0x540>
 8002968:	2580      	movs	r5, #128	; 0x80
 800296a:	042d      	lsls	r5, r5, #16
 800296c:	4273      	negs	r3, r6
 800296e:	4329      	orrs	r1, r5
 8002970:	e7a8      	b.n	80028c4 <__aeabi_dsub+0x504>
 8002972:	4308      	orrs	r0, r1
 8002974:	1e41      	subs	r1, r0, #1
 8002976:	4188      	sbcs	r0, r1
 8002978:	e6a2      	b.n	80026c0 <__aeabi_dsub+0x300>
 800297a:	2f00      	cmp	r7, #0
 800297c:	d100      	bne.n	8002980 <__aeabi_dsub+0x5c0>
 800297e:	e63c      	b.n	80025fa <__aeabi_dsub+0x23a>
 8002980:	4663      	mov	r3, ip
 8002982:	1a86      	subs	r6, r0, r2
 8002984:	1acf      	subs	r7, r1, r3
 8002986:	42b0      	cmp	r0, r6
 8002988:	419b      	sbcs	r3, r3
 800298a:	425b      	negs	r3, r3
 800298c:	1afb      	subs	r3, r7, r3
 800298e:	4698      	mov	r8, r3
 8002990:	021b      	lsls	r3, r3, #8
 8002992:	d54e      	bpl.n	8002a32 <__aeabi_dsub+0x672>
 8002994:	1a16      	subs	r6, r2, r0
 8002996:	4663      	mov	r3, ip
 8002998:	42b2      	cmp	r2, r6
 800299a:	4192      	sbcs	r2, r2
 800299c:	1a59      	subs	r1, r3, r1
 800299e:	4252      	negs	r2, r2
 80029a0:	1a89      	subs	r1, r1, r2
 80029a2:	465c      	mov	r4, fp
 80029a4:	2200      	movs	r2, #0
 80029a6:	e57b      	b.n	80024a0 <__aeabi_dsub+0xe0>
 80029a8:	4301      	orrs	r1, r0
 80029aa:	000e      	movs	r6, r1
 80029ac:	1e71      	subs	r1, r6, #1
 80029ae:	418e      	sbcs	r6, r1
 80029b0:	e79f      	b.n	80028f2 <__aeabi_dsub+0x532>
 80029b2:	001d      	movs	r5, r3
 80029b4:	000e      	movs	r6, r1
 80029b6:	3d20      	subs	r5, #32
 80029b8:	40ee      	lsrs	r6, r5
 80029ba:	46b0      	mov	r8, r6
 80029bc:	2b20      	cmp	r3, #32
 80029be:	d004      	beq.n	80029ca <__aeabi_dsub+0x60a>
 80029c0:	2540      	movs	r5, #64	; 0x40
 80029c2:	1aeb      	subs	r3, r5, r3
 80029c4:	4099      	lsls	r1, r3
 80029c6:	4308      	orrs	r0, r1
 80029c8:	4681      	mov	r9, r0
 80029ca:	4648      	mov	r0, r9
 80029cc:	4643      	mov	r3, r8
 80029ce:	1e41      	subs	r1, r0, #1
 80029d0:	4188      	sbcs	r0, r1
 80029d2:	4318      	orrs	r0, r3
 80029d4:	e674      	b.n	80026c0 <__aeabi_dsub+0x300>
 80029d6:	2200      	movs	r2, #0
 80029d8:	2400      	movs	r4, #0
 80029da:	e617      	b.n	800260c <__aeabi_dsub+0x24c>
 80029dc:	1a16      	subs	r6, r2, r0
 80029de:	4663      	mov	r3, ip
 80029e0:	42b2      	cmp	r2, r6
 80029e2:	4192      	sbcs	r2, r2
 80029e4:	1a59      	subs	r1, r3, r1
 80029e6:	4252      	negs	r2, r2
 80029e8:	1a89      	subs	r1, r1, r2
 80029ea:	003d      	movs	r5, r7
 80029ec:	e525      	b.n	800243a <__aeabi_dsub+0x7a>
 80029ee:	4661      	mov	r1, ip
 80029f0:	4691      	mov	r9, r2
 80029f2:	4d15      	ldr	r5, [pc, #84]	; (8002a48 <__aeabi_dsub+0x688>)
 80029f4:	e601      	b.n	80025fa <__aeabi_dsub+0x23a>
 80029f6:	2280      	movs	r2, #128	; 0x80
 80029f8:	2400      	movs	r4, #0
 80029fa:	0312      	lsls	r2, r2, #12
 80029fc:	e679      	b.n	80026f2 <__aeabi_dsub+0x332>
 80029fe:	001d      	movs	r5, r3
 8002a00:	000e      	movs	r6, r1
 8002a02:	3d20      	subs	r5, #32
 8002a04:	40ee      	lsrs	r6, r5
 8002a06:	46b0      	mov	r8, r6
 8002a08:	2b20      	cmp	r3, #32
 8002a0a:	d004      	beq.n	8002a16 <__aeabi_dsub+0x656>
 8002a0c:	2540      	movs	r5, #64	; 0x40
 8002a0e:	1aeb      	subs	r3, r5, r3
 8002a10:	4099      	lsls	r1, r3
 8002a12:	4308      	orrs	r0, r1
 8002a14:	4681      	mov	r9, r0
 8002a16:	464e      	mov	r6, r9
 8002a18:	4643      	mov	r3, r8
 8002a1a:	1e71      	subs	r1, r6, #1
 8002a1c:	418e      	sbcs	r6, r1
 8002a1e:	431e      	orrs	r6, r3
 8002a20:	e767      	b.n	80028f2 <__aeabi_dsub+0x532>
 8002a22:	1886      	adds	r6, r0, r2
 8002a24:	4296      	cmp	r6, r2
 8002a26:	419b      	sbcs	r3, r3
 8002a28:	4461      	add	r1, ip
 8002a2a:	425b      	negs	r3, r3
 8002a2c:	18c9      	adds	r1, r1, r3
 8002a2e:	003d      	movs	r5, r7
 8002a30:	e58c      	b.n	800254c <__aeabi_dsub+0x18c>
 8002a32:	4647      	mov	r7, r8
 8002a34:	4337      	orrs	r7, r6
 8002a36:	d0ce      	beq.n	80029d6 <__aeabi_dsub+0x616>
 8002a38:	2207      	movs	r2, #7
 8002a3a:	4641      	mov	r1, r8
 8002a3c:	4032      	ands	r2, r6
 8002a3e:	e649      	b.n	80026d4 <__aeabi_dsub+0x314>
 8002a40:	2700      	movs	r7, #0
 8002a42:	003a      	movs	r2, r7
 8002a44:	e5e6      	b.n	8002614 <__aeabi_dsub+0x254>
 8002a46:	46c0      	nop			; (mov r8, r8)
 8002a48:	000007ff 	.word	0x000007ff
 8002a4c:	ff7fffff 	.word	0xff7fffff

08002a50 <__aeabi_dcmpun>:
 8002a50:	b570      	push	{r4, r5, r6, lr}
 8002a52:	4e0c      	ldr	r6, [pc, #48]	; (8002a84 <__aeabi_dcmpun+0x34>)
 8002a54:	030d      	lsls	r5, r1, #12
 8002a56:	031c      	lsls	r4, r3, #12
 8002a58:	0049      	lsls	r1, r1, #1
 8002a5a:	005b      	lsls	r3, r3, #1
 8002a5c:	0b2d      	lsrs	r5, r5, #12
 8002a5e:	0d49      	lsrs	r1, r1, #21
 8002a60:	0b24      	lsrs	r4, r4, #12
 8002a62:	0d5b      	lsrs	r3, r3, #21
 8002a64:	42b1      	cmp	r1, r6
 8002a66:	d008      	beq.n	8002a7a <__aeabi_dcmpun+0x2a>
 8002a68:	4906      	ldr	r1, [pc, #24]	; (8002a84 <__aeabi_dcmpun+0x34>)
 8002a6a:	2000      	movs	r0, #0
 8002a6c:	428b      	cmp	r3, r1
 8002a6e:	d103      	bne.n	8002a78 <__aeabi_dcmpun+0x28>
 8002a70:	4314      	orrs	r4, r2
 8002a72:	0020      	movs	r0, r4
 8002a74:	1e44      	subs	r4, r0, #1
 8002a76:	41a0      	sbcs	r0, r4
 8002a78:	bd70      	pop	{r4, r5, r6, pc}
 8002a7a:	4305      	orrs	r5, r0
 8002a7c:	2001      	movs	r0, #1
 8002a7e:	2d00      	cmp	r5, #0
 8002a80:	d1fa      	bne.n	8002a78 <__aeabi_dcmpun+0x28>
 8002a82:	e7f1      	b.n	8002a68 <__aeabi_dcmpun+0x18>
 8002a84:	000007ff 	.word	0x000007ff

08002a88 <__aeabi_d2iz>:
 8002a88:	b530      	push	{r4, r5, lr}
 8002a8a:	4d14      	ldr	r5, [pc, #80]	; (8002adc <__aeabi_d2iz+0x54>)
 8002a8c:	030a      	lsls	r2, r1, #12
 8002a8e:	004b      	lsls	r3, r1, #1
 8002a90:	0b12      	lsrs	r2, r2, #12
 8002a92:	0d5b      	lsrs	r3, r3, #21
 8002a94:	0fc9      	lsrs	r1, r1, #31
 8002a96:	2400      	movs	r4, #0
 8002a98:	42ab      	cmp	r3, r5
 8002a9a:	dd11      	ble.n	8002ac0 <__aeabi_d2iz+0x38>
 8002a9c:	4c10      	ldr	r4, [pc, #64]	; (8002ae0 <__aeabi_d2iz+0x58>)
 8002a9e:	42a3      	cmp	r3, r4
 8002aa0:	dc10      	bgt.n	8002ac4 <__aeabi_d2iz+0x3c>
 8002aa2:	2480      	movs	r4, #128	; 0x80
 8002aa4:	0364      	lsls	r4, r4, #13
 8002aa6:	4322      	orrs	r2, r4
 8002aa8:	4c0e      	ldr	r4, [pc, #56]	; (8002ae4 <__aeabi_d2iz+0x5c>)
 8002aaa:	1ae4      	subs	r4, r4, r3
 8002aac:	2c1f      	cmp	r4, #31
 8002aae:	dd0c      	ble.n	8002aca <__aeabi_d2iz+0x42>
 8002ab0:	480d      	ldr	r0, [pc, #52]	; (8002ae8 <__aeabi_d2iz+0x60>)
 8002ab2:	1ac3      	subs	r3, r0, r3
 8002ab4:	40da      	lsrs	r2, r3
 8002ab6:	0013      	movs	r3, r2
 8002ab8:	425c      	negs	r4, r3
 8002aba:	2900      	cmp	r1, #0
 8002abc:	d100      	bne.n	8002ac0 <__aeabi_d2iz+0x38>
 8002abe:	001c      	movs	r4, r3
 8002ac0:	0020      	movs	r0, r4
 8002ac2:	bd30      	pop	{r4, r5, pc}
 8002ac4:	4b09      	ldr	r3, [pc, #36]	; (8002aec <__aeabi_d2iz+0x64>)
 8002ac6:	18cc      	adds	r4, r1, r3
 8002ac8:	e7fa      	b.n	8002ac0 <__aeabi_d2iz+0x38>
 8002aca:	4d09      	ldr	r5, [pc, #36]	; (8002af0 <__aeabi_d2iz+0x68>)
 8002acc:	40e0      	lsrs	r0, r4
 8002ace:	46ac      	mov	ip, r5
 8002ad0:	4463      	add	r3, ip
 8002ad2:	409a      	lsls	r2, r3
 8002ad4:	0013      	movs	r3, r2
 8002ad6:	4303      	orrs	r3, r0
 8002ad8:	e7ee      	b.n	8002ab8 <__aeabi_d2iz+0x30>
 8002ada:	46c0      	nop			; (mov r8, r8)
 8002adc:	000003fe 	.word	0x000003fe
 8002ae0:	0000041d 	.word	0x0000041d
 8002ae4:	00000433 	.word	0x00000433
 8002ae8:	00000413 	.word	0x00000413
 8002aec:	7fffffff 	.word	0x7fffffff
 8002af0:	fffffbed 	.word	0xfffffbed

08002af4 <__aeabi_i2d>:
 8002af4:	b570      	push	{r4, r5, r6, lr}
 8002af6:	2800      	cmp	r0, #0
 8002af8:	d02d      	beq.n	8002b56 <__aeabi_i2d+0x62>
 8002afa:	17c3      	asrs	r3, r0, #31
 8002afc:	18c5      	adds	r5, r0, r3
 8002afe:	405d      	eors	r5, r3
 8002b00:	0fc4      	lsrs	r4, r0, #31
 8002b02:	0028      	movs	r0, r5
 8002b04:	f000 f920 	bl	8002d48 <__clzsi2>
 8002b08:	4b15      	ldr	r3, [pc, #84]	; (8002b60 <__aeabi_i2d+0x6c>)
 8002b0a:	1a1b      	subs	r3, r3, r0
 8002b0c:	055b      	lsls	r3, r3, #21
 8002b0e:	0d5b      	lsrs	r3, r3, #21
 8002b10:	280a      	cmp	r0, #10
 8002b12:	dd15      	ble.n	8002b40 <__aeabi_i2d+0x4c>
 8002b14:	380b      	subs	r0, #11
 8002b16:	4085      	lsls	r5, r0
 8002b18:	2200      	movs	r2, #0
 8002b1a:	032d      	lsls	r5, r5, #12
 8002b1c:	0b2d      	lsrs	r5, r5, #12
 8002b1e:	2100      	movs	r1, #0
 8002b20:	0010      	movs	r0, r2
 8002b22:	032d      	lsls	r5, r5, #12
 8002b24:	0d0a      	lsrs	r2, r1, #20
 8002b26:	0b2d      	lsrs	r5, r5, #12
 8002b28:	0512      	lsls	r2, r2, #20
 8002b2a:	432a      	orrs	r2, r5
 8002b2c:	4d0d      	ldr	r5, [pc, #52]	; (8002b64 <__aeabi_i2d+0x70>)
 8002b2e:	051b      	lsls	r3, r3, #20
 8002b30:	402a      	ands	r2, r5
 8002b32:	4313      	orrs	r3, r2
 8002b34:	005b      	lsls	r3, r3, #1
 8002b36:	07e4      	lsls	r4, r4, #31
 8002b38:	085b      	lsrs	r3, r3, #1
 8002b3a:	4323      	orrs	r3, r4
 8002b3c:	0019      	movs	r1, r3
 8002b3e:	bd70      	pop	{r4, r5, r6, pc}
 8002b40:	0002      	movs	r2, r0
 8002b42:	0029      	movs	r1, r5
 8002b44:	3215      	adds	r2, #21
 8002b46:	4091      	lsls	r1, r2
 8002b48:	000a      	movs	r2, r1
 8002b4a:	210b      	movs	r1, #11
 8002b4c:	1a08      	subs	r0, r1, r0
 8002b4e:	40c5      	lsrs	r5, r0
 8002b50:	032d      	lsls	r5, r5, #12
 8002b52:	0b2d      	lsrs	r5, r5, #12
 8002b54:	e7e3      	b.n	8002b1e <__aeabi_i2d+0x2a>
 8002b56:	2400      	movs	r4, #0
 8002b58:	2300      	movs	r3, #0
 8002b5a:	2500      	movs	r5, #0
 8002b5c:	2200      	movs	r2, #0
 8002b5e:	e7de      	b.n	8002b1e <__aeabi_i2d+0x2a>
 8002b60:	0000041e 	.word	0x0000041e
 8002b64:	800fffff 	.word	0x800fffff

08002b68 <__aeabi_ui2d>:
 8002b68:	b510      	push	{r4, lr}
 8002b6a:	1e04      	subs	r4, r0, #0
 8002b6c:	d025      	beq.n	8002bba <__aeabi_ui2d+0x52>
 8002b6e:	f000 f8eb 	bl	8002d48 <__clzsi2>
 8002b72:	4b14      	ldr	r3, [pc, #80]	; (8002bc4 <__aeabi_ui2d+0x5c>)
 8002b74:	1a1b      	subs	r3, r3, r0
 8002b76:	055b      	lsls	r3, r3, #21
 8002b78:	0d5b      	lsrs	r3, r3, #21
 8002b7a:	280a      	cmp	r0, #10
 8002b7c:	dd12      	ble.n	8002ba4 <__aeabi_ui2d+0x3c>
 8002b7e:	380b      	subs	r0, #11
 8002b80:	4084      	lsls	r4, r0
 8002b82:	2200      	movs	r2, #0
 8002b84:	0324      	lsls	r4, r4, #12
 8002b86:	0b24      	lsrs	r4, r4, #12
 8002b88:	2100      	movs	r1, #0
 8002b8a:	0010      	movs	r0, r2
 8002b8c:	0324      	lsls	r4, r4, #12
 8002b8e:	0d0a      	lsrs	r2, r1, #20
 8002b90:	0b24      	lsrs	r4, r4, #12
 8002b92:	0512      	lsls	r2, r2, #20
 8002b94:	4322      	orrs	r2, r4
 8002b96:	4c0c      	ldr	r4, [pc, #48]	; (8002bc8 <__aeabi_ui2d+0x60>)
 8002b98:	051b      	lsls	r3, r3, #20
 8002b9a:	4022      	ands	r2, r4
 8002b9c:	4313      	orrs	r3, r2
 8002b9e:	005b      	lsls	r3, r3, #1
 8002ba0:	0859      	lsrs	r1, r3, #1
 8002ba2:	bd10      	pop	{r4, pc}
 8002ba4:	0002      	movs	r2, r0
 8002ba6:	0021      	movs	r1, r4
 8002ba8:	3215      	adds	r2, #21
 8002baa:	4091      	lsls	r1, r2
 8002bac:	000a      	movs	r2, r1
 8002bae:	210b      	movs	r1, #11
 8002bb0:	1a08      	subs	r0, r1, r0
 8002bb2:	40c4      	lsrs	r4, r0
 8002bb4:	0324      	lsls	r4, r4, #12
 8002bb6:	0b24      	lsrs	r4, r4, #12
 8002bb8:	e7e6      	b.n	8002b88 <__aeabi_ui2d+0x20>
 8002bba:	2300      	movs	r3, #0
 8002bbc:	2400      	movs	r4, #0
 8002bbe:	2200      	movs	r2, #0
 8002bc0:	e7e2      	b.n	8002b88 <__aeabi_ui2d+0x20>
 8002bc2:	46c0      	nop			; (mov r8, r8)
 8002bc4:	0000041e 	.word	0x0000041e
 8002bc8:	800fffff 	.word	0x800fffff

08002bcc <__aeabi_d2f>:
 8002bcc:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002bce:	004c      	lsls	r4, r1, #1
 8002bd0:	0d64      	lsrs	r4, r4, #21
 8002bd2:	030b      	lsls	r3, r1, #12
 8002bd4:	1c62      	adds	r2, r4, #1
 8002bd6:	0a5b      	lsrs	r3, r3, #9
 8002bd8:	0f46      	lsrs	r6, r0, #29
 8002bda:	0552      	lsls	r2, r2, #21
 8002bdc:	0fc9      	lsrs	r1, r1, #31
 8002bde:	431e      	orrs	r6, r3
 8002be0:	00c5      	lsls	r5, r0, #3
 8002be2:	0d52      	lsrs	r2, r2, #21
 8002be4:	2a01      	cmp	r2, #1
 8002be6:	dd29      	ble.n	8002c3c <__aeabi_d2f+0x70>
 8002be8:	4b37      	ldr	r3, [pc, #220]	; (8002cc8 <__aeabi_d2f+0xfc>)
 8002bea:	18e7      	adds	r7, r4, r3
 8002bec:	2ffe      	cmp	r7, #254	; 0xfe
 8002bee:	dc1c      	bgt.n	8002c2a <__aeabi_d2f+0x5e>
 8002bf0:	2f00      	cmp	r7, #0
 8002bf2:	dd3b      	ble.n	8002c6c <__aeabi_d2f+0xa0>
 8002bf4:	0180      	lsls	r0, r0, #6
 8002bf6:	1e43      	subs	r3, r0, #1
 8002bf8:	4198      	sbcs	r0, r3
 8002bfa:	2207      	movs	r2, #7
 8002bfc:	00f3      	lsls	r3, r6, #3
 8002bfe:	0f6d      	lsrs	r5, r5, #29
 8002c00:	4303      	orrs	r3, r0
 8002c02:	432b      	orrs	r3, r5
 8002c04:	401a      	ands	r2, r3
 8002c06:	2a00      	cmp	r2, #0
 8002c08:	d004      	beq.n	8002c14 <__aeabi_d2f+0x48>
 8002c0a:	220f      	movs	r2, #15
 8002c0c:	401a      	ands	r2, r3
 8002c0e:	2a04      	cmp	r2, #4
 8002c10:	d000      	beq.n	8002c14 <__aeabi_d2f+0x48>
 8002c12:	3304      	adds	r3, #4
 8002c14:	2280      	movs	r2, #128	; 0x80
 8002c16:	04d2      	lsls	r2, r2, #19
 8002c18:	401a      	ands	r2, r3
 8002c1a:	d024      	beq.n	8002c66 <__aeabi_d2f+0x9a>
 8002c1c:	3701      	adds	r7, #1
 8002c1e:	b2fa      	uxtb	r2, r7
 8002c20:	2fff      	cmp	r7, #255	; 0xff
 8002c22:	d002      	beq.n	8002c2a <__aeabi_d2f+0x5e>
 8002c24:	019b      	lsls	r3, r3, #6
 8002c26:	0a58      	lsrs	r0, r3, #9
 8002c28:	e001      	b.n	8002c2e <__aeabi_d2f+0x62>
 8002c2a:	22ff      	movs	r2, #255	; 0xff
 8002c2c:	2000      	movs	r0, #0
 8002c2e:	0240      	lsls	r0, r0, #9
 8002c30:	05d2      	lsls	r2, r2, #23
 8002c32:	0a40      	lsrs	r0, r0, #9
 8002c34:	07c9      	lsls	r1, r1, #31
 8002c36:	4310      	orrs	r0, r2
 8002c38:	4308      	orrs	r0, r1
 8002c3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002c3c:	4335      	orrs	r5, r6
 8002c3e:	2c00      	cmp	r4, #0
 8002c40:	d104      	bne.n	8002c4c <__aeabi_d2f+0x80>
 8002c42:	2d00      	cmp	r5, #0
 8002c44:	d10a      	bne.n	8002c5c <__aeabi_d2f+0x90>
 8002c46:	2200      	movs	r2, #0
 8002c48:	2000      	movs	r0, #0
 8002c4a:	e7f0      	b.n	8002c2e <__aeabi_d2f+0x62>
 8002c4c:	2d00      	cmp	r5, #0
 8002c4e:	d0ec      	beq.n	8002c2a <__aeabi_d2f+0x5e>
 8002c50:	2080      	movs	r0, #128	; 0x80
 8002c52:	03c0      	lsls	r0, r0, #15
 8002c54:	4330      	orrs	r0, r6
 8002c56:	22ff      	movs	r2, #255	; 0xff
 8002c58:	e7e9      	b.n	8002c2e <__aeabi_d2f+0x62>
 8002c5a:	2400      	movs	r4, #0
 8002c5c:	2300      	movs	r3, #0
 8002c5e:	025b      	lsls	r3, r3, #9
 8002c60:	0a58      	lsrs	r0, r3, #9
 8002c62:	b2e2      	uxtb	r2, r4
 8002c64:	e7e3      	b.n	8002c2e <__aeabi_d2f+0x62>
 8002c66:	08db      	lsrs	r3, r3, #3
 8002c68:	003c      	movs	r4, r7
 8002c6a:	e7f8      	b.n	8002c5e <__aeabi_d2f+0x92>
 8002c6c:	003b      	movs	r3, r7
 8002c6e:	3317      	adds	r3, #23
 8002c70:	dbf3      	blt.n	8002c5a <__aeabi_d2f+0x8e>
 8002c72:	2380      	movs	r3, #128	; 0x80
 8002c74:	041b      	lsls	r3, r3, #16
 8002c76:	4333      	orrs	r3, r6
 8002c78:	261e      	movs	r6, #30
 8002c7a:	1bf6      	subs	r6, r6, r7
 8002c7c:	2e1f      	cmp	r6, #31
 8002c7e:	dd14      	ble.n	8002caa <__aeabi_d2f+0xde>
 8002c80:	2202      	movs	r2, #2
 8002c82:	4252      	negs	r2, r2
 8002c84:	1bd7      	subs	r7, r2, r7
 8002c86:	001a      	movs	r2, r3
 8002c88:	40fa      	lsrs	r2, r7
 8002c8a:	0017      	movs	r7, r2
 8002c8c:	2e20      	cmp	r6, #32
 8002c8e:	d004      	beq.n	8002c9a <__aeabi_d2f+0xce>
 8002c90:	4a0e      	ldr	r2, [pc, #56]	; (8002ccc <__aeabi_d2f+0x100>)
 8002c92:	4694      	mov	ip, r2
 8002c94:	4464      	add	r4, ip
 8002c96:	40a3      	lsls	r3, r4
 8002c98:	431d      	orrs	r5, r3
 8002c9a:	002b      	movs	r3, r5
 8002c9c:	1e5d      	subs	r5, r3, #1
 8002c9e:	41ab      	sbcs	r3, r5
 8002ca0:	2207      	movs	r2, #7
 8002ca2:	433b      	orrs	r3, r7
 8002ca4:	401a      	ands	r2, r3
 8002ca6:	2700      	movs	r7, #0
 8002ca8:	e7ad      	b.n	8002c06 <__aeabi_d2f+0x3a>
 8002caa:	4a09      	ldr	r2, [pc, #36]	; (8002cd0 <__aeabi_d2f+0x104>)
 8002cac:	0028      	movs	r0, r5
 8002cae:	18a2      	adds	r2, r4, r2
 8002cb0:	4095      	lsls	r5, r2
 8002cb2:	4093      	lsls	r3, r2
 8002cb4:	1e6c      	subs	r4, r5, #1
 8002cb6:	41a5      	sbcs	r5, r4
 8002cb8:	40f0      	lsrs	r0, r6
 8002cba:	2207      	movs	r2, #7
 8002cbc:	432b      	orrs	r3, r5
 8002cbe:	4303      	orrs	r3, r0
 8002cc0:	401a      	ands	r2, r3
 8002cc2:	2700      	movs	r7, #0
 8002cc4:	e79f      	b.n	8002c06 <__aeabi_d2f+0x3a>
 8002cc6:	46c0      	nop			; (mov r8, r8)
 8002cc8:	fffffc80 	.word	0xfffffc80
 8002ccc:	fffffca2 	.word	0xfffffca2
 8002cd0:	fffffc82 	.word	0xfffffc82

08002cd4 <__aeabi_cfrcmple>:
 8002cd4:	4684      	mov	ip, r0
 8002cd6:	1c08      	adds	r0, r1, #0
 8002cd8:	4661      	mov	r1, ip
 8002cda:	e7ff      	b.n	8002cdc <__aeabi_cfcmpeq>

08002cdc <__aeabi_cfcmpeq>:
 8002cdc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8002cde:	f000 f8d3 	bl	8002e88 <__lesf2>
 8002ce2:	2800      	cmp	r0, #0
 8002ce4:	d401      	bmi.n	8002cea <__aeabi_cfcmpeq+0xe>
 8002ce6:	2100      	movs	r1, #0
 8002ce8:	42c8      	cmn	r0, r1
 8002cea:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

08002cec <__aeabi_fcmpeq>:
 8002cec:	b510      	push	{r4, lr}
 8002cee:	f000 f855 	bl	8002d9c <__eqsf2>
 8002cf2:	4240      	negs	r0, r0
 8002cf4:	3001      	adds	r0, #1
 8002cf6:	bd10      	pop	{r4, pc}

08002cf8 <__aeabi_fcmplt>:
 8002cf8:	b510      	push	{r4, lr}
 8002cfa:	f000 f8c5 	bl	8002e88 <__lesf2>
 8002cfe:	2800      	cmp	r0, #0
 8002d00:	db01      	blt.n	8002d06 <__aeabi_fcmplt+0xe>
 8002d02:	2000      	movs	r0, #0
 8002d04:	bd10      	pop	{r4, pc}
 8002d06:	2001      	movs	r0, #1
 8002d08:	bd10      	pop	{r4, pc}
 8002d0a:	46c0      	nop			; (mov r8, r8)

08002d0c <__aeabi_fcmple>:
 8002d0c:	b510      	push	{r4, lr}
 8002d0e:	f000 f8bb 	bl	8002e88 <__lesf2>
 8002d12:	2800      	cmp	r0, #0
 8002d14:	dd01      	ble.n	8002d1a <__aeabi_fcmple+0xe>
 8002d16:	2000      	movs	r0, #0
 8002d18:	bd10      	pop	{r4, pc}
 8002d1a:	2001      	movs	r0, #1
 8002d1c:	bd10      	pop	{r4, pc}
 8002d1e:	46c0      	nop			; (mov r8, r8)

08002d20 <__aeabi_fcmpgt>:
 8002d20:	b510      	push	{r4, lr}
 8002d22:	f000 f863 	bl	8002dec <__gesf2>
 8002d26:	2800      	cmp	r0, #0
 8002d28:	dc01      	bgt.n	8002d2e <__aeabi_fcmpgt+0xe>
 8002d2a:	2000      	movs	r0, #0
 8002d2c:	bd10      	pop	{r4, pc}
 8002d2e:	2001      	movs	r0, #1
 8002d30:	bd10      	pop	{r4, pc}
 8002d32:	46c0      	nop			; (mov r8, r8)

08002d34 <__aeabi_fcmpge>:
 8002d34:	b510      	push	{r4, lr}
 8002d36:	f000 f859 	bl	8002dec <__gesf2>
 8002d3a:	2800      	cmp	r0, #0
 8002d3c:	da01      	bge.n	8002d42 <__aeabi_fcmpge+0xe>
 8002d3e:	2000      	movs	r0, #0
 8002d40:	bd10      	pop	{r4, pc}
 8002d42:	2001      	movs	r0, #1
 8002d44:	bd10      	pop	{r4, pc}
 8002d46:	46c0      	nop			; (mov r8, r8)

08002d48 <__clzsi2>:
 8002d48:	211c      	movs	r1, #28
 8002d4a:	2301      	movs	r3, #1
 8002d4c:	041b      	lsls	r3, r3, #16
 8002d4e:	4298      	cmp	r0, r3
 8002d50:	d301      	bcc.n	8002d56 <__clzsi2+0xe>
 8002d52:	0c00      	lsrs	r0, r0, #16
 8002d54:	3910      	subs	r1, #16
 8002d56:	0a1b      	lsrs	r3, r3, #8
 8002d58:	4298      	cmp	r0, r3
 8002d5a:	d301      	bcc.n	8002d60 <__clzsi2+0x18>
 8002d5c:	0a00      	lsrs	r0, r0, #8
 8002d5e:	3908      	subs	r1, #8
 8002d60:	091b      	lsrs	r3, r3, #4
 8002d62:	4298      	cmp	r0, r3
 8002d64:	d301      	bcc.n	8002d6a <__clzsi2+0x22>
 8002d66:	0900      	lsrs	r0, r0, #4
 8002d68:	3904      	subs	r1, #4
 8002d6a:	a202      	add	r2, pc, #8	; (adr r2, 8002d74 <__clzsi2+0x2c>)
 8002d6c:	5c10      	ldrb	r0, [r2, r0]
 8002d6e:	1840      	adds	r0, r0, r1
 8002d70:	4770      	bx	lr
 8002d72:	46c0      	nop			; (mov r8, r8)
 8002d74:	02020304 	.word	0x02020304
 8002d78:	01010101 	.word	0x01010101
	...

08002d84 <__clzdi2>:
 8002d84:	b510      	push	{r4, lr}
 8002d86:	2900      	cmp	r1, #0
 8002d88:	d103      	bne.n	8002d92 <__clzdi2+0xe>
 8002d8a:	f7ff ffdd 	bl	8002d48 <__clzsi2>
 8002d8e:	3020      	adds	r0, #32
 8002d90:	e002      	b.n	8002d98 <__clzdi2+0x14>
 8002d92:	1c08      	adds	r0, r1, #0
 8002d94:	f7ff ffd8 	bl	8002d48 <__clzsi2>
 8002d98:	bd10      	pop	{r4, pc}
 8002d9a:	46c0      	nop			; (mov r8, r8)

08002d9c <__eqsf2>:
 8002d9c:	b570      	push	{r4, r5, r6, lr}
 8002d9e:	0042      	lsls	r2, r0, #1
 8002da0:	024e      	lsls	r6, r1, #9
 8002da2:	004c      	lsls	r4, r1, #1
 8002da4:	0245      	lsls	r5, r0, #9
 8002da6:	0a6d      	lsrs	r5, r5, #9
 8002da8:	0e12      	lsrs	r2, r2, #24
 8002daa:	0fc3      	lsrs	r3, r0, #31
 8002dac:	0a76      	lsrs	r6, r6, #9
 8002dae:	0e24      	lsrs	r4, r4, #24
 8002db0:	0fc9      	lsrs	r1, r1, #31
 8002db2:	2aff      	cmp	r2, #255	; 0xff
 8002db4:	d00f      	beq.n	8002dd6 <__eqsf2+0x3a>
 8002db6:	2cff      	cmp	r4, #255	; 0xff
 8002db8:	d011      	beq.n	8002dde <__eqsf2+0x42>
 8002dba:	2001      	movs	r0, #1
 8002dbc:	42a2      	cmp	r2, r4
 8002dbe:	d000      	beq.n	8002dc2 <__eqsf2+0x26>
 8002dc0:	bd70      	pop	{r4, r5, r6, pc}
 8002dc2:	42b5      	cmp	r5, r6
 8002dc4:	d1fc      	bne.n	8002dc0 <__eqsf2+0x24>
 8002dc6:	428b      	cmp	r3, r1
 8002dc8:	d00d      	beq.n	8002de6 <__eqsf2+0x4a>
 8002dca:	2a00      	cmp	r2, #0
 8002dcc:	d1f8      	bne.n	8002dc0 <__eqsf2+0x24>
 8002dce:	0028      	movs	r0, r5
 8002dd0:	1e45      	subs	r5, r0, #1
 8002dd2:	41a8      	sbcs	r0, r5
 8002dd4:	e7f4      	b.n	8002dc0 <__eqsf2+0x24>
 8002dd6:	2001      	movs	r0, #1
 8002dd8:	2d00      	cmp	r5, #0
 8002dda:	d1f1      	bne.n	8002dc0 <__eqsf2+0x24>
 8002ddc:	e7eb      	b.n	8002db6 <__eqsf2+0x1a>
 8002dde:	2001      	movs	r0, #1
 8002de0:	2e00      	cmp	r6, #0
 8002de2:	d1ed      	bne.n	8002dc0 <__eqsf2+0x24>
 8002de4:	e7e9      	b.n	8002dba <__eqsf2+0x1e>
 8002de6:	2000      	movs	r0, #0
 8002de8:	e7ea      	b.n	8002dc0 <__eqsf2+0x24>
 8002dea:	46c0      	nop			; (mov r8, r8)

08002dec <__gesf2>:
 8002dec:	b570      	push	{r4, r5, r6, lr}
 8002dee:	004a      	lsls	r2, r1, #1
 8002df0:	024e      	lsls	r6, r1, #9
 8002df2:	0245      	lsls	r5, r0, #9
 8002df4:	0044      	lsls	r4, r0, #1
 8002df6:	0a6d      	lsrs	r5, r5, #9
 8002df8:	0e24      	lsrs	r4, r4, #24
 8002dfa:	0fc3      	lsrs	r3, r0, #31
 8002dfc:	0a76      	lsrs	r6, r6, #9
 8002dfe:	0e12      	lsrs	r2, r2, #24
 8002e00:	0fc9      	lsrs	r1, r1, #31
 8002e02:	2cff      	cmp	r4, #255	; 0xff
 8002e04:	d015      	beq.n	8002e32 <__gesf2+0x46>
 8002e06:	2aff      	cmp	r2, #255	; 0xff
 8002e08:	d00e      	beq.n	8002e28 <__gesf2+0x3c>
 8002e0a:	2c00      	cmp	r4, #0
 8002e0c:	d115      	bne.n	8002e3a <__gesf2+0x4e>
 8002e0e:	2a00      	cmp	r2, #0
 8002e10:	d101      	bne.n	8002e16 <__gesf2+0x2a>
 8002e12:	2e00      	cmp	r6, #0
 8002e14:	d01c      	beq.n	8002e50 <__gesf2+0x64>
 8002e16:	2d00      	cmp	r5, #0
 8002e18:	d014      	beq.n	8002e44 <__gesf2+0x58>
 8002e1a:	428b      	cmp	r3, r1
 8002e1c:	d027      	beq.n	8002e6e <__gesf2+0x82>
 8002e1e:	2002      	movs	r0, #2
 8002e20:	3b01      	subs	r3, #1
 8002e22:	4018      	ands	r0, r3
 8002e24:	3801      	subs	r0, #1
 8002e26:	bd70      	pop	{r4, r5, r6, pc}
 8002e28:	2e00      	cmp	r6, #0
 8002e2a:	d0ee      	beq.n	8002e0a <__gesf2+0x1e>
 8002e2c:	2002      	movs	r0, #2
 8002e2e:	4240      	negs	r0, r0
 8002e30:	e7f9      	b.n	8002e26 <__gesf2+0x3a>
 8002e32:	2d00      	cmp	r5, #0
 8002e34:	d1fa      	bne.n	8002e2c <__gesf2+0x40>
 8002e36:	2aff      	cmp	r2, #255	; 0xff
 8002e38:	d00e      	beq.n	8002e58 <__gesf2+0x6c>
 8002e3a:	2a00      	cmp	r2, #0
 8002e3c:	d10e      	bne.n	8002e5c <__gesf2+0x70>
 8002e3e:	2e00      	cmp	r6, #0
 8002e40:	d0ed      	beq.n	8002e1e <__gesf2+0x32>
 8002e42:	e00b      	b.n	8002e5c <__gesf2+0x70>
 8002e44:	2301      	movs	r3, #1
 8002e46:	3901      	subs	r1, #1
 8002e48:	4399      	bics	r1, r3
 8002e4a:	0008      	movs	r0, r1
 8002e4c:	3001      	adds	r0, #1
 8002e4e:	e7ea      	b.n	8002e26 <__gesf2+0x3a>
 8002e50:	2000      	movs	r0, #0
 8002e52:	2d00      	cmp	r5, #0
 8002e54:	d0e7      	beq.n	8002e26 <__gesf2+0x3a>
 8002e56:	e7e2      	b.n	8002e1e <__gesf2+0x32>
 8002e58:	2e00      	cmp	r6, #0
 8002e5a:	d1e7      	bne.n	8002e2c <__gesf2+0x40>
 8002e5c:	428b      	cmp	r3, r1
 8002e5e:	d1de      	bne.n	8002e1e <__gesf2+0x32>
 8002e60:	4294      	cmp	r4, r2
 8002e62:	dd05      	ble.n	8002e70 <__gesf2+0x84>
 8002e64:	2102      	movs	r1, #2
 8002e66:	1e58      	subs	r0, r3, #1
 8002e68:	4008      	ands	r0, r1
 8002e6a:	3801      	subs	r0, #1
 8002e6c:	e7db      	b.n	8002e26 <__gesf2+0x3a>
 8002e6e:	2400      	movs	r4, #0
 8002e70:	42a2      	cmp	r2, r4
 8002e72:	dc04      	bgt.n	8002e7e <__gesf2+0x92>
 8002e74:	42b5      	cmp	r5, r6
 8002e76:	d8d2      	bhi.n	8002e1e <__gesf2+0x32>
 8002e78:	2000      	movs	r0, #0
 8002e7a:	42b5      	cmp	r5, r6
 8002e7c:	d2d3      	bcs.n	8002e26 <__gesf2+0x3a>
 8002e7e:	1e58      	subs	r0, r3, #1
 8002e80:	2301      	movs	r3, #1
 8002e82:	4398      	bics	r0, r3
 8002e84:	3001      	adds	r0, #1
 8002e86:	e7ce      	b.n	8002e26 <__gesf2+0x3a>

08002e88 <__lesf2>:
 8002e88:	b530      	push	{r4, r5, lr}
 8002e8a:	0042      	lsls	r2, r0, #1
 8002e8c:	0244      	lsls	r4, r0, #9
 8002e8e:	024d      	lsls	r5, r1, #9
 8002e90:	0fc3      	lsrs	r3, r0, #31
 8002e92:	0048      	lsls	r0, r1, #1
 8002e94:	0a64      	lsrs	r4, r4, #9
 8002e96:	0e12      	lsrs	r2, r2, #24
 8002e98:	0a6d      	lsrs	r5, r5, #9
 8002e9a:	0e00      	lsrs	r0, r0, #24
 8002e9c:	0fc9      	lsrs	r1, r1, #31
 8002e9e:	2aff      	cmp	r2, #255	; 0xff
 8002ea0:	d012      	beq.n	8002ec8 <__lesf2+0x40>
 8002ea2:	28ff      	cmp	r0, #255	; 0xff
 8002ea4:	d00c      	beq.n	8002ec0 <__lesf2+0x38>
 8002ea6:	2a00      	cmp	r2, #0
 8002ea8:	d112      	bne.n	8002ed0 <__lesf2+0x48>
 8002eaa:	2800      	cmp	r0, #0
 8002eac:	d119      	bne.n	8002ee2 <__lesf2+0x5a>
 8002eae:	2d00      	cmp	r5, #0
 8002eb0:	d117      	bne.n	8002ee2 <__lesf2+0x5a>
 8002eb2:	2c00      	cmp	r4, #0
 8002eb4:	d02b      	beq.n	8002f0e <__lesf2+0x86>
 8002eb6:	2002      	movs	r0, #2
 8002eb8:	3b01      	subs	r3, #1
 8002eba:	4018      	ands	r0, r3
 8002ebc:	3801      	subs	r0, #1
 8002ebe:	e026      	b.n	8002f0e <__lesf2+0x86>
 8002ec0:	2d00      	cmp	r5, #0
 8002ec2:	d0f0      	beq.n	8002ea6 <__lesf2+0x1e>
 8002ec4:	2002      	movs	r0, #2
 8002ec6:	e022      	b.n	8002f0e <__lesf2+0x86>
 8002ec8:	2c00      	cmp	r4, #0
 8002eca:	d1fb      	bne.n	8002ec4 <__lesf2+0x3c>
 8002ecc:	28ff      	cmp	r0, #255	; 0xff
 8002ece:	d01f      	beq.n	8002f10 <__lesf2+0x88>
 8002ed0:	2800      	cmp	r0, #0
 8002ed2:	d11f      	bne.n	8002f14 <__lesf2+0x8c>
 8002ed4:	2d00      	cmp	r5, #0
 8002ed6:	d11d      	bne.n	8002f14 <__lesf2+0x8c>
 8002ed8:	2002      	movs	r0, #2
 8002eda:	3b01      	subs	r3, #1
 8002edc:	4018      	ands	r0, r3
 8002ede:	3801      	subs	r0, #1
 8002ee0:	e015      	b.n	8002f0e <__lesf2+0x86>
 8002ee2:	2c00      	cmp	r4, #0
 8002ee4:	d00e      	beq.n	8002f04 <__lesf2+0x7c>
 8002ee6:	428b      	cmp	r3, r1
 8002ee8:	d1e5      	bne.n	8002eb6 <__lesf2+0x2e>
 8002eea:	2200      	movs	r2, #0
 8002eec:	4290      	cmp	r0, r2
 8002eee:	dc04      	bgt.n	8002efa <__lesf2+0x72>
 8002ef0:	42ac      	cmp	r4, r5
 8002ef2:	d8e0      	bhi.n	8002eb6 <__lesf2+0x2e>
 8002ef4:	2000      	movs	r0, #0
 8002ef6:	42ac      	cmp	r4, r5
 8002ef8:	d209      	bcs.n	8002f0e <__lesf2+0x86>
 8002efa:	1e58      	subs	r0, r3, #1
 8002efc:	2301      	movs	r3, #1
 8002efe:	4398      	bics	r0, r3
 8002f00:	3001      	adds	r0, #1
 8002f02:	e004      	b.n	8002f0e <__lesf2+0x86>
 8002f04:	2301      	movs	r3, #1
 8002f06:	3901      	subs	r1, #1
 8002f08:	4399      	bics	r1, r3
 8002f0a:	0008      	movs	r0, r1
 8002f0c:	3001      	adds	r0, #1
 8002f0e:	bd30      	pop	{r4, r5, pc}
 8002f10:	2d00      	cmp	r5, #0
 8002f12:	d1d7      	bne.n	8002ec4 <__lesf2+0x3c>
 8002f14:	428b      	cmp	r3, r1
 8002f16:	d1ce      	bne.n	8002eb6 <__lesf2+0x2e>
 8002f18:	4282      	cmp	r2, r0
 8002f1a:	dde7      	ble.n	8002eec <__lesf2+0x64>
 8002f1c:	2102      	movs	r1, #2
 8002f1e:	1e58      	subs	r0, r3, #1
 8002f20:	4008      	ands	r0, r1
 8002f22:	3801      	subs	r0, #1
 8002f24:	e7f3      	b.n	8002f0e <__lesf2+0x86>
 8002f26:	46c0      	nop			; (mov r8, r8)

08002f28 <BloqueCaptura>:
						pstfuerza: Apuntador a la estructura de datos de Fuerza
Salidas:          		N/A
Descripción:  		    Ejecuta el proceso principal del bloque Captura
****************************************************************************************/
void BloqueCaptura(stCaptura *pstcaptura, stComCEIT *pstcomceit, stMotor *pstmotor, stDistancia *pstdistancia)
{
 8002f28:	b5b0      	push	{r4, r5, r7, lr}
 8002f2a:	b086      	sub	sp, #24
 8002f2c:	af00      	add	r7, sp, #0
 8002f2e:	60f8      	str	r0, [r7, #12]
 8002f30:	60b9      	str	r1, [r7, #8]
 8002f32:	607a      	str	r2, [r7, #4]
 8002f34:	603b      	str	r3, [r7, #0]
	int i,j;
	
	//Máquina de Estados del bloque
	switch(pstcaptura->CAP_State)
 8002f36:	68fb      	ldr	r3, [r7, #12]
 8002f38:	781b      	ldrb	r3, [r3, #0]
 8002f3a:	2b04      	cmp	r3, #4
 8002f3c:	d900      	bls.n	8002f40 <BloqueCaptura+0x18>
 8002f3e:	e1db      	b.n	80032f8 <BloqueCaptura+0x3d0>
 8002f40:	009a      	lsls	r2, r3, #2
 8002f42:	4bd8      	ldr	r3, [pc, #864]	; (80032a4 <BloqueCaptura+0x37c>)
 8002f44:	18d3      	adds	r3, r2, r3
 8002f46:	681b      	ldr	r3, [r3, #0]
 8002f48:	469f      	mov	pc, r3
  {
		case CAP_ESPERAR:  
			//Actualizar estado actual			
			if(pstcomceit->enviarDatos == false || pstcomceit->envioOK == false)
 8002f4a:	68bb      	ldr	r3, [r7, #8]
 8002f4c:	785b      	ldrb	r3, [r3, #1]
 8002f4e:	2201      	movs	r2, #1
 8002f50:	4053      	eors	r3, r2
 8002f52:	b2db      	uxtb	r3, r3
 8002f54:	2b00      	cmp	r3, #0
 8002f56:	d106      	bne.n	8002f66 <BloqueCaptura+0x3e>
 8002f58:	68bb      	ldr	r3, [r7, #8]
 8002f5a:	78db      	ldrb	r3, [r3, #3]
 8002f5c:	2201      	movs	r2, #1
 8002f5e:	4053      	eors	r3, r2
 8002f60:	b2db      	uxtb	r3, r3
 8002f62:	2b00      	cmp	r3, #0
 8002f64:	d003      	beq.n	8002f6e <BloqueCaptura+0x46>
			{
				pstcaptura->CAP_State = CAP_ESPERAR;
 8002f66:	68fb      	ldr	r3, [r7, #12]
 8002f68:	2200      	movs	r2, #0
 8002f6a:	701a      	strb	r2, [r3, #0]
			{
				pstcomceit->datosListos = false;
				pstcomceit->envioOK = false;
				pstcaptura->CAP_State = CAP_CONFIGURAR;
			}
    break;
 8002f6c:	e1c1      	b.n	80032f2 <BloqueCaptura+0x3ca>
			else if(pstcomceit->Rx_Buffer[CMD] == GET_DATA)
 8002f6e:	68bb      	ldr	r3, [r7, #8]
 8002f70:	2274      	movs	r2, #116	; 0x74
 8002f72:	5c9b      	ldrb	r3, [r3, r2]
 8002f74:	2b60      	cmp	r3, #96	; 0x60
 8002f76:	d10f      	bne.n	8002f98 <BloqueCaptura+0x70>
				pstcomceit->datosListos = false;
 8002f78:	68bb      	ldr	r3, [r7, #8]
 8002f7a:	2200      	movs	r2, #0
 8002f7c:	709a      	strb	r2, [r3, #2]
				pstmotor->posMotor = 0;
 8002f7e:	687b      	ldr	r3, [r7, #4]
 8002f80:	2200      	movs	r2, #0
 8002f82:	721a      	strb	r2, [r3, #8]
				pstmotor->bandMotor = true;
 8002f84:	687b      	ldr	r3, [r7, #4]
 8002f86:	2201      	movs	r2, #1
 8002f88:	701a      	strb	r2, [r3, #0]
				pstcomceit->envioOK = false;
 8002f8a:	68bb      	ldr	r3, [r7, #8]
 8002f8c:	2200      	movs	r2, #0
 8002f8e:	70da      	strb	r2, [r3, #3]
				pstcaptura->CAP_State = CAP_MOVER_MOTOR;
 8002f90:	68fb      	ldr	r3, [r7, #12]
 8002f92:	2201      	movs	r2, #1
 8002f94:	701a      	strb	r2, [r3, #0]
    break;
 8002f96:	e1ac      	b.n	80032f2 <BloqueCaptura+0x3ca>
			else if(pstcomceit->Rx_Buffer[CMD] == CONFIG)
 8002f98:	68bb      	ldr	r3, [r7, #8]
 8002f9a:	2274      	movs	r2, #116	; 0x74
 8002f9c:	5c9b      	ldrb	r3, [r3, r2]
 8002f9e:	2b61      	cmp	r3, #97	; 0x61
 8002fa0:	d000      	beq.n	8002fa4 <BloqueCaptura+0x7c>
 8002fa2:	e1a6      	b.n	80032f2 <BloqueCaptura+0x3ca>
				pstcomceit->datosListos = false;
 8002fa4:	68bb      	ldr	r3, [r7, #8]
 8002fa6:	2200      	movs	r2, #0
 8002fa8:	709a      	strb	r2, [r3, #2]
				pstcomceit->envioOK = false;
 8002faa:	68bb      	ldr	r3, [r7, #8]
 8002fac:	2200      	movs	r2, #0
 8002fae:	70da      	strb	r2, [r3, #3]
				pstcaptura->CAP_State = CAP_CONFIGURAR;
 8002fb0:	68fb      	ldr	r3, [r7, #12]
 8002fb2:	2203      	movs	r2, #3
 8002fb4:	701a      	strb	r2, [r3, #0]
    break;
 8002fb6:	e19c      	b.n	80032f2 <BloqueCaptura+0x3ca>
    
		case CAP_MOVER_MOTOR:
			
			//Actualizar estado actual
			if(pstmotor->bandMotor == 0)
 8002fb8:	687b      	ldr	r3, [r7, #4]
 8002fba:	781b      	ldrb	r3, [r3, #0]
 8002fbc:	2201      	movs	r2, #1
 8002fbe:	4053      	eors	r3, r2
 8002fc0:	b2db      	uxtb	r3, r3
 8002fc2:	2b00      	cmp	r3, #0
 8002fc4:	d006      	beq.n	8002fd4 <BloqueCaptura+0xac>
			{
				pstdistancia->bandDistancia = true;
 8002fc6:	683b      	ldr	r3, [r7, #0]
 8002fc8:	2201      	movs	r2, #1
 8002fca:	701a      	strb	r2, [r3, #0]
				pstcaptura->CAP_State = CAP_LEER_DISTANCIA;
 8002fcc:	68fb      	ldr	r3, [r7, #12]
 8002fce:	2202      	movs	r2, #2
 8002fd0:	701a      	strb	r2, [r3, #0]
			}
			else
			{
				pstcaptura->CAP_State = CAP_MOVER_MOTOR;
			}
    break;
 8002fd2:	e191      	b.n	80032f8 <BloqueCaptura+0x3d0>
				pstcaptura->CAP_State = CAP_MOVER_MOTOR;
 8002fd4:	68fb      	ldr	r3, [r7, #12]
 8002fd6:	2201      	movs	r2, #1
 8002fd8:	701a      	strb	r2, [r3, #0]
    break;
 8002fda:	e18d      	b.n	80032f8 <BloqueCaptura+0x3d0>
    
		case CAP_LEER_DISTANCIA:  
			
			//Actualizar estado actual
			if(pstdistancia->bandDistancia == true)
 8002fdc:	683b      	ldr	r3, [r7, #0]
 8002fde:	781b      	ldrb	r3, [r3, #0]
 8002fe0:	2b00      	cmp	r3, #0
 8002fe2:	d003      	beq.n	8002fec <BloqueCaptura+0xc4>
			{
				pstcaptura->CAP_State = CAP_LEER_DISTANCIA;
 8002fe4:	68fb      	ldr	r3, [r7, #12]
 8002fe6:	2202      	movs	r2, #2
 8002fe8:	701a      	strb	r2, [r3, #0]
					pstdistancia->posSensor[i] = 0;
				}
				pstmotor->bandMotor = true;
				pstcaptura->CAP_State = CAP_ARMAR_TRAMA;
			}
    break;  
 8002fea:	e184      	b.n	80032f6 <BloqueCaptura+0x3ce>
			else if(pstmotor->posMotor < pstmotor->MaxPosMotor)
 8002fec:	687b      	ldr	r3, [r7, #4]
 8002fee:	7a1b      	ldrb	r3, [r3, #8]
 8002ff0:	b25b      	sxtb	r3, r3
 8002ff2:	0019      	movs	r1, r3
 8002ff4:	687b      	ldr	r3, [r7, #4]
 8002ff6:	4aac      	ldr	r2, [pc, #688]	; (80032a8 <BloqueCaptura+0x380>)
 8002ff8:	5c9b      	ldrb	r3, [r3, r2]
 8002ffa:	4299      	cmp	r1, r3
 8002ffc:	db00      	blt.n	8003000 <BloqueCaptura+0xd8>
 8002ffe:	e087      	b.n	8003110 <BloqueCaptura+0x1e8>
				pstcaptura->filaActual = pstdistancia->posSensor[pstdistancia->contParrilla];
 8003000:	683b      	ldr	r3, [r7, #0]
 8003002:	2266      	movs	r2, #102	; 0x66
 8003004:	5c9b      	ldrb	r3, [r3, r2]
 8003006:	0019      	movs	r1, r3
 8003008:	683a      	ldr	r2, [r7, #0]
 800300a:	23cf      	movs	r3, #207	; 0xcf
 800300c:	005b      	lsls	r3, r3, #1
 800300e:	1852      	adds	r2, r2, r1
 8003010:	18d3      	adds	r3, r2, r3
 8003012:	781a      	ldrb	r2, [r3, #0]
 8003014:	68fb      	ldr	r3, [r7, #12]
 8003016:	705a      	strb	r2, [r3, #1]
				if(pstdistancia->senStatus[pstdistancia->contParrilla][pstcaptura->filaActual] == 0){
 8003018:	683b      	ldr	r3, [r7, #0]
 800301a:	2266      	movs	r2, #102	; 0x66
 800301c:	5c9b      	ldrb	r3, [r3, r2]
 800301e:	0019      	movs	r1, r3
 8003020:	68fb      	ldr	r3, [r7, #12]
 8003022:	785b      	ldrb	r3, [r3, #1]
 8003024:	0018      	movs	r0, r3
 8003026:	683a      	ldr	r2, [r7, #0]
 8003028:	000b      	movs	r3, r1
 800302a:	009b      	lsls	r3, r3, #2
 800302c:	185b      	adds	r3, r3, r1
 800302e:	005b      	lsls	r3, r3, #1
 8003030:	18d3      	adds	r3, r2, r3
 8003032:	181b      	adds	r3, r3, r0
 8003034:	3301      	adds	r3, #1
 8003036:	781b      	ldrb	r3, [r3, #0]
 8003038:	2b00      	cmp	r3, #0
 800303a:	d12c      	bne.n	8003096 <BloqueCaptura+0x16e>
					pstcaptura->cantidades[pstdistancia->contParrilla][pstcaptura->filaActual] = ConvertirDistancia(pstcaptura, pstdistancia);
 800303c:	683b      	ldr	r3, [r7, #0]
 800303e:	2266      	movs	r2, #102	; 0x66
 8003040:	5c9b      	ldrb	r3, [r3, r2]
 8003042:	001c      	movs	r4, r3
 8003044:	68fb      	ldr	r3, [r7, #12]
 8003046:	785b      	ldrb	r3, [r3, #1]
 8003048:	001d      	movs	r5, r3
 800304a:	683a      	ldr	r2, [r7, #0]
 800304c:	68fb      	ldr	r3, [r7, #12]
 800304e:	0011      	movs	r1, r2
 8003050:	0018      	movs	r0, r3
 8003052:	f000 fb61 	bl	8003718 <ConvertirDistancia>
 8003056:	0003      	movs	r3, r0
 8003058:	0018      	movs	r0, r3
 800305a:	68fa      	ldr	r2, [r7, #12]
 800305c:	21cb      	movs	r1, #203	; 0xcb
 800305e:	0023      	movs	r3, r4
 8003060:	009b      	lsls	r3, r3, #2
 8003062:	191b      	adds	r3, r3, r4
 8003064:	005b      	lsls	r3, r3, #1
 8003066:	18d3      	adds	r3, r2, r3
 8003068:	195b      	adds	r3, r3, r5
 800306a:	185b      	adds	r3, r3, r1
 800306c:	1c02      	adds	r2, r0, #0
 800306e:	701a      	strb	r2, [r3, #0]
					pstdistancia->posSensor[pstdistancia->contParrilla]++;
 8003070:	683b      	ldr	r3, [r7, #0]
 8003072:	2266      	movs	r2, #102	; 0x66
 8003074:	5c9b      	ldrb	r3, [r3, r2]
 8003076:	6839      	ldr	r1, [r7, #0]
 8003078:	22cf      	movs	r2, #207	; 0xcf
 800307a:	0052      	lsls	r2, r2, #1
 800307c:	18c9      	adds	r1, r1, r3
 800307e:	188a      	adds	r2, r1, r2
 8003080:	7812      	ldrb	r2, [r2, #0]
 8003082:	3201      	adds	r2, #1
 8003084:	b2d0      	uxtb	r0, r2
 8003086:	6839      	ldr	r1, [r7, #0]
 8003088:	22cf      	movs	r2, #207	; 0xcf
 800308a:	0052      	lsls	r2, r2, #1
 800308c:	18cb      	adds	r3, r1, r3
 800308e:	189b      	adds	r3, r3, r2
 8003090:	1c02      	adds	r2, r0, #0
 8003092:	701a      	strb	r2, [r3, #0]
 8003094:	e035      	b.n	8003102 <BloqueCaptura+0x1da>
					pstcaptura->cantidades[pstdistancia->contParrilla][pstcaptura->filaActual] = 250+pstdistancia->senStatus[pstdistancia->contParrilla][pstcaptura->filaActual];
 8003096:	683b      	ldr	r3, [r7, #0]
 8003098:	2266      	movs	r2, #102	; 0x66
 800309a:	5c9b      	ldrb	r3, [r3, r2]
 800309c:	0019      	movs	r1, r3
 800309e:	68fb      	ldr	r3, [r7, #12]
 80030a0:	785b      	ldrb	r3, [r3, #1]
 80030a2:	0018      	movs	r0, r3
 80030a4:	683a      	ldr	r2, [r7, #0]
 80030a6:	000b      	movs	r3, r1
 80030a8:	009b      	lsls	r3, r3, #2
 80030aa:	185b      	adds	r3, r3, r1
 80030ac:	005b      	lsls	r3, r3, #1
 80030ae:	18d3      	adds	r3, r2, r3
 80030b0:	181b      	adds	r3, r3, r0
 80030b2:	3301      	adds	r3, #1
 80030b4:	781b      	ldrb	r3, [r3, #0]
 80030b6:	683a      	ldr	r2, [r7, #0]
 80030b8:	2166      	movs	r1, #102	; 0x66
 80030ba:	5c52      	ldrb	r2, [r2, r1]
 80030bc:	0010      	movs	r0, r2
 80030be:	68fa      	ldr	r2, [r7, #12]
 80030c0:	7852      	ldrb	r2, [r2, #1]
 80030c2:	0015      	movs	r5, r2
 80030c4:	3b06      	subs	r3, #6
 80030c6:	b2dc      	uxtb	r4, r3
 80030c8:	68fa      	ldr	r2, [r7, #12]
 80030ca:	21cb      	movs	r1, #203	; 0xcb
 80030cc:	0003      	movs	r3, r0
 80030ce:	009b      	lsls	r3, r3, #2
 80030d0:	181b      	adds	r3, r3, r0
 80030d2:	005b      	lsls	r3, r3, #1
 80030d4:	18d3      	adds	r3, r2, r3
 80030d6:	195b      	adds	r3, r3, r5
 80030d8:	185b      	adds	r3, r3, r1
 80030da:	1c22      	adds	r2, r4, #0
 80030dc:	701a      	strb	r2, [r3, #0]
					pstdistancia->posSensor[pstdistancia->contParrilla]++;
 80030de:	683b      	ldr	r3, [r7, #0]
 80030e0:	2266      	movs	r2, #102	; 0x66
 80030e2:	5c9b      	ldrb	r3, [r3, r2]
 80030e4:	6839      	ldr	r1, [r7, #0]
 80030e6:	22cf      	movs	r2, #207	; 0xcf
 80030e8:	0052      	lsls	r2, r2, #1
 80030ea:	18c9      	adds	r1, r1, r3
 80030ec:	188a      	adds	r2, r1, r2
 80030ee:	7812      	ldrb	r2, [r2, #0]
 80030f0:	3201      	adds	r2, #1
 80030f2:	b2d0      	uxtb	r0, r2
 80030f4:	6839      	ldr	r1, [r7, #0]
 80030f6:	22cf      	movs	r2, #207	; 0xcf
 80030f8:	0052      	lsls	r2, r2, #1
 80030fa:	18cb      	adds	r3, r1, r3
 80030fc:	189b      	adds	r3, r3, r2
 80030fe:	1c02      	adds	r2, r0, #0
 8003100:	701a      	strb	r2, [r3, #0]
				pstmotor->bandMotor = true;
 8003102:	687b      	ldr	r3, [r7, #4]
 8003104:	2201      	movs	r2, #1
 8003106:	701a      	strb	r2, [r3, #0]
				pstcaptura->CAP_State = CAP_MOVER_MOTOR;
 8003108:	68fb      	ldr	r3, [r7, #12]
 800310a:	2201      	movs	r2, #1
 800310c:	701a      	strb	r2, [r3, #0]
    break;  
 800310e:	e0f2      	b.n	80032f6 <BloqueCaptura+0x3ce>
			else if(pstmotor->posMotor >= pstmotor->MaxPosMotor)
 8003110:	687b      	ldr	r3, [r7, #4]
 8003112:	7a1b      	ldrb	r3, [r3, #8]
 8003114:	b25b      	sxtb	r3, r3
 8003116:	0019      	movs	r1, r3
 8003118:	687b      	ldr	r3, [r7, #4]
 800311a:	4a63      	ldr	r2, [pc, #396]	; (80032a8 <BloqueCaptura+0x380>)
 800311c:	5c9b      	ldrb	r3, [r3, r2]
 800311e:	4299      	cmp	r1, r3
 8003120:	da00      	bge.n	8003124 <BloqueCaptura+0x1fc>
 8003122:	e0e8      	b.n	80032f6 <BloqueCaptura+0x3ce>
				pstcaptura->filaActual = pstdistancia->posSensor[pstdistancia->contParrilla];
 8003124:	683b      	ldr	r3, [r7, #0]
 8003126:	2266      	movs	r2, #102	; 0x66
 8003128:	5c9b      	ldrb	r3, [r3, r2]
 800312a:	0019      	movs	r1, r3
 800312c:	683a      	ldr	r2, [r7, #0]
 800312e:	23cf      	movs	r3, #207	; 0xcf
 8003130:	005b      	lsls	r3, r3, #1
 8003132:	1852      	adds	r2, r2, r1
 8003134:	18d3      	adds	r3, r2, r3
 8003136:	781a      	ldrb	r2, [r3, #0]
 8003138:	68fb      	ldr	r3, [r7, #12]
 800313a:	705a      	strb	r2, [r3, #1]
				if(pstdistancia->senStatus[pstdistancia->contParrilla][pstcaptura->filaActual] == 0){
 800313c:	683b      	ldr	r3, [r7, #0]
 800313e:	2266      	movs	r2, #102	; 0x66
 8003140:	5c9b      	ldrb	r3, [r3, r2]
 8003142:	0019      	movs	r1, r3
 8003144:	68fb      	ldr	r3, [r7, #12]
 8003146:	785b      	ldrb	r3, [r3, #1]
 8003148:	0018      	movs	r0, r3
 800314a:	683a      	ldr	r2, [r7, #0]
 800314c:	000b      	movs	r3, r1
 800314e:	009b      	lsls	r3, r3, #2
 8003150:	185b      	adds	r3, r3, r1
 8003152:	005b      	lsls	r3, r3, #1
 8003154:	18d3      	adds	r3, r2, r3
 8003156:	181b      	adds	r3, r3, r0
 8003158:	3301      	adds	r3, #1
 800315a:	781b      	ldrb	r3, [r3, #0]
 800315c:	2b00      	cmp	r3, #0
 800315e:	d11a      	bne.n	8003196 <BloqueCaptura+0x26e>
					pstcaptura->cantidades[pstdistancia->contParrilla][pstcaptura->filaActual] = ConvertirDistancia(pstcaptura, pstdistancia);
 8003160:	683b      	ldr	r3, [r7, #0]
 8003162:	2266      	movs	r2, #102	; 0x66
 8003164:	5c9b      	ldrb	r3, [r3, r2]
 8003166:	001c      	movs	r4, r3
 8003168:	68fb      	ldr	r3, [r7, #12]
 800316a:	785b      	ldrb	r3, [r3, #1]
 800316c:	001d      	movs	r5, r3
 800316e:	683a      	ldr	r2, [r7, #0]
 8003170:	68fb      	ldr	r3, [r7, #12]
 8003172:	0011      	movs	r1, r2
 8003174:	0018      	movs	r0, r3
 8003176:	f000 facf 	bl	8003718 <ConvertirDistancia>
 800317a:	0003      	movs	r3, r0
 800317c:	0018      	movs	r0, r3
 800317e:	68fa      	ldr	r2, [r7, #12]
 8003180:	21cb      	movs	r1, #203	; 0xcb
 8003182:	0023      	movs	r3, r4
 8003184:	009b      	lsls	r3, r3, #2
 8003186:	191b      	adds	r3, r3, r4
 8003188:	005b      	lsls	r3, r3, #1
 800318a:	18d3      	adds	r3, r2, r3
 800318c:	195b      	adds	r3, r3, r5
 800318e:	185b      	adds	r3, r3, r1
 8003190:	1c02      	adds	r2, r0, #0
 8003192:	701a      	strb	r2, [r3, #0]
 8003194:	e023      	b.n	80031de <BloqueCaptura+0x2b6>
					pstcaptura->cantidades[pstdistancia->contParrilla][pstcaptura->filaActual] = 250+pstdistancia->senStatus[pstdistancia->contParrilla][pstcaptura->filaActual];
 8003196:	683b      	ldr	r3, [r7, #0]
 8003198:	2266      	movs	r2, #102	; 0x66
 800319a:	5c9b      	ldrb	r3, [r3, r2]
 800319c:	0019      	movs	r1, r3
 800319e:	68fb      	ldr	r3, [r7, #12]
 80031a0:	785b      	ldrb	r3, [r3, #1]
 80031a2:	0018      	movs	r0, r3
 80031a4:	683a      	ldr	r2, [r7, #0]
 80031a6:	000b      	movs	r3, r1
 80031a8:	009b      	lsls	r3, r3, #2
 80031aa:	185b      	adds	r3, r3, r1
 80031ac:	005b      	lsls	r3, r3, #1
 80031ae:	18d3      	adds	r3, r2, r3
 80031b0:	181b      	adds	r3, r3, r0
 80031b2:	3301      	adds	r3, #1
 80031b4:	781b      	ldrb	r3, [r3, #0]
 80031b6:	683a      	ldr	r2, [r7, #0]
 80031b8:	2166      	movs	r1, #102	; 0x66
 80031ba:	5c52      	ldrb	r2, [r2, r1]
 80031bc:	0010      	movs	r0, r2
 80031be:	68fa      	ldr	r2, [r7, #12]
 80031c0:	7852      	ldrb	r2, [r2, #1]
 80031c2:	0015      	movs	r5, r2
 80031c4:	3b06      	subs	r3, #6
 80031c6:	b2dc      	uxtb	r4, r3
 80031c8:	68fa      	ldr	r2, [r7, #12]
 80031ca:	21cb      	movs	r1, #203	; 0xcb
 80031cc:	0003      	movs	r3, r0
 80031ce:	009b      	lsls	r3, r3, #2
 80031d0:	181b      	adds	r3, r3, r0
 80031d2:	005b      	lsls	r3, r3, #1
 80031d4:	18d3      	adds	r3, r2, r3
 80031d6:	195b      	adds	r3, r3, r5
 80031d8:	185b      	adds	r3, r3, r1
 80031da:	1c22      	adds	r2, r4, #0
 80031dc:	701a      	strb	r2, [r3, #0]
				pstcaptura->filaActual = 0;
 80031de:	68fb      	ldr	r3, [r7, #12]
 80031e0:	2200      	movs	r2, #0
 80031e2:	705a      	strb	r2, [r3, #1]
				pstdistancia->contDistancia = 0;
 80031e4:	683b      	ldr	r3, [r7, #0]
 80031e6:	2265      	movs	r2, #101	; 0x65
 80031e8:	2100      	movs	r1, #0
 80031ea:	5499      	strb	r1, [r3, r2]
				for(i=0; i<MAX_PARR; i++)
 80031ec:	2300      	movs	r3, #0
 80031ee:	617b      	str	r3, [r7, #20]
 80031f0:	e00a      	b.n	8003208 <BloqueCaptura+0x2e0>
					pstdistancia->posSensor[i] = 0;
 80031f2:	6839      	ldr	r1, [r7, #0]
 80031f4:	23cf      	movs	r3, #207	; 0xcf
 80031f6:	005b      	lsls	r3, r3, #1
 80031f8:	697a      	ldr	r2, [r7, #20]
 80031fa:	188a      	adds	r2, r1, r2
 80031fc:	18d3      	adds	r3, r2, r3
 80031fe:	2200      	movs	r2, #0
 8003200:	701a      	strb	r2, [r3, #0]
				for(i=0; i<MAX_PARR; i++)
 8003202:	697b      	ldr	r3, [r7, #20]
 8003204:	3301      	adds	r3, #1
 8003206:	617b      	str	r3, [r7, #20]
 8003208:	697b      	ldr	r3, [r7, #20]
 800320a:	2b09      	cmp	r3, #9
 800320c:	ddf1      	ble.n	80031f2 <BloqueCaptura+0x2ca>
				pstmotor->bandMotor = true;
 800320e:	687b      	ldr	r3, [r7, #4]
 8003210:	2201      	movs	r2, #1
 8003212:	701a      	strb	r2, [r3, #0]
				pstcaptura->CAP_State = CAP_ARMAR_TRAMA;
 8003214:	68fb      	ldr	r3, [r7, #12]
 8003216:	2204      	movs	r2, #4
 8003218:	701a      	strb	r2, [r3, #0]
    break;  
 800321a:	e06c      	b.n	80032f6 <BloqueCaptura+0x3ce>
    
		case CAP_CONFIGURAR:

			/*Actualizar parámetros de funcionamiento*/
			ConfigParrillas(pstcaptura, pstcomceit, pstmotor, pstdistancia);
 800321c:	683b      	ldr	r3, [r7, #0]
 800321e:	687a      	ldr	r2, [r7, #4]
 8003220:	68b9      	ldr	r1, [r7, #8]
 8003222:	68f8      	ldr	r0, [r7, #12]
 8003224:	f000 f86c 	bl	8003300 <ConfigParrillas>
			/*Ordenar vectores*/
			Ordenar(pstmotor,pstdistancia);
 8003228:	683a      	ldr	r2, [r7, #0]
 800322a:	687b      	ldr	r3, [r7, #4]
 800322c:	0011      	movs	r1, r2
 800322e:	0018      	movs	r0, r3
 8003230:	f000 f9de 	bl	80035f0 <Ordenar>

			pstcaptura->CAP_State = CAP_ARMAR_TRAMA;
 8003234:	68fb      	ldr	r3, [r7, #12]
 8003236:	2204      	movs	r2, #4
 8003238:	701a      	strb	r2, [r3, #0]
    break;
 800323a:	e05d      	b.n	80032f8 <BloqueCaptura+0x3d0>
    
		case CAP_ARMAR_TRAMA:
			
			if(pstcomceit->Rx_Buffer[CMD] == GET_DATA)
 800323c:	68bb      	ldr	r3, [r7, #8]
 800323e:	2274      	movs	r2, #116	; 0x74
 8003240:	5c9b      	ldrb	r3, [r3, r2]
 8003242:	2b60      	cmp	r3, #96	; 0x60
 8003244:	d14e      	bne.n	80032e4 <BloqueCaptura+0x3bc>
			{
				//Incluir cantidades de productos
				for(i = 0; i < MAX_PARR; i++)
 8003246:	2300      	movs	r3, #0
 8003248:	617b      	str	r3, [r7, #20]
 800324a:	e022      	b.n	8003292 <BloqueCaptura+0x36a>
				{
					for(j = 0; j < MAX_FILAS; j++)
 800324c:	2300      	movs	r3, #0
 800324e:	613b      	str	r3, [r7, #16]
 8003250:	e019      	b.n	8003286 <BloqueCaptura+0x35e>
					{
						pstcomceit->Tx_Buffer[j+i*10] = pstcaptura->cantidades[i][j];
 8003252:	697a      	ldr	r2, [r7, #20]
 8003254:	0013      	movs	r3, r2
 8003256:	009b      	lsls	r3, r3, #2
 8003258:	189b      	adds	r3, r3, r2
 800325a:	005b      	lsls	r3, r3, #1
 800325c:	001a      	movs	r2, r3
 800325e:	693b      	ldr	r3, [r7, #16]
 8003260:	18d1      	adds	r1, r2, r3
 8003262:	68f8      	ldr	r0, [r7, #12]
 8003264:	697a      	ldr	r2, [r7, #20]
 8003266:	24cb      	movs	r4, #203	; 0xcb
 8003268:	0013      	movs	r3, r2
 800326a:	009b      	lsls	r3, r3, #2
 800326c:	189b      	adds	r3, r3, r2
 800326e:	005b      	lsls	r3, r3, #1
 8003270:	18c2      	adds	r2, r0, r3
 8003272:	693b      	ldr	r3, [r7, #16]
 8003274:	18d3      	adds	r3, r2, r3
 8003276:	191b      	adds	r3, r3, r4
 8003278:	781a      	ldrb	r2, [r3, #0]
 800327a:	68bb      	ldr	r3, [r7, #8]
 800327c:	185b      	adds	r3, r3, r1
 800327e:	721a      	strb	r2, [r3, #8]
					for(j = 0; j < MAX_FILAS; j++)
 8003280:	693b      	ldr	r3, [r7, #16]
 8003282:	3301      	adds	r3, #1
 8003284:	613b      	str	r3, [r7, #16]
 8003286:	693b      	ldr	r3, [r7, #16]
 8003288:	2b09      	cmp	r3, #9
 800328a:	dde2      	ble.n	8003252 <BloqueCaptura+0x32a>
				for(i = 0; i < MAX_PARR; i++)
 800328c:	697b      	ldr	r3, [r7, #20]
 800328e:	3301      	adds	r3, #1
 8003290:	617b      	str	r3, [r7, #20]
 8003292:	697b      	ldr	r3, [r7, #20]
 8003294:	2b09      	cmp	r3, #9
 8003296:	ddd9      	ble.n	800324c <BloqueCaptura+0x324>
					}
				}
				
				for(i = 0; i < MAX_PARR; i++)
 8003298:	2300      	movs	r3, #0
 800329a:	617b      	str	r3, [r7, #20]
 800329c:	e01c      	b.n	80032d8 <BloqueCaptura+0x3b0>
				{
					for(j = 0; j < MAX_FILAS; j++)
 800329e:	2300      	movs	r3, #0
 80032a0:	613b      	str	r3, [r7, #16]
 80032a2:	e013      	b.n	80032cc <BloqueCaptura+0x3a4>
 80032a4:	08014e44 	.word	0x08014e44
 80032a8:	00000335 	.word	0x00000335
					{
						pstcaptura->cantidades[i][j] = 255;
 80032ac:	68f9      	ldr	r1, [r7, #12]
 80032ae:	697a      	ldr	r2, [r7, #20]
 80032b0:	20cb      	movs	r0, #203	; 0xcb
 80032b2:	0013      	movs	r3, r2
 80032b4:	009b      	lsls	r3, r3, #2
 80032b6:	189b      	adds	r3, r3, r2
 80032b8:	005b      	lsls	r3, r3, #1
 80032ba:	18ca      	adds	r2, r1, r3
 80032bc:	693b      	ldr	r3, [r7, #16]
 80032be:	18d3      	adds	r3, r2, r3
 80032c0:	181b      	adds	r3, r3, r0
 80032c2:	22ff      	movs	r2, #255	; 0xff
 80032c4:	701a      	strb	r2, [r3, #0]
					for(j = 0; j < MAX_FILAS; j++)
 80032c6:	693b      	ldr	r3, [r7, #16]
 80032c8:	3301      	adds	r3, #1
 80032ca:	613b      	str	r3, [r7, #16]
 80032cc:	693b      	ldr	r3, [r7, #16]
 80032ce:	2b09      	cmp	r3, #9
 80032d0:	ddec      	ble.n	80032ac <BloqueCaptura+0x384>
				for(i = 0; i < MAX_PARR; i++)
 80032d2:	697b      	ldr	r3, [r7, #20]
 80032d4:	3301      	adds	r3, #1
 80032d6:	617b      	str	r3, [r7, #20]
 80032d8:	697b      	ldr	r3, [r7, #20]
 80032da:	2b09      	cmp	r3, #9
 80032dc:	dddf      	ble.n	800329e <BloqueCaptura+0x376>
//				//Copiar en el vector de transmisión
//				for(i = 0; i < (TX_BUFFER_SIZE - 5); i++)
//				{
//					pstcomceit->Tx_Buffer[i] = pstcaptura->bufferTrama[i];
//				}
				pstcomceit->TxLength = MAX_PARR*MAX_FILAS;
 80032de:	68bb      	ldr	r3, [r7, #8]
 80032e0:	2264      	movs	r2, #100	; 0x64
 80032e2:	719a      	strb	r2, [r3, #6]
//				pstcomceit->Tx_Buffer[0] = 0xAA;
//				pstcomceit->TxLength = 1;
			}
			
			//Actualizar bandera de envío
 			pstcomceit->datosListos = true;
 80032e4:	68bb      	ldr	r3, [r7, #8]
 80032e6:	2201      	movs	r2, #1
 80032e8:	709a      	strb	r2, [r3, #2]
			pstcaptura->CAP_State = CAP_ESPERAR;
 80032ea:	68fb      	ldr	r3, [r7, #12]
 80032ec:	2200      	movs	r2, #0
 80032ee:	701a      	strb	r2, [r3, #0]

		break;
 80032f0:	e002      	b.n	80032f8 <BloqueCaptura+0x3d0>
    break;
 80032f2:	46c0      	nop			; (mov r8, r8)
 80032f4:	e000      	b.n	80032f8 <BloqueCaptura+0x3d0>
    break;  
 80032f6:	46c0      	nop			; (mov r8, r8)
  }
}
 80032f8:	46c0      	nop			; (mov r8, r8)
 80032fa:	46bd      	mov	sp, r7
 80032fc:	b006      	add	sp, #24
 80032fe:	bdb0      	pop	{r4, r5, r7, pc}

08003300 <ConfigParrillas>:
						pstfuerza: Apuntador a la estructura de datos de Fuerza
Salidas:          		N/A
Descripción:  		    Realiza la configuración de las parrillas
****************************************************************************************/
void ConfigParrillas(stCaptura *pstcaptura, stComCEIT *pstcomceit, stMotor *pstmotor, stDistancia *pstdistancia)
{
 8003300:	b590      	push	{r4, r7, lr}
 8003302:	b089      	sub	sp, #36	; 0x24
 8003304:	af00      	add	r7, sp, #0
 8003306:	60f8      	str	r0, [r7, #12]
 8003308:	60b9      	str	r1, [r7, #8]
 800330a:	607a      	str	r2, [r7, #4]
 800330c:	603b      	str	r3, [r7, #0]
	int i,j,k;
	pstmotor->ParrHab = pstcomceit->Rx_Data[0];
 800330e:	68bb      	ldr	r3, [r7, #8]
 8003310:	2277      	movs	r2, #119	; 0x77
 8003312:	5c99      	ldrb	r1, [r3, r2]
 8003314:	687a      	ldr	r2, [r7, #4]
 8003316:	23cd      	movs	r3, #205	; 0xcd
 8003318:	009b      	lsls	r3, r3, #2
 800331a:	54d1      	strb	r1, [r2, r3]
	pstdistancia->SenHab = pstcomceit->Rx_Data[0];
 800331c:	68bb      	ldr	r3, [r7, #8]
 800331e:	2277      	movs	r2, #119	; 0x77
 8003320:	5c99      	ldrb	r1, [r3, r2]
 8003322:	683a      	ldr	r2, [r7, #0]
 8003324:	23d4      	movs	r3, #212	; 0xd4
 8003326:	005b      	lsls	r3, r3, #1
 8003328:	54d1      	strb	r1, [r2, r3]
	pstcaptura->Distancia = pstcomceit->Rx_Data[1];
 800332a:	68bb      	ldr	r3, [r7, #8]
 800332c:	2278      	movs	r2, #120	; 0x78
 800332e:	5c9a      	ldrb	r2, [r3, r2]
 8003330:	68fb      	ldr	r3, [r7, #12]
 8003332:	709a      	strb	r2, [r3, #2]

	/*Actualizar largo y ancho*/
	for(i=0; i<pstmotor->ParrHab; i++)
 8003334:	2300      	movs	r3, #0
 8003336:	61fb      	str	r3, [r7, #28]
 8003338:	e09d      	b.n	8003476 <ConfigParrillas+0x176>
	{
		j=0;
 800333a:	2300      	movs	r3, #0
 800333c:	61bb      	str	r3, [r7, #24]
		while(pstcomceit->Rx_Data[2+i*20+2*j+1] != 255)
 800333e:	e07c      	b.n	800343a <ConfigParrillas+0x13a>
		{
			if(pstcomceit->Rx_Data[2+i*20+2*j+1] !=0)
 8003340:	69fa      	ldr	r2, [r7, #28]
 8003342:	0013      	movs	r3, r2
 8003344:	009b      	lsls	r3, r3, #2
 8003346:	189b      	adds	r3, r3, r2
 8003348:	009b      	lsls	r3, r3, #2
 800334a:	1c9a      	adds	r2, r3, #2
 800334c:	69bb      	ldr	r3, [r7, #24]
 800334e:	005b      	lsls	r3, r3, #1
 8003350:	18d3      	adds	r3, r2, r3
 8003352:	3301      	adds	r3, #1
 8003354:	68ba      	ldr	r2, [r7, #8]
 8003356:	2177      	movs	r1, #119	; 0x77
 8003358:	18d3      	adds	r3, r2, r3
 800335a:	185b      	adds	r3, r3, r1
 800335c:	781b      	ldrb	r3, [r3, #0]
 800335e:	2b00      	cmp	r3, #0
 8003360:	d036      	beq.n	80033d0 <ConfigParrillas+0xd0>
			{
				pstcaptura->ancho[i][j] = pstcomceit->Rx_Data[2+i*20+2*j];
 8003362:	69fa      	ldr	r2, [r7, #28]
 8003364:	0013      	movs	r3, r2
 8003366:	009b      	lsls	r3, r3, #2
 8003368:	189b      	adds	r3, r3, r2
 800336a:	009b      	lsls	r3, r3, #2
 800336c:	1c9a      	adds	r2, r3, #2
 800336e:	69bb      	ldr	r3, [r7, #24]
 8003370:	005b      	lsls	r3, r3, #1
 8003372:	18d3      	adds	r3, r2, r3
 8003374:	68ba      	ldr	r2, [r7, #8]
 8003376:	2177      	movs	r1, #119	; 0x77
 8003378:	18d3      	adds	r3, r2, r3
 800337a:	185b      	adds	r3, r3, r1
 800337c:	7818      	ldrb	r0, [r3, #0]
 800337e:	68f9      	ldr	r1, [r7, #12]
 8003380:	69fa      	ldr	r2, [r7, #28]
 8003382:	0013      	movs	r3, r2
 8003384:	009b      	lsls	r3, r3, #2
 8003386:	189b      	adds	r3, r3, r2
 8003388:	005b      	lsls	r3, r3, #1
 800338a:	18ca      	adds	r2, r1, r3
 800338c:	69bb      	ldr	r3, [r7, #24]
 800338e:	18d3      	adds	r3, r2, r3
 8003390:	3303      	adds	r3, #3
 8003392:	1c02      	adds	r2, r0, #0
 8003394:	701a      	strb	r2, [r3, #0]
				pstcaptura->largo[i][j] = pstcomceit->Rx_Data[2+i*20+2*j+1];
 8003396:	69fa      	ldr	r2, [r7, #28]
 8003398:	0013      	movs	r3, r2
 800339a:	009b      	lsls	r3, r3, #2
 800339c:	189b      	adds	r3, r3, r2
 800339e:	009b      	lsls	r3, r3, #2
 80033a0:	1c9a      	adds	r2, r3, #2
 80033a2:	69bb      	ldr	r3, [r7, #24]
 80033a4:	005b      	lsls	r3, r3, #1
 80033a6:	18d3      	adds	r3, r2, r3
 80033a8:	3301      	adds	r3, #1
 80033aa:	68ba      	ldr	r2, [r7, #8]
 80033ac:	2177      	movs	r1, #119	; 0x77
 80033ae:	18d3      	adds	r3, r2, r3
 80033b0:	185b      	adds	r3, r3, r1
 80033b2:	781c      	ldrb	r4, [r3, #0]
 80033b4:	68f9      	ldr	r1, [r7, #12]
 80033b6:	69fa      	ldr	r2, [r7, #28]
 80033b8:	2067      	movs	r0, #103	; 0x67
 80033ba:	0013      	movs	r3, r2
 80033bc:	009b      	lsls	r3, r3, #2
 80033be:	189b      	adds	r3, r3, r2
 80033c0:	005b      	lsls	r3, r3, #1
 80033c2:	18ca      	adds	r2, r1, r3
 80033c4:	69bb      	ldr	r3, [r7, #24]
 80033c6:	18d3      	adds	r3, r2, r3
 80033c8:	181b      	adds	r3, r3, r0
 80033ca:	1c22      	adds	r2, r4, #0
 80033cc:	701a      	strb	r2, [r3, #0]
 80033ce:	e031      	b.n	8003434 <ConfigParrillas+0x134>
			}
			else
			{
				pstcaptura->ancho[i][j] = pstcomceit->Rx_Data[2+i*20+2*j];
 80033d0:	69fa      	ldr	r2, [r7, #28]
 80033d2:	0013      	movs	r3, r2
 80033d4:	009b      	lsls	r3, r3, #2
 80033d6:	189b      	adds	r3, r3, r2
 80033d8:	009b      	lsls	r3, r3, #2
 80033da:	1c9a      	adds	r2, r3, #2
 80033dc:	69bb      	ldr	r3, [r7, #24]
 80033de:	005b      	lsls	r3, r3, #1
 80033e0:	18d3      	adds	r3, r2, r3
 80033e2:	68ba      	ldr	r2, [r7, #8]
 80033e4:	2177      	movs	r1, #119	; 0x77
 80033e6:	18d3      	adds	r3, r2, r3
 80033e8:	185b      	adds	r3, r3, r1
 80033ea:	7818      	ldrb	r0, [r3, #0]
 80033ec:	68f9      	ldr	r1, [r7, #12]
 80033ee:	69fa      	ldr	r2, [r7, #28]
 80033f0:	0013      	movs	r3, r2
 80033f2:	009b      	lsls	r3, r3, #2
 80033f4:	189b      	adds	r3, r3, r2
 80033f6:	005b      	lsls	r3, r3, #1
 80033f8:	18ca      	adds	r2, r1, r3
 80033fa:	69bb      	ldr	r3, [r7, #24]
 80033fc:	18d3      	adds	r3, r2, r3
 80033fe:	3303      	adds	r3, #3
 8003400:	1c02      	adds	r2, r0, #0
 8003402:	701a      	strb	r2, [r3, #0]
				pstcaptura->largo[i][j] = pstcaptura->ancho[i][j];
 8003404:	68f9      	ldr	r1, [r7, #12]
 8003406:	69fa      	ldr	r2, [r7, #28]
 8003408:	0013      	movs	r3, r2
 800340a:	009b      	lsls	r3, r3, #2
 800340c:	189b      	adds	r3, r3, r2
 800340e:	005b      	lsls	r3, r3, #1
 8003410:	18ca      	adds	r2, r1, r3
 8003412:	69bb      	ldr	r3, [r7, #24]
 8003414:	18d3      	adds	r3, r2, r3
 8003416:	3303      	adds	r3, #3
 8003418:	781c      	ldrb	r4, [r3, #0]
 800341a:	68f9      	ldr	r1, [r7, #12]
 800341c:	69fa      	ldr	r2, [r7, #28]
 800341e:	2067      	movs	r0, #103	; 0x67
 8003420:	0013      	movs	r3, r2
 8003422:	009b      	lsls	r3, r3, #2
 8003424:	189b      	adds	r3, r3, r2
 8003426:	005b      	lsls	r3, r3, #1
 8003428:	18ca      	adds	r2, r1, r3
 800342a:	69bb      	ldr	r3, [r7, #24]
 800342c:	18d3      	adds	r3, r2, r3
 800342e:	181b      	adds	r3, r3, r0
 8003430:	1c22      	adds	r2, r4, #0
 8003432:	701a      	strb	r2, [r3, #0]
			}
			j++;
 8003434:	69bb      	ldr	r3, [r7, #24]
 8003436:	3301      	adds	r3, #1
 8003438:	61bb      	str	r3, [r7, #24]
		while(pstcomceit->Rx_Data[2+i*20+2*j+1] != 255)
 800343a:	69fa      	ldr	r2, [r7, #28]
 800343c:	0013      	movs	r3, r2
 800343e:	009b      	lsls	r3, r3, #2
 8003440:	189b      	adds	r3, r3, r2
 8003442:	009b      	lsls	r3, r3, #2
 8003444:	1c9a      	adds	r2, r3, #2
 8003446:	69bb      	ldr	r3, [r7, #24]
 8003448:	005b      	lsls	r3, r3, #1
 800344a:	18d3      	adds	r3, r2, r3
 800344c:	3301      	adds	r3, #1
 800344e:	68ba      	ldr	r2, [r7, #8]
 8003450:	2177      	movs	r1, #119	; 0x77
 8003452:	18d3      	adds	r3, r2, r3
 8003454:	185b      	adds	r3, r3, r1
 8003456:	781b      	ldrb	r3, [r3, #0]
 8003458:	2bff      	cmp	r3, #255	; 0xff
 800345a:	d000      	beq.n	800345e <ConfigParrillas+0x15e>
 800345c:	e770      	b.n	8003340 <ConfigParrillas+0x40>
		}
		pstdistancia->cantFilas[i] = j;
 800345e:	69bb      	ldr	r3, [r7, #24]
 8003460:	b2d8      	uxtb	r0, r3
 8003462:	683a      	ldr	r2, [r7, #0]
 8003464:	2167      	movs	r1, #103	; 0x67
 8003466:	69fb      	ldr	r3, [r7, #28]
 8003468:	18d3      	adds	r3, r2, r3
 800346a:	185b      	adds	r3, r3, r1
 800346c:	1c02      	adds	r2, r0, #0
 800346e:	701a      	strb	r2, [r3, #0]
	for(i=0; i<pstmotor->ParrHab; i++)
 8003470:	69fb      	ldr	r3, [r7, #28]
 8003472:	3301      	adds	r3, #1
 8003474:	61fb      	str	r3, [r7, #28]
 8003476:	687a      	ldr	r2, [r7, #4]
 8003478:	23cd      	movs	r3, #205	; 0xcd
 800347a:	009b      	lsls	r3, r3, #2
 800347c:	5cd3      	ldrb	r3, [r2, r3]
 800347e:	001a      	movs	r2, r3
 8003480:	69fb      	ldr	r3, [r7, #28]
 8003482:	4293      	cmp	r3, r2
 8003484:	da00      	bge.n	8003488 <ConfigParrillas+0x188>
 8003486:	e758      	b.n	800333a <ConfigParrillas+0x3a>
	}

	/*Actualizar distancias a recorrer y crear vectores de recorrido y sensor*/
	k=0;
 8003488:	2300      	movs	r3, #0
 800348a:	617b      	str	r3, [r7, #20]
	for(i=0; i<pstmotor->ParrHab; i++)
 800348c:	2300      	movs	r3, #0
 800348e:	61fb      	str	r3, [r7, #28]
 8003490:	e097      	b.n	80035c2 <ConfigParrillas+0x2c2>
	{
		pstmotor->distFilas[i][0] = 0;
 8003492:	6879      	ldr	r1, [r7, #4]
 8003494:	69fa      	ldr	r2, [r7, #28]
 8003496:	0013      	movs	r3, r2
 8003498:	009b      	lsls	r3, r3, #2
 800349a:	189b      	adds	r3, r3, r2
 800349c:	00db      	lsls	r3, r3, #3
 800349e:	18cb      	adds	r3, r1, r3
 80034a0:	3314      	adds	r3, #20
 80034a2:	2200      	movs	r2, #0
 80034a4:	601a      	str	r2, [r3, #0]
		pstmotor->recorrido[k] = pstmotor->distFilas[i][0];
 80034a6:	6879      	ldr	r1, [r7, #4]
 80034a8:	69fa      	ldr	r2, [r7, #28]
 80034aa:	0013      	movs	r3, r2
 80034ac:	009b      	lsls	r3, r3, #2
 80034ae:	189b      	adds	r3, r3, r2
 80034b0:	00db      	lsls	r3, r3, #3
 80034b2:	18cb      	adds	r3, r1, r3
 80034b4:	3314      	adds	r3, #20
 80034b6:	681a      	ldr	r2, [r3, #0]
 80034b8:	6879      	ldr	r1, [r7, #4]
 80034ba:	697b      	ldr	r3, [r7, #20]
 80034bc:	3368      	adds	r3, #104	; 0x68
 80034be:	009b      	lsls	r3, r3, #2
 80034c0:	18cb      	adds	r3, r1, r3
 80034c2:	3304      	adds	r3, #4
 80034c4:	601a      	str	r2, [r3, #0]
		pstdistancia->sensor[k] = i;
 80034c6:	69fb      	ldr	r3, [r7, #28]
 80034c8:	b2d8      	uxtb	r0, r3
 80034ca:	6839      	ldr	r1, [r7, #0]
 80034cc:	239d      	movs	r3, #157	; 0x9d
 80034ce:	005b      	lsls	r3, r3, #1
 80034d0:	697a      	ldr	r2, [r7, #20]
 80034d2:	188a      	adds	r2, r1, r2
 80034d4:	18d3      	adds	r3, r2, r3
 80034d6:	1c02      	adds	r2, r0, #0
 80034d8:	701a      	strb	r2, [r3, #0]
		k++;
 80034da:	697b      	ldr	r3, [r7, #20]
 80034dc:	3301      	adds	r3, #1
 80034de:	617b      	str	r3, [r7, #20]
		for(j=1; j<pstdistancia->cantFilas[i]; j++)
 80034e0:	2301      	movs	r3, #1
 80034e2:	61bb      	str	r3, [r7, #24]
 80034e4:	e060      	b.n	80035a8 <ConfigParrillas+0x2a8>
		{
			pstmotor->distFilas[i][j] = ((pstcaptura->ancho[i][j-1]+pstcaptura->ancho[i][j])/2+SEPARADOR)*STEP_1MM+pstmotor->distFilas[i][j-1];// Fix signo
 80034e6:	69bb      	ldr	r3, [r7, #24]
 80034e8:	1e59      	subs	r1, r3, #1
 80034ea:	68f8      	ldr	r0, [r7, #12]
 80034ec:	69fa      	ldr	r2, [r7, #28]
 80034ee:	0013      	movs	r3, r2
 80034f0:	009b      	lsls	r3, r3, #2
 80034f2:	189b      	adds	r3, r3, r2
 80034f4:	005b      	lsls	r3, r3, #1
 80034f6:	18c3      	adds	r3, r0, r3
 80034f8:	185b      	adds	r3, r3, r1
 80034fa:	3303      	adds	r3, #3
 80034fc:	781b      	ldrb	r3, [r3, #0]
 80034fe:	0018      	movs	r0, r3
 8003500:	68f9      	ldr	r1, [r7, #12]
 8003502:	69fa      	ldr	r2, [r7, #28]
 8003504:	0013      	movs	r3, r2
 8003506:	009b      	lsls	r3, r3, #2
 8003508:	189b      	adds	r3, r3, r2
 800350a:	005b      	lsls	r3, r3, #1
 800350c:	18ca      	adds	r2, r1, r3
 800350e:	69bb      	ldr	r3, [r7, #24]
 8003510:	18d3      	adds	r3, r2, r3
 8003512:	3303      	adds	r3, #3
 8003514:	781b      	ldrb	r3, [r3, #0]
 8003516:	18c3      	adds	r3, r0, r3
 8003518:	2b00      	cmp	r3, #0
 800351a:	da00      	bge.n	800351e <ConfigParrillas+0x21e>
 800351c:	3301      	adds	r3, #1
 800351e:	105b      	asrs	r3, r3, #1
 8003520:	3307      	adds	r3, #7
 8003522:	4a31      	ldr	r2, [pc, #196]	; (80035e8 <ConfigParrillas+0x2e8>)
 8003524:	4353      	muls	r3, r2
 8003526:	001c      	movs	r4, r3
 8003528:	69bb      	ldr	r3, [r7, #24]
 800352a:	1e58      	subs	r0, r3, #1
 800352c:	6879      	ldr	r1, [r7, #4]
 800352e:	69fa      	ldr	r2, [r7, #28]
 8003530:	0013      	movs	r3, r2
 8003532:	009b      	lsls	r3, r3, #2
 8003534:	189b      	adds	r3, r3, r2
 8003536:	005b      	lsls	r3, r3, #1
 8003538:	181b      	adds	r3, r3, r0
 800353a:	3304      	adds	r3, #4
 800353c:	009b      	lsls	r3, r3, #2
 800353e:	18cb      	adds	r3, r1, r3
 8003540:	3304      	adds	r3, #4
 8003542:	681b      	ldr	r3, [r3, #0]
 8003544:	18e1      	adds	r1, r4, r3
 8003546:	6878      	ldr	r0, [r7, #4]
 8003548:	69fa      	ldr	r2, [r7, #28]
 800354a:	0013      	movs	r3, r2
 800354c:	009b      	lsls	r3, r3, #2
 800354e:	189b      	adds	r3, r3, r2
 8003550:	005b      	lsls	r3, r3, #1
 8003552:	69ba      	ldr	r2, [r7, #24]
 8003554:	189b      	adds	r3, r3, r2
 8003556:	3304      	adds	r3, #4
 8003558:	009b      	lsls	r3, r3, #2
 800355a:	18c3      	adds	r3, r0, r3
 800355c:	3304      	adds	r3, #4
 800355e:	6019      	str	r1, [r3, #0]
			pstmotor->recorrido[k] = pstmotor->distFilas[i][j];
 8003560:	6879      	ldr	r1, [r7, #4]
 8003562:	69fa      	ldr	r2, [r7, #28]
 8003564:	0013      	movs	r3, r2
 8003566:	009b      	lsls	r3, r3, #2
 8003568:	189b      	adds	r3, r3, r2
 800356a:	005b      	lsls	r3, r3, #1
 800356c:	69ba      	ldr	r2, [r7, #24]
 800356e:	189b      	adds	r3, r3, r2
 8003570:	3304      	adds	r3, #4
 8003572:	009b      	lsls	r3, r3, #2
 8003574:	18cb      	adds	r3, r1, r3
 8003576:	3304      	adds	r3, #4
 8003578:	681a      	ldr	r2, [r3, #0]
 800357a:	6879      	ldr	r1, [r7, #4]
 800357c:	697b      	ldr	r3, [r7, #20]
 800357e:	3368      	adds	r3, #104	; 0x68
 8003580:	009b      	lsls	r3, r3, #2
 8003582:	18cb      	adds	r3, r1, r3
 8003584:	3304      	adds	r3, #4
 8003586:	601a      	str	r2, [r3, #0]
			pstdistancia->sensor[k] = i;
 8003588:	69fb      	ldr	r3, [r7, #28]
 800358a:	b2d8      	uxtb	r0, r3
 800358c:	6839      	ldr	r1, [r7, #0]
 800358e:	239d      	movs	r3, #157	; 0x9d
 8003590:	005b      	lsls	r3, r3, #1
 8003592:	697a      	ldr	r2, [r7, #20]
 8003594:	188a      	adds	r2, r1, r2
 8003596:	18d3      	adds	r3, r2, r3
 8003598:	1c02      	adds	r2, r0, #0
 800359a:	701a      	strb	r2, [r3, #0]
			k++;
 800359c:	697b      	ldr	r3, [r7, #20]
 800359e:	3301      	adds	r3, #1
 80035a0:	617b      	str	r3, [r7, #20]
		for(j=1; j<pstdistancia->cantFilas[i]; j++)
 80035a2:	69bb      	ldr	r3, [r7, #24]
 80035a4:	3301      	adds	r3, #1
 80035a6:	61bb      	str	r3, [r7, #24]
 80035a8:	683a      	ldr	r2, [r7, #0]
 80035aa:	2167      	movs	r1, #103	; 0x67
 80035ac:	69fb      	ldr	r3, [r7, #28]
 80035ae:	18d3      	adds	r3, r2, r3
 80035b0:	185b      	adds	r3, r3, r1
 80035b2:	781b      	ldrb	r3, [r3, #0]
 80035b4:	001a      	movs	r2, r3
 80035b6:	69bb      	ldr	r3, [r7, #24]
 80035b8:	4293      	cmp	r3, r2
 80035ba:	db94      	blt.n	80034e6 <ConfigParrillas+0x1e6>
	for(i=0; i<pstmotor->ParrHab; i++)
 80035bc:	69fb      	ldr	r3, [r7, #28]
 80035be:	3301      	adds	r3, #1
 80035c0:	61fb      	str	r3, [r7, #28]
 80035c2:	687a      	ldr	r2, [r7, #4]
 80035c4:	23cd      	movs	r3, #205	; 0xcd
 80035c6:	009b      	lsls	r3, r3, #2
 80035c8:	5cd3      	ldrb	r3, [r2, r3]
 80035ca:	001a      	movs	r2, r3
 80035cc:	69fb      	ldr	r3, [r7, #28]
 80035ce:	4293      	cmp	r3, r2
 80035d0:	da00      	bge.n	80035d4 <ConfigParrillas+0x2d4>
 80035d2:	e75e      	b.n	8003492 <ConfigParrillas+0x192>
		}
	}
	pstmotor->MaxPosMotor = k;
 80035d4:	697b      	ldr	r3, [r7, #20]
 80035d6:	b2d9      	uxtb	r1, r3
 80035d8:	687b      	ldr	r3, [r7, #4]
 80035da:	4a04      	ldr	r2, [pc, #16]	; (80035ec <ConfigParrillas+0x2ec>)
 80035dc:	5499      	strb	r1, [r3, r2]
}
 80035de:	46c0      	nop			; (mov r8, r8)
 80035e0:	46bd      	mov	sp, r7
 80035e2:	b009      	add	sp, #36	; 0x24
 80035e4:	bd90      	pop	{r4, r7, pc}
 80035e6:	46c0      	nop			; (mov r8, r8)
 80035e8:	0000031d 	.word	0x0000031d
 80035ec:	00000335 	.word	0x00000335

080035f0 <Ordenar>:
						pstdistancia: Apuntador a la estructura de datos de Distancia
Salidas:          		N/A
Descripción:  		    Planeación de las paradas que deben realizar los motores
****************************************************************************************/
void Ordenar(stMotor *pstmotor, stDistancia *pstdistancia)
{
 80035f0:	b580      	push	{r7, lr}
 80035f2:	b086      	sub	sp, #24
 80035f4:	af00      	add	r7, sp, #0
 80035f6:	6078      	str	r0, [r7, #4]
 80035f8:	6039      	str	r1, [r7, #0]
	int i,j,band=1;
 80035fa:	2301      	movs	r3, #1
 80035fc:	613b      	str	r3, [r7, #16]
	while(band)
 80035fe:	e065      	b.n	80036cc <Ordenar+0xdc>
	{
		band = 0;
 8003600:	2300      	movs	r3, #0
 8003602:	613b      	str	r3, [r7, #16]
		for(i=1; i<pstmotor->MaxPosMotor; i++)
 8003604:	2301      	movs	r3, #1
 8003606:	617b      	str	r3, [r7, #20]
 8003608:	e059      	b.n	80036be <Ordenar+0xce>
		{
			if(pstmotor->recorrido[i]<pstmotor->recorrido[i-1])
 800360a:	687a      	ldr	r2, [r7, #4]
 800360c:	697b      	ldr	r3, [r7, #20]
 800360e:	3368      	adds	r3, #104	; 0x68
 8003610:	009b      	lsls	r3, r3, #2
 8003612:	18d3      	adds	r3, r2, r3
 8003614:	3304      	adds	r3, #4
 8003616:	681a      	ldr	r2, [r3, #0]
 8003618:	697b      	ldr	r3, [r7, #20]
 800361a:	3b01      	subs	r3, #1
 800361c:	6879      	ldr	r1, [r7, #4]
 800361e:	3368      	adds	r3, #104	; 0x68
 8003620:	009b      	lsls	r3, r3, #2
 8003622:	18cb      	adds	r3, r1, r3
 8003624:	3304      	adds	r3, #4
 8003626:	681b      	ldr	r3, [r3, #0]
 8003628:	429a      	cmp	r2, r3
 800362a:	d245      	bcs.n	80036b8 <Ordenar+0xc8>
			{
				j = pstmotor->recorrido[i-1];
 800362c:	697b      	ldr	r3, [r7, #20]
 800362e:	3b01      	subs	r3, #1
 8003630:	687a      	ldr	r2, [r7, #4]
 8003632:	3368      	adds	r3, #104	; 0x68
 8003634:	009b      	lsls	r3, r3, #2
 8003636:	18d3      	adds	r3, r2, r3
 8003638:	3304      	adds	r3, #4
 800363a:	681b      	ldr	r3, [r3, #0]
 800363c:	60fb      	str	r3, [r7, #12]
				pstmotor->recorrido[i-1] = pstmotor->recorrido[i];
 800363e:	697b      	ldr	r3, [r7, #20]
 8003640:	1e58      	subs	r0, r3, #1
 8003642:	687a      	ldr	r2, [r7, #4]
 8003644:	697b      	ldr	r3, [r7, #20]
 8003646:	3368      	adds	r3, #104	; 0x68
 8003648:	009b      	lsls	r3, r3, #2
 800364a:	18d3      	adds	r3, r2, r3
 800364c:	3304      	adds	r3, #4
 800364e:	681a      	ldr	r2, [r3, #0]
 8003650:	6879      	ldr	r1, [r7, #4]
 8003652:	0003      	movs	r3, r0
 8003654:	3368      	adds	r3, #104	; 0x68
 8003656:	009b      	lsls	r3, r3, #2
 8003658:	18cb      	adds	r3, r1, r3
 800365a:	3304      	adds	r3, #4
 800365c:	601a      	str	r2, [r3, #0]
				pstmotor->recorrido[i] = j;
 800365e:	68fa      	ldr	r2, [r7, #12]
 8003660:	6879      	ldr	r1, [r7, #4]
 8003662:	697b      	ldr	r3, [r7, #20]
 8003664:	3368      	adds	r3, #104	; 0x68
 8003666:	009b      	lsls	r3, r3, #2
 8003668:	18cb      	adds	r3, r1, r3
 800366a:	3304      	adds	r3, #4
 800366c:	601a      	str	r2, [r3, #0]
				j = pstdistancia->sensor[i-1];
 800366e:	697b      	ldr	r3, [r7, #20]
 8003670:	1e5a      	subs	r2, r3, #1
 8003672:	6839      	ldr	r1, [r7, #0]
 8003674:	239d      	movs	r3, #157	; 0x9d
 8003676:	005b      	lsls	r3, r3, #1
 8003678:	188a      	adds	r2, r1, r2
 800367a:	18d3      	adds	r3, r2, r3
 800367c:	781b      	ldrb	r3, [r3, #0]
 800367e:	60fb      	str	r3, [r7, #12]
				pstdistancia->sensor[i-1] = pstdistancia->sensor[i];
 8003680:	697b      	ldr	r3, [r7, #20]
 8003682:	1e5a      	subs	r2, r3, #1
 8003684:	6838      	ldr	r0, [r7, #0]
 8003686:	239d      	movs	r3, #157	; 0x9d
 8003688:	005b      	lsls	r3, r3, #1
 800368a:	6979      	ldr	r1, [r7, #20]
 800368c:	1841      	adds	r1, r0, r1
 800368e:	18cb      	adds	r3, r1, r3
 8003690:	7818      	ldrb	r0, [r3, #0]
 8003692:	6839      	ldr	r1, [r7, #0]
 8003694:	239d      	movs	r3, #157	; 0x9d
 8003696:	005b      	lsls	r3, r3, #1
 8003698:	188a      	adds	r2, r1, r2
 800369a:	18d3      	adds	r3, r2, r3
 800369c:	1c02      	adds	r2, r0, #0
 800369e:	701a      	strb	r2, [r3, #0]
				pstdistancia->sensor[i] = j;
 80036a0:	68fb      	ldr	r3, [r7, #12]
 80036a2:	b2d8      	uxtb	r0, r3
 80036a4:	6839      	ldr	r1, [r7, #0]
 80036a6:	239d      	movs	r3, #157	; 0x9d
 80036a8:	005b      	lsls	r3, r3, #1
 80036aa:	697a      	ldr	r2, [r7, #20]
 80036ac:	188a      	adds	r2, r1, r2
 80036ae:	18d3      	adds	r3, r2, r3
 80036b0:	1c02      	adds	r2, r0, #0
 80036b2:	701a      	strb	r2, [r3, #0]
				band = 1;
 80036b4:	2301      	movs	r3, #1
 80036b6:	613b      	str	r3, [r7, #16]
		for(i=1; i<pstmotor->MaxPosMotor; i++)
 80036b8:	697b      	ldr	r3, [r7, #20]
 80036ba:	3301      	adds	r3, #1
 80036bc:	617b      	str	r3, [r7, #20]
 80036be:	687b      	ldr	r3, [r7, #4]
 80036c0:	4a14      	ldr	r2, [pc, #80]	; (8003714 <Ordenar+0x124>)
 80036c2:	5c9b      	ldrb	r3, [r3, r2]
 80036c4:	001a      	movs	r2, r3
 80036c6:	697b      	ldr	r3, [r7, #20]
 80036c8:	4293      	cmp	r3, r2
 80036ca:	db9e      	blt.n	800360a <Ordenar+0x1a>
	while(band)
 80036cc:	693b      	ldr	r3, [r7, #16]
 80036ce:	2b00      	cmp	r3, #0
 80036d0:	d196      	bne.n	8003600 <Ordenar+0x10>
			}
		}
	}
	for(i=0; i<pstmotor->MaxPosMotor; i++)
 80036d2:	2300      	movs	r3, #0
 80036d4:	617b      	str	r3, [r7, #20]
 80036d6:	e011      	b.n	80036fc <Ordenar+0x10c>
	{
		pstmotor->recorrido[i] = -pstmotor->recorrido[i];
 80036d8:	687a      	ldr	r2, [r7, #4]
 80036da:	697b      	ldr	r3, [r7, #20]
 80036dc:	3368      	adds	r3, #104	; 0x68
 80036de:	009b      	lsls	r3, r3, #2
 80036e0:	18d3      	adds	r3, r2, r3
 80036e2:	3304      	adds	r3, #4
 80036e4:	681b      	ldr	r3, [r3, #0]
 80036e6:	425a      	negs	r2, r3
 80036e8:	6879      	ldr	r1, [r7, #4]
 80036ea:	697b      	ldr	r3, [r7, #20]
 80036ec:	3368      	adds	r3, #104	; 0x68
 80036ee:	009b      	lsls	r3, r3, #2
 80036f0:	18cb      	adds	r3, r1, r3
 80036f2:	3304      	adds	r3, #4
 80036f4:	601a      	str	r2, [r3, #0]
	for(i=0; i<pstmotor->MaxPosMotor; i++)
 80036f6:	697b      	ldr	r3, [r7, #20]
 80036f8:	3301      	adds	r3, #1
 80036fa:	617b      	str	r3, [r7, #20]
 80036fc:	687b      	ldr	r3, [r7, #4]
 80036fe:	4a05      	ldr	r2, [pc, #20]	; (8003714 <Ordenar+0x124>)
 8003700:	5c9b      	ldrb	r3, [r3, r2]
 8003702:	001a      	movs	r2, r3
 8003704:	697b      	ldr	r3, [r7, #20]
 8003706:	4293      	cmp	r3, r2
 8003708:	dbe6      	blt.n	80036d8 <Ordenar+0xe8>
	}
}
 800370a:	46c0      	nop			; (mov r8, r8)
 800370c:	46bd      	mov	sp, r7
 800370e:	b006      	add	sp, #24
 8003710:	bd80      	pop	{r7, pc}
 8003712:	46c0      	nop			; (mov r8, r8)
 8003714:	00000335 	.word	0x00000335

08003718 <ConvertirDistancia>:
						pstdistancia: Apuntador a la estructura de datos de Distancia
Salidas:          		Retorna la cantidad de productos de acuerdo a la distancia
Descripción:  		    Convierte el valor de distancia a cantidad de productos
****************************************************************************************/
uint8_t ConvertirDistancia(stCaptura *pstcaptura, stDistancia *pstdistancia)
{
 8003718:	b5b0      	push	{r4, r5, r7, lr}
 800371a:	b08a      	sub	sp, #40	; 0x28
 800371c:	af00      	add	r7, sp, #0
 800371e:	6078      	str	r0, [r7, #4]
 8003720:	6039      	str	r1, [r7, #0]
	uint8_t resultado = 0, sensor;
 8003722:	2327      	movs	r3, #39	; 0x27
 8003724:	18fb      	adds	r3, r7, r3
 8003726:	2200      	movs	r2, #0
 8003728:	701a      	strb	r2, [r3, #0]
	uint16_t dist, largo;
	float e1, e2, e3, e4, e5;

	sensor = pstdistancia->contParrilla;
 800372a:	2326      	movs	r3, #38	; 0x26
 800372c:	18fb      	adds	r3, r7, r3
 800372e:	683a      	ldr	r2, [r7, #0]
 8003730:	2166      	movs	r1, #102	; 0x66
 8003732:	5c52      	ldrb	r2, [r2, r1]
 8003734:	701a      	strb	r2, [r3, #0]
	dist = pstdistancia->datosDistancia[pstdistancia->contParrilla][pstcaptura->filaActual];
 8003736:	683b      	ldr	r3, [r7, #0]
 8003738:	2266      	movs	r2, #102	; 0x66
 800373a:	5c9b      	ldrb	r3, [r3, r2]
 800373c:	0018      	movs	r0, r3
 800373e:	687b      	ldr	r3, [r7, #4]
 8003740:	785b      	ldrb	r3, [r3, #1]
 8003742:	001c      	movs	r4, r3
 8003744:	2324      	movs	r3, #36	; 0x24
 8003746:	18fa      	adds	r2, r7, r3
 8003748:	6839      	ldr	r1, [r7, #0]
 800374a:	0003      	movs	r3, r0
 800374c:	009b      	lsls	r3, r3, #2
 800374e:	181b      	adds	r3, r3, r0
 8003750:	005b      	lsls	r3, r3, #1
 8003752:	191b      	adds	r3, r3, r4
 8003754:	3338      	adds	r3, #56	; 0x38
 8003756:	005b      	lsls	r3, r3, #1
 8003758:	18cb      	adds	r3, r1, r3
 800375a:	3302      	adds	r3, #2
 800375c:	881b      	ldrh	r3, [r3, #0]
 800375e:	8013      	strh	r3, [r2, #0]
	largo = pstcaptura->largo[pstdistancia->contParrilla][pstcaptura->filaActual];
 8003760:	683b      	ldr	r3, [r7, #0]
 8003762:	2266      	movs	r2, #102	; 0x66
 8003764:	5c9b      	ldrb	r3, [r3, r2]
 8003766:	0018      	movs	r0, r3
 8003768:	687b      	ldr	r3, [r7, #4]
 800376a:	785b      	ldrb	r3, [r3, #1]
 800376c:	001c      	movs	r4, r3
 800376e:	687a      	ldr	r2, [r7, #4]
 8003770:	2167      	movs	r1, #103	; 0x67
 8003772:	0003      	movs	r3, r0
 8003774:	009b      	lsls	r3, r3, #2
 8003776:	181b      	adds	r3, r3, r0
 8003778:	005b      	lsls	r3, r3, #1
 800377a:	18d3      	adds	r3, r2, r3
 800377c:	191b      	adds	r3, r3, r4
 800377e:	185b      	adds	r3, r3, r1
 8003780:	781a      	ldrb	r2, [r3, #0]
 8003782:	2322      	movs	r3, #34	; 0x22
 8003784:	18fb      	adds	r3, r7, r3
 8003786:	801a      	strh	r2, [r3, #0]
	e1=pstdistancia->datosDistancia[pstdistancia->contParrilla][pstcaptura->filaActual]*0.0309-36.803;
 8003788:	683b      	ldr	r3, [r7, #0]
 800378a:	2266      	movs	r2, #102	; 0x66
 800378c:	5c9b      	ldrb	r3, [r3, r2]
 800378e:	0019      	movs	r1, r3
 8003790:	687b      	ldr	r3, [r7, #4]
 8003792:	785b      	ldrb	r3, [r3, #1]
 8003794:	0018      	movs	r0, r3
 8003796:	683a      	ldr	r2, [r7, #0]
 8003798:	000b      	movs	r3, r1
 800379a:	009b      	lsls	r3, r3, #2
 800379c:	185b      	adds	r3, r3, r1
 800379e:	005b      	lsls	r3, r3, #1
 80037a0:	181b      	adds	r3, r3, r0
 80037a2:	3338      	adds	r3, #56	; 0x38
 80037a4:	005b      	lsls	r3, r3, #1
 80037a6:	18d3      	adds	r3, r2, r3
 80037a8:	3302      	adds	r3, #2
 80037aa:	881b      	ldrh	r3, [r3, #0]
 80037ac:	0018      	movs	r0, r3
 80037ae:	f7ff f9a1 	bl	8002af4 <__aeabi_i2d>
 80037b2:	4aeb      	ldr	r2, [pc, #940]	; (8003b60 <ConvertirDistancia+0x448>)
 80037b4:	4beb      	ldr	r3, [pc, #940]	; (8003b64 <ConvertirDistancia+0x44c>)
 80037b6:	f7fe fb91 	bl	8001edc <__aeabi_dmul>
 80037ba:	0003      	movs	r3, r0
 80037bc:	000c      	movs	r4, r1
 80037be:	0018      	movs	r0, r3
 80037c0:	0021      	movs	r1, r4
 80037c2:	4ae9      	ldr	r2, [pc, #932]	; (8003b68 <ConvertirDistancia+0x450>)
 80037c4:	4be9      	ldr	r3, [pc, #932]	; (8003b6c <ConvertirDistancia+0x454>)
 80037c6:	f7fe fdfb 	bl	80023c0 <__aeabi_dsub>
 80037ca:	0003      	movs	r3, r0
 80037cc:	000c      	movs	r4, r1
 80037ce:	0018      	movs	r0, r3
 80037d0:	0021      	movs	r1, r4
 80037d2:	f7ff f9fb 	bl	8002bcc <__aeabi_d2f>
 80037d6:	1c03      	adds	r3, r0, #0
 80037d8:	61fb      	str	r3, [r7, #28]
	e2=pstdistancia->datosDistancia[pstdistancia->contParrilla][pstcaptura->filaActual]*0.0583-42.687;
 80037da:	683b      	ldr	r3, [r7, #0]
 80037dc:	2266      	movs	r2, #102	; 0x66
 80037de:	5c9b      	ldrb	r3, [r3, r2]
 80037e0:	0019      	movs	r1, r3
 80037e2:	687b      	ldr	r3, [r7, #4]
 80037e4:	785b      	ldrb	r3, [r3, #1]
 80037e6:	0018      	movs	r0, r3
 80037e8:	683a      	ldr	r2, [r7, #0]
 80037ea:	000b      	movs	r3, r1
 80037ec:	009b      	lsls	r3, r3, #2
 80037ee:	185b      	adds	r3, r3, r1
 80037f0:	005b      	lsls	r3, r3, #1
 80037f2:	181b      	adds	r3, r3, r0
 80037f4:	3338      	adds	r3, #56	; 0x38
 80037f6:	005b      	lsls	r3, r3, #1
 80037f8:	18d3      	adds	r3, r2, r3
 80037fa:	3302      	adds	r3, #2
 80037fc:	881b      	ldrh	r3, [r3, #0]
 80037fe:	0018      	movs	r0, r3
 8003800:	f7ff f978 	bl	8002af4 <__aeabi_i2d>
 8003804:	4ada      	ldr	r2, [pc, #872]	; (8003b70 <ConvertirDistancia+0x458>)
 8003806:	4bdb      	ldr	r3, [pc, #876]	; (8003b74 <ConvertirDistancia+0x45c>)
 8003808:	f7fe fb68 	bl	8001edc <__aeabi_dmul>
 800380c:	0003      	movs	r3, r0
 800380e:	000c      	movs	r4, r1
 8003810:	0018      	movs	r0, r3
 8003812:	0021      	movs	r1, r4
 8003814:	4ad8      	ldr	r2, [pc, #864]	; (8003b78 <ConvertirDistancia+0x460>)
 8003816:	4bd9      	ldr	r3, [pc, #868]	; (8003b7c <ConvertirDistancia+0x464>)
 8003818:	f7fe fdd2 	bl	80023c0 <__aeabi_dsub>
 800381c:	0003      	movs	r3, r0
 800381e:	000c      	movs	r4, r1
 8003820:	0018      	movs	r0, r3
 8003822:	0021      	movs	r1, r4
 8003824:	f7ff f9d2 	bl	8002bcc <__aeabi_d2f>
 8003828:	1c03      	adds	r3, r0, #0
 800382a:	61bb      	str	r3, [r7, #24]
	e3=pstdistancia->datosDistancia[pstdistancia->contParrilla][pstcaptura->filaActual]*-0.0067-23.071;
 800382c:	683b      	ldr	r3, [r7, #0]
 800382e:	2266      	movs	r2, #102	; 0x66
 8003830:	5c9b      	ldrb	r3, [r3, r2]
 8003832:	0019      	movs	r1, r3
 8003834:	687b      	ldr	r3, [r7, #4]
 8003836:	785b      	ldrb	r3, [r3, #1]
 8003838:	0018      	movs	r0, r3
 800383a:	683a      	ldr	r2, [r7, #0]
 800383c:	000b      	movs	r3, r1
 800383e:	009b      	lsls	r3, r3, #2
 8003840:	185b      	adds	r3, r3, r1
 8003842:	005b      	lsls	r3, r3, #1
 8003844:	181b      	adds	r3, r3, r0
 8003846:	3338      	adds	r3, #56	; 0x38
 8003848:	005b      	lsls	r3, r3, #1
 800384a:	18d3      	adds	r3, r2, r3
 800384c:	3302      	adds	r3, #2
 800384e:	881b      	ldrh	r3, [r3, #0]
 8003850:	0018      	movs	r0, r3
 8003852:	f7ff f94f 	bl	8002af4 <__aeabi_i2d>
 8003856:	4aca      	ldr	r2, [pc, #808]	; (8003b80 <ConvertirDistancia+0x468>)
 8003858:	4bca      	ldr	r3, [pc, #808]	; (8003b84 <ConvertirDistancia+0x46c>)
 800385a:	f7fe fb3f 	bl	8001edc <__aeabi_dmul>
 800385e:	0003      	movs	r3, r0
 8003860:	000c      	movs	r4, r1
 8003862:	0018      	movs	r0, r3
 8003864:	0021      	movs	r1, r4
 8003866:	4ac8      	ldr	r2, [pc, #800]	; (8003b88 <ConvertirDistancia+0x470>)
 8003868:	4bc8      	ldr	r3, [pc, #800]	; (8003b8c <ConvertirDistancia+0x474>)
 800386a:	f7fe fda9 	bl	80023c0 <__aeabi_dsub>
 800386e:	0003      	movs	r3, r0
 8003870:	000c      	movs	r4, r1
 8003872:	0018      	movs	r0, r3
 8003874:	0021      	movs	r1, r4
 8003876:	f7ff f9a9 	bl	8002bcc <__aeabi_d2f>
 800387a:	1c03      	adds	r3, r0, #0
 800387c:	617b      	str	r3, [r7, #20]
	e4=pstdistancia->datosDistancia[pstdistancia->contParrilla][pstcaptura->filaActual]*0.0192-24.945;
 800387e:	683b      	ldr	r3, [r7, #0]
 8003880:	2266      	movs	r2, #102	; 0x66
 8003882:	5c9b      	ldrb	r3, [r3, r2]
 8003884:	0019      	movs	r1, r3
 8003886:	687b      	ldr	r3, [r7, #4]
 8003888:	785b      	ldrb	r3, [r3, #1]
 800388a:	0018      	movs	r0, r3
 800388c:	683a      	ldr	r2, [r7, #0]
 800388e:	000b      	movs	r3, r1
 8003890:	009b      	lsls	r3, r3, #2
 8003892:	185b      	adds	r3, r3, r1
 8003894:	005b      	lsls	r3, r3, #1
 8003896:	181b      	adds	r3, r3, r0
 8003898:	3338      	adds	r3, #56	; 0x38
 800389a:	005b      	lsls	r3, r3, #1
 800389c:	18d3      	adds	r3, r2, r3
 800389e:	3302      	adds	r3, #2
 80038a0:	881b      	ldrh	r3, [r3, #0]
 80038a2:	0018      	movs	r0, r3
 80038a4:	f7ff f926 	bl	8002af4 <__aeabi_i2d>
 80038a8:	4ab9      	ldr	r2, [pc, #740]	; (8003b90 <ConvertirDistancia+0x478>)
 80038aa:	4bba      	ldr	r3, [pc, #744]	; (8003b94 <ConvertirDistancia+0x47c>)
 80038ac:	f7fe fb16 	bl	8001edc <__aeabi_dmul>
 80038b0:	0003      	movs	r3, r0
 80038b2:	000c      	movs	r4, r1
 80038b4:	0018      	movs	r0, r3
 80038b6:	0021      	movs	r1, r4
 80038b8:	4ab7      	ldr	r2, [pc, #732]	; (8003b98 <ConvertirDistancia+0x480>)
 80038ba:	4bb8      	ldr	r3, [pc, #736]	; (8003b9c <ConvertirDistancia+0x484>)
 80038bc:	f7fe fd80 	bl	80023c0 <__aeabi_dsub>
 80038c0:	0003      	movs	r3, r0
 80038c2:	000c      	movs	r4, r1
 80038c4:	0018      	movs	r0, r3
 80038c6:	0021      	movs	r1, r4
 80038c8:	f7ff f980 	bl	8002bcc <__aeabi_d2f>
 80038cc:	1c03      	adds	r3, r0, #0
 80038ce:	613b      	str	r3, [r7, #16]
	e5=pstdistancia->datosDistancia[pstdistancia->contParrilla][pstcaptura->filaActual]*0.0177-26.045;
 80038d0:	683b      	ldr	r3, [r7, #0]
 80038d2:	2266      	movs	r2, #102	; 0x66
 80038d4:	5c9b      	ldrb	r3, [r3, r2]
 80038d6:	0019      	movs	r1, r3
 80038d8:	687b      	ldr	r3, [r7, #4]
 80038da:	785b      	ldrb	r3, [r3, #1]
 80038dc:	0018      	movs	r0, r3
 80038de:	683a      	ldr	r2, [r7, #0]
 80038e0:	000b      	movs	r3, r1
 80038e2:	009b      	lsls	r3, r3, #2
 80038e4:	185b      	adds	r3, r3, r1
 80038e6:	005b      	lsls	r3, r3, #1
 80038e8:	181b      	adds	r3, r3, r0
 80038ea:	3338      	adds	r3, #56	; 0x38
 80038ec:	005b      	lsls	r3, r3, #1
 80038ee:	18d3      	adds	r3, r2, r3
 80038f0:	3302      	adds	r3, #2
 80038f2:	881b      	ldrh	r3, [r3, #0]
 80038f4:	0018      	movs	r0, r3
 80038f6:	f7ff f8fd 	bl	8002af4 <__aeabi_i2d>
 80038fa:	4aa9      	ldr	r2, [pc, #676]	; (8003ba0 <ConvertirDistancia+0x488>)
 80038fc:	4ba9      	ldr	r3, [pc, #676]	; (8003ba4 <ConvertirDistancia+0x48c>)
 80038fe:	f7fe faed 	bl	8001edc <__aeabi_dmul>
 8003902:	0003      	movs	r3, r0
 8003904:	000c      	movs	r4, r1
 8003906:	0018      	movs	r0, r3
 8003908:	0021      	movs	r1, r4
 800390a:	4aa7      	ldr	r2, [pc, #668]	; (8003ba8 <ConvertirDistancia+0x490>)
 800390c:	4ba7      	ldr	r3, [pc, #668]	; (8003bac <ConvertirDistancia+0x494>)
 800390e:	f7fe fd57 	bl	80023c0 <__aeabi_dsub>
 8003912:	0003      	movs	r3, r0
 8003914:	000c      	movs	r4, r1
 8003916:	0018      	movs	r0, r3
 8003918:	0021      	movs	r1, r4
 800391a:	f7ff f957 	bl	8002bcc <__aeabi_d2f>
 800391e:	1c03      	adds	r3, r0, #0
 8003920:	60fb      	str	r3, [r7, #12]
//		}
//	}



	if(pstdistancia->datosDistancia[pstdistancia->contParrilla][pstcaptura->filaActual] > 400){
 8003922:	683b      	ldr	r3, [r7, #0]
 8003924:	2266      	movs	r2, #102	; 0x66
 8003926:	5c9b      	ldrb	r3, [r3, r2]
 8003928:	0019      	movs	r1, r3
 800392a:	687b      	ldr	r3, [r7, #4]
 800392c:	785b      	ldrb	r3, [r3, #1]
 800392e:	0018      	movs	r0, r3
 8003930:	683a      	ldr	r2, [r7, #0]
 8003932:	000b      	movs	r3, r1
 8003934:	009b      	lsls	r3, r3, #2
 8003936:	185b      	adds	r3, r3, r1
 8003938:	005b      	lsls	r3, r3, #1
 800393a:	181b      	adds	r3, r3, r0
 800393c:	3338      	adds	r3, #56	; 0x38
 800393e:	005b      	lsls	r3, r3, #1
 8003940:	18d3      	adds	r3, r2, r3
 8003942:	3302      	adds	r3, #2
 8003944:	881a      	ldrh	r2, [r3, #0]
 8003946:	23c8      	movs	r3, #200	; 0xc8
 8003948:	005b      	lsls	r3, r3, #1
 800394a:	429a      	cmp	r2, r3
 800394c:	d904      	bls.n	8003958 <ConvertirDistancia+0x240>
		resultado = 0;
 800394e:	2327      	movs	r3, #39	; 0x27
 8003950:	18fb      	adds	r3, r7, r3
 8003952:	2200      	movs	r2, #0
 8003954:	701a      	strb	r2, [r3, #0]
 8003956:	e1a9      	b.n	8003cac <ConvertirDistancia+0x594>
	}else{
		switch(sensor){
 8003958:	2326      	movs	r3, #38	; 0x26
 800395a:	18fb      	adds	r3, r7, r3
 800395c:	781b      	ldrb	r3, [r3, #0]
 800395e:	2b04      	cmp	r3, #4
 8003960:	d900      	bls.n	8003964 <ConvertirDistancia+0x24c>
 8003962:	e165      	b.n	8003c30 <ConvertirDistancia+0x518>
 8003964:	009a      	lsls	r2, r3, #2
 8003966:	4b92      	ldr	r3, [pc, #584]	; (8003bb0 <ConvertirDistancia+0x498>)
 8003968:	18d3      	adds	r3, r2, r3
 800396a:	681b      	ldr	r3, [r3, #0]
 800396c:	469f      	mov	pc, r3
		case 0:
			resultado = (pstcaptura->Distancia*10-(dist+CORR_DIST-e1)+largo) / largo;
 800396e:	687b      	ldr	r3, [r7, #4]
 8003970:	789b      	ldrb	r3, [r3, #2]
 8003972:	001a      	movs	r2, r3
 8003974:	0013      	movs	r3, r2
 8003976:	009b      	lsls	r3, r3, #2
 8003978:	189b      	adds	r3, r3, r2
 800397a:	005b      	lsls	r3, r3, #1
 800397c:	0018      	movs	r0, r3
 800397e:	f7fd fb3d 	bl	8000ffc <__aeabi_i2f>
 8003982:	1c04      	adds	r4, r0, #0
 8003984:	2324      	movs	r3, #36	; 0x24
 8003986:	18fb      	adds	r3, r7, r3
 8003988:	881b      	ldrh	r3, [r3, #0]
 800398a:	3b1b      	subs	r3, #27
 800398c:	0018      	movs	r0, r3
 800398e:	f7fd fb35 	bl	8000ffc <__aeabi_i2f>
 8003992:	1c03      	adds	r3, r0, #0
 8003994:	69f9      	ldr	r1, [r7, #28]
 8003996:	1c18      	adds	r0, r3, #0
 8003998:	f7fd f94c 	bl	8000c34 <__aeabi_fsub>
 800399c:	1c03      	adds	r3, r0, #0
 800399e:	1c19      	adds	r1, r3, #0
 80039a0:	1c20      	adds	r0, r4, #0
 80039a2:	f7fd f947 	bl	8000c34 <__aeabi_fsub>
 80039a6:	1c03      	adds	r3, r0, #0
 80039a8:	1c1c      	adds	r4, r3, #0
 80039aa:	2522      	movs	r5, #34	; 0x22
 80039ac:	197b      	adds	r3, r7, r5
 80039ae:	881b      	ldrh	r3, [r3, #0]
 80039b0:	0018      	movs	r0, r3
 80039b2:	f7fd fb23 	bl	8000ffc <__aeabi_i2f>
 80039b6:	1c03      	adds	r3, r0, #0
 80039b8:	1c19      	adds	r1, r3, #0
 80039ba:	1c20      	adds	r0, r4, #0
 80039bc:	f7fc fe8e 	bl	80006dc <__aeabi_fadd>
 80039c0:	1c03      	adds	r3, r0, #0
 80039c2:	1c1c      	adds	r4, r3, #0
 80039c4:	197b      	adds	r3, r7, r5
 80039c6:	881b      	ldrh	r3, [r3, #0]
 80039c8:	0018      	movs	r0, r3
 80039ca:	f7fd fb17 	bl	8000ffc <__aeabi_i2f>
 80039ce:	1c03      	adds	r3, r0, #0
 80039d0:	1c19      	adds	r1, r3, #0
 80039d2:	1c20      	adds	r0, r4, #0
 80039d4:	f7fd f81c 	bl	8000a10 <__aeabi_fdiv>
 80039d8:	1c03      	adds	r3, r0, #0
 80039da:	2227      	movs	r2, #39	; 0x27
 80039dc:	18bc      	adds	r4, r7, r2
 80039de:	1c18      	adds	r0, r3, #0
 80039e0:	f7fc fda2 	bl	8000528 <__aeabi_f2uiz>
 80039e4:	0003      	movs	r3, r0
 80039e6:	7023      	strb	r3, [r4, #0]
			break;
 80039e8:	e160      	b.n	8003cac <ConvertirDistancia+0x594>
		case 1:
			resultado = (pstcaptura->Distancia*10-(dist+CORR_DIST-e2)+largo) / largo;
 80039ea:	687b      	ldr	r3, [r7, #4]
 80039ec:	789b      	ldrb	r3, [r3, #2]
 80039ee:	001a      	movs	r2, r3
 80039f0:	0013      	movs	r3, r2
 80039f2:	009b      	lsls	r3, r3, #2
 80039f4:	189b      	adds	r3, r3, r2
 80039f6:	005b      	lsls	r3, r3, #1
 80039f8:	0018      	movs	r0, r3
 80039fa:	f7fd faff 	bl	8000ffc <__aeabi_i2f>
 80039fe:	1c04      	adds	r4, r0, #0
 8003a00:	2324      	movs	r3, #36	; 0x24
 8003a02:	18fb      	adds	r3, r7, r3
 8003a04:	881b      	ldrh	r3, [r3, #0]
 8003a06:	3b1b      	subs	r3, #27
 8003a08:	0018      	movs	r0, r3
 8003a0a:	f7fd faf7 	bl	8000ffc <__aeabi_i2f>
 8003a0e:	1c03      	adds	r3, r0, #0
 8003a10:	69b9      	ldr	r1, [r7, #24]
 8003a12:	1c18      	adds	r0, r3, #0
 8003a14:	f7fd f90e 	bl	8000c34 <__aeabi_fsub>
 8003a18:	1c03      	adds	r3, r0, #0
 8003a1a:	1c19      	adds	r1, r3, #0
 8003a1c:	1c20      	adds	r0, r4, #0
 8003a1e:	f7fd f909 	bl	8000c34 <__aeabi_fsub>
 8003a22:	1c03      	adds	r3, r0, #0
 8003a24:	1c1c      	adds	r4, r3, #0
 8003a26:	2522      	movs	r5, #34	; 0x22
 8003a28:	197b      	adds	r3, r7, r5
 8003a2a:	881b      	ldrh	r3, [r3, #0]
 8003a2c:	0018      	movs	r0, r3
 8003a2e:	f7fd fae5 	bl	8000ffc <__aeabi_i2f>
 8003a32:	1c03      	adds	r3, r0, #0
 8003a34:	1c19      	adds	r1, r3, #0
 8003a36:	1c20      	adds	r0, r4, #0
 8003a38:	f7fc fe50 	bl	80006dc <__aeabi_fadd>
 8003a3c:	1c03      	adds	r3, r0, #0
 8003a3e:	1c1c      	adds	r4, r3, #0
 8003a40:	197b      	adds	r3, r7, r5
 8003a42:	881b      	ldrh	r3, [r3, #0]
 8003a44:	0018      	movs	r0, r3
 8003a46:	f7fd fad9 	bl	8000ffc <__aeabi_i2f>
 8003a4a:	1c03      	adds	r3, r0, #0
 8003a4c:	1c19      	adds	r1, r3, #0
 8003a4e:	1c20      	adds	r0, r4, #0
 8003a50:	f7fc ffde 	bl	8000a10 <__aeabi_fdiv>
 8003a54:	1c03      	adds	r3, r0, #0
 8003a56:	2227      	movs	r2, #39	; 0x27
 8003a58:	18bc      	adds	r4, r7, r2
 8003a5a:	1c18      	adds	r0, r3, #0
 8003a5c:	f7fc fd64 	bl	8000528 <__aeabi_f2uiz>
 8003a60:	0003      	movs	r3, r0
 8003a62:	7023      	strb	r3, [r4, #0]
			break;
 8003a64:	e122      	b.n	8003cac <ConvertirDistancia+0x594>
		case 2:
			resultado = (pstcaptura->Distancia*10-(dist+CORR_DIST-e3)+largo) / largo;
 8003a66:	687b      	ldr	r3, [r7, #4]
 8003a68:	789b      	ldrb	r3, [r3, #2]
 8003a6a:	001a      	movs	r2, r3
 8003a6c:	0013      	movs	r3, r2
 8003a6e:	009b      	lsls	r3, r3, #2
 8003a70:	189b      	adds	r3, r3, r2
 8003a72:	005b      	lsls	r3, r3, #1
 8003a74:	0018      	movs	r0, r3
 8003a76:	f7fd fac1 	bl	8000ffc <__aeabi_i2f>
 8003a7a:	1c04      	adds	r4, r0, #0
 8003a7c:	2324      	movs	r3, #36	; 0x24
 8003a7e:	18fb      	adds	r3, r7, r3
 8003a80:	881b      	ldrh	r3, [r3, #0]
 8003a82:	3b1b      	subs	r3, #27
 8003a84:	0018      	movs	r0, r3
 8003a86:	f7fd fab9 	bl	8000ffc <__aeabi_i2f>
 8003a8a:	1c03      	adds	r3, r0, #0
 8003a8c:	6979      	ldr	r1, [r7, #20]
 8003a8e:	1c18      	adds	r0, r3, #0
 8003a90:	f7fd f8d0 	bl	8000c34 <__aeabi_fsub>
 8003a94:	1c03      	adds	r3, r0, #0
 8003a96:	1c19      	adds	r1, r3, #0
 8003a98:	1c20      	adds	r0, r4, #0
 8003a9a:	f7fd f8cb 	bl	8000c34 <__aeabi_fsub>
 8003a9e:	1c03      	adds	r3, r0, #0
 8003aa0:	1c1c      	adds	r4, r3, #0
 8003aa2:	2522      	movs	r5, #34	; 0x22
 8003aa4:	197b      	adds	r3, r7, r5
 8003aa6:	881b      	ldrh	r3, [r3, #0]
 8003aa8:	0018      	movs	r0, r3
 8003aaa:	f7fd faa7 	bl	8000ffc <__aeabi_i2f>
 8003aae:	1c03      	adds	r3, r0, #0
 8003ab0:	1c19      	adds	r1, r3, #0
 8003ab2:	1c20      	adds	r0, r4, #0
 8003ab4:	f7fc fe12 	bl	80006dc <__aeabi_fadd>
 8003ab8:	1c03      	adds	r3, r0, #0
 8003aba:	1c1c      	adds	r4, r3, #0
 8003abc:	197b      	adds	r3, r7, r5
 8003abe:	881b      	ldrh	r3, [r3, #0]
 8003ac0:	0018      	movs	r0, r3
 8003ac2:	f7fd fa9b 	bl	8000ffc <__aeabi_i2f>
 8003ac6:	1c03      	adds	r3, r0, #0
 8003ac8:	1c19      	adds	r1, r3, #0
 8003aca:	1c20      	adds	r0, r4, #0
 8003acc:	f7fc ffa0 	bl	8000a10 <__aeabi_fdiv>
 8003ad0:	1c03      	adds	r3, r0, #0
 8003ad2:	2227      	movs	r2, #39	; 0x27
 8003ad4:	18bc      	adds	r4, r7, r2
 8003ad6:	1c18      	adds	r0, r3, #0
 8003ad8:	f7fc fd26 	bl	8000528 <__aeabi_f2uiz>
 8003adc:	0003      	movs	r3, r0
 8003ade:	7023      	strb	r3, [r4, #0]
			break;
 8003ae0:	e0e4      	b.n	8003cac <ConvertirDistancia+0x594>
		case 3:
			resultado = (pstcaptura->Distancia*10-(dist+CORR_DIST-e4)+largo) / largo;
 8003ae2:	687b      	ldr	r3, [r7, #4]
 8003ae4:	789b      	ldrb	r3, [r3, #2]
 8003ae6:	001a      	movs	r2, r3
 8003ae8:	0013      	movs	r3, r2
 8003aea:	009b      	lsls	r3, r3, #2
 8003aec:	189b      	adds	r3, r3, r2
 8003aee:	005b      	lsls	r3, r3, #1
 8003af0:	0018      	movs	r0, r3
 8003af2:	f7fd fa83 	bl	8000ffc <__aeabi_i2f>
 8003af6:	1c04      	adds	r4, r0, #0
 8003af8:	2324      	movs	r3, #36	; 0x24
 8003afa:	18fb      	adds	r3, r7, r3
 8003afc:	881b      	ldrh	r3, [r3, #0]
 8003afe:	3b1b      	subs	r3, #27
 8003b00:	0018      	movs	r0, r3
 8003b02:	f7fd fa7b 	bl	8000ffc <__aeabi_i2f>
 8003b06:	1c03      	adds	r3, r0, #0
 8003b08:	6939      	ldr	r1, [r7, #16]
 8003b0a:	1c18      	adds	r0, r3, #0
 8003b0c:	f7fd f892 	bl	8000c34 <__aeabi_fsub>
 8003b10:	1c03      	adds	r3, r0, #0
 8003b12:	1c19      	adds	r1, r3, #0
 8003b14:	1c20      	adds	r0, r4, #0
 8003b16:	f7fd f88d 	bl	8000c34 <__aeabi_fsub>
 8003b1a:	1c03      	adds	r3, r0, #0
 8003b1c:	1c1c      	adds	r4, r3, #0
 8003b1e:	2522      	movs	r5, #34	; 0x22
 8003b20:	197b      	adds	r3, r7, r5
 8003b22:	881b      	ldrh	r3, [r3, #0]
 8003b24:	0018      	movs	r0, r3
 8003b26:	f7fd fa69 	bl	8000ffc <__aeabi_i2f>
 8003b2a:	1c03      	adds	r3, r0, #0
 8003b2c:	1c19      	adds	r1, r3, #0
 8003b2e:	1c20      	adds	r0, r4, #0
 8003b30:	f7fc fdd4 	bl	80006dc <__aeabi_fadd>
 8003b34:	1c03      	adds	r3, r0, #0
 8003b36:	1c1c      	adds	r4, r3, #0
 8003b38:	197b      	adds	r3, r7, r5
 8003b3a:	881b      	ldrh	r3, [r3, #0]
 8003b3c:	0018      	movs	r0, r3
 8003b3e:	f7fd fa5d 	bl	8000ffc <__aeabi_i2f>
 8003b42:	1c03      	adds	r3, r0, #0
 8003b44:	1c19      	adds	r1, r3, #0
 8003b46:	1c20      	adds	r0, r4, #0
 8003b48:	f7fc ff62 	bl	8000a10 <__aeabi_fdiv>
 8003b4c:	1c03      	adds	r3, r0, #0
 8003b4e:	2227      	movs	r2, #39	; 0x27
 8003b50:	18bc      	adds	r4, r7, r2
 8003b52:	1c18      	adds	r0, r3, #0
 8003b54:	f7fc fce8 	bl	8000528 <__aeabi_f2uiz>
 8003b58:	0003      	movs	r3, r0
 8003b5a:	7023      	strb	r3, [r4, #0]
			break;
 8003b5c:	e0a6      	b.n	8003cac <ConvertirDistancia+0x594>
 8003b5e:	46c0      	nop			; (mov r8, r8)
 8003b60:	e5c91d15 	.word	0xe5c91d15
 8003b64:	3f9fa43f 	.word	0x3f9fa43f
 8003b68:	b4395810 	.word	0xb4395810
 8003b6c:	404266c8 	.word	0x404266c8
 8003b70:	62b6ae7d 	.word	0x62b6ae7d
 8003b74:	3fadd97f 	.word	0x3fadd97f
 8003b78:	9db22d0e 	.word	0x9db22d0e
 8003b7c:	404557ef 	.word	0x404557ef
 8003b80:	8e219653 	.word	0x8e219653
 8003b84:	bf7b7175 	.word	0xbf7b7175
 8003b88:	0e560419 	.word	0x0e560419
 8003b8c:	4037122d 	.word	0x4037122d
 8003b90:	30553261 	.word	0x30553261
 8003b94:	3f93a92a 	.word	0x3f93a92a
 8003b98:	851eb852 	.word	0x851eb852
 8003b9c:	4038f1eb 	.word	0x4038f1eb
 8003ba0:	e48e8a72 	.word	0xe48e8a72
 8003ba4:	3f921ff2 	.word	0x3f921ff2
 8003ba8:	1eb851ec 	.word	0x1eb851ec
 8003bac:	403a0b85 	.word	0x403a0b85
 8003bb0:	08014e58 	.word	0x08014e58
		case 4:
			resultado = (pstcaptura->Distancia*10-(dist+CORR_DIST-e5)+largo) / largo;
 8003bb4:	687b      	ldr	r3, [r7, #4]
 8003bb6:	789b      	ldrb	r3, [r3, #2]
 8003bb8:	001a      	movs	r2, r3
 8003bba:	0013      	movs	r3, r2
 8003bbc:	009b      	lsls	r3, r3, #2
 8003bbe:	189b      	adds	r3, r3, r2
 8003bc0:	005b      	lsls	r3, r3, #1
 8003bc2:	0018      	movs	r0, r3
 8003bc4:	f7fd fa1a 	bl	8000ffc <__aeabi_i2f>
 8003bc8:	1c04      	adds	r4, r0, #0
 8003bca:	2324      	movs	r3, #36	; 0x24
 8003bcc:	18fb      	adds	r3, r7, r3
 8003bce:	881b      	ldrh	r3, [r3, #0]
 8003bd0:	3b1b      	subs	r3, #27
 8003bd2:	0018      	movs	r0, r3
 8003bd4:	f7fd fa12 	bl	8000ffc <__aeabi_i2f>
 8003bd8:	1c03      	adds	r3, r0, #0
 8003bda:	68f9      	ldr	r1, [r7, #12]
 8003bdc:	1c18      	adds	r0, r3, #0
 8003bde:	f7fd f829 	bl	8000c34 <__aeabi_fsub>
 8003be2:	1c03      	adds	r3, r0, #0
 8003be4:	1c19      	adds	r1, r3, #0
 8003be6:	1c20      	adds	r0, r4, #0
 8003be8:	f7fd f824 	bl	8000c34 <__aeabi_fsub>
 8003bec:	1c03      	adds	r3, r0, #0
 8003bee:	1c1c      	adds	r4, r3, #0
 8003bf0:	2522      	movs	r5, #34	; 0x22
 8003bf2:	197b      	adds	r3, r7, r5
 8003bf4:	881b      	ldrh	r3, [r3, #0]
 8003bf6:	0018      	movs	r0, r3
 8003bf8:	f7fd fa00 	bl	8000ffc <__aeabi_i2f>
 8003bfc:	1c03      	adds	r3, r0, #0
 8003bfe:	1c19      	adds	r1, r3, #0
 8003c00:	1c20      	adds	r0, r4, #0
 8003c02:	f7fc fd6b 	bl	80006dc <__aeabi_fadd>
 8003c06:	1c03      	adds	r3, r0, #0
 8003c08:	1c1c      	adds	r4, r3, #0
 8003c0a:	197b      	adds	r3, r7, r5
 8003c0c:	881b      	ldrh	r3, [r3, #0]
 8003c0e:	0018      	movs	r0, r3
 8003c10:	f7fd f9f4 	bl	8000ffc <__aeabi_i2f>
 8003c14:	1c03      	adds	r3, r0, #0
 8003c16:	1c19      	adds	r1, r3, #0
 8003c18:	1c20      	adds	r0, r4, #0
 8003c1a:	f7fc fef9 	bl	8000a10 <__aeabi_fdiv>
 8003c1e:	1c03      	adds	r3, r0, #0
 8003c20:	2227      	movs	r2, #39	; 0x27
 8003c22:	18bc      	adds	r4, r7, r2
 8003c24:	1c18      	adds	r0, r3, #0
 8003c26:	f7fc fc7f 	bl	8000528 <__aeabi_f2uiz>
 8003c2a:	0003      	movs	r3, r0
 8003c2c:	7023      	strb	r3, [r4, #0]
			break;
 8003c2e:	e03d      	b.n	8003cac <ConvertirDistancia+0x594>
		default:
			resultado = (pstcaptura->Distancia*10-(dist+CORR_DIST-e1)+largo) / largo;
 8003c30:	687b      	ldr	r3, [r7, #4]
 8003c32:	789b      	ldrb	r3, [r3, #2]
 8003c34:	001a      	movs	r2, r3
 8003c36:	0013      	movs	r3, r2
 8003c38:	009b      	lsls	r3, r3, #2
 8003c3a:	189b      	adds	r3, r3, r2
 8003c3c:	005b      	lsls	r3, r3, #1
 8003c3e:	0018      	movs	r0, r3
 8003c40:	f7fd f9dc 	bl	8000ffc <__aeabi_i2f>
 8003c44:	1c04      	adds	r4, r0, #0
 8003c46:	2324      	movs	r3, #36	; 0x24
 8003c48:	18fb      	adds	r3, r7, r3
 8003c4a:	881b      	ldrh	r3, [r3, #0]
 8003c4c:	3b1b      	subs	r3, #27
 8003c4e:	0018      	movs	r0, r3
 8003c50:	f7fd f9d4 	bl	8000ffc <__aeabi_i2f>
 8003c54:	1c03      	adds	r3, r0, #0
 8003c56:	69f9      	ldr	r1, [r7, #28]
 8003c58:	1c18      	adds	r0, r3, #0
 8003c5a:	f7fc ffeb 	bl	8000c34 <__aeabi_fsub>
 8003c5e:	1c03      	adds	r3, r0, #0
 8003c60:	1c19      	adds	r1, r3, #0
 8003c62:	1c20      	adds	r0, r4, #0
 8003c64:	f7fc ffe6 	bl	8000c34 <__aeabi_fsub>
 8003c68:	1c03      	adds	r3, r0, #0
 8003c6a:	1c1c      	adds	r4, r3, #0
 8003c6c:	2522      	movs	r5, #34	; 0x22
 8003c6e:	197b      	adds	r3, r7, r5
 8003c70:	881b      	ldrh	r3, [r3, #0]
 8003c72:	0018      	movs	r0, r3
 8003c74:	f7fd f9c2 	bl	8000ffc <__aeabi_i2f>
 8003c78:	1c03      	adds	r3, r0, #0
 8003c7a:	1c19      	adds	r1, r3, #0
 8003c7c:	1c20      	adds	r0, r4, #0
 8003c7e:	f7fc fd2d 	bl	80006dc <__aeabi_fadd>
 8003c82:	1c03      	adds	r3, r0, #0
 8003c84:	1c1c      	adds	r4, r3, #0
 8003c86:	197b      	adds	r3, r7, r5
 8003c88:	881b      	ldrh	r3, [r3, #0]
 8003c8a:	0018      	movs	r0, r3
 8003c8c:	f7fd f9b6 	bl	8000ffc <__aeabi_i2f>
 8003c90:	1c03      	adds	r3, r0, #0
 8003c92:	1c19      	adds	r1, r3, #0
 8003c94:	1c20      	adds	r0, r4, #0
 8003c96:	f7fc febb 	bl	8000a10 <__aeabi_fdiv>
 8003c9a:	1c03      	adds	r3, r0, #0
 8003c9c:	2227      	movs	r2, #39	; 0x27
 8003c9e:	18bc      	adds	r4, r7, r2
 8003ca0:	1c18      	adds	r0, r3, #0
 8003ca2:	f7fc fc41 	bl	8000528 <__aeabi_f2uiz>
 8003ca6:	0003      	movs	r3, r0
 8003ca8:	7023      	strb	r3, [r4, #0]
			break;
 8003caa:	46c0      	nop			; (mov r8, r8)
		}
	}

//	resultado = (pstcaptura->Distancia*10-pstdistancia->datosDistancia[pstdistancia->contParrilla][pstcaptura->filaActual]+pstcaptura->largo[pstdistancia->contParrilla][pstcaptura->filaActual]) / pstcaptura->largo[pstdistancia->contParrilla][pstcaptura->filaActual];

	return resultado;
 8003cac:	2327      	movs	r3, #39	; 0x27
 8003cae:	18fb      	adds	r3, r7, r3
 8003cb0:	781b      	ldrb	r3, [r3, #0]
}
 8003cb2:	0018      	movs	r0, r3
 8003cb4:	46bd      	mov	sp, r7
 8003cb6:	b00a      	add	sp, #40	; 0x28
 8003cb8:	bdb0      	pop	{r4, r5, r7, pc}
 8003cba:	46c0      	nop			; (mov r8, r8)

08003cbc <BloqueCOM_CEIT>:
Salidas:          		N/A
Descripción:  		    Ejecuta la Máquina de Estados del bloque COM_CEIT
Notas y Cambios:  
****************************************************************************************/
void BloqueCOM_CEIT(stComCEIT *pstcomceit)
{
 8003cbc:	b580      	push	{r7, lr}
 8003cbe:	b084      	sub	sp, #16
 8003cc0:	af00      	add	r7, sp, #0
 8003cc2:	6078      	str	r0, [r7, #4]
	int i;
  
  switch(pstcomceit->SM_State)
 8003cc4:	687b      	ldr	r3, [r7, #4]
 8003cc6:	781b      	ldrb	r3, [r3, #0]
 8003cc8:	2b04      	cmp	r3, #4
 8003cca:	d900      	bls.n	8003cce <BloqueCOM_CEIT+0x12>
 8003ccc:	e0b9      	b.n	8003e42 <BloqueCOM_CEIT+0x186>
 8003cce:	009a      	lsls	r2, r3, #2
 8003cd0:	4b5e      	ldr	r3, [pc, #376]	; (8003e4c <BloqueCOM_CEIT+0x190>)
 8003cd2:	18d3      	adds	r3, r2, r3
 8003cd4:	681b      	ldr	r3, [r3, #0]
 8003cd6:	469f      	mov	pc, r3
  {
		case SM_STATE_START_RX:      
      /* wait for data received or timeout period occured */
			pstcomceit->SM_State = SM_STATE_WAIT_FOR_RX_DONE;
 8003cd8:	687b      	ldr	r3, [r7, #4]
 8003cda:	2201      	movs	r2, #1
 8003cdc:	701a      	strb	r2, [r3, #0]
		break;
 8003cde:	e0b0      	b.n	8003e42 <BloqueCOM_CEIT+0x186>
    
		case SM_STATE_WAIT_FOR_RX_DONE:
			if((pstcomceit->xRxDoneFlag != RESET))
 8003ce0:	687b      	ldr	r3, [r7, #4]
 8003ce2:	791b      	ldrb	r3, [r3, #4]
 8003ce4:	2b00      	cmp	r3, #0
 8003ce6:	d003      	beq.n	8003cf0 <BloqueCOM_CEIT+0x34>
			{
//				pstcomceit->xRxDoneFlag = RESET;
				pstcomceit->SM_State = SM_STATE_DATA_RECEIVED;
 8003ce8:	687b      	ldr	r3, [r7, #4]
 8003cea:	2202      	movs	r2, #2
 8003cec:	701a      	strb	r2, [r3, #0]
			}
			else
			{
				pstcomceit->SM_State = SM_STATE_START_RX;
			}
		break;
 8003cee:	e0a8      	b.n	8003e42 <BloqueCOM_CEIT+0x186>
				pstcomceit->SM_State = SM_STATE_START_RX;
 8003cf0:	687b      	ldr	r3, [r7, #4]
 8003cf2:	2200      	movs	r2, #0
 8003cf4:	701a      	strb	r2, [r3, #0]
		break;
 8003cf6:	e0a4      	b.n	8003e42 <BloqueCOM_CEIT+0x186>
    
		case SM_STATE_DATA_RECEIVED:  

			if((pstcomceit->Rx_Buffer[CMD] == GET_DATA) || (pstcomceit->Rx_Buffer[CMD] == CONFIG))
 8003cf8:	687b      	ldr	r3, [r7, #4]
 8003cfa:	2274      	movs	r2, #116	; 0x74
 8003cfc:	5c9b      	ldrb	r3, [r3, r2]
 8003cfe:	2b60      	cmp	r3, #96	; 0x60
 8003d00:	d004      	beq.n	8003d0c <BloqueCOM_CEIT+0x50>
 8003d02:	687b      	ldr	r3, [r7, #4]
 8003d04:	2274      	movs	r2, #116	; 0x74
 8003d06:	5c9b      	ldrb	r3, [r3, r2]
 8003d08:	2b61      	cmp	r3, #97	; 0x61
 8003d0a:	d106      	bne.n	8003d1a <BloqueCOM_CEIT+0x5e>
			{
				pstcomceit->enviarDatos = true;
 8003d0c:	687b      	ldr	r3, [r7, #4]
 8003d0e:	2201      	movs	r2, #1
 8003d10:	705a      	strb	r2, [r3, #1]
				pstcomceit->SM_State = SM_STATE_WAIT_FOR_TX_DONE;
 8003d12:	687b      	ldr	r3, [r7, #4]
 8003d14:	2204      	movs	r2, #4
 8003d16:	701a      	strb	r2, [r3, #0]
				pstcomceit->enviarDatos = false;
				pstcomceit->envioOK = true;
				pstcomceit->xRxDoneFlag = RESET;
				pstcomceit->SM_State = SM_STATE_START_RX;
			}
		break;
 8003d18:	e093      	b.n	8003e42 <BloqueCOM_CEIT+0x186>
				pstcomceit->enviarDatos = false;
 8003d1a:	687b      	ldr	r3, [r7, #4]
 8003d1c:	2200      	movs	r2, #0
 8003d1e:	705a      	strb	r2, [r3, #1]
				pstcomceit->envioOK = true;
 8003d20:	687b      	ldr	r3, [r7, #4]
 8003d22:	2201      	movs	r2, #1
 8003d24:	70da      	strb	r2, [r3, #3]
				pstcomceit->xRxDoneFlag = RESET;
 8003d26:	687b      	ldr	r3, [r7, #4]
 8003d28:	2200      	movs	r2, #0
 8003d2a:	711a      	strb	r2, [r3, #4]
				pstcomceit->SM_State = SM_STATE_START_RX;
 8003d2c:	687b      	ldr	r3, [r7, #4]
 8003d2e:	2200      	movs	r2, #0
 8003d30:	701a      	strb	r2, [r3, #0]
		break;
 8003d32:	e086      	b.n	8003e42 <BloqueCOM_CEIT+0x186>

		case SM_STATE_WAIT_FOR_TX_DONE:
			
			if((pstcomceit->enviarDatos == true) && (pstcomceit->datosListos == true))
 8003d34:	687b      	ldr	r3, [r7, #4]
 8003d36:	785b      	ldrb	r3, [r3, #1]
 8003d38:	2b00      	cmp	r3, #0
 8003d3a:	d007      	beq.n	8003d4c <BloqueCOM_CEIT+0x90>
 8003d3c:	687b      	ldr	r3, [r7, #4]
 8003d3e:	789b      	ldrb	r3, [r3, #2]
 8003d40:	2b00      	cmp	r3, #0
 8003d42:	d003      	beq.n	8003d4c <BloqueCOM_CEIT+0x90>
			{
				pstcomceit->SM_State = SM_STATE_SEND_DATA;
 8003d44:	687b      	ldr	r3, [r7, #4]
 8003d46:	2203      	movs	r2, #3
 8003d48:	701a      	strb	r2, [r3, #0]
 8003d4a:	e022      	b.n	8003d92 <BloqueCOM_CEIT+0xd6>
			}
			else if((pstcomceit->xTxDoneFlag == RESET) || (pstcomceit->datosListos == false))
 8003d4c:	687b      	ldr	r3, [r7, #4]
 8003d4e:	795b      	ldrb	r3, [r3, #5]
 8003d50:	2201      	movs	r2, #1
 8003d52:	4053      	eors	r3, r2
 8003d54:	b2db      	uxtb	r3, r3
 8003d56:	2b00      	cmp	r3, #0
 8003d58:	d106      	bne.n	8003d68 <BloqueCOM_CEIT+0xac>
 8003d5a:	687b      	ldr	r3, [r7, #4]
 8003d5c:	789b      	ldrb	r3, [r3, #2]
 8003d5e:	2201      	movs	r2, #1
 8003d60:	4053      	eors	r3, r2
 8003d62:	b2db      	uxtb	r3, r3
 8003d64:	2b00      	cmp	r3, #0
 8003d66:	d003      	beq.n	8003d70 <BloqueCOM_CEIT+0xb4>
			{
				pstcomceit->SM_State = SM_STATE_WAIT_FOR_TX_DONE;
 8003d68:	687b      	ldr	r3, [r7, #4]
 8003d6a:	2204      	movs	r2, #4
 8003d6c:	701a      	strb	r2, [r3, #0]
 8003d6e:	e010      	b.n	8003d92 <BloqueCOM_CEIT+0xd6>
			}
			else if(pstcomceit->xTxDoneFlag == SET)
 8003d70:	687b      	ldr	r3, [r7, #4]
 8003d72:	795b      	ldrb	r3, [r3, #5]
 8003d74:	2b00      	cmp	r3, #0
 8003d76:	d063      	beq.n	8003e40 <BloqueCOM_CEIT+0x184>
			{
				pstcomceit->xTxDoneFlag = RESET;
 8003d78:	687b      	ldr	r3, [r7, #4]
 8003d7a:	2200      	movs	r2, #0
 8003d7c:	715a      	strb	r2, [r3, #5]
				pstcomceit->envioOK = true;
 8003d7e:	687b      	ldr	r3, [r7, #4]
 8003d80:	2201      	movs	r2, #1
 8003d82:	70da      	strb	r2, [r3, #3]
				pstcomceit->xRxDoneFlag = RESET;
 8003d84:	687b      	ldr	r3, [r7, #4]
 8003d86:	2200      	movs	r2, #0
 8003d88:	711a      	strb	r2, [r3, #4]
				pstcomceit->SM_State = SM_STATE_START_RX;
 8003d8a:	687b      	ldr	r3, [r7, #4]
 8003d8c:	2200      	movs	r2, #0
 8003d8e:	701a      	strb	r2, [r3, #0]
			}
		break;
 8003d90:	e056      	b.n	8003e40 <BloqueCOM_CEIT+0x184>
 8003d92:	e055      	b.n	8003e40 <BloqueCOM_CEIT+0x184>
		
		case SM_STATE_SEND_DATA:

			if(pstcomceit->Rx_Buffer[CMD] == GET_DATA)
 8003d94:	687b      	ldr	r3, [r7, #4]
 8003d96:	2274      	movs	r2, #116	; 0x74
 8003d98:	5c9b      	ldrb	r3, [r3, r2]
 8003d9a:	2b60      	cmp	r3, #96	; 0x60
 8003d9c:	d146      	bne.n	8003e2c <BloqueCOM_CEIT+0x170>
			{
				TX_Frame[CMD_LENGTH] = 0x01;
 8003d9e:	4b2c      	ldr	r3, [pc, #176]	; (8003e50 <BloqueCOM_CEIT+0x194>)
 8003da0:	2201      	movs	r2, #1
 8003da2:	701a      	strb	r2, [r3, #0]
				TX_Frame[CMD_TAG] = pstcomceit->Rx_Buffer[CMD_TAG];
 8003da4:	687b      	ldr	r3, [r7, #4]
 8003da6:	2272      	movs	r2, #114	; 0x72
 8003da8:	5c9a      	ldrb	r2, [r3, r2]
 8003daa:	4b29      	ldr	r3, [pc, #164]	; (8003e50 <BloqueCOM_CEIT+0x194>)
 8003dac:	705a      	strb	r2, [r3, #1]
				TX_Frame[CMD_TYPE] = 0x11;
 8003dae:	4b28      	ldr	r3, [pc, #160]	; (8003e50 <BloqueCOM_CEIT+0x194>)
 8003db0:	2211      	movs	r2, #17
 8003db2:	709a      	strb	r2, [r3, #2]
				TX_Frame[CMD] = DATA;			
 8003db4:	4b26      	ldr	r3, [pc, #152]	; (8003e50 <BloqueCOM_CEIT+0x194>)
 8003db6:	2270      	movs	r2, #112	; 0x70
 8003db8:	70da      	strb	r2, [r3, #3]
				TX_Frame[DATA_LENGTH] = pstcomceit->TxLength;
 8003dba:	687b      	ldr	r3, [r7, #4]
 8003dbc:	799a      	ldrb	r2, [r3, #6]
 8003dbe:	4b24      	ldr	r3, [pc, #144]	; (8003e50 <BloqueCOM_CEIT+0x194>)
 8003dc0:	711a      	strb	r2, [r3, #4]
				for (int i=5; i<pstcomceit->TxLength+5; i++)
 8003dc2:	2305      	movs	r3, #5
 8003dc4:	60fb      	str	r3, [r7, #12]
 8003dc6:	e00c      	b.n	8003de2 <BloqueCOM_CEIT+0x126>
				{
					TX_Frame[i] = pstcomceit->Tx_Buffer[i-5];
 8003dc8:	68fb      	ldr	r3, [r7, #12]
 8003dca:	3b05      	subs	r3, #5
 8003dcc:	687a      	ldr	r2, [r7, #4]
 8003dce:	18d3      	adds	r3, r2, r3
 8003dd0:	7a19      	ldrb	r1, [r3, #8]
 8003dd2:	4a1f      	ldr	r2, [pc, #124]	; (8003e50 <BloqueCOM_CEIT+0x194>)
 8003dd4:	68fb      	ldr	r3, [r7, #12]
 8003dd6:	18d3      	adds	r3, r2, r3
 8003dd8:	1c0a      	adds	r2, r1, #0
 8003dda:	701a      	strb	r2, [r3, #0]
				for (int i=5; i<pstcomceit->TxLength+5; i++)
 8003ddc:	68fb      	ldr	r3, [r7, #12]
 8003dde:	3301      	adds	r3, #1
 8003de0:	60fb      	str	r3, [r7, #12]
 8003de2:	687b      	ldr	r3, [r7, #4]
 8003de4:	799b      	ldrb	r3, [r3, #6]
 8003de6:	3305      	adds	r3, #5
 8003de8:	68fa      	ldr	r2, [r7, #12]
 8003dea:	429a      	cmp	r2, r3
 8003dec:	dbec      	blt.n	8003dc8 <BloqueCOM_CEIT+0x10c>
				}
				TX_Frame[TX_BUFFER_SIZE] = 0xFA;
 8003dee:	4b18      	ldr	r3, [pc, #96]	; (8003e50 <BloqueCOM_CEIT+0x194>)
 8003df0:	2269      	movs	r2, #105	; 0x69
 8003df2:	21fa      	movs	r1, #250	; 0xfa
 8003df4:	5499      	strb	r1, [r3, r2]
				if (HAL_UART_Transmit(&huart5, TX_Frame, TX_BUFFER_SIZE+1, HAL_MAX_DELAY) != HAL_OK)
 8003df6:	2301      	movs	r3, #1
 8003df8:	425b      	negs	r3, r3
 8003dfa:	4915      	ldr	r1, [pc, #84]	; (8003e50 <BloqueCOM_CEIT+0x194>)
 8003dfc:	4815      	ldr	r0, [pc, #84]	; (8003e54 <BloqueCOM_CEIT+0x198>)
 8003dfe:	226a      	movs	r2, #106	; 0x6a
 8003e00:	f00e f992 	bl	8012128 <HAL_UART_Transmit>
 8003e04:	1e03      	subs	r3, r0, #0
 8003e06:	d003      	beq.n	8003e10 <BloqueCOM_CEIT+0x154>
				{
					pstcomceit->xTxDoneFlag=RESET;
 8003e08:	687b      	ldr	r3, [r7, #4]
 8003e0a:	2200      	movs	r2, #0
 8003e0c:	715a      	strb	r2, [r3, #5]
 8003e0e:	e013      	b.n	8003e38 <BloqueCOM_CEIT+0x17c>
				}
				else
				{
					HAL_UART_Transmit(&huart2, TX_Frame, TX_BUFFER_SIZE+1, HAL_MAX_DELAY);
 8003e10:	2301      	movs	r3, #1
 8003e12:	425b      	negs	r3, r3
 8003e14:	490e      	ldr	r1, [pc, #56]	; (8003e50 <BloqueCOM_CEIT+0x194>)
 8003e16:	4810      	ldr	r0, [pc, #64]	; (8003e58 <BloqueCOM_CEIT+0x19c>)
 8003e18:	226a      	movs	r2, #106	; 0x6a
 8003e1a:	f00e f985 	bl	8012128 <HAL_UART_Transmit>
					pstcomceit->xTxDoneFlag=SET;
 8003e1e:	687b      	ldr	r3, [r7, #4]
 8003e20:	2201      	movs	r2, #1
 8003e22:	715a      	strb	r2, [r3, #5]
					pstcomceit->enviarDatos = false;
 8003e24:	687b      	ldr	r3, [r7, #4]
 8003e26:	2200      	movs	r2, #0
 8003e28:	705a      	strb	r2, [r3, #1]
 8003e2a:	e005      	b.n	8003e38 <BloqueCOM_CEIT+0x17c>
				}
			}
			else
			{
				pstcomceit->xTxDoneFlag=SET;
 8003e2c:	687b      	ldr	r3, [r7, #4]
 8003e2e:	2201      	movs	r2, #1
 8003e30:	715a      	strb	r2, [r3, #5]
				pstcomceit->enviarDatos = false;
 8003e32:	687b      	ldr	r3, [r7, #4]
 8003e34:	2200      	movs	r2, #0
 8003e36:	705a      	strb	r2, [r3, #1]
			}
			pstcomceit->SM_State = SM_STATE_WAIT_FOR_TX_DONE;
 8003e38:	687b      	ldr	r3, [r7, #4]
 8003e3a:	2204      	movs	r2, #4
 8003e3c:	701a      	strb	r2, [r3, #0]
		break;
 8003e3e:	e000      	b.n	8003e42 <BloqueCOM_CEIT+0x186>
		break;
 8003e40:	46c0      	nop			; (mov r8, r8)
  }
}
 8003e42:	46c0      	nop			; (mov r8, r8)
 8003e44:	46bd      	mov	sp, r7
 8003e46:	b004      	add	sp, #16
 8003e48:	bd80      	pop	{r7, pc}
 8003e4a:	46c0      	nop			; (mov r8, r8)
 8003e4c:	08014e6c 	.word	0x08014e6c
 8003e50:	20000470 	.word	0x20000470
 8003e54:	2000317c 	.word	0x2000317c
 8003e58:	200031fc 	.word	0x200031fc

08003e5c <BloqueDistancia>:
						2 -> Si la lectura de distancia falló
Descripción:  		    Ejecuta el proceso principal del bloque Distancia
Notas y Cambios:  
****************************************************************************************/
uint8_t BloqueDistancia(stDistancia *pstdistancia)
{
 8003e5c:	b5b0      	push	{r4, r5, r7, lr}
 8003e5e:	b088      	sub	sp, #32
 8003e60:	af00      	add	r7, sp, #0
 8003e62:	6078      	str	r0, [r7, #4]
	uint8_t sensorOK, configOK, col;
	uint16_t d1,d2,d3,d;
	int status;
	
	//Verificar si hay solicitud de lectura
	if(pstdistancia->bandDistancia == true)
 8003e64:	687b      	ldr	r3, [r7, #4]
 8003e66:	781b      	ldrb	r3, [r3, #0]
 8003e68:	2b00      	cmp	r3, #0
 8003e6a:	d100      	bne.n	8003e6e <BloqueDistancia+0x12>
 8003e6c:	e1bc      	b.n	80041e8 <BloqueDistancia+0x38c>
	{
		col = pstdistancia->posSensor[pstdistancia->contParrilla];
 8003e6e:	687b      	ldr	r3, [r7, #4]
 8003e70:	2266      	movs	r2, #102	; 0x66
 8003e72:	5c9b      	ldrb	r3, [r3, r2]
 8003e74:	0018      	movs	r0, r3
 8003e76:	231b      	movs	r3, #27
 8003e78:	18fb      	adds	r3, r7, r3
 8003e7a:	6879      	ldr	r1, [r7, #4]
 8003e7c:	22cf      	movs	r2, #207	; 0xcf
 8003e7e:	0052      	lsls	r2, r2, #1
 8003e80:	1809      	adds	r1, r1, r0
 8003e82:	188a      	adds	r2, r1, r2
 8003e84:	7812      	ldrb	r2, [r2, #0]
 8003e86:	701a      	strb	r2, [r3, #0]

		if(pstdistancia->bandInicio[pstdistancia->contParrilla] == 0){
 8003e88:	687b      	ldr	r3, [r7, #4]
 8003e8a:	2266      	movs	r2, #102	; 0x66
 8003e8c:	5c9b      	ldrb	r3, [r3, r2]
 8003e8e:	0019      	movs	r1, r3
 8003e90:	687a      	ldr	r2, [r7, #4]
 8003e92:	23aa      	movs	r3, #170	; 0xaa
 8003e94:	33ff      	adds	r3, #255	; 0xff
 8003e96:	1852      	adds	r2, r2, r1
 8003e98:	18d3      	adds	r3, r2, r3
 8003e9a:	781b      	ldrb	r3, [r3, #0]
 8003e9c:	2b00      	cmp	r3, #0
 8003e9e:	d11e      	bne.n	8003ede <BloqueDistancia+0x82>
			sensorOK = VL53L1_StartMeasurement( &(pstdistancia->VL53L1_DEV[pstdistancia->contParrilla]) );
 8003ea0:	687b      	ldr	r3, [r7, #4]
 8003ea2:	2266      	movs	r2, #102	; 0x66
 8003ea4:	5c9b      	ldrb	r3, [r3, r2]
 8003ea6:	001a      	movs	r2, r3
 8003ea8:	23e9      	movs	r3, #233	; 0xe9
 8003eaa:	009b      	lsls	r3, r3, #2
 8003eac:	4353      	muls	r3, r2
 8003eae:	33d1      	adds	r3, #209	; 0xd1
 8003eb0:	33ff      	adds	r3, #255	; 0xff
 8003eb2:	687a      	ldr	r2, [r7, #4]
 8003eb4:	18d3      	adds	r3, r2, r3
 8003eb6:	0018      	movs	r0, r3
 8003eb8:	f004 ffcc 	bl	8008e54 <VL53L1_StartMeasurement>
 8003ebc:	0003      	movs	r3, r0
 8003ebe:	001a      	movs	r2, r3
 8003ec0:	231f      	movs	r3, #31
 8003ec2:	18fb      	adds	r3, r7, r3
 8003ec4:	701a      	strb	r2, [r3, #0]
			pstdistancia->bandInicio[pstdistancia->contParrilla] = 1;
 8003ec6:	687b      	ldr	r3, [r7, #4]
 8003ec8:	2266      	movs	r2, #102	; 0x66
 8003eca:	5c9b      	ldrb	r3, [r3, r2]
 8003ecc:	0019      	movs	r1, r3
 8003ece:	687a      	ldr	r2, [r7, #4]
 8003ed0:	23aa      	movs	r3, #170	; 0xaa
 8003ed2:	33ff      	adds	r3, #255	; 0xff
 8003ed4:	1852      	adds	r2, r2, r1
 8003ed6:	18d3      	adds	r3, r2, r3
 8003ed8:	2201      	movs	r2, #1
 8003eda:	701a      	strb	r2, [r3, #0]
 8003edc:	e003      	b.n	8003ee6 <BloqueDistancia+0x8a>
		}else{
			sensorOK = 0;
 8003ede:	231f      	movs	r3, #31
 8003ee0:	18fb      	adds	r3, r7, r3
 8003ee2:	2200      	movs	r2, #0
 8003ee4:	701a      	strb	r2, [r3, #0]
		}

		if(sensorOK == 0)
 8003ee6:	231f      	movs	r3, #31
 8003ee8:	18fb      	adds	r3, r7, r3
 8003eea:	781b      	ldrb	r3, [r3, #0]
 8003eec:	2b00      	cmp	r3, #0
 8003eee:	d000      	beq.n	8003ef2 <BloqueDistancia+0x96>
 8003ef0:	e167      	b.n	80041c2 <BloqueDistancia+0x366>
		{

			status=VL53L1_WaitMeasurementDataReady( &pstdistancia->VL53L1_DEV[pstdistancia->contParrilla] );
 8003ef2:	687b      	ldr	r3, [r7, #4]
 8003ef4:	2266      	movs	r2, #102	; 0x66
 8003ef6:	5c9b      	ldrb	r3, [r3, r2]
 8003ef8:	001a      	movs	r2, r3
 8003efa:	23e9      	movs	r3, #233	; 0xe9
 8003efc:	009b      	lsls	r3, r3, #2
 8003efe:	4353      	muls	r3, r2
 8003f00:	33d1      	adds	r3, #209	; 0xd1
 8003f02:	33ff      	adds	r3, #255	; 0xff
 8003f04:	687a      	ldr	r2, [r7, #4]
 8003f06:	18d3      	adds	r3, r2, r3
 8003f08:	0018      	movs	r0, r3
 8003f0a:	f005 f92b 	bl	8009164 <VL53L1_WaitMeasurementDataReady>
 8003f0e:	0003      	movs	r3, r0
 8003f10:	617b      	str	r3, [r7, #20]
			status= VL53L1_GetRangingMeasurementData(&pstdistancia->VL53L1_DEV[pstdistancia->contParrilla], &pstdistancia->RangingData);
 8003f12:	687b      	ldr	r3, [r7, #4]
 8003f14:	2266      	movs	r2, #102	; 0x66
 8003f16:	5c9b      	ldrb	r3, [r3, r2]
 8003f18:	001a      	movs	r2, r3
 8003f1a:	23e9      	movs	r3, #233	; 0xe9
 8003f1c:	009b      	lsls	r3, r3, #2
 8003f1e:	4353      	muls	r3, r2
 8003f20:	33d1      	adds	r3, #209	; 0xd1
 8003f22:	33ff      	adds	r3, #255	; 0xff
 8003f24:	687a      	ldr	r2, [r7, #4]
 8003f26:	18d2      	adds	r2, r2, r3
 8003f28:	687b      	ldr	r3, [r7, #4]
 8003f2a:	33b5      	adds	r3, #181	; 0xb5
 8003f2c:	33ff      	adds	r3, #255	; 0xff
 8003f2e:	0019      	movs	r1, r3
 8003f30:	0010      	movs	r0, r2
 8003f32:	f005 fb0d 	bl	8009550 <VL53L1_GetRangingMeasurementData>
 8003f36:	0003      	movs	r3, r0
 8003f38:	617b      	str	r3, [r7, #20]
			status = VL53L1_ClearInterruptAndStartMeasurement( &pstdistancia->VL53L1_DEV[pstdistancia->contParrilla] );
 8003f3a:	687b      	ldr	r3, [r7, #4]
 8003f3c:	2266      	movs	r2, #102	; 0x66
 8003f3e:	5c9b      	ldrb	r3, [r3, r2]
 8003f40:	001a      	movs	r2, r3
 8003f42:	23e9      	movs	r3, #233	; 0xe9
 8003f44:	009b      	lsls	r3, r3, #2
 8003f46:	4353      	muls	r3, r2
 8003f48:	33d1      	adds	r3, #209	; 0xd1
 8003f4a:	33ff      	adds	r3, #255	; 0xff
 8003f4c:	687a      	ldr	r2, [r7, #4]
 8003f4e:	18d3      	adds	r3, r2, r3
 8003f50:	0018      	movs	r0, r3
 8003f52:	f005 f8c7 	bl	80090e4 <VL53L1_ClearInterruptAndStartMeasurement>
 8003f56:	0003      	movs	r3, r0
 8003f58:	617b      	str	r3, [r7, #20]
			d1 = pstdistancia->RangingData.RangeMilliMeter;
 8003f5a:	687a      	ldr	r2, [r7, #4]
 8003f5c:	23e6      	movs	r3, #230	; 0xe6
 8003f5e:	005b      	lsls	r3, r3, #1
 8003f60:	5ed2      	ldrsh	r2, [r2, r3]
 8003f62:	2412      	movs	r4, #18
 8003f64:	193b      	adds	r3, r7, r4
 8003f66:	801a      	strh	r2, [r3, #0]
//			d2=d1;
//			d3=d1;
			status=VL53L1_WaitMeasurementDataReady( &pstdistancia->VL53L1_DEV[pstdistancia->contParrilla] );
 8003f68:	687b      	ldr	r3, [r7, #4]
 8003f6a:	2266      	movs	r2, #102	; 0x66
 8003f6c:	5c9b      	ldrb	r3, [r3, r2]
 8003f6e:	001a      	movs	r2, r3
 8003f70:	23e9      	movs	r3, #233	; 0xe9
 8003f72:	009b      	lsls	r3, r3, #2
 8003f74:	4353      	muls	r3, r2
 8003f76:	33d1      	adds	r3, #209	; 0xd1
 8003f78:	33ff      	adds	r3, #255	; 0xff
 8003f7a:	687a      	ldr	r2, [r7, #4]
 8003f7c:	18d3      	adds	r3, r2, r3
 8003f7e:	0018      	movs	r0, r3
 8003f80:	f005 f8f0 	bl	8009164 <VL53L1_WaitMeasurementDataReady>
 8003f84:	0003      	movs	r3, r0
 8003f86:	617b      	str	r3, [r7, #20]
			status= VL53L1_GetRangingMeasurementData(&pstdistancia->VL53L1_DEV[pstdistancia->contParrilla], &pstdistancia->RangingData);
 8003f88:	687b      	ldr	r3, [r7, #4]
 8003f8a:	2266      	movs	r2, #102	; 0x66
 8003f8c:	5c9b      	ldrb	r3, [r3, r2]
 8003f8e:	001a      	movs	r2, r3
 8003f90:	23e9      	movs	r3, #233	; 0xe9
 8003f92:	009b      	lsls	r3, r3, #2
 8003f94:	4353      	muls	r3, r2
 8003f96:	33d1      	adds	r3, #209	; 0xd1
 8003f98:	33ff      	adds	r3, #255	; 0xff
 8003f9a:	687a      	ldr	r2, [r7, #4]
 8003f9c:	18d2      	adds	r2, r2, r3
 8003f9e:	687b      	ldr	r3, [r7, #4]
 8003fa0:	33b5      	adds	r3, #181	; 0xb5
 8003fa2:	33ff      	adds	r3, #255	; 0xff
 8003fa4:	0019      	movs	r1, r3
 8003fa6:	0010      	movs	r0, r2
 8003fa8:	f005 fad2 	bl	8009550 <VL53L1_GetRangingMeasurementData>
 8003fac:	0003      	movs	r3, r0
 8003fae:	617b      	str	r3, [r7, #20]
			status = VL53L1_ClearInterruptAndStartMeasurement( &pstdistancia->VL53L1_DEV[pstdistancia->contParrilla] );
 8003fb0:	687b      	ldr	r3, [r7, #4]
 8003fb2:	2266      	movs	r2, #102	; 0x66
 8003fb4:	5c9b      	ldrb	r3, [r3, r2]
 8003fb6:	001a      	movs	r2, r3
 8003fb8:	23e9      	movs	r3, #233	; 0xe9
 8003fba:	009b      	lsls	r3, r3, #2
 8003fbc:	4353      	muls	r3, r2
 8003fbe:	33d1      	adds	r3, #209	; 0xd1
 8003fc0:	33ff      	adds	r3, #255	; 0xff
 8003fc2:	687a      	ldr	r2, [r7, #4]
 8003fc4:	18d3      	adds	r3, r2, r3
 8003fc6:	0018      	movs	r0, r3
 8003fc8:	f005 f88c 	bl	80090e4 <VL53L1_ClearInterruptAndStartMeasurement>
 8003fcc:	0003      	movs	r3, r0
 8003fce:	617b      	str	r3, [r7, #20]
			d2 = pstdistancia->RangingData.RangeMilliMeter;
 8003fd0:	687a      	ldr	r2, [r7, #4]
 8003fd2:	23e6      	movs	r3, #230	; 0xe6
 8003fd4:	005b      	lsls	r3, r3, #1
 8003fd6:	5ed2      	ldrsh	r2, [r2, r3]
 8003fd8:	2510      	movs	r5, #16
 8003fda:	197b      	adds	r3, r7, r5
 8003fdc:	801a      	strh	r2, [r3, #0]
			status=VL53L1_WaitMeasurementDataReady( &pstdistancia->VL53L1_DEV[pstdistancia->contParrilla] );
 8003fde:	687b      	ldr	r3, [r7, #4]
 8003fe0:	2266      	movs	r2, #102	; 0x66
 8003fe2:	5c9b      	ldrb	r3, [r3, r2]
 8003fe4:	001a      	movs	r2, r3
 8003fe6:	23e9      	movs	r3, #233	; 0xe9
 8003fe8:	009b      	lsls	r3, r3, #2
 8003fea:	4353      	muls	r3, r2
 8003fec:	33d1      	adds	r3, #209	; 0xd1
 8003fee:	33ff      	adds	r3, #255	; 0xff
 8003ff0:	687a      	ldr	r2, [r7, #4]
 8003ff2:	18d3      	adds	r3, r2, r3
 8003ff4:	0018      	movs	r0, r3
 8003ff6:	f005 f8b5 	bl	8009164 <VL53L1_WaitMeasurementDataReady>
 8003ffa:	0003      	movs	r3, r0
 8003ffc:	617b      	str	r3, [r7, #20]
			status= VL53L1_GetRangingMeasurementData(&pstdistancia->VL53L1_DEV[pstdistancia->contParrilla], &pstdistancia->RangingData);
 8003ffe:	687b      	ldr	r3, [r7, #4]
 8004000:	2266      	movs	r2, #102	; 0x66
 8004002:	5c9b      	ldrb	r3, [r3, r2]
 8004004:	001a      	movs	r2, r3
 8004006:	23e9      	movs	r3, #233	; 0xe9
 8004008:	009b      	lsls	r3, r3, #2
 800400a:	4353      	muls	r3, r2
 800400c:	33d1      	adds	r3, #209	; 0xd1
 800400e:	33ff      	adds	r3, #255	; 0xff
 8004010:	687a      	ldr	r2, [r7, #4]
 8004012:	18d2      	adds	r2, r2, r3
 8004014:	687b      	ldr	r3, [r7, #4]
 8004016:	33b5      	adds	r3, #181	; 0xb5
 8004018:	33ff      	adds	r3, #255	; 0xff
 800401a:	0019      	movs	r1, r3
 800401c:	0010      	movs	r0, r2
 800401e:	f005 fa97 	bl	8009550 <VL53L1_GetRangingMeasurementData>
 8004022:	0003      	movs	r3, r0
 8004024:	617b      	str	r3, [r7, #20]
			status = VL53L1_ClearInterruptAndStartMeasurement( &pstdistancia->VL53L1_DEV[pstdistancia->contParrilla] );
 8004026:	687b      	ldr	r3, [r7, #4]
 8004028:	2266      	movs	r2, #102	; 0x66
 800402a:	5c9b      	ldrb	r3, [r3, r2]
 800402c:	001a      	movs	r2, r3
 800402e:	23e9      	movs	r3, #233	; 0xe9
 8004030:	009b      	lsls	r3, r3, #2
 8004032:	4353      	muls	r3, r2
 8004034:	33d1      	adds	r3, #209	; 0xd1
 8004036:	33ff      	adds	r3, #255	; 0xff
 8004038:	687a      	ldr	r2, [r7, #4]
 800403a:	18d3      	adds	r3, r2, r3
 800403c:	0018      	movs	r0, r3
 800403e:	f005 f851 	bl	80090e4 <VL53L1_ClearInterruptAndStartMeasurement>
 8004042:	0003      	movs	r3, r0
 8004044:	617b      	str	r3, [r7, #20]
			d3 = pstdistancia->RangingData.RangeMilliMeter;
 8004046:	687a      	ldr	r2, [r7, #4]
 8004048:	23e6      	movs	r3, #230	; 0xe6
 800404a:	005b      	lsls	r3, r3, #1
 800404c:	5ed2      	ldrsh	r2, [r2, r3]
 800404e:	230e      	movs	r3, #14
 8004050:	18fb      	adds	r3, r7, r3
 8004052:	801a      	strh	r2, [r3, #0]

			/*Mediana*/
			if(d1<d2 && d2<d3){
 8004054:	193a      	adds	r2, r7, r4
 8004056:	197b      	adds	r3, r7, r5
 8004058:	8812      	ldrh	r2, [r2, #0]
 800405a:	881b      	ldrh	r3, [r3, #0]
 800405c:	429a      	cmp	r2, r3
 800405e:	d20e      	bcs.n	800407e <BloqueDistancia+0x222>
 8004060:	2310      	movs	r3, #16
 8004062:	18fa      	adds	r2, r7, r3
 8004064:	230e      	movs	r3, #14
 8004066:	18fb      	adds	r3, r7, r3
 8004068:	8812      	ldrh	r2, [r2, #0]
 800406a:	881b      	ldrh	r3, [r3, #0]
 800406c:	429a      	cmp	r2, r3
 800406e:	d206      	bcs.n	800407e <BloqueDistancia+0x222>
				d=d2;
 8004070:	231c      	movs	r3, #28
 8004072:	18fb      	adds	r3, r7, r3
 8004074:	2210      	movs	r2, #16
 8004076:	18ba      	adds	r2, r7, r2
 8004078:	8812      	ldrh	r2, [r2, #0]
 800407a:	801a      	strh	r2, [r3, #0]
 800407c:	e061      	b.n	8004142 <BloqueDistancia+0x2e6>
			}else{
				if(d1<d3 && d3<d2){
 800407e:	2312      	movs	r3, #18
 8004080:	18fa      	adds	r2, r7, r3
 8004082:	230e      	movs	r3, #14
 8004084:	18fb      	adds	r3, r7, r3
 8004086:	8812      	ldrh	r2, [r2, #0]
 8004088:	881b      	ldrh	r3, [r3, #0]
 800408a:	429a      	cmp	r2, r3
 800408c:	d20e      	bcs.n	80040ac <BloqueDistancia+0x250>
 800408e:	230e      	movs	r3, #14
 8004090:	18fa      	adds	r2, r7, r3
 8004092:	2310      	movs	r3, #16
 8004094:	18fb      	adds	r3, r7, r3
 8004096:	8812      	ldrh	r2, [r2, #0]
 8004098:	881b      	ldrh	r3, [r3, #0]
 800409a:	429a      	cmp	r2, r3
 800409c:	d206      	bcs.n	80040ac <BloqueDistancia+0x250>
					d=d3;
 800409e:	231c      	movs	r3, #28
 80040a0:	18fb      	adds	r3, r7, r3
 80040a2:	220e      	movs	r2, #14
 80040a4:	18ba      	adds	r2, r7, r2
 80040a6:	8812      	ldrh	r2, [r2, #0]
 80040a8:	801a      	strh	r2, [r3, #0]
 80040aa:	e04a      	b.n	8004142 <BloqueDistancia+0x2e6>
				}else{
					if(d2<d1 && d1<d3){
 80040ac:	2310      	movs	r3, #16
 80040ae:	18fa      	adds	r2, r7, r3
 80040b0:	2312      	movs	r3, #18
 80040b2:	18fb      	adds	r3, r7, r3
 80040b4:	8812      	ldrh	r2, [r2, #0]
 80040b6:	881b      	ldrh	r3, [r3, #0]
 80040b8:	429a      	cmp	r2, r3
 80040ba:	d20e      	bcs.n	80040da <BloqueDistancia+0x27e>
 80040bc:	2312      	movs	r3, #18
 80040be:	18fa      	adds	r2, r7, r3
 80040c0:	230e      	movs	r3, #14
 80040c2:	18fb      	adds	r3, r7, r3
 80040c4:	8812      	ldrh	r2, [r2, #0]
 80040c6:	881b      	ldrh	r3, [r3, #0]
 80040c8:	429a      	cmp	r2, r3
 80040ca:	d206      	bcs.n	80040da <BloqueDistancia+0x27e>
						d=d1;
 80040cc:	231c      	movs	r3, #28
 80040ce:	18fb      	adds	r3, r7, r3
 80040d0:	2212      	movs	r2, #18
 80040d2:	18ba      	adds	r2, r7, r2
 80040d4:	8812      	ldrh	r2, [r2, #0]
 80040d6:	801a      	strh	r2, [r3, #0]
 80040d8:	e033      	b.n	8004142 <BloqueDistancia+0x2e6>
					}else{
						if(d2<d3 && d3<d1){
 80040da:	2310      	movs	r3, #16
 80040dc:	18fa      	adds	r2, r7, r3
 80040de:	230e      	movs	r3, #14
 80040e0:	18fb      	adds	r3, r7, r3
 80040e2:	8812      	ldrh	r2, [r2, #0]
 80040e4:	881b      	ldrh	r3, [r3, #0]
 80040e6:	429a      	cmp	r2, r3
 80040e8:	d20e      	bcs.n	8004108 <BloqueDistancia+0x2ac>
 80040ea:	230e      	movs	r3, #14
 80040ec:	18fa      	adds	r2, r7, r3
 80040ee:	2312      	movs	r3, #18
 80040f0:	18fb      	adds	r3, r7, r3
 80040f2:	8812      	ldrh	r2, [r2, #0]
 80040f4:	881b      	ldrh	r3, [r3, #0]
 80040f6:	429a      	cmp	r2, r3
 80040f8:	d206      	bcs.n	8004108 <BloqueDistancia+0x2ac>
							d=d3;
 80040fa:	231c      	movs	r3, #28
 80040fc:	18fb      	adds	r3, r7, r3
 80040fe:	220e      	movs	r2, #14
 8004100:	18ba      	adds	r2, r7, r2
 8004102:	8812      	ldrh	r2, [r2, #0]
 8004104:	801a      	strh	r2, [r3, #0]
 8004106:	e01c      	b.n	8004142 <BloqueDistancia+0x2e6>
						}else{
							if(d3<d2 && d2<d1){
 8004108:	230e      	movs	r3, #14
 800410a:	18fa      	adds	r2, r7, r3
 800410c:	2310      	movs	r3, #16
 800410e:	18fb      	adds	r3, r7, r3
 8004110:	8812      	ldrh	r2, [r2, #0]
 8004112:	881b      	ldrh	r3, [r3, #0]
 8004114:	429a      	cmp	r2, r3
 8004116:	d20e      	bcs.n	8004136 <BloqueDistancia+0x2da>
 8004118:	2310      	movs	r3, #16
 800411a:	18fa      	adds	r2, r7, r3
 800411c:	2312      	movs	r3, #18
 800411e:	18fb      	adds	r3, r7, r3
 8004120:	8812      	ldrh	r2, [r2, #0]
 8004122:	881b      	ldrh	r3, [r3, #0]
 8004124:	429a      	cmp	r2, r3
 8004126:	d206      	bcs.n	8004136 <BloqueDistancia+0x2da>
								d=d2;
 8004128:	231c      	movs	r3, #28
 800412a:	18fb      	adds	r3, r7, r3
 800412c:	2210      	movs	r2, #16
 800412e:	18ba      	adds	r2, r7, r2
 8004130:	8812      	ldrh	r2, [r2, #0]
 8004132:	801a      	strh	r2, [r3, #0]
 8004134:	e005      	b.n	8004142 <BloqueDistancia+0x2e6>
							}else{
								d=d1;
 8004136:	231c      	movs	r3, #28
 8004138:	18fb      	adds	r3, r7, r3
 800413a:	2212      	movs	r2, #18
 800413c:	18ba      	adds	r2, r7, r2
 800413e:	8812      	ldrh	r2, [r2, #0]
 8004140:	801a      	strh	r2, [r3, #0]
//					d=d3;

				/*Promedio*/
//				d=(d1+d2+d3)/3;
			
				if(status == VL53L1_ERROR_NONE)
 8004142:	697b      	ldr	r3, [r7, #20]
 8004144:	2b00      	cmp	r3, #0
 8004146:	d129      	bne.n	800419c <BloqueDistancia+0x340>
				{
					pstdistancia->datosDistancia[pstdistancia->contParrilla][col] = d;
 8004148:	687b      	ldr	r3, [r7, #4]
 800414a:	2266      	movs	r2, #102	; 0x66
 800414c:	5c9b      	ldrb	r3, [r3, r2]
 800414e:	0018      	movs	r0, r3
 8004150:	241b      	movs	r4, #27
 8004152:	193b      	adds	r3, r7, r4
 8004154:	7819      	ldrb	r1, [r3, #0]
 8004156:	687a      	ldr	r2, [r7, #4]
 8004158:	0003      	movs	r3, r0
 800415a:	009b      	lsls	r3, r3, #2
 800415c:	181b      	adds	r3, r3, r0
 800415e:	005b      	lsls	r3, r3, #1
 8004160:	185b      	adds	r3, r3, r1
 8004162:	3338      	adds	r3, #56	; 0x38
 8004164:	005b      	lsls	r3, r3, #1
 8004166:	18d3      	adds	r3, r2, r3
 8004168:	3302      	adds	r3, #2
 800416a:	221c      	movs	r2, #28
 800416c:	18ba      	adds	r2, r7, r2
 800416e:	8812      	ldrh	r2, [r2, #0]
 8004170:	801a      	strh	r2, [r3, #0]

					//Reiniciar bandera de solicitud de lectura
					pstdistancia->bandDistancia = false;
 8004172:	687b      	ldr	r3, [r7, #4]
 8004174:	2200      	movs	r2, #0
 8004176:	701a      	strb	r2, [r3, #0]
					pstdistancia->senStatus[pstdistancia->contParrilla][col] = 0;
 8004178:	687b      	ldr	r3, [r7, #4]
 800417a:	2266      	movs	r2, #102	; 0x66
 800417c:	5c9b      	ldrb	r3, [r3, r2]
 800417e:	0018      	movs	r0, r3
 8004180:	193b      	adds	r3, r7, r4
 8004182:	781a      	ldrb	r2, [r3, #0]
 8004184:	6879      	ldr	r1, [r7, #4]
 8004186:	0003      	movs	r3, r0
 8004188:	009b      	lsls	r3, r3, #2
 800418a:	181b      	adds	r3, r3, r0
 800418c:	005b      	lsls	r3, r3, #1
 800418e:	18cb      	adds	r3, r1, r3
 8004190:	189b      	adds	r3, r3, r2
 8004192:	3301      	adds	r3, #1
 8004194:	2200      	movs	r2, #0
 8004196:	701a      	strb	r2, [r3, #0]
					return (uint8_t)0;
 8004198:	2300      	movs	r3, #0
 800419a:	e026      	b.n	80041ea <BloqueDistancia+0x38e>
				}
				else
				{
					pstdistancia->senStatus[pstdistancia->contParrilla][col] = 2;
 800419c:	687b      	ldr	r3, [r7, #4]
 800419e:	2266      	movs	r2, #102	; 0x66
 80041a0:	5c9b      	ldrb	r3, [r3, r2]
 80041a2:	0018      	movs	r0, r3
 80041a4:	231b      	movs	r3, #27
 80041a6:	18fb      	adds	r3, r7, r3
 80041a8:	781a      	ldrb	r2, [r3, #0]
 80041aa:	6879      	ldr	r1, [r7, #4]
 80041ac:	0003      	movs	r3, r0
 80041ae:	009b      	lsls	r3, r3, #2
 80041b0:	181b      	adds	r3, r3, r0
 80041b2:	005b      	lsls	r3, r3, #1
 80041b4:	18cb      	adds	r3, r1, r3
 80041b6:	189b      	adds	r3, r3, r2
 80041b8:	3301      	adds	r3, #1
 80041ba:	2202      	movs	r2, #2
 80041bc:	701a      	strb	r2, [r3, #0]
					return (uint8_t)2;
 80041be:	2302      	movs	r3, #2
 80041c0:	e013      	b.n	80041ea <BloqueDistancia+0x38e>
				}
		}
		else
		{
			pstdistancia->senStatus[pstdistancia->contParrilla][col] = 1;
 80041c2:	687b      	ldr	r3, [r7, #4]
 80041c4:	2266      	movs	r2, #102	; 0x66
 80041c6:	5c9b      	ldrb	r3, [r3, r2]
 80041c8:	0018      	movs	r0, r3
 80041ca:	231b      	movs	r3, #27
 80041cc:	18fb      	adds	r3, r7, r3
 80041ce:	781a      	ldrb	r2, [r3, #0]
 80041d0:	6879      	ldr	r1, [r7, #4]
 80041d2:	0003      	movs	r3, r0
 80041d4:	009b      	lsls	r3, r3, #2
 80041d6:	181b      	adds	r3, r3, r0
 80041d8:	005b      	lsls	r3, r3, #1
 80041da:	18cb      	adds	r3, r1, r3
 80041dc:	189b      	adds	r3, r3, r2
 80041de:	3301      	adds	r3, #1
 80041e0:	2201      	movs	r2, #1
 80041e2:	701a      	strb	r2, [r3, #0]
			return (uint8_t)1;
 80041e4:	2301      	movs	r3, #1
 80041e6:	e000      	b.n	80041ea <BloqueDistancia+0x38e>
		}
	}
	else
	{
		return (uint8_t)4;
 80041e8:	2304      	movs	r3, #4
	}
}
 80041ea:	0018      	movs	r0, r3
 80041ec:	46bd      	mov	sp, r7
 80041ee:	b008      	add	sp, #32
 80041f0:	bdb0      	pop	{r4, r5, r7, pc}
	...

080041f4 <IniciarSensores>:
Salidas:          		N/A
Descripción:  		    Esta función inicia y configura los sesores
Notas y Cambios:
****************************************************************************************/
int IniciarSensores(stDistancia *pstdistancia)
{
 80041f4:	b5b0      	push	{r4, r5, r7, lr}
 80041f6:	b088      	sub	sp, #32
 80041f8:	af00      	add	r7, sp, #0
 80041fa:	6078      	str	r0, [r7, #4]
	int sensor;
	uint8_t newI2C = 0x52;
 80041fc:	231b      	movs	r3, #27
 80041fe:	18fb      	adds	r3, r7, r3
 8004200:	2252      	movs	r2, #82	; 0x52
 8004202:	701a      	strb	r2, [r3, #0]
	uint16_t wordData;
	VL53L1_UserRoi_t roiConfig;
	roiConfig.TopLeftX = 7;
 8004204:	210c      	movs	r1, #12
 8004206:	187b      	adds	r3, r7, r1
 8004208:	2207      	movs	r2, #7
 800420a:	701a      	strb	r2, [r3, #0]
	roiConfig.TopLeftY = 10;
 800420c:	187b      	adds	r3, r7, r1
 800420e:	220a      	movs	r2, #10
 8004210:	705a      	strb	r2, [r3, #1]
	roiConfig.BotRightX = 10;
 8004212:	187b      	adds	r3, r7, r1
 8004214:	220a      	movs	r2, #10
 8004216:	709a      	strb	r2, [r3, #2]
	roiConfig.BotRightY = 7;
 8004218:	187b      	adds	r3, r7, r1
 800421a:	2207      	movs	r2, #7
 800421c:	70da      	strb	r2, [r3, #3]
	int status;

	for(sensor=0; sensor<pstdistancia->SenHab; sensor++){
 800421e:	2300      	movs	r3, #0
 8004220:	61fb      	str	r3, [r7, #28]
 8004222:	e0e4      	b.n	80043ee <IniciarSensores+0x1fa>
		pstdistancia->contParrilla = sensor;
 8004224:	69fb      	ldr	r3, [r7, #28]
 8004226:	b2d9      	uxtb	r1, r3
 8004228:	687b      	ldr	r3, [r7, #4]
 800422a:	2266      	movs	r2, #102	; 0x66
 800422c:	5499      	strb	r1, [r3, r2]
		EnableSensors(pstdistancia);
 800422e:	687b      	ldr	r3, [r7, #4]
 8004230:	0018      	movs	r0, r3
 8004232:	f000 f8f3 	bl	800441c <EnableSensors>
		pstdistancia->VL53L1_DEV[sensor].comms_speed_khz = 400;
 8004236:	687a      	ldr	r2, [r7, #4]
 8004238:	69fb      	ldr	r3, [r7, #28]
 800423a:	4874      	ldr	r0, [pc, #464]	; (800440c <IniciarSensores+0x218>)
 800423c:	21e9      	movs	r1, #233	; 0xe9
 800423e:	0089      	lsls	r1, r1, #2
 8004240:	434b      	muls	r3, r1
 8004242:	18d3      	adds	r3, r2, r3
 8004244:	181b      	adds	r3, r3, r0
 8004246:	22c8      	movs	r2, #200	; 0xc8
 8004248:	0052      	lsls	r2, r2, #1
 800424a:	801a      	strh	r2, [r3, #0]
		pstdistancia->VL53L1_DEV[sensor].I2cHandle = &hi2c1;
 800424c:	6879      	ldr	r1, [r7, #4]
 800424e:	69fa      	ldr	r2, [r7, #28]
 8004250:	23ae      	movs	r3, #174	; 0xae
 8004252:	00db      	lsls	r3, r3, #3
 8004254:	20e9      	movs	r0, #233	; 0xe9
 8004256:	0080      	lsls	r0, r0, #2
 8004258:	4342      	muls	r2, r0
 800425a:	188a      	adds	r2, r1, r2
 800425c:	18d3      	adds	r3, r2, r3
 800425e:	4a6c      	ldr	r2, [pc, #432]	; (8004410 <IniciarSensores+0x21c>)
 8004260:	601a      	str	r2, [r3, #0]
		pstdistancia->VL53L1_DEV[sensor].comms_type = 1;
 8004262:	687a      	ldr	r2, [r7, #4]
 8004264:	69fb      	ldr	r3, [r7, #28]
 8004266:	486b      	ldr	r0, [pc, #428]	; (8004414 <IniciarSensores+0x220>)
 8004268:	21e9      	movs	r1, #233	; 0xe9
 800426a:	0089      	lsls	r1, r1, #2
 800426c:	434b      	muls	r3, r1
 800426e:	18d3      	adds	r3, r2, r3
 8004270:	181b      	adds	r3, r3, r0
 8004272:	2201      	movs	r2, #1
 8004274:	701a      	strb	r2, [r3, #0]
		pstdistancia->VL53L1_DEV[sensor].I2cDevAddr=0x52; /* default ToF sensor I2C address*/
 8004276:	6879      	ldr	r1, [r7, #4]
 8004278:	69fa      	ldr	r2, [r7, #28]
 800427a:	23ad      	movs	r3, #173	; 0xad
 800427c:	00db      	lsls	r3, r3, #3
 800427e:	20e9      	movs	r0, #233	; 0xe9
 8004280:	0080      	lsls	r0, r0, #2
 8004282:	4342      	muls	r2, r0
 8004284:	188a      	adds	r2, r1, r2
 8004286:	18d3      	adds	r3, r2, r3
 8004288:	2252      	movs	r2, #82	; 0x52
 800428a:	701a      	strb	r2, [r3, #0]
		VL53L1_RdWord(&pstdistancia->VL53L1_DEV[sensor], 0x010F, &wordData);
 800428c:	69fb      	ldr	r3, [r7, #28]
 800428e:	22e9      	movs	r2, #233	; 0xe9
 8004290:	0092      	lsls	r2, r2, #2
 8004292:	4353      	muls	r3, r2
 8004294:	33d1      	adds	r3, #209	; 0xd1
 8004296:	33ff      	adds	r3, #255	; 0xff
 8004298:	687a      	ldr	r2, [r7, #4]
 800429a:	18d0      	adds	r0, r2, r3
 800429c:	2512      	movs	r5, #18
 800429e:	197a      	adds	r2, r7, r5
 80042a0:	2310      	movs	r3, #16
 80042a2:	33ff      	adds	r3, #255	; 0xff
 80042a4:	0019      	movs	r1, r3
 80042a6:	f00a f863 	bl	800e370 <VL53L1_RdWord>
//		printf("VL53L1X: %02X\n\r", wordData);
		newI2C = pstdistancia->VL53L1_DEV[sensor].I2cDevAddr + (sensor+1)*2;
 80042aa:	6879      	ldr	r1, [r7, #4]
 80042ac:	69fa      	ldr	r2, [r7, #28]
 80042ae:	23ad      	movs	r3, #173	; 0xad
 80042b0:	00db      	lsls	r3, r3, #3
 80042b2:	20e9      	movs	r0, #233	; 0xe9
 80042b4:	0080      	lsls	r0, r0, #2
 80042b6:	4342      	muls	r2, r0
 80042b8:	188a      	adds	r2, r1, r2
 80042ba:	18d3      	adds	r3, r2, r3
 80042bc:	7819      	ldrb	r1, [r3, #0]
 80042be:	69fb      	ldr	r3, [r7, #28]
 80042c0:	3301      	adds	r3, #1
 80042c2:	b2db      	uxtb	r3, r3
 80042c4:	18db      	adds	r3, r3, r3
 80042c6:	b2da      	uxtb	r2, r3
 80042c8:	241b      	movs	r4, #27
 80042ca:	193b      	adds	r3, r7, r4
 80042cc:	188a      	adds	r2, r1, r2
 80042ce:	701a      	strb	r2, [r3, #0]
		status = VL53L1_SetDeviceAddress(&pstdistancia->VL53L1_DEV[sensor], newI2C);
 80042d0:	69fb      	ldr	r3, [r7, #28]
 80042d2:	22e9      	movs	r2, #233	; 0xe9
 80042d4:	0092      	lsls	r2, r2, #2
 80042d6:	4353      	muls	r3, r2
 80042d8:	33d1      	adds	r3, #209	; 0xd1
 80042da:	33ff      	adds	r3, #255	; 0xff
 80042dc:	687a      	ldr	r2, [r7, #4]
 80042de:	18d2      	adds	r2, r2, r3
 80042e0:	193b      	adds	r3, r7, r4
 80042e2:	781b      	ldrb	r3, [r3, #0]
 80042e4:	0019      	movs	r1, r3
 80042e6:	0010      	movs	r0, r2
 80042e8:	f003 fe5b 	bl	8007fa2 <VL53L1_SetDeviceAddress>
 80042ec:	0003      	movs	r3, r0
 80042ee:	617b      	str	r3, [r7, #20]
		pstdistancia->VL53L1_DEV[sensor].I2cDevAddr=newI2C;
 80042f0:	6879      	ldr	r1, [r7, #4]
 80042f2:	69fa      	ldr	r2, [r7, #28]
 80042f4:	23ad      	movs	r3, #173	; 0xad
 80042f6:	00db      	lsls	r3, r3, #3
 80042f8:	20e9      	movs	r0, #233	; 0xe9
 80042fa:	0080      	lsls	r0, r0, #2
 80042fc:	4342      	muls	r2, r0
 80042fe:	188a      	adds	r2, r1, r2
 8004300:	18d3      	adds	r3, r2, r3
 8004302:	193a      	adds	r2, r7, r4
 8004304:	7812      	ldrb	r2, [r2, #0]
 8004306:	701a      	strb	r2, [r3, #0]
		VL53L1_RdWord(&pstdistancia->VL53L1_DEV[sensor], 0x010F, &wordData);
 8004308:	69fb      	ldr	r3, [r7, #28]
 800430a:	22e9      	movs	r2, #233	; 0xe9
 800430c:	0092      	lsls	r2, r2, #2
 800430e:	4353      	muls	r3, r2
 8004310:	33d1      	adds	r3, #209	; 0xd1
 8004312:	33ff      	adds	r3, #255	; 0xff
 8004314:	687a      	ldr	r2, [r7, #4]
 8004316:	18d0      	adds	r0, r2, r3
 8004318:	197a      	adds	r2, r7, r5
 800431a:	2310      	movs	r3, #16
 800431c:	33ff      	adds	r3, #255	; 0xff
 800431e:	0019      	movs	r1, r3
 8004320:	f00a f826 	bl	800e370 <VL53L1_RdWord>
//		printf("VL53L1X: %02X\n\r", wordData);
		/* Device Initialization and setting */
		status = VL53L1_WaitDeviceBooted(&pstdistancia->VL53L1_DEV[sensor]);
 8004324:	69fb      	ldr	r3, [r7, #28]
 8004326:	22e9      	movs	r2, #233	; 0xe9
 8004328:	0092      	lsls	r2, r2, #2
 800432a:	4353      	muls	r3, r2
 800432c:	33d1      	adds	r3, #209	; 0xd1
 800432e:	33ff      	adds	r3, #255	; 0xff
 8004330:	687a      	ldr	r2, [r7, #4]
 8004332:	18d3      	adds	r3, r2, r3
 8004334:	0018      	movs	r0, r3
 8004336:	f003 ff05 	bl	8008144 <VL53L1_WaitDeviceBooted>
 800433a:	0003      	movs	r3, r0
 800433c:	617b      	str	r3, [r7, #20]
		status = VL53L1_DataInit(&pstdistancia->VL53L1_DEV[sensor]);
 800433e:	69fb      	ldr	r3, [r7, #28]
 8004340:	22e9      	movs	r2, #233	; 0xe9
 8004342:	0092      	lsls	r2, r2, #2
 8004344:	4353      	muls	r3, r2
 8004346:	33d1      	adds	r3, #209	; 0xd1
 8004348:	33ff      	adds	r3, #255	; 0xff
 800434a:	687a      	ldr	r2, [r7, #4]
 800434c:	18d3      	adds	r3, r2, r3
 800434e:	0018      	movs	r0, r3
 8004350:	f003 fe47 	bl	8007fe2 <VL53L1_DataInit>
 8004354:	0003      	movs	r3, r0
 8004356:	617b      	str	r3, [r7, #20]
		status = VL53L1_StaticInit(&pstdistancia->VL53L1_DEV[sensor]);
 8004358:	69fb      	ldr	r3, [r7, #28]
 800435a:	22e9      	movs	r2, #233	; 0xe9
 800435c:	0092      	lsls	r2, r2, #2
 800435e:	4353      	muls	r3, r2
 8004360:	33d1      	adds	r3, #209	; 0xd1
 8004362:	33ff      	adds	r3, #255	; 0xff
 8004364:	687a      	ldr	r2, [r7, #4]
 8004366:	18d3      	adds	r3, r2, r3
 8004368:	0018      	movs	r0, r3
 800436a:	f003 feb3 	bl	80080d4 <VL53L1_StaticInit>
 800436e:	0003      	movs	r3, r0
 8004370:	617b      	str	r3, [r7, #20]
		status = VL53L1_SetDistanceMode(&pstdistancia->VL53L1_DEV[sensor], VL53L1_DISTANCEMODE_SHORT);
 8004372:	69fb      	ldr	r3, [r7, #28]
 8004374:	22e9      	movs	r2, #233	; 0xe9
 8004376:	0092      	lsls	r2, r2, #2
 8004378:	4353      	muls	r3, r2
 800437a:	33d1      	adds	r3, #209	; 0xd1
 800437c:	33ff      	adds	r3, #255	; 0xff
 800437e:	687a      	ldr	r2, [r7, #4]
 8004380:	18d3      	adds	r3, r2, r3
 8004382:	2101      	movs	r1, #1
 8004384:	0018      	movs	r0, r3
 8004386:	f004 f863 	bl	8008450 <VL53L1_SetDistanceMode>
 800438a:	0003      	movs	r3, r0
 800438c:	617b      	str	r3, [r7, #20]
		status = VL53L1_SetMeasurementTimingBudgetMicroSeconds(&pstdistancia->VL53L1_DEV[sensor], 50000);
 800438e:	69fb      	ldr	r3, [r7, #28]
 8004390:	22e9      	movs	r2, #233	; 0xe9
 8004392:	0092      	lsls	r2, r2, #2
 8004394:	4353      	muls	r3, r2
 8004396:	33d1      	adds	r3, #209	; 0xd1
 8004398:	33ff      	adds	r3, #255	; 0xff
 800439a:	687a      	ldr	r2, [r7, #4]
 800439c:	18d3      	adds	r3, r2, r3
 800439e:	4a1e      	ldr	r2, [pc, #120]	; (8004418 <IniciarSensores+0x224>)
 80043a0:	0011      	movs	r1, r2
 80043a2:	0018      	movs	r0, r3
 80043a4:	f004 f916 	bl	80085d4 <VL53L1_SetMeasurementTimingBudgetMicroSeconds>
 80043a8:	0003      	movs	r3, r0
 80043aa:	617b      	str	r3, [r7, #20]
		status = VL53L1_SetInterMeasurementPeriodMilliSeconds(&pstdistancia->VL53L1_DEV[sensor], 55);
 80043ac:	69fb      	ldr	r3, [r7, #28]
 80043ae:	22e9      	movs	r2, #233	; 0xe9
 80043b0:	0092      	lsls	r2, r2, #2
 80043b2:	4353      	muls	r3, r2
 80043b4:	33d1      	adds	r3, #209	; 0xd1
 80043b6:	33ff      	adds	r3, #255	; 0xff
 80043b8:	687a      	ldr	r2, [r7, #4]
 80043ba:	18d3      	adds	r3, r2, r3
 80043bc:	2137      	movs	r1, #55	; 0x37
 80043be:	0018      	movs	r0, r3
 80043c0:	f004 fade 	bl	8008980 <VL53L1_SetInterMeasurementPeriodMilliSeconds>
 80043c4:	0003      	movs	r3, r0
 80043c6:	617b      	str	r3, [r7, #20]
		status = VL53L1_SetUserROI(&pstdistancia->VL53L1_DEV[sensor], &roiConfig);
 80043c8:	69fb      	ldr	r3, [r7, #28]
 80043ca:	22e9      	movs	r2, #233	; 0xe9
 80043cc:	0092      	lsls	r2, r2, #2
 80043ce:	4353      	muls	r3, r2
 80043d0:	33d1      	adds	r3, #209	; 0xd1
 80043d2:	33ff      	adds	r3, #255	; 0xff
 80043d4:	687a      	ldr	r2, [r7, #4]
 80043d6:	18d3      	adds	r3, r2, r3
 80043d8:	220c      	movs	r2, #12
 80043da:	18ba      	adds	r2, r7, r2
 80043dc:	0011      	movs	r1, r2
 80043de:	0018      	movs	r0, r3
 80043e0:	f004 fca7 	bl	8008d32 <VL53L1_SetUserROI>
 80043e4:	0003      	movs	r3, r0
 80043e6:	617b      	str	r3, [r7, #20]
	for(sensor=0; sensor<pstdistancia->SenHab; sensor++){
 80043e8:	69fb      	ldr	r3, [r7, #28]
 80043ea:	3301      	adds	r3, #1
 80043ec:	61fb      	str	r3, [r7, #28]
 80043ee:	687a      	ldr	r2, [r7, #4]
 80043f0:	23d4      	movs	r3, #212	; 0xd4
 80043f2:	005b      	lsls	r3, r3, #1
 80043f4:	5cd3      	ldrb	r3, [r2, r3]
 80043f6:	001a      	movs	r2, r3
 80043f8:	69fb      	ldr	r3, [r7, #28]
 80043fa:	4293      	cmp	r3, r2
 80043fc:	da00      	bge.n	8004400 <IniciarSensores+0x20c>
 80043fe:	e711      	b.n	8004224 <IniciarSensores+0x30>
	}


	return 1;
 8004400:	2301      	movs	r3, #1
}
 8004402:	0018      	movs	r0, r3
 8004404:	46bd      	mov	sp, r7
 8004406:	b008      	add	sp, #32
 8004408:	bdb0      	pop	{r4, r5, r7, pc}
 800440a:	46c0      	nop			; (mov r8, r8)
 800440c:	0000056a 	.word	0x0000056a
 8004410:	200004e4 	.word	0x200004e4
 8004414:	00000569 	.word	0x00000569
 8004418:	0000c350 	.word	0x0000c350

0800441c <EnableSensors>:
Salidas:          		0
Descripción:  		    Habilita los sensores secuencialmente para su configuración
Notas y Cambios:
****************************************************************************************/
uint8_t EnableSensors(stDistancia *pstdistancia)
{
 800441c:	b580      	push	{r7, lr}
 800441e:	b082      	sub	sp, #8
 8004420:	af00      	add	r7, sp, #0
 8004422:	6078      	str	r0, [r7, #4]
	switch(pstdistancia->contParrilla)
 8004424:	687b      	ldr	r3, [r7, #4]
 8004426:	2266      	movs	r2, #102	; 0x66
 8004428:	5c9b      	ldrb	r3, [r3, r2]
 800442a:	2b05      	cmp	r3, #5
 800442c:	d900      	bls.n	8004430 <EnableSensors+0x14>
 800442e:	e0f4      	b.n	800461a <EnableSensors+0x1fe>
 8004430:	009a      	lsls	r2, r3, #2
 8004432:	4b92      	ldr	r3, [pc, #584]	; (800467c <EnableSensors+0x260>)
 8004434:	18d3      	adds	r3, r2, r3
 8004436:	681b      	ldr	r3, [r3, #0]
 8004438:	469f      	mov	pc, r3
	{
	case 0:
		HAL_GPIO_WritePin(VL53_XSHUT_1_GPIO_Port, VL53_XSHUT_1_Pin, GPIO_PIN_SET);
 800443a:	2380      	movs	r3, #128	; 0x80
 800443c:	01db      	lsls	r3, r3, #7
 800443e:	4890      	ldr	r0, [pc, #576]	; (8004680 <EnableSensors+0x264>)
 8004440:	2201      	movs	r2, #1
 8004442:	0019      	movs	r1, r3
 8004444:	f00b fc67 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_2_GPIO_Port, VL53_XSHUT_2_Pin, GPIO_PIN_RESET);
 8004448:	4b8d      	ldr	r3, [pc, #564]	; (8004680 <EnableSensors+0x264>)
 800444a:	2200      	movs	r2, #0
 800444c:	2140      	movs	r1, #64	; 0x40
 800444e:	0018      	movs	r0, r3
 8004450:	f00b fc61 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_3_GPIO_Port, VL53_XSHUT_3_Pin, GPIO_PIN_RESET);
 8004454:	2380      	movs	r3, #128	; 0x80
 8004456:	00db      	lsls	r3, r3, #3
 8004458:	488a      	ldr	r0, [pc, #552]	; (8004684 <EnableSensors+0x268>)
 800445a:	2200      	movs	r2, #0
 800445c:	0019      	movs	r1, r3
 800445e:	f00b fc5a 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_4_GPIO_Port, VL53_XSHUT_4_Pin, GPIO_PIN_RESET);
 8004462:	4b88      	ldr	r3, [pc, #544]	; (8004684 <EnableSensors+0x268>)
 8004464:	2200      	movs	r2, #0
 8004466:	2102      	movs	r1, #2
 8004468:	0018      	movs	r0, r3
 800446a:	f00b fc54 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_5_GPIO_Port, VL53_XSHUT_5_Pin, GPIO_PIN_RESET);
 800446e:	23a0      	movs	r3, #160	; 0xa0
 8004470:	05db      	lsls	r3, r3, #23
 8004472:	2200      	movs	r2, #0
 8004474:	2120      	movs	r1, #32
 8004476:	0018      	movs	r0, r3
 8004478:	f00b fc4d 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_6_GPIO_Port, VL53_XSHUT_6_Pin, GPIO_PIN_RESET);
 800447c:	4b80      	ldr	r3, [pc, #512]	; (8004680 <EnableSensors+0x264>)
 800447e:	2200      	movs	r2, #0
 8004480:	2104      	movs	r1, #4
 8004482:	0018      	movs	r0, r3
 8004484:	f00b fc47 	bl	800fd16 <HAL_GPIO_WritePin>
		break;
 8004488:	e0ef      	b.n	800466a <EnableSensors+0x24e>
	case 1:
		HAL_GPIO_WritePin(VL53_XSHUT_1_GPIO_Port, VL53_XSHUT_1_Pin, GPIO_PIN_SET);
 800448a:	2380      	movs	r3, #128	; 0x80
 800448c:	01db      	lsls	r3, r3, #7
 800448e:	487c      	ldr	r0, [pc, #496]	; (8004680 <EnableSensors+0x264>)
 8004490:	2201      	movs	r2, #1
 8004492:	0019      	movs	r1, r3
 8004494:	f00b fc3f 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_2_GPIO_Port, VL53_XSHUT_2_Pin, GPIO_PIN_SET);
 8004498:	4b79      	ldr	r3, [pc, #484]	; (8004680 <EnableSensors+0x264>)
 800449a:	2201      	movs	r2, #1
 800449c:	2140      	movs	r1, #64	; 0x40
 800449e:	0018      	movs	r0, r3
 80044a0:	f00b fc39 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_3_GPIO_Port, VL53_XSHUT_3_Pin, GPIO_PIN_RESET);
 80044a4:	2380      	movs	r3, #128	; 0x80
 80044a6:	00db      	lsls	r3, r3, #3
 80044a8:	4876      	ldr	r0, [pc, #472]	; (8004684 <EnableSensors+0x268>)
 80044aa:	2200      	movs	r2, #0
 80044ac:	0019      	movs	r1, r3
 80044ae:	f00b fc32 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_4_GPIO_Port, VL53_XSHUT_4_Pin, GPIO_PIN_RESET);
 80044b2:	4b74      	ldr	r3, [pc, #464]	; (8004684 <EnableSensors+0x268>)
 80044b4:	2200      	movs	r2, #0
 80044b6:	2102      	movs	r1, #2
 80044b8:	0018      	movs	r0, r3
 80044ba:	f00b fc2c 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_5_GPIO_Port, VL53_XSHUT_5_Pin, GPIO_PIN_RESET);
 80044be:	23a0      	movs	r3, #160	; 0xa0
 80044c0:	05db      	lsls	r3, r3, #23
 80044c2:	2200      	movs	r2, #0
 80044c4:	2120      	movs	r1, #32
 80044c6:	0018      	movs	r0, r3
 80044c8:	f00b fc25 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_6_GPIO_Port, VL53_XSHUT_6_Pin, GPIO_PIN_RESET);
 80044cc:	4b6c      	ldr	r3, [pc, #432]	; (8004680 <EnableSensors+0x264>)
 80044ce:	2200      	movs	r2, #0
 80044d0:	2104      	movs	r1, #4
 80044d2:	0018      	movs	r0, r3
 80044d4:	f00b fc1f 	bl	800fd16 <HAL_GPIO_WritePin>
		break;
 80044d8:	e0c7      	b.n	800466a <EnableSensors+0x24e>
	case 2:
		HAL_GPIO_WritePin(VL53_XSHUT_1_GPIO_Port, VL53_XSHUT_1_Pin, GPIO_PIN_SET);
 80044da:	2380      	movs	r3, #128	; 0x80
 80044dc:	01db      	lsls	r3, r3, #7
 80044de:	4868      	ldr	r0, [pc, #416]	; (8004680 <EnableSensors+0x264>)
 80044e0:	2201      	movs	r2, #1
 80044e2:	0019      	movs	r1, r3
 80044e4:	f00b fc17 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_2_GPIO_Port, VL53_XSHUT_2_Pin, GPIO_PIN_SET);
 80044e8:	4b65      	ldr	r3, [pc, #404]	; (8004680 <EnableSensors+0x264>)
 80044ea:	2201      	movs	r2, #1
 80044ec:	2140      	movs	r1, #64	; 0x40
 80044ee:	0018      	movs	r0, r3
 80044f0:	f00b fc11 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_3_GPIO_Port, VL53_XSHUT_3_Pin, GPIO_PIN_SET);
 80044f4:	2380      	movs	r3, #128	; 0x80
 80044f6:	00db      	lsls	r3, r3, #3
 80044f8:	4862      	ldr	r0, [pc, #392]	; (8004684 <EnableSensors+0x268>)
 80044fa:	2201      	movs	r2, #1
 80044fc:	0019      	movs	r1, r3
 80044fe:	f00b fc0a 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_4_GPIO_Port, VL53_XSHUT_4_Pin, GPIO_PIN_RESET);
 8004502:	4b60      	ldr	r3, [pc, #384]	; (8004684 <EnableSensors+0x268>)
 8004504:	2200      	movs	r2, #0
 8004506:	2102      	movs	r1, #2
 8004508:	0018      	movs	r0, r3
 800450a:	f00b fc04 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_5_GPIO_Port, VL53_XSHUT_5_Pin, GPIO_PIN_RESET);
 800450e:	23a0      	movs	r3, #160	; 0xa0
 8004510:	05db      	lsls	r3, r3, #23
 8004512:	2200      	movs	r2, #0
 8004514:	2120      	movs	r1, #32
 8004516:	0018      	movs	r0, r3
 8004518:	f00b fbfd 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_6_GPIO_Port, VL53_XSHUT_6_Pin, GPIO_PIN_RESET);
 800451c:	4b58      	ldr	r3, [pc, #352]	; (8004680 <EnableSensors+0x264>)
 800451e:	2200      	movs	r2, #0
 8004520:	2104      	movs	r1, #4
 8004522:	0018      	movs	r0, r3
 8004524:	f00b fbf7 	bl	800fd16 <HAL_GPIO_WritePin>
		break;
 8004528:	e09f      	b.n	800466a <EnableSensors+0x24e>
	case 3:
		HAL_GPIO_WritePin(VL53_XSHUT_1_GPIO_Port, VL53_XSHUT_1_Pin, GPIO_PIN_SET);
 800452a:	2380      	movs	r3, #128	; 0x80
 800452c:	01db      	lsls	r3, r3, #7
 800452e:	4854      	ldr	r0, [pc, #336]	; (8004680 <EnableSensors+0x264>)
 8004530:	2201      	movs	r2, #1
 8004532:	0019      	movs	r1, r3
 8004534:	f00b fbef 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_2_GPIO_Port, VL53_XSHUT_2_Pin, GPIO_PIN_SET);
 8004538:	4b51      	ldr	r3, [pc, #324]	; (8004680 <EnableSensors+0x264>)
 800453a:	2201      	movs	r2, #1
 800453c:	2140      	movs	r1, #64	; 0x40
 800453e:	0018      	movs	r0, r3
 8004540:	f00b fbe9 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_3_GPIO_Port, VL53_XSHUT_3_Pin, GPIO_PIN_SET);
 8004544:	2380      	movs	r3, #128	; 0x80
 8004546:	00db      	lsls	r3, r3, #3
 8004548:	484e      	ldr	r0, [pc, #312]	; (8004684 <EnableSensors+0x268>)
 800454a:	2201      	movs	r2, #1
 800454c:	0019      	movs	r1, r3
 800454e:	f00b fbe2 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_4_GPIO_Port, VL53_XSHUT_4_Pin, GPIO_PIN_SET);
 8004552:	4b4c      	ldr	r3, [pc, #304]	; (8004684 <EnableSensors+0x268>)
 8004554:	2201      	movs	r2, #1
 8004556:	2102      	movs	r1, #2
 8004558:	0018      	movs	r0, r3
 800455a:	f00b fbdc 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_5_GPIO_Port, VL53_XSHUT_5_Pin, GPIO_PIN_RESET);
 800455e:	23a0      	movs	r3, #160	; 0xa0
 8004560:	05db      	lsls	r3, r3, #23
 8004562:	2200      	movs	r2, #0
 8004564:	2120      	movs	r1, #32
 8004566:	0018      	movs	r0, r3
 8004568:	f00b fbd5 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_6_GPIO_Port, VL53_XSHUT_6_Pin, GPIO_PIN_RESET);
 800456c:	4b44      	ldr	r3, [pc, #272]	; (8004680 <EnableSensors+0x264>)
 800456e:	2200      	movs	r2, #0
 8004570:	2104      	movs	r1, #4
 8004572:	0018      	movs	r0, r3
 8004574:	f00b fbcf 	bl	800fd16 <HAL_GPIO_WritePin>
		break;
 8004578:	e077      	b.n	800466a <EnableSensors+0x24e>
	case 4:
		HAL_GPIO_WritePin(VL53_XSHUT_1_GPIO_Port, VL53_XSHUT_1_Pin, GPIO_PIN_SET);
 800457a:	2380      	movs	r3, #128	; 0x80
 800457c:	01db      	lsls	r3, r3, #7
 800457e:	4840      	ldr	r0, [pc, #256]	; (8004680 <EnableSensors+0x264>)
 8004580:	2201      	movs	r2, #1
 8004582:	0019      	movs	r1, r3
 8004584:	f00b fbc7 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_2_GPIO_Port, VL53_XSHUT_2_Pin, GPIO_PIN_SET);
 8004588:	4b3d      	ldr	r3, [pc, #244]	; (8004680 <EnableSensors+0x264>)
 800458a:	2201      	movs	r2, #1
 800458c:	2140      	movs	r1, #64	; 0x40
 800458e:	0018      	movs	r0, r3
 8004590:	f00b fbc1 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_3_GPIO_Port, VL53_XSHUT_3_Pin, GPIO_PIN_SET);
 8004594:	2380      	movs	r3, #128	; 0x80
 8004596:	00db      	lsls	r3, r3, #3
 8004598:	483a      	ldr	r0, [pc, #232]	; (8004684 <EnableSensors+0x268>)
 800459a:	2201      	movs	r2, #1
 800459c:	0019      	movs	r1, r3
 800459e:	f00b fbba 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_4_GPIO_Port, VL53_XSHUT_4_Pin, GPIO_PIN_SET);
 80045a2:	4b38      	ldr	r3, [pc, #224]	; (8004684 <EnableSensors+0x268>)
 80045a4:	2201      	movs	r2, #1
 80045a6:	2102      	movs	r1, #2
 80045a8:	0018      	movs	r0, r3
 80045aa:	f00b fbb4 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_5_GPIO_Port, VL53_XSHUT_5_Pin, GPIO_PIN_SET);
 80045ae:	23a0      	movs	r3, #160	; 0xa0
 80045b0:	05db      	lsls	r3, r3, #23
 80045b2:	2201      	movs	r2, #1
 80045b4:	2120      	movs	r1, #32
 80045b6:	0018      	movs	r0, r3
 80045b8:	f00b fbad 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_6_GPIO_Port, VL53_XSHUT_6_Pin, GPIO_PIN_RESET);
 80045bc:	4b30      	ldr	r3, [pc, #192]	; (8004680 <EnableSensors+0x264>)
 80045be:	2200      	movs	r2, #0
 80045c0:	2104      	movs	r1, #4
 80045c2:	0018      	movs	r0, r3
 80045c4:	f00b fba7 	bl	800fd16 <HAL_GPIO_WritePin>
		break;
 80045c8:	e04f      	b.n	800466a <EnableSensors+0x24e>
	case 5:
		HAL_GPIO_WritePin(VL53_XSHUT_1_GPIO_Port, VL53_XSHUT_1_Pin, GPIO_PIN_SET);
 80045ca:	2380      	movs	r3, #128	; 0x80
 80045cc:	01db      	lsls	r3, r3, #7
 80045ce:	482c      	ldr	r0, [pc, #176]	; (8004680 <EnableSensors+0x264>)
 80045d0:	2201      	movs	r2, #1
 80045d2:	0019      	movs	r1, r3
 80045d4:	f00b fb9f 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_2_GPIO_Port, VL53_XSHUT_2_Pin, GPIO_PIN_SET);
 80045d8:	4b29      	ldr	r3, [pc, #164]	; (8004680 <EnableSensors+0x264>)
 80045da:	2201      	movs	r2, #1
 80045dc:	2140      	movs	r1, #64	; 0x40
 80045de:	0018      	movs	r0, r3
 80045e0:	f00b fb99 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_3_GPIO_Port, VL53_XSHUT_3_Pin, GPIO_PIN_SET);
 80045e4:	2380      	movs	r3, #128	; 0x80
 80045e6:	00db      	lsls	r3, r3, #3
 80045e8:	4826      	ldr	r0, [pc, #152]	; (8004684 <EnableSensors+0x268>)
 80045ea:	2201      	movs	r2, #1
 80045ec:	0019      	movs	r1, r3
 80045ee:	f00b fb92 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_4_GPIO_Port, VL53_XSHUT_4_Pin, GPIO_PIN_SET);
 80045f2:	4b24      	ldr	r3, [pc, #144]	; (8004684 <EnableSensors+0x268>)
 80045f4:	2201      	movs	r2, #1
 80045f6:	2102      	movs	r1, #2
 80045f8:	0018      	movs	r0, r3
 80045fa:	f00b fb8c 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_5_GPIO_Port, VL53_XSHUT_5_Pin, GPIO_PIN_SET);
 80045fe:	23a0      	movs	r3, #160	; 0xa0
 8004600:	05db      	lsls	r3, r3, #23
 8004602:	2201      	movs	r2, #1
 8004604:	2120      	movs	r1, #32
 8004606:	0018      	movs	r0, r3
 8004608:	f00b fb85 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_6_GPIO_Port, VL53_XSHUT_6_Pin, GPIO_PIN_SET);
 800460c:	4b1c      	ldr	r3, [pc, #112]	; (8004680 <EnableSensors+0x264>)
 800460e:	2201      	movs	r2, #1
 8004610:	2104      	movs	r1, #4
 8004612:	0018      	movs	r0, r3
 8004614:	f00b fb7f 	bl	800fd16 <HAL_GPIO_WritePin>
		break;
 8004618:	e027      	b.n	800466a <EnableSensors+0x24e>
	default:
		HAL_GPIO_WritePin(VL53_XSHUT_1_GPIO_Port, VL53_XSHUT_1_Pin, GPIO_PIN_SET);
 800461a:	2380      	movs	r3, #128	; 0x80
 800461c:	01db      	lsls	r3, r3, #7
 800461e:	4818      	ldr	r0, [pc, #96]	; (8004680 <EnableSensors+0x264>)
 8004620:	2201      	movs	r2, #1
 8004622:	0019      	movs	r1, r3
 8004624:	f00b fb77 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_2_GPIO_Port, VL53_XSHUT_2_Pin, GPIO_PIN_RESET);
 8004628:	4b15      	ldr	r3, [pc, #84]	; (8004680 <EnableSensors+0x264>)
 800462a:	2200      	movs	r2, #0
 800462c:	2140      	movs	r1, #64	; 0x40
 800462e:	0018      	movs	r0, r3
 8004630:	f00b fb71 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_3_GPIO_Port, VL53_XSHUT_3_Pin, GPIO_PIN_RESET);
 8004634:	2380      	movs	r3, #128	; 0x80
 8004636:	00db      	lsls	r3, r3, #3
 8004638:	4812      	ldr	r0, [pc, #72]	; (8004684 <EnableSensors+0x268>)
 800463a:	2200      	movs	r2, #0
 800463c:	0019      	movs	r1, r3
 800463e:	f00b fb6a 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_4_GPIO_Port, VL53_XSHUT_4_Pin, GPIO_PIN_RESET);
 8004642:	4b10      	ldr	r3, [pc, #64]	; (8004684 <EnableSensors+0x268>)
 8004644:	2200      	movs	r2, #0
 8004646:	2102      	movs	r1, #2
 8004648:	0018      	movs	r0, r3
 800464a:	f00b fb64 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_5_GPIO_Port, VL53_XSHUT_5_Pin, GPIO_PIN_RESET);
 800464e:	23a0      	movs	r3, #160	; 0xa0
 8004650:	05db      	lsls	r3, r3, #23
 8004652:	2200      	movs	r2, #0
 8004654:	2120      	movs	r1, #32
 8004656:	0018      	movs	r0, r3
 8004658:	f00b fb5d 	bl	800fd16 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VL53_XSHUT_6_GPIO_Port, VL53_XSHUT_6_Pin, GPIO_PIN_RESET);
 800465c:	4b08      	ldr	r3, [pc, #32]	; (8004680 <EnableSensors+0x264>)
 800465e:	2200      	movs	r2, #0
 8004660:	2104      	movs	r1, #4
 8004662:	0018      	movs	r0, r3
 8004664:	f00b fb57 	bl	800fd16 <HAL_GPIO_WritePin>
		break;
 8004668:	46c0      	nop			; (mov r8, r8)
	}
	HAL_Delay(30);
 800466a:	201e      	movs	r0, #30
 800466c:	f00a ff42 	bl	800f4f4 <HAL_Delay>

	return (uint8_t)0;
 8004670:	2300      	movs	r3, #0
}
 8004672:	0018      	movs	r0, r3
 8004674:	46bd      	mov	sp, r7
 8004676:	b002      	add	sp, #8
 8004678:	bd80      	pop	{r7, pc}
 800467a:	46c0      	nop			; (mov r8, r8)
 800467c:	08014e80 	.word	0x08014e80
 8004680:	50000800 	.word	0x50000800
 8004684:	50000400 	.word	0x50000400

08004688 <Convertir4Cif>:
Entradas:
Salidas:
Descripción:  		    Esta función convierte de uint16_t a decimal
Notas y Cambios:
****************************************************************************************/
void Convertir4Cif(uint16_t numero, uint8_t *mil, uint8_t *centena,	uint8_t *decena, uint8_t *unidad) {
 8004688:	b590      	push	{r4, r7, lr}
 800468a:	b087      	sub	sp, #28
 800468c:	af00      	add	r7, sp, #0
 800468e:	60b9      	str	r1, [r7, #8]
 8004690:	607a      	str	r2, [r7, #4]
 8004692:	603b      	str	r3, [r7, #0]
 8004694:	210e      	movs	r1, #14
 8004696:	187b      	adds	r3, r7, r1
 8004698:	1c02      	adds	r2, r0, #0
 800469a:	801a      	strh	r2, [r3, #0]
	uint16_t temp = 0;
 800469c:	2016      	movs	r0, #22
 800469e:	183b      	adds	r3, r7, r0
 80046a0:	2200      	movs	r2, #0
 80046a2:	801a      	strh	r2, [r3, #0]

	*unidad = 0;
 80046a4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80046a6:	2200      	movs	r2, #0
 80046a8:	701a      	strb	r2, [r3, #0]
	*decena = 0;
 80046aa:	683b      	ldr	r3, [r7, #0]
 80046ac:	2200      	movs	r2, #0
 80046ae:	701a      	strb	r2, [r3, #0]
	*centena = 0;
 80046b0:	687b      	ldr	r3, [r7, #4]
 80046b2:	2200      	movs	r2, #0
 80046b4:	701a      	strb	r2, [r3, #0]
	*mil = 0;
 80046b6:	68bb      	ldr	r3, [r7, #8]
 80046b8:	2200      	movs	r2, #0
 80046ba:	701a      	strb	r2, [r3, #0]

	temp = numero;
 80046bc:	183b      	adds	r3, r7, r0
 80046be:	187a      	adds	r2, r7, r1
 80046c0:	8812      	ldrh	r2, [r2, #0]
 80046c2:	801a      	strh	r2, [r3, #0]

	if (numero < 9999) {
 80046c4:	187b      	adds	r3, r7, r1
 80046c6:	881b      	ldrh	r3, [r3, #0]
 80046c8:	4a42      	ldr	r2, [pc, #264]	; (80047d4 <Convertir4Cif+0x14c>)
 80046ca:	4293      	cmp	r3, r2
 80046cc:	d871      	bhi.n	80047b2 <Convertir4Cif+0x12a>
		*mil = temp / 1000;
 80046ce:	2416      	movs	r4, #22
 80046d0:	193b      	adds	r3, r7, r4
 80046d2:	881a      	ldrh	r2, [r3, #0]
 80046d4:	23fa      	movs	r3, #250	; 0xfa
 80046d6:	0099      	lsls	r1, r3, #2
 80046d8:	0010      	movs	r0, r2
 80046da:	f7fb fd27 	bl	800012c <__udivsi3>
 80046de:	0003      	movs	r3, r0
 80046e0:	b29b      	uxth	r3, r3
 80046e2:	b2da      	uxtb	r2, r3
 80046e4:	68bb      	ldr	r3, [r7, #8]
 80046e6:	701a      	strb	r2, [r3, #0]
		temp = temp - *mil * 1000;
 80046e8:	68bb      	ldr	r3, [r7, #8]
 80046ea:	781b      	ldrb	r3, [r3, #0]
 80046ec:	b29b      	uxth	r3, r3
 80046ee:	1c1a      	adds	r2, r3, #0
 80046f0:	0192      	lsls	r2, r2, #6
 80046f2:	1ad2      	subs	r2, r2, r3
 80046f4:	0192      	lsls	r2, r2, #6
 80046f6:	18d2      	adds	r2, r2, r3
 80046f8:	1892      	adds	r2, r2, r2
 80046fa:	18d3      	adds	r3, r2, r3
 80046fc:	00db      	lsls	r3, r3, #3
 80046fe:	b299      	uxth	r1, r3
 8004700:	193b      	adds	r3, r7, r4
 8004702:	193a      	adds	r2, r7, r4
 8004704:	8812      	ldrh	r2, [r2, #0]
 8004706:	188a      	adds	r2, r1, r2
 8004708:	801a      	strh	r2, [r3, #0]
		*centena = temp / 100;
 800470a:	193b      	adds	r3, r7, r4
 800470c:	881b      	ldrh	r3, [r3, #0]
 800470e:	2164      	movs	r1, #100	; 0x64
 8004710:	0018      	movs	r0, r3
 8004712:	f7fb fd0b 	bl	800012c <__udivsi3>
 8004716:	0003      	movs	r3, r0
 8004718:	b29b      	uxth	r3, r3
 800471a:	b2da      	uxtb	r2, r3
 800471c:	687b      	ldr	r3, [r7, #4]
 800471e:	701a      	strb	r2, [r3, #0]
		temp = temp - *centena * 100;
 8004720:	687b      	ldr	r3, [r7, #4]
 8004722:	781b      	ldrb	r3, [r3, #0]
 8004724:	b29b      	uxth	r3, r3
 8004726:	1c1a      	adds	r2, r3, #0
 8004728:	0252      	lsls	r2, r2, #9
 800472a:	1ad2      	subs	r2, r2, r3
 800472c:	0092      	lsls	r2, r2, #2
 800472e:	18d2      	adds	r2, r2, r3
 8004730:	00d2      	lsls	r2, r2, #3
 8004732:	1ad3      	subs	r3, r2, r3
 8004734:	009b      	lsls	r3, r3, #2
 8004736:	b299      	uxth	r1, r3
 8004738:	193b      	adds	r3, r7, r4
 800473a:	193a      	adds	r2, r7, r4
 800473c:	8812      	ldrh	r2, [r2, #0]
 800473e:	188a      	adds	r2, r1, r2
 8004740:	801a      	strh	r2, [r3, #0]
		*decena = temp / 10;
 8004742:	193b      	adds	r3, r7, r4
 8004744:	881b      	ldrh	r3, [r3, #0]
 8004746:	210a      	movs	r1, #10
 8004748:	0018      	movs	r0, r3
 800474a:	f7fb fcef 	bl	800012c <__udivsi3>
 800474e:	0003      	movs	r3, r0
 8004750:	b29b      	uxth	r3, r3
 8004752:	b2da      	uxtb	r2, r3
 8004754:	683b      	ldr	r3, [r7, #0]
 8004756:	701a      	strb	r2, [r3, #0]
		temp = temp - *decena * 10;
 8004758:	683b      	ldr	r3, [r7, #0]
 800475a:	781b      	ldrb	r3, [r3, #0]
 800475c:	b29b      	uxth	r3, r3
 800475e:	1c1a      	adds	r2, r3, #0
 8004760:	0352      	lsls	r2, r2, #13
 8004762:	1ad2      	subs	r2, r2, r3
 8004764:	0092      	lsls	r2, r2, #2
 8004766:	1ad3      	subs	r3, r2, r3
 8004768:	18db      	adds	r3, r3, r3
 800476a:	b299      	uxth	r1, r3
 800476c:	193b      	adds	r3, r7, r4
 800476e:	193a      	adds	r2, r7, r4
 8004770:	8812      	ldrh	r2, [r2, #0]
 8004772:	188a      	adds	r2, r1, r2
 8004774:	801a      	strh	r2, [r3, #0]
		*unidad = temp;
 8004776:	193b      	adds	r3, r7, r4
 8004778:	881b      	ldrh	r3, [r3, #0]
 800477a:	b2da      	uxtb	r2, r3
 800477c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800477e:	701a      	strb	r2, [r3, #0]
		*mil = *mil + 48;
 8004780:	68bb      	ldr	r3, [r7, #8]
 8004782:	781b      	ldrb	r3, [r3, #0]
 8004784:	3330      	adds	r3, #48	; 0x30
 8004786:	b2da      	uxtb	r2, r3
 8004788:	68bb      	ldr	r3, [r7, #8]
 800478a:	701a      	strb	r2, [r3, #0]
		*centena = *centena + 48;
 800478c:	687b      	ldr	r3, [r7, #4]
 800478e:	781b      	ldrb	r3, [r3, #0]
 8004790:	3330      	adds	r3, #48	; 0x30
 8004792:	b2da      	uxtb	r2, r3
 8004794:	687b      	ldr	r3, [r7, #4]
 8004796:	701a      	strb	r2, [r3, #0]
		*decena = *decena + 48;
 8004798:	683b      	ldr	r3, [r7, #0]
 800479a:	781b      	ldrb	r3, [r3, #0]
 800479c:	3330      	adds	r3, #48	; 0x30
 800479e:	b2da      	uxtb	r2, r3
 80047a0:	683b      	ldr	r3, [r7, #0]
 80047a2:	701a      	strb	r2, [r3, #0]
		*unidad = *unidad + 48;
 80047a4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80047a6:	781b      	ldrb	r3, [r3, #0]
 80047a8:	3330      	adds	r3, #48	; 0x30
 80047aa:	b2da      	uxtb	r2, r3
 80047ac:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80047ae:	701a      	strb	r2, [r3, #0]
		*mil = 255;
		*centena = 255;
		*decena = 255;
		*unidad = 255;
	}
}
 80047b0:	e00b      	b.n	80047ca <Convertir4Cif+0x142>
		*mil = 255;
 80047b2:	68bb      	ldr	r3, [r7, #8]
 80047b4:	22ff      	movs	r2, #255	; 0xff
 80047b6:	701a      	strb	r2, [r3, #0]
		*centena = 255;
 80047b8:	687b      	ldr	r3, [r7, #4]
 80047ba:	22ff      	movs	r2, #255	; 0xff
 80047bc:	701a      	strb	r2, [r3, #0]
		*decena = 255;
 80047be:	683b      	ldr	r3, [r7, #0]
 80047c0:	22ff      	movs	r2, #255	; 0xff
 80047c2:	701a      	strb	r2, [r3, #0]
		*unidad = 255;
 80047c4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80047c6:	22ff      	movs	r2, #255	; 0xff
 80047c8:	701a      	strb	r2, [r3, #0]
}
 80047ca:	46c0      	nop			; (mov r8, r8)
 80047cc:	46bd      	mov	sp, r7
 80047ce:	b007      	add	sp, #28
 80047d0:	bd90      	pop	{r4, r7, pc}
 80047d2:	46c0      	nop			; (mov r8, r8)
 80047d4:	0000270e 	.word	0x0000270e

080047d8 <Iniciar_EstrucCaptura>:
Salidas:          				N/A
Descripción:  		    		Esta función inicia la Estructura de Datos del Bloque Captura
Notas y Cambios:  
****************************************************************************************/
char Iniciar_EstrucCaptura(stCaptura *pstcaptura)
{
 80047d8:	b580      	push	{r7, lr}
 80047da:	b084      	sub	sp, #16
 80047dc:	af00      	add	r7, sp, #0
 80047de:	6078      	str	r0, [r7, #4]
	int i,j;

	pstcaptura->CAP_State = CAP_ESPERAR;
 80047e0:	687b      	ldr	r3, [r7, #4]
 80047e2:	2200      	movs	r2, #0
 80047e4:	701a      	strb	r2, [r3, #0]
	pstcaptura->filaActual = 0;
 80047e6:	687b      	ldr	r3, [r7, #4]
 80047e8:	2200      	movs	r2, #0
 80047ea:	705a      	strb	r2, [r3, #1]
	pstcaptura->Distancia = 34;  // Profundidad dada en cm
 80047ec:	687b      	ldr	r3, [r7, #4]
 80047ee:	2222      	movs	r2, #34	; 0x22
 80047f0:	709a      	strb	r2, [r3, #2]
	
	for(i = 0; i < MAX_PARR; i++)
 80047f2:	2300      	movs	r3, #0
 80047f4:	60fb      	str	r3, [r7, #12]
 80047f6:	e031      	b.n	800485c <Iniciar_EstrucCaptura+0x84>
	{
		for(j = 0; j < MAX_FILAS; j++)
 80047f8:	2300      	movs	r3, #0
 80047fa:	60bb      	str	r3, [r7, #8]
 80047fc:	e028      	b.n	8004850 <Iniciar_EstrucCaptura+0x78>
		{
	//		pstcaptura->anchos[i] = 70; // 7cm
			pstcaptura->ancho[i][j] = 61; // 6.1cm
 80047fe:	6879      	ldr	r1, [r7, #4]
 8004800:	68fa      	ldr	r2, [r7, #12]
 8004802:	0013      	movs	r3, r2
 8004804:	009b      	lsls	r3, r3, #2
 8004806:	189b      	adds	r3, r3, r2
 8004808:	005b      	lsls	r3, r3, #1
 800480a:	18ca      	adds	r2, r1, r3
 800480c:	68bb      	ldr	r3, [r7, #8]
 800480e:	18d3      	adds	r3, r2, r3
 8004810:	3303      	adds	r3, #3
 8004812:	223d      	movs	r2, #61	; 0x3d
 8004814:	701a      	strb	r2, [r3, #0]
			pstcaptura->largo[i][j] = 61; // 6.1cm
 8004816:	6879      	ldr	r1, [r7, #4]
 8004818:	68fa      	ldr	r2, [r7, #12]
 800481a:	2067      	movs	r0, #103	; 0x67
 800481c:	0013      	movs	r3, r2
 800481e:	009b      	lsls	r3, r3, #2
 8004820:	189b      	adds	r3, r3, r2
 8004822:	005b      	lsls	r3, r3, #1
 8004824:	18ca      	adds	r2, r1, r3
 8004826:	68bb      	ldr	r3, [r7, #8]
 8004828:	18d3      	adds	r3, r2, r3
 800482a:	181b      	adds	r3, r3, r0
 800482c:	223d      	movs	r2, #61	; 0x3d
 800482e:	701a      	strb	r2, [r3, #0]
			pstcaptura->cantidades[i][j] = 255;
 8004830:	6879      	ldr	r1, [r7, #4]
 8004832:	68fa      	ldr	r2, [r7, #12]
 8004834:	20cb      	movs	r0, #203	; 0xcb
 8004836:	0013      	movs	r3, r2
 8004838:	009b      	lsls	r3, r3, #2
 800483a:	189b      	adds	r3, r3, r2
 800483c:	005b      	lsls	r3, r3, #1
 800483e:	18ca      	adds	r2, r1, r3
 8004840:	68bb      	ldr	r3, [r7, #8]
 8004842:	18d3      	adds	r3, r2, r3
 8004844:	181b      	adds	r3, r3, r0
 8004846:	22ff      	movs	r2, #255	; 0xff
 8004848:	701a      	strb	r2, [r3, #0]
		for(j = 0; j < MAX_FILAS; j++)
 800484a:	68bb      	ldr	r3, [r7, #8]
 800484c:	3301      	adds	r3, #1
 800484e:	60bb      	str	r3, [r7, #8]
 8004850:	68bb      	ldr	r3, [r7, #8]
 8004852:	2b09      	cmp	r3, #9
 8004854:	ddd3      	ble.n	80047fe <Iniciar_EstrucCaptura+0x26>
	for(i = 0; i < MAX_PARR; i++)
 8004856:	68fb      	ldr	r3, [r7, #12]
 8004858:	3301      	adds	r3, #1
 800485a:	60fb      	str	r3, [r7, #12]
 800485c:	68fb      	ldr	r3, [r7, #12]
 800485e:	2b09      	cmp	r3, #9
 8004860:	ddca      	ble.n	80047f8 <Iniciar_EstrucCaptura+0x20>
		}
	}
	
	for(i = 0; i < TX_BUFFER_SIZE; i++)
 8004862:	2300      	movs	r3, #0
 8004864:	60fb      	str	r3, [r7, #12]
 8004866:	e00a      	b.n	800487e <Iniciar_EstrucCaptura+0xa6>
	{
		pstcaptura->bufferTrama[i] = 0x00;
 8004868:	6879      	ldr	r1, [r7, #4]
 800486a:	2330      	movs	r3, #48	; 0x30
 800486c:	33ff      	adds	r3, #255	; 0xff
 800486e:	68fa      	ldr	r2, [r7, #12]
 8004870:	188a      	adds	r2, r1, r2
 8004872:	18d3      	adds	r3, r2, r3
 8004874:	2200      	movs	r2, #0
 8004876:	701a      	strb	r2, [r3, #0]
	for(i = 0; i < TX_BUFFER_SIZE; i++)
 8004878:	68fb      	ldr	r3, [r7, #12]
 800487a:	3301      	adds	r3, #1
 800487c:	60fb      	str	r3, [r7, #12]
 800487e:	68fb      	ldr	r3, [r7, #12]
 8004880:	2b68      	cmp	r3, #104	; 0x68
 8004882:	ddf1      	ble.n	8004868 <Iniciar_EstrucCaptura+0x90>
	}
	
	return 1;
 8004884:	2301      	movs	r3, #1
}
 8004886:	0018      	movs	r0, r3
 8004888:	46bd      	mov	sp, r7
 800488a:	b004      	add	sp, #16
 800488c:	bd80      	pop	{r7, pc}

0800488e <Iniciar_EstrucComCEIT>:
Salidas:          		N/A
Descripción:  		    Esta función inicia la Estructura de Datos del Bloque COM_CEIT
Notas y Cambios:  
****************************************************************************************/
char Iniciar_EstrucComCEIT(stComCEIT *pstcomceit)
{
 800488e:	b580      	push	{r7, lr}
 8004890:	b084      	sub	sp, #16
 8004892:	af00      	add	r7, sp, #0
 8004894:	6078      	str	r0, [r7, #4]
	int i;
	
	pstcomceit->SM_State = SM_STATE_START_RX;
 8004896:	687b      	ldr	r3, [r7, #4]
 8004898:	2200      	movs	r2, #0
 800489a:	701a      	strb	r2, [r3, #0]
	pstcomceit->enviarDatos = false;
 800489c:	687b      	ldr	r3, [r7, #4]
 800489e:	2200      	movs	r2, #0
 80048a0:	705a      	strb	r2, [r3, #1]
	pstcomceit->datosListos = false;
 80048a2:	687b      	ldr	r3, [r7, #4]
 80048a4:	2200      	movs	r2, #0
 80048a6:	709a      	strb	r2, [r3, #2]
	pstcomceit->envioOK = true;
 80048a8:	687b      	ldr	r3, [r7, #4]
 80048aa:	2201      	movs	r2, #1
 80048ac:	70da      	strb	r2, [r3, #3]
	pstcomceit->xRxDoneFlag = false;
 80048ae:	687b      	ldr	r3, [r7, #4]
 80048b0:	2200      	movs	r2, #0
 80048b2:	711a      	strb	r2, [r3, #4]
	pstcomceit->xTxDoneFlag = false;
 80048b4:	687b      	ldr	r3, [r7, #4]
 80048b6:	2200      	movs	r2, #0
 80048b8:	715a      	strb	r2, [r3, #5]
	pstcomceit->TxLength = 0;
 80048ba:	687b      	ldr	r3, [r7, #4]
 80048bc:	2200      	movs	r2, #0
 80048be:	719a      	strb	r2, [r3, #6]
	pstcomceit->RxLength = 0;
 80048c0:	687b      	ldr	r3, [r7, #4]
 80048c2:	2200      	movs	r2, #0
 80048c4:	71da      	strb	r2, [r3, #7]
	
	for(i = 0; i < TX_BUFFER_SIZE; i++)
 80048c6:	2300      	movs	r3, #0
 80048c8:	60fb      	str	r3, [r7, #12]
 80048ca:	e008      	b.n	80048de <Iniciar_EstrucComCEIT+0x50>
	{
		pstcomceit->Tx_Buffer[i] = 0x00;
 80048cc:	687a      	ldr	r2, [r7, #4]
 80048ce:	68fb      	ldr	r3, [r7, #12]
 80048d0:	18d3      	adds	r3, r2, r3
 80048d2:	3308      	adds	r3, #8
 80048d4:	2200      	movs	r2, #0
 80048d6:	701a      	strb	r2, [r3, #0]
	for(i = 0; i < TX_BUFFER_SIZE; i++)
 80048d8:	68fb      	ldr	r3, [r7, #12]
 80048da:	3301      	adds	r3, #1
 80048dc:	60fb      	str	r3, [r7, #12]
 80048de:	68fb      	ldr	r3, [r7, #12]
 80048e0:	2b68      	cmp	r3, #104	; 0x68
 80048e2:	ddf3      	ble.n	80048cc <Iniciar_EstrucComCEIT+0x3e>
	}
	
	for(i = 0; i < RX_BUFFER_SIZE; i++)
 80048e4:	2300      	movs	r3, #0
 80048e6:	60fb      	str	r3, [r7, #12]
 80048e8:	e009      	b.n	80048fe <Iniciar_EstrucComCEIT+0x70>
	{
		pstcomceit->Rx_Buffer[i] = 0x00;
 80048ea:	687a      	ldr	r2, [r7, #4]
 80048ec:	2171      	movs	r1, #113	; 0x71
 80048ee:	68fb      	ldr	r3, [r7, #12]
 80048f0:	18d3      	adds	r3, r2, r3
 80048f2:	185b      	adds	r3, r3, r1
 80048f4:	2200      	movs	r2, #0
 80048f6:	701a      	strb	r2, [r3, #0]
	for(i = 0; i < RX_BUFFER_SIZE; i++)
 80048f8:	68fb      	ldr	r3, [r7, #12]
 80048fa:	3301      	adds	r3, #1
 80048fc:	60fb      	str	r3, [r7, #12]
 80048fe:	68fb      	ldr	r3, [r7, #12]
 8004900:	2b05      	cmp	r3, #5
 8004902:	ddf2      	ble.n	80048ea <Iniciar_EstrucComCEIT+0x5c>
	}
	
	for(i = 0; i < RX_DATA_SIZE; i++)
 8004904:	2300      	movs	r3, #0
 8004906:	60fb      	str	r3, [r7, #12]
 8004908:	e009      	b.n	800491e <Iniciar_EstrucComCEIT+0x90>
	{
		pstcomceit->Rx_Data[i] = 0x00;
 800490a:	687a      	ldr	r2, [r7, #4]
 800490c:	2177      	movs	r1, #119	; 0x77
 800490e:	68fb      	ldr	r3, [r7, #12]
 8004910:	18d3      	adds	r3, r2, r3
 8004912:	185b      	adds	r3, r3, r1
 8004914:	2200      	movs	r2, #0
 8004916:	701a      	strb	r2, [r3, #0]
	for(i = 0; i < RX_DATA_SIZE; i++)
 8004918:	68fb      	ldr	r3, [r7, #12]
 800491a:	3301      	adds	r3, #1
 800491c:	60fb      	str	r3, [r7, #12]
 800491e:	68fb      	ldr	r3, [r7, #12]
 8004920:	2bca      	cmp	r3, #202	; 0xca
 8004922:	ddf2      	ble.n	800490a <Iniciar_EstrucComCEIT+0x7c>
	}

	return 1;
 8004924:	2301      	movs	r3, #1
}
 8004926:	0018      	movs	r0, r3
 8004928:	46bd      	mov	sp, r7
 800492a:	b004      	add	sp, #16
 800492c:	bd80      	pop	{r7, pc}

0800492e <Iniciar_EstrucDistancia>:
Salidas:          		N/A
Descripción:  		    Esta función inicia la Estructura de Datos del Bloque Distancia
Notas y Cambios:  
****************************************************************************************/
char Iniciar_EstrucDistancia(stDistancia *pstdistancia)
{
 800492e:	b580      	push	{r7, lr}
 8004930:	b086      	sub	sp, #24
 8004932:	af00      	add	r7, sp, #0
 8004934:	6078      	str	r0, [r7, #4]
	int i,j,k;
	
	pstdistancia->bandDistancia = false;							
 8004936:	687b      	ldr	r3, [r7, #4]
 8004938:	2200      	movs	r2, #0
 800493a:	701a      	strb	r2, [r3, #0]

	pstdistancia->contParrilla = 0;
 800493c:	687b      	ldr	r3, [r7, #4]
 800493e:	2266      	movs	r2, #102	; 0x66
 8004940:	2100      	movs	r1, #0
 8004942:	5499      	strb	r1, [r3, r2]


	for(i = 0; i < MAX_PARR; i++)
 8004944:	2300      	movs	r3, #0
 8004946:	617b      	str	r3, [r7, #20]
 8004948:	e011      	b.n	800496e <Iniciar_EstrucDistancia+0x40>
	{
		pstdistancia->cantFilas[i] = CANT_FILAS;
 800494a:	687a      	ldr	r2, [r7, #4]
 800494c:	2167      	movs	r1, #103	; 0x67
 800494e:	697b      	ldr	r3, [r7, #20]
 8004950:	18d3      	adds	r3, r2, r3
 8004952:	185b      	adds	r3, r3, r1
 8004954:	2208      	movs	r2, #8
 8004956:	701a      	strb	r2, [r3, #0]
		pstdistancia->bandInicio[i] = 0;
 8004958:	6879      	ldr	r1, [r7, #4]
 800495a:	23aa      	movs	r3, #170	; 0xaa
 800495c:	33ff      	adds	r3, #255	; 0xff
 800495e:	697a      	ldr	r2, [r7, #20]
 8004960:	188a      	adds	r2, r1, r2
 8004962:	18d3      	adds	r3, r2, r3
 8004964:	2200      	movs	r2, #0
 8004966:	701a      	strb	r2, [r3, #0]
	for(i = 0; i < MAX_PARR; i++)
 8004968:	697b      	ldr	r3, [r7, #20]
 800496a:	3301      	adds	r3, #1
 800496c:	617b      	str	r3, [r7, #20]
 800496e:	697b      	ldr	r3, [r7, #20]
 8004970:	2b09      	cmp	r3, #9
 8004972:	ddea      	ble.n	800494a <Iniciar_EstrucDistancia+0x1c>
	}
	k=0;
 8004974:	2300      	movs	r3, #0
 8004976:	60fb      	str	r3, [r7, #12]
	for(i = 0; i < PH; i++)
 8004978:	2300      	movs	r3, #0
 800497a:	617b      	str	r3, [r7, #20]
 800497c:	e03a      	b.n	80049f4 <Iniciar_EstrucDistancia+0xc6>
	{
		pstdistancia->posSensor[i] = 0;
 800497e:	6879      	ldr	r1, [r7, #4]
 8004980:	23cf      	movs	r3, #207	; 0xcf
 8004982:	005b      	lsls	r3, r3, #1
 8004984:	697a      	ldr	r2, [r7, #20]
 8004986:	188a      	adds	r2, r1, r2
 8004988:	18d3      	adds	r3, r2, r3
 800498a:	2200      	movs	r2, #0
 800498c:	701a      	strb	r2, [r3, #0]
		for(j = 0; j < CANT_FILAS; j++)
 800498e:	2300      	movs	r3, #0
 8004990:	613b      	str	r3, [r7, #16]
 8004992:	e029      	b.n	80049e8 <Iniciar_EstrucDistancia+0xba>
		{
			pstdistancia->datosDistancia[i][j] = 0;
 8004994:	6879      	ldr	r1, [r7, #4]
 8004996:	697a      	ldr	r2, [r7, #20]
 8004998:	0013      	movs	r3, r2
 800499a:	009b      	lsls	r3, r3, #2
 800499c:	189b      	adds	r3, r3, r2
 800499e:	005b      	lsls	r3, r3, #1
 80049a0:	693a      	ldr	r2, [r7, #16]
 80049a2:	189b      	adds	r3, r3, r2
 80049a4:	3338      	adds	r3, #56	; 0x38
 80049a6:	005b      	lsls	r3, r3, #1
 80049a8:	18cb      	adds	r3, r1, r3
 80049aa:	3302      	adds	r3, #2
 80049ac:	2200      	movs	r2, #0
 80049ae:	801a      	strh	r2, [r3, #0]
			pstdistancia->sensor[k] = i;
 80049b0:	697b      	ldr	r3, [r7, #20]
 80049b2:	b2d8      	uxtb	r0, r3
 80049b4:	6879      	ldr	r1, [r7, #4]
 80049b6:	239d      	movs	r3, #157	; 0x9d
 80049b8:	005b      	lsls	r3, r3, #1
 80049ba:	68fa      	ldr	r2, [r7, #12]
 80049bc:	188a      	adds	r2, r1, r2
 80049be:	18d3      	adds	r3, r2, r3
 80049c0:	1c02      	adds	r2, r0, #0
 80049c2:	701a      	strb	r2, [r3, #0]
			pstdistancia->senStatus[i][j] = 0;
 80049c4:	6879      	ldr	r1, [r7, #4]
 80049c6:	697a      	ldr	r2, [r7, #20]
 80049c8:	0013      	movs	r3, r2
 80049ca:	009b      	lsls	r3, r3, #2
 80049cc:	189b      	adds	r3, r3, r2
 80049ce:	005b      	lsls	r3, r3, #1
 80049d0:	18ca      	adds	r2, r1, r3
 80049d2:	693b      	ldr	r3, [r7, #16]
 80049d4:	18d3      	adds	r3, r2, r3
 80049d6:	3301      	adds	r3, #1
 80049d8:	2200      	movs	r2, #0
 80049da:	701a      	strb	r2, [r3, #0]
			k++;
 80049dc:	68fb      	ldr	r3, [r7, #12]
 80049de:	3301      	adds	r3, #1
 80049e0:	60fb      	str	r3, [r7, #12]
		for(j = 0; j < CANT_FILAS; j++)
 80049e2:	693b      	ldr	r3, [r7, #16]
 80049e4:	3301      	adds	r3, #1
 80049e6:	613b      	str	r3, [r7, #16]
 80049e8:	693b      	ldr	r3, [r7, #16]
 80049ea:	2b07      	cmp	r3, #7
 80049ec:	ddd2      	ble.n	8004994 <Iniciar_EstrucDistancia+0x66>
	for(i = 0; i < PH; i++)
 80049ee:	697b      	ldr	r3, [r7, #20]
 80049f0:	3301      	adds	r3, #1
 80049f2:	617b      	str	r3, [r7, #20]
 80049f4:	697b      	ldr	r3, [r7, #20]
 80049f6:	2b04      	cmp	r3, #4
 80049f8:	ddc1      	ble.n	800497e <Iniciar_EstrucDistancia+0x50>
		}
	}
	return 1;
 80049fa:	2301      	movs	r3, #1
}
 80049fc:	0018      	movs	r0, r3
 80049fe:	46bd      	mov	sp, r7
 8004a00:	b006      	add	sp, #24
 8004a02:	bd80      	pop	{r7, pc}

08004a04 <Iniciar_EstrucMotor>:
Salidas:          		N/A
Descripción:  		    Esta función inicia la Estructura de Datos del Bloque Motor
Notas y Cambios:  
****************************************************************************************/
char Iniciar_EstrucMotor(stMotor *pstmotor)
{
 8004a04:	b580      	push	{r7, lr}
 8004a06:	b086      	sub	sp, #24
 8004a08:	af00      	add	r7, sp, #0
 8004a0a:	6078      	str	r0, [r7, #4]
	int i,j,k;

	pstmotor->bandMotor = false;
 8004a0c:	687b      	ldr	r3, [r7, #4]
 8004a0e:	2200      	movs	r2, #0
 8004a10:	701a      	strb	r2, [r3, #0]
	pstmotor->posInicial = 0;
 8004a12:	687b      	ldr	r3, [r7, #4]
 8004a14:	2200      	movs	r2, #0
 8004a16:	605a      	str	r2, [r3, #4]
	pstmotor->posMotor = 0;
 8004a18:	687b      	ldr	r3, [r7, #4]
 8004a1a:	2200      	movs	r2, #0
 8004a1c:	721a      	strb	r2, [r3, #8]
	for(i = 0; i < MAX_PARR; i++)
 8004a1e:	2300      	movs	r3, #0
 8004a20:	617b      	str	r3, [r7, #20]
 8004a22:	e008      	b.n	8004a36 <Iniciar_EstrucMotor+0x32>
	{
		pstmotor->cantFilas[i] = CANT_FILAS;
 8004a24:	687a      	ldr	r2, [r7, #4]
 8004a26:	697b      	ldr	r3, [r7, #20]
 8004a28:	18d3      	adds	r3, r2, r3
 8004a2a:	3309      	adds	r3, #9
 8004a2c:	2208      	movs	r2, #8
 8004a2e:	701a      	strb	r2, [r3, #0]
	for(i = 0; i < MAX_PARR; i++)
 8004a30:	697b      	ldr	r3, [r7, #20]
 8004a32:	3301      	adds	r3, #1
 8004a34:	617b      	str	r3, [r7, #20]
 8004a36:	697b      	ldr	r3, [r7, #20]
 8004a38:	2b09      	cmp	r3, #9
 8004a3a:	ddf3      	ble.n	8004a24 <Iniciar_EstrucMotor+0x20>
	}
	pstmotor->ParrHab = PH;
 8004a3c:	687a      	ldr	r2, [r7, #4]
 8004a3e:	23cd      	movs	r3, #205	; 0xcd
 8004a40:	009b      	lsls	r3, r3, #2
 8004a42:	2105      	movs	r1, #5
 8004a44:	54d1      	strb	r1, [r2, r3]
//	pstmotor->MaxPosMotor = pstmotor->ParrHab*CANT_FILAS;

	for(i = 0; i < pstmotor->ParrHab; i++)
 8004a46:	2300      	movs	r3, #0
 8004a48:	617b      	str	r3, [r7, #20]
 8004a4a:	e053      	b.n	8004af4 <Iniciar_EstrucMotor+0xf0>
	{
		pstmotor->distFilas[i][0] = -POS_LINE_1;
 8004a4c:	6879      	ldr	r1, [r7, #4]
 8004a4e:	697a      	ldr	r2, [r7, #20]
 8004a50:	0013      	movs	r3, r2
 8004a52:	009b      	lsls	r3, r3, #2
 8004a54:	189b      	adds	r3, r3, r2
 8004a56:	00db      	lsls	r3, r3, #3
 8004a58:	18cb      	adds	r3, r1, r3
 8004a5a:	3314      	adds	r3, #20
 8004a5c:	2200      	movs	r2, #0
 8004a5e:	601a      	str	r2, [r3, #0]
		pstmotor->distFilas[i][1] = -POS_LINE_2;
 8004a60:	6879      	ldr	r1, [r7, #4]
 8004a62:	697a      	ldr	r2, [r7, #20]
 8004a64:	0013      	movs	r3, r2
 8004a66:	009b      	lsls	r3, r3, #2
 8004a68:	189b      	adds	r3, r3, r2
 8004a6a:	00db      	lsls	r3, r3, #3
 8004a6c:	18cb      	adds	r3, r1, r3
 8004a6e:	3318      	adds	r3, #24
 8004a70:	4a41      	ldr	r2, [pc, #260]	; (8004b78 <Iniciar_EstrucMotor+0x174>)
 8004a72:	601a      	str	r2, [r3, #0]
		pstmotor->distFilas[i][2] = -POS_LINE_3;
 8004a74:	6879      	ldr	r1, [r7, #4]
 8004a76:	697a      	ldr	r2, [r7, #20]
 8004a78:	0013      	movs	r3, r2
 8004a7a:	009b      	lsls	r3, r3, #2
 8004a7c:	189b      	adds	r3, r3, r2
 8004a7e:	00db      	lsls	r3, r3, #3
 8004a80:	18cb      	adds	r3, r1, r3
 8004a82:	331c      	adds	r3, #28
 8004a84:	4a3d      	ldr	r2, [pc, #244]	; (8004b7c <Iniciar_EstrucMotor+0x178>)
 8004a86:	601a      	str	r2, [r3, #0]
		pstmotor->distFilas[i][3] = -POS_LINE_4;
 8004a88:	6879      	ldr	r1, [r7, #4]
 8004a8a:	697a      	ldr	r2, [r7, #20]
 8004a8c:	0013      	movs	r3, r2
 8004a8e:	009b      	lsls	r3, r3, #2
 8004a90:	189b      	adds	r3, r3, r2
 8004a92:	00db      	lsls	r3, r3, #3
 8004a94:	18cb      	adds	r3, r1, r3
 8004a96:	3320      	adds	r3, #32
 8004a98:	4a39      	ldr	r2, [pc, #228]	; (8004b80 <Iniciar_EstrucMotor+0x17c>)
 8004a9a:	601a      	str	r2, [r3, #0]
		pstmotor->distFilas[i][4] = -POS_LINE_5;
 8004a9c:	6879      	ldr	r1, [r7, #4]
 8004a9e:	697a      	ldr	r2, [r7, #20]
 8004aa0:	0013      	movs	r3, r2
 8004aa2:	009b      	lsls	r3, r3, #2
 8004aa4:	189b      	adds	r3, r3, r2
 8004aa6:	00db      	lsls	r3, r3, #3
 8004aa8:	18cb      	adds	r3, r1, r3
 8004aaa:	3324      	adds	r3, #36	; 0x24
 8004aac:	4a35      	ldr	r2, [pc, #212]	; (8004b84 <Iniciar_EstrucMotor+0x180>)
 8004aae:	601a      	str	r2, [r3, #0]
		pstmotor->distFilas[i][5] = -POS_LINE_6;
 8004ab0:	6879      	ldr	r1, [r7, #4]
 8004ab2:	697a      	ldr	r2, [r7, #20]
 8004ab4:	0013      	movs	r3, r2
 8004ab6:	009b      	lsls	r3, r3, #2
 8004ab8:	189b      	adds	r3, r3, r2
 8004aba:	00db      	lsls	r3, r3, #3
 8004abc:	18cb      	adds	r3, r1, r3
 8004abe:	3328      	adds	r3, #40	; 0x28
 8004ac0:	4a31      	ldr	r2, [pc, #196]	; (8004b88 <Iniciar_EstrucMotor+0x184>)
 8004ac2:	601a      	str	r2, [r3, #0]
		pstmotor->distFilas[i][6] = -POS_LINE_7;
 8004ac4:	6879      	ldr	r1, [r7, #4]
 8004ac6:	697b      	ldr	r3, [r7, #20]
 8004ac8:	1c5a      	adds	r2, r3, #1
 8004aca:	0013      	movs	r3, r2
 8004acc:	009b      	lsls	r3, r3, #2
 8004ace:	189b      	adds	r3, r3, r2
 8004ad0:	00db      	lsls	r3, r3, #3
 8004ad2:	18cb      	adds	r3, r1, r3
 8004ad4:	3304      	adds	r3, #4
 8004ad6:	4a2d      	ldr	r2, [pc, #180]	; (8004b8c <Iniciar_EstrucMotor+0x188>)
 8004ad8:	601a      	str	r2, [r3, #0]
		pstmotor->distFilas[i][7] = -POS_LINE_8;
 8004ada:	6879      	ldr	r1, [r7, #4]
 8004adc:	697a      	ldr	r2, [r7, #20]
 8004ade:	0013      	movs	r3, r2
 8004ae0:	009b      	lsls	r3, r3, #2
 8004ae2:	189b      	adds	r3, r3, r2
 8004ae4:	00db      	lsls	r3, r3, #3
 8004ae6:	18cb      	adds	r3, r1, r3
 8004ae8:	3330      	adds	r3, #48	; 0x30
 8004aea:	4a29      	ldr	r2, [pc, #164]	; (8004b90 <Iniciar_EstrucMotor+0x18c>)
 8004aec:	601a      	str	r2, [r3, #0]
	for(i = 0; i < pstmotor->ParrHab; i++)
 8004aee:	697b      	ldr	r3, [r7, #20]
 8004af0:	3301      	adds	r3, #1
 8004af2:	617b      	str	r3, [r7, #20]
 8004af4:	687a      	ldr	r2, [r7, #4]
 8004af6:	23cd      	movs	r3, #205	; 0xcd
 8004af8:	009b      	lsls	r3, r3, #2
 8004afa:	5cd3      	ldrb	r3, [r2, r3]
 8004afc:	001a      	movs	r2, r3
 8004afe:	697b      	ldr	r3, [r7, #20]
 8004b00:	4293      	cmp	r3, r2
 8004b02:	dba3      	blt.n	8004a4c <Iniciar_EstrucMotor+0x48>

	}
	k=0;
 8004b04:	2300      	movs	r3, #0
 8004b06:	60fb      	str	r3, [r7, #12]
	for(i = 0; i < pstmotor->ParrHab; i++)
 8004b08:	2300      	movs	r3, #0
 8004b0a:	617b      	str	r3, [r7, #20]
 8004b0c:	e022      	b.n	8004b54 <Iniciar_EstrucMotor+0x150>
	{
		for(j=0; j<CANT_FILAS; j++)
 8004b0e:	2300      	movs	r3, #0
 8004b10:	613b      	str	r3, [r7, #16]
 8004b12:	e019      	b.n	8004b48 <Iniciar_EstrucMotor+0x144>
		{
			pstmotor->recorrido[k] = pstmotor->distFilas[i][j];
 8004b14:	6879      	ldr	r1, [r7, #4]
 8004b16:	697a      	ldr	r2, [r7, #20]
 8004b18:	0013      	movs	r3, r2
 8004b1a:	009b      	lsls	r3, r3, #2
 8004b1c:	189b      	adds	r3, r3, r2
 8004b1e:	005b      	lsls	r3, r3, #1
 8004b20:	693a      	ldr	r2, [r7, #16]
 8004b22:	189b      	adds	r3, r3, r2
 8004b24:	3304      	adds	r3, #4
 8004b26:	009b      	lsls	r3, r3, #2
 8004b28:	18cb      	adds	r3, r1, r3
 8004b2a:	3304      	adds	r3, #4
 8004b2c:	681a      	ldr	r2, [r3, #0]
 8004b2e:	6879      	ldr	r1, [r7, #4]
 8004b30:	68fb      	ldr	r3, [r7, #12]
 8004b32:	3368      	adds	r3, #104	; 0x68
 8004b34:	009b      	lsls	r3, r3, #2
 8004b36:	18cb      	adds	r3, r1, r3
 8004b38:	3304      	adds	r3, #4
 8004b3a:	601a      	str	r2, [r3, #0]
			k++;
 8004b3c:	68fb      	ldr	r3, [r7, #12]
 8004b3e:	3301      	adds	r3, #1
 8004b40:	60fb      	str	r3, [r7, #12]
		for(j=0; j<CANT_FILAS; j++)
 8004b42:	693b      	ldr	r3, [r7, #16]
 8004b44:	3301      	adds	r3, #1
 8004b46:	613b      	str	r3, [r7, #16]
 8004b48:	693b      	ldr	r3, [r7, #16]
 8004b4a:	2b07      	cmp	r3, #7
 8004b4c:	dde2      	ble.n	8004b14 <Iniciar_EstrucMotor+0x110>
	for(i = 0; i < pstmotor->ParrHab; i++)
 8004b4e:	697b      	ldr	r3, [r7, #20]
 8004b50:	3301      	adds	r3, #1
 8004b52:	617b      	str	r3, [r7, #20]
 8004b54:	687a      	ldr	r2, [r7, #4]
 8004b56:	23cd      	movs	r3, #205	; 0xcd
 8004b58:	009b      	lsls	r3, r3, #2
 8004b5a:	5cd3      	ldrb	r3, [r2, r3]
 8004b5c:	001a      	movs	r2, r3
 8004b5e:	697b      	ldr	r3, [r7, #20]
 8004b60:	4293      	cmp	r3, r2
 8004b62:	dbd4      	blt.n	8004b0e <Iniciar_EstrucMotor+0x10a>
		}
	}
	pstmotor->MaxPosMotor = k;
 8004b64:	68fb      	ldr	r3, [r7, #12]
 8004b66:	b2d9      	uxtb	r1, r3
 8004b68:	687b      	ldr	r3, [r7, #4]
 8004b6a:	4a0a      	ldr	r2, [pc, #40]	; (8004b94 <Iniciar_EstrucMotor+0x190>)
 8004b6c:	5499      	strb	r1, [r3, r2]
//	pstmotor->initDeviceParameters.stepMode = STEP_MODE_1_32;  				//Step mode via enum motorStepMode_t
//	pstmotor->initDeviceParameters.stopMode = HOLD_MODE;
//	pstmotor->initDeviceParameters.vrefPwmFreq = 100000;           		//REF frequency (Hz)
       				//Automatic HIZ STOP
	
	return 1;
 8004b6e:	2301      	movs	r3, #1
}
 8004b70:	0018      	movs	r0, r3
 8004b72:	46bd      	mov	sp, r7
 8004b74:	b006      	add	sp, #24
 8004b76:	bd80      	pop	{r7, pc}
 8004b78:	0000ca5d 	.word	0x0000ca5d
 8004b7c:	000194ba 	.word	0x000194ba
 8004b80:	00025f17 	.word	0x00025f17
 8004b84:	00032974 	.word	0x00032974
 8004b88:	0003f3d1 	.word	0x0003f3d1
 8004b8c:	0004be2e 	.word	0x0004be2e
 8004b90:	0005888b 	.word	0x0005888b
 8004b94:	00000335 	.word	0x00000335

08004b98 <MX_GPIO_Init>:
        * Output
        * EVENT_OUT
        * EXTI
*/
void MX_GPIO_Init(void)
{
 8004b98:	b590      	push	{r4, r7, lr}
 8004b9a:	b08b      	sub	sp, #44	; 0x2c
 8004b9c:	af00      	add	r7, sp, #0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8004b9e:	2414      	movs	r4, #20
 8004ba0:	193b      	adds	r3, r7, r4
 8004ba2:	0018      	movs	r0, r3
 8004ba4:	2314      	movs	r3, #20
 8004ba6:	001a      	movs	r2, r3
 8004ba8:	2100      	movs	r1, #0
 8004baa:	f00e fb14 	bl	80131d6 <memset>

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8004bae:	4b98      	ldr	r3, [pc, #608]	; (8004e10 <MX_GPIO_Init+0x278>)
 8004bb0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8004bb2:	4b97      	ldr	r3, [pc, #604]	; (8004e10 <MX_GPIO_Init+0x278>)
 8004bb4:	2104      	movs	r1, #4
 8004bb6:	430a      	orrs	r2, r1
 8004bb8:	62da      	str	r2, [r3, #44]	; 0x2c
 8004bba:	4b95      	ldr	r3, [pc, #596]	; (8004e10 <MX_GPIO_Init+0x278>)
 8004bbc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004bbe:	2204      	movs	r2, #4
 8004bc0:	4013      	ands	r3, r2
 8004bc2:	613b      	str	r3, [r7, #16]
 8004bc4:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8004bc6:	4b92      	ldr	r3, [pc, #584]	; (8004e10 <MX_GPIO_Init+0x278>)
 8004bc8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8004bca:	4b91      	ldr	r3, [pc, #580]	; (8004e10 <MX_GPIO_Init+0x278>)
 8004bcc:	2180      	movs	r1, #128	; 0x80
 8004bce:	430a      	orrs	r2, r1
 8004bd0:	62da      	str	r2, [r3, #44]	; 0x2c
 8004bd2:	4b8f      	ldr	r3, [pc, #572]	; (8004e10 <MX_GPIO_Init+0x278>)
 8004bd4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004bd6:	2280      	movs	r2, #128	; 0x80
 8004bd8:	4013      	ands	r3, r2
 8004bda:	60fb      	str	r3, [r7, #12]
 8004bdc:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8004bde:	4b8c      	ldr	r3, [pc, #560]	; (8004e10 <MX_GPIO_Init+0x278>)
 8004be0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8004be2:	4b8b      	ldr	r3, [pc, #556]	; (8004e10 <MX_GPIO_Init+0x278>)
 8004be4:	2101      	movs	r1, #1
 8004be6:	430a      	orrs	r2, r1
 8004be8:	62da      	str	r2, [r3, #44]	; 0x2c
 8004bea:	4b89      	ldr	r3, [pc, #548]	; (8004e10 <MX_GPIO_Init+0x278>)
 8004bec:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004bee:	2201      	movs	r2, #1
 8004bf0:	4013      	ands	r3, r2
 8004bf2:	60bb      	str	r3, [r7, #8]
 8004bf4:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8004bf6:	4b86      	ldr	r3, [pc, #536]	; (8004e10 <MX_GPIO_Init+0x278>)
 8004bf8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8004bfa:	4b85      	ldr	r3, [pc, #532]	; (8004e10 <MX_GPIO_Init+0x278>)
 8004bfc:	2102      	movs	r1, #2
 8004bfe:	430a      	orrs	r2, r1
 8004c00:	62da      	str	r2, [r3, #44]	; 0x2c
 8004c02:	4b83      	ldr	r3, [pc, #524]	; (8004e10 <MX_GPIO_Init+0x278>)
 8004c04:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004c06:	2202      	movs	r2, #2
 8004c08:	4013      	ands	r3, r2
 8004c0a:	607b      	str	r3, [r7, #4]
 8004c0c:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8004c0e:	4b80      	ldr	r3, [pc, #512]	; (8004e10 <MX_GPIO_Init+0x278>)
 8004c10:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8004c12:	4b7f      	ldr	r3, [pc, #508]	; (8004e10 <MX_GPIO_Init+0x278>)
 8004c14:	2108      	movs	r1, #8
 8004c16:	430a      	orrs	r2, r1
 8004c18:	62da      	str	r2, [r3, #44]	; 0x2c
 8004c1a:	4b7d      	ldr	r3, [pc, #500]	; (8004e10 <MX_GPIO_Init+0x278>)
 8004c1c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004c1e:	2208      	movs	r2, #8
 8004c20:	4013      	ands	r3, r2
 8004c22:	603b      	str	r3, [r7, #0]
 8004c24:	683b      	ldr	r3, [r7, #0]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOC, VL53_XSHUT_1_Pin|VL53_XSHUT_6_Pin|GPIO_EXP_1_Pin|GPIO_EXP_2_Pin, GPIO_PIN_RESET);
 8004c26:	497b      	ldr	r1, [pc, #492]	; (8004e14 <MX_GPIO_Init+0x27c>)
 8004c28:	4b7b      	ldr	r3, [pc, #492]	; (8004e18 <MX_GPIO_Init+0x280>)
 8004c2a:	2200      	movs	r2, #0
 8004c2c:	0018      	movs	r0, r3
 8004c2e:	f00b f872 	bl	800fd16 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(DRV_RES_6_GPIO_Port, DRV_RES_6_Pin, GPIO_PIN_SET);
 8004c32:	4b7a      	ldr	r3, [pc, #488]	; (8004e1c <MX_GPIO_Init+0x284>)
 8004c34:	2201      	movs	r2, #1
 8004c36:	2102      	movs	r1, #2
 8004c38:	0018      	movs	r0, r3
 8004c3a:	f00b f86c 	bl	800fd16 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOC, DRV_EN_6_Pin|DRV_RES_4_Pin|VL53_XSHUT_2_Pin, GPIO_PIN_SET);
 8004c3e:	4b76      	ldr	r3, [pc, #472]	; (8004e18 <MX_GPIO_Init+0x280>)
 8004c40:	2201      	movs	r2, #1
 8004c42:	2161      	movs	r1, #97	; 0x61
 8004c44:	0018      	movs	r0, r3
 8004c46:	f00b f866 	bl	800fd16 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, DRV_RES_5_Pin|DRV_EN_5_Pin|DRV_RES_2_Pin|DRV_EN_2_Pin, GPIO_PIN_SET);
 8004c4a:	4975      	ldr	r1, [pc, #468]	; (8004e20 <MX_GPIO_Init+0x288>)
 8004c4c:	23a0      	movs	r3, #160	; 0xa0
 8004c4e:	05db      	lsls	r3, r3, #23
 8004c50:	2201      	movs	r2, #1
 8004c52:	0018      	movs	r0, r3
 8004c54:	f00b f85f 	bl	800fd16 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, VL53_XSHUT_5_Pin|DRV_MOD4_Pin, GPIO_PIN_RESET);
 8004c58:	2390      	movs	r3, #144	; 0x90
 8004c5a:	0059      	lsls	r1, r3, #1
 8004c5c:	23a0      	movs	r3, #160	; 0xa0
 8004c5e:	05db      	lsls	r3, r3, #23
 8004c60:	2200      	movs	r2, #0
 8004c62:	0018      	movs	r0, r3
 8004c64:	f00b f857 	bl	800fd16 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, DRV_EN_4_Pin|DRV_RES_3_Pin|DRV_EN_3_Pin|DRV_RES_1_Pin
 8004c68:	496e      	ldr	r1, [pc, #440]	; (8004e24 <MX_GPIO_Init+0x28c>)
 8004c6a:	4b6f      	ldr	r3, [pc, #444]	; (8004e28 <MX_GPIO_Init+0x290>)
 8004c6c:	2201      	movs	r2, #1
 8004c6e:	0018      	movs	r0, r3
 8004c70:	f00b f851 	bl	800fd16 <HAL_GPIO_WritePin>
                          |DRV_EN_1_Pin, GPIO_PIN_SET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, VL53_XSHUT_4_Pin|VL53_XSHUT_3_Pin|DRV_MOD1_Pin|DRV_MOD2_Pin, GPIO_PIN_RESET);
 8004c74:	496d      	ldr	r1, [pc, #436]	; (8004e2c <MX_GPIO_Init+0x294>)
 8004c76:	4b6c      	ldr	r3, [pc, #432]	; (8004e28 <MX_GPIO_Init+0x290>)
 8004c78:	2200      	movs	r2, #0
 8004c7a:	0018      	movs	r0, r3
 8004c7c:	f00b f84b 	bl	800fd16 <HAL_GPIO_WritePin>

  /*Configure GPIO pins : PCPin PCPin PCPin PCPin
                           PCPin */
  GPIO_InitStruct.Pin = VL53_XSHUT_1_Pin|VL53_XSHUT_6_Pin|VL53_XSHUT_2_Pin|GPIO_EXP_1_Pin
 8004c80:	193b      	adds	r3, r7, r4
 8004c82:	4a6b      	ldr	r2, [pc, #428]	; (8004e30 <MX_GPIO_Init+0x298>)
 8004c84:	601a      	str	r2, [r3, #0]
                          |GPIO_EXP_2_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8004c86:	193b      	adds	r3, r7, r4
 8004c88:	2201      	movs	r2, #1
 8004c8a:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8004c8c:	193b      	adds	r3, r7, r4
 8004c8e:	2200      	movs	r2, #0
 8004c90:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8004c92:	193b      	adds	r3, r7, r4
 8004c94:	2200      	movs	r2, #0
 8004c96:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8004c98:	193b      	adds	r3, r7, r4
 8004c9a:	4a5f      	ldr	r2, [pc, #380]	; (8004e18 <MX_GPIO_Init+0x280>)
 8004c9c:	0019      	movs	r1, r3
 8004c9e:	0010      	movs	r0, r2
 8004ca0:	f00a fdbc 	bl	800f81c <HAL_GPIO_Init>

  /*Configure GPIO pins : PCPin PCPin PCPin PCPin */
  GPIO_InitStruct.Pin = DRV_FCA_6_Pin|DRV_FCA_5_Pin|DRV_FCB_4_Pin|DRV_FCB_2_Pin;
 8004ca4:	193b      	adds	r3, r7, r4
 8004ca6:	4a63      	ldr	r2, [pc, #396]	; (8004e34 <MX_GPIO_Init+0x29c>)
 8004ca8:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8004caa:	193b      	adds	r3, r7, r4
 8004cac:	2200      	movs	r2, #0
 8004cae:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8004cb0:	193b      	adds	r3, r7, r4
 8004cb2:	2200      	movs	r2, #0
 8004cb4:	609a      	str	r2, [r3, #8]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8004cb6:	193b      	adds	r3, r7, r4
 8004cb8:	4a57      	ldr	r2, [pc, #348]	; (8004e18 <MX_GPIO_Init+0x280>)
 8004cba:	0019      	movs	r1, r3
 8004cbc:	0010      	movs	r0, r2
 8004cbe:	f00a fdad 	bl	800f81c <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = DRV_FCB_6_Pin;
 8004cc2:	193b      	adds	r3, r7, r4
 8004cc4:	2201      	movs	r2, #1
 8004cc6:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8004cc8:	193b      	adds	r3, r7, r4
 8004cca:	2200      	movs	r2, #0
 8004ccc:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8004cce:	193b      	adds	r3, r7, r4
 8004cd0:	2200      	movs	r2, #0
 8004cd2:	609a      	str	r2, [r3, #8]
  HAL_GPIO_Init(DRV_FCB_6_GPIO_Port, &GPIO_InitStruct);
 8004cd4:	193b      	adds	r3, r7, r4
 8004cd6:	4a51      	ldr	r2, [pc, #324]	; (8004e1c <MX_GPIO_Init+0x284>)
 8004cd8:	0019      	movs	r1, r3
 8004cda:	0010      	movs	r0, r2
 8004cdc:	f00a fd9e 	bl	800f81c <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = DRV_RES_6_Pin;
 8004ce0:	193b      	adds	r3, r7, r4
 8004ce2:	2202      	movs	r2, #2
 8004ce4:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8004ce6:	193b      	adds	r3, r7, r4
 8004ce8:	2201      	movs	r2, #1
 8004cea:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8004cec:	193b      	adds	r3, r7, r4
 8004cee:	2200      	movs	r2, #0
 8004cf0:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
 8004cf2:	193b      	adds	r3, r7, r4
 8004cf4:	2201      	movs	r2, #1
 8004cf6:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(DRV_RES_6_GPIO_Port, &GPIO_InitStruct);
 8004cf8:	193b      	adds	r3, r7, r4
 8004cfa:	4a48      	ldr	r2, [pc, #288]	; (8004e1c <MX_GPIO_Init+0x284>)
 8004cfc:	0019      	movs	r1, r3
 8004cfe:	0010      	movs	r0, r2
 8004d00:	f00a fd8c 	bl	800f81c <HAL_GPIO_Init>

  /*Configure GPIO pins : PCPin PCPin */
  GPIO_InitStruct.Pin = DRV_EN_6_Pin|DRV_RES_4_Pin;
 8004d04:	193b      	adds	r3, r7, r4
 8004d06:	2221      	movs	r2, #33	; 0x21
 8004d08:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8004d0a:	193b      	adds	r3, r7, r4
 8004d0c:	2201      	movs	r2, #1
 8004d0e:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8004d10:	193b      	adds	r3, r7, r4
 8004d12:	2200      	movs	r2, #0
 8004d14:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
 8004d16:	193b      	adds	r3, r7, r4
 8004d18:	2201      	movs	r2, #1
 8004d1a:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8004d1c:	193b      	adds	r3, r7, r4
 8004d1e:	4a3e      	ldr	r2, [pc, #248]	; (8004e18 <MX_GPIO_Init+0x280>)
 8004d20:	0019      	movs	r1, r3
 8004d22:	0010      	movs	r0, r2
 8004d24:	f00a fd7a 	bl	800f81c <HAL_GPIO_Init>

  /*Configure GPIO pins : PAPin PAPin PAPin PAPin
                           PAPin */
  GPIO_InitStruct.Pin = DRV_FCB_5_Pin|DRV_FCA_4_Pin|DRV_FCA_2_Pin|DRV_FCB_1_Pin
 8004d28:	193b      	adds	r3, r7, r4
 8004d2a:	4a43      	ldr	r2, [pc, #268]	; (8004e38 <MX_GPIO_Init+0x2a0>)
 8004d2c:	601a      	str	r2, [r3, #0]
                          |DRV_FCA_1_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8004d2e:	193b      	adds	r3, r7, r4
 8004d30:	2200      	movs	r2, #0
 8004d32:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8004d34:	193b      	adds	r3, r7, r4
 8004d36:	2200      	movs	r2, #0
 8004d38:	609a      	str	r2, [r3, #8]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8004d3a:	193a      	adds	r2, r7, r4
 8004d3c:	23a0      	movs	r3, #160	; 0xa0
 8004d3e:	05db      	lsls	r3, r3, #23
 8004d40:	0011      	movs	r1, r2
 8004d42:	0018      	movs	r0, r3
 8004d44:	f00a fd6a 	bl	800f81c <HAL_GPIO_Init>

  /*Configure GPIO pins : PAPin PAPin PAPin PAPin
                           PAPin */
  GPIO_InitStruct.Pin = DRV_RES_5_Pin|DRV_EN_5_Pin|DRV_MOD4_Pin|DRV_RES_2_Pin
 8004d48:	193b      	adds	r3, r7, r4
 8004d4a:	4a3c      	ldr	r2, [pc, #240]	; (8004e3c <MX_GPIO_Init+0x2a4>)
 8004d4c:	601a      	str	r2, [r3, #0]
                          |DRV_EN_2_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8004d4e:	193b      	adds	r3, r7, r4
 8004d50:	2201      	movs	r2, #1
 8004d52:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8004d54:	193b      	adds	r3, r7, r4
 8004d56:	2200      	movs	r2, #0
 8004d58:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
 8004d5a:	193b      	adds	r3, r7, r4
 8004d5c:	2201      	movs	r2, #1
 8004d5e:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8004d60:	193a      	adds	r2, r7, r4
 8004d62:	23a0      	movs	r3, #160	; 0xa0
 8004d64:	05db      	lsls	r3, r3, #23
 8004d66:	0011      	movs	r1, r2
 8004d68:	0018      	movs	r0, r3
 8004d6a:	f00a fd57 	bl	800f81c <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = VL53_XSHUT_5_Pin;
 8004d6e:	193b      	adds	r3, r7, r4
 8004d70:	2220      	movs	r2, #32
 8004d72:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8004d74:	193b      	adds	r3, r7, r4
 8004d76:	2201      	movs	r2, #1
 8004d78:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8004d7a:	193b      	adds	r3, r7, r4
 8004d7c:	2200      	movs	r2, #0
 8004d7e:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8004d80:	193b      	adds	r3, r7, r4
 8004d82:	2200      	movs	r2, #0
 8004d84:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(VL53_XSHUT_5_GPIO_Port, &GPIO_InitStruct);
 8004d86:	193a      	adds	r2, r7, r4
 8004d88:	23a0      	movs	r3, #160	; 0xa0
 8004d8a:	05db      	lsls	r3, r3, #23
 8004d8c:	0011      	movs	r1, r2
 8004d8e:	0018      	movs	r0, r3
 8004d90:	f00a fd44 	bl	800f81c <HAL_GPIO_Init>

  /*Configure GPIO pins : PBPin PBPin PBPin PBPin
                           PBPin PBPin PBPin */
  GPIO_InitStruct.Pin = DRV_EN_4_Pin|DRV_RES_3_Pin|DRV_EN_3_Pin|DRV_MOD1_Pin
 8004d94:	0021      	movs	r1, r4
 8004d96:	187b      	adds	r3, r7, r1
 8004d98:	4a29      	ldr	r2, [pc, #164]	; (8004e40 <MX_GPIO_Init+0x2a8>)
 8004d9a:	601a      	str	r2, [r3, #0]
                          |DRV_RES_1_Pin|DRV_MOD2_Pin|DRV_EN_1_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8004d9c:	187b      	adds	r3, r7, r1
 8004d9e:	2201      	movs	r2, #1
 8004da0:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8004da2:	187b      	adds	r3, r7, r1
 8004da4:	2200      	movs	r2, #0
 8004da6:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
 8004da8:	187b      	adds	r3, r7, r1
 8004daa:	2201      	movs	r2, #1
 8004dac:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8004dae:	000c      	movs	r4, r1
 8004db0:	187b      	adds	r3, r7, r1
 8004db2:	4a1d      	ldr	r2, [pc, #116]	; (8004e28 <MX_GPIO_Init+0x290>)
 8004db4:	0019      	movs	r1, r3
 8004db6:	0010      	movs	r0, r2
 8004db8:	f00a fd30 	bl	800f81c <HAL_GPIO_Init>

  /*Configure GPIO pins : PBPin PBPin */
  GPIO_InitStruct.Pin = VL53_XSHUT_4_Pin|VL53_XSHUT_3_Pin;
 8004dbc:	0021      	movs	r1, r4
 8004dbe:	187b      	adds	r3, r7, r1
 8004dc0:	4a20      	ldr	r2, [pc, #128]	; (8004e44 <MX_GPIO_Init+0x2ac>)
 8004dc2:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8004dc4:	187b      	adds	r3, r7, r1
 8004dc6:	2201      	movs	r2, #1
 8004dc8:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8004dca:	187b      	adds	r3, r7, r1
 8004dcc:	2200      	movs	r2, #0
 8004dce:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8004dd0:	187b      	adds	r3, r7, r1
 8004dd2:	2200      	movs	r2, #0
 8004dd4:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8004dd6:	000c      	movs	r4, r1
 8004dd8:	187b      	adds	r3, r7, r1
 8004dda:	4a13      	ldr	r2, [pc, #76]	; (8004e28 <MX_GPIO_Init+0x290>)
 8004ddc:	0019      	movs	r1, r3
 8004dde:	0010      	movs	r0, r2
 8004de0:	f00a fd1c 	bl	800f81c <HAL_GPIO_Init>

  /*Configure GPIO pins : PBPin PBPin */
  GPIO_InitStruct.Pin = DRV_FCB_3_Pin|DRV_FCA_3_Pin;
 8004de4:	0021      	movs	r1, r4
 8004de6:	187b      	adds	r3, r7, r1
 8004de8:	22c0      	movs	r2, #192	; 0xc0
 8004dea:	0212      	lsls	r2, r2, #8
 8004dec:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8004dee:	187b      	adds	r3, r7, r1
 8004df0:	2200      	movs	r2, #0
 8004df2:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8004df4:	187b      	adds	r3, r7, r1
 8004df6:	2200      	movs	r2, #0
 8004df8:	609a      	str	r2, [r3, #8]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8004dfa:	187b      	adds	r3, r7, r1
 8004dfc:	4a0a      	ldr	r2, [pc, #40]	; (8004e28 <MX_GPIO_Init+0x290>)
 8004dfe:	0019      	movs	r1, r3
 8004e00:	0010      	movs	r0, r2
 8004e02:	f00a fd0b 	bl	800f81c <HAL_GPIO_Init>

}
 8004e06:	46c0      	nop			; (mov r8, r8)
 8004e08:	46bd      	mov	sp, r7
 8004e0a:	b00b      	add	sp, #44	; 0x2c
 8004e0c:	bd90      	pop	{r4, r7, pc}
 8004e0e:	46c0      	nop			; (mov r8, r8)
 8004e10:	40021000 	.word	0x40021000
 8004e14:	00004c04 	.word	0x00004c04
 8004e18:	50000800 	.word	0x50000800
 8004e1c:	50001c00 	.word	0x50001c00
 8004e20:	00000612 	.word	0x00000612
 8004e24:	000030a1 	.word	0x000030a1
 8004e28:	50000400 	.word	0x50000400
 8004e2c:	00000452 	.word	0x00000452
 8004e30:	00004c44 	.word	0x00004c44
 8004e34:	00008218 	.word	0x00008218
 8004e38:	00009881 	.word	0x00009881
 8004e3c:	00000712 	.word	0x00000712
 8004e40:	000030f1 	.word	0x000030f1
 8004e44:	00000402 	.word	0x00000402

08004e48 <MX_I2C1_Init>:

I2C_HandleTypeDef hi2c1;

/* I2C1 init function */
void MX_I2C1_Init(void)
{
 8004e48:	b580      	push	{r7, lr}
 8004e4a:	af00      	add	r7, sp, #0

  hi2c1.Instance = I2C1;
 8004e4c:	4b1b      	ldr	r3, [pc, #108]	; (8004ebc <MX_I2C1_Init+0x74>)
 8004e4e:	4a1c      	ldr	r2, [pc, #112]	; (8004ec0 <MX_I2C1_Init+0x78>)
 8004e50:	601a      	str	r2, [r3, #0]
  hi2c1.Init.Timing = 0x00707CBB;
 8004e52:	4b1a      	ldr	r3, [pc, #104]	; (8004ebc <MX_I2C1_Init+0x74>)
 8004e54:	4a1b      	ldr	r2, [pc, #108]	; (8004ec4 <MX_I2C1_Init+0x7c>)
 8004e56:	605a      	str	r2, [r3, #4]
  hi2c1.Init.OwnAddress1 = 0;
 8004e58:	4b18      	ldr	r3, [pc, #96]	; (8004ebc <MX_I2C1_Init+0x74>)
 8004e5a:	2200      	movs	r2, #0
 8004e5c:	609a      	str	r2, [r3, #8]
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8004e5e:	4b17      	ldr	r3, [pc, #92]	; (8004ebc <MX_I2C1_Init+0x74>)
 8004e60:	2201      	movs	r2, #1
 8004e62:	60da      	str	r2, [r3, #12]
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 8004e64:	4b15      	ldr	r3, [pc, #84]	; (8004ebc <MX_I2C1_Init+0x74>)
 8004e66:	2200      	movs	r2, #0
 8004e68:	611a      	str	r2, [r3, #16]
  hi2c1.Init.OwnAddress2 = 0;
 8004e6a:	4b14      	ldr	r3, [pc, #80]	; (8004ebc <MX_I2C1_Init+0x74>)
 8004e6c:	2200      	movs	r2, #0
 8004e6e:	615a      	str	r2, [r3, #20]
  hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
 8004e70:	4b12      	ldr	r3, [pc, #72]	; (8004ebc <MX_I2C1_Init+0x74>)
 8004e72:	2200      	movs	r2, #0
 8004e74:	619a      	str	r2, [r3, #24]
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 8004e76:	4b11      	ldr	r3, [pc, #68]	; (8004ebc <MX_I2C1_Init+0x74>)
 8004e78:	2200      	movs	r2, #0
 8004e7a:	61da      	str	r2, [r3, #28]
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 8004e7c:	4b0f      	ldr	r3, [pc, #60]	; (8004ebc <MX_I2C1_Init+0x74>)
 8004e7e:	2200      	movs	r2, #0
 8004e80:	621a      	str	r2, [r3, #32]
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
 8004e82:	4b0e      	ldr	r3, [pc, #56]	; (8004ebc <MX_I2C1_Init+0x74>)
 8004e84:	0018      	movs	r0, r3
 8004e86:	f00a ff63 	bl	800fd50 <HAL_I2C_Init>
 8004e8a:	1e03      	subs	r3, r0, #0
 8004e8c:	d001      	beq.n	8004e92 <MX_I2C1_Init+0x4a>
  {
    Error_Handler();
 8004e8e:	f000 ff8f 	bl	8005db0 <Error_Handler>
  }
  /** Configure Analogue filter
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 8004e92:	4b0a      	ldr	r3, [pc, #40]	; (8004ebc <MX_I2C1_Init+0x74>)
 8004e94:	2100      	movs	r1, #0
 8004e96:	0018      	movs	r0, r3
 8004e98:	f00b fbe4 	bl	8010664 <HAL_I2CEx_ConfigAnalogFilter>
 8004e9c:	1e03      	subs	r3, r0, #0
 8004e9e:	d001      	beq.n	8004ea4 <MX_I2C1_Init+0x5c>
  {
    Error_Handler();
 8004ea0:	f000 ff86 	bl	8005db0 <Error_Handler>
  }
  /** Configure Digital filter
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK)
 8004ea4:	4b05      	ldr	r3, [pc, #20]	; (8004ebc <MX_I2C1_Init+0x74>)
 8004ea6:	2100      	movs	r1, #0
 8004ea8:	0018      	movs	r0, r3
 8004eaa:	f00b fc27 	bl	80106fc <HAL_I2CEx_ConfigDigitalFilter>
 8004eae:	1e03      	subs	r3, r0, #0
 8004eb0:	d001      	beq.n	8004eb6 <MX_I2C1_Init+0x6e>
  {
    Error_Handler();
 8004eb2:	f000 ff7d 	bl	8005db0 <Error_Handler>
  }

}
 8004eb6:	46c0      	nop			; (mov r8, r8)
 8004eb8:	46bd      	mov	sp, r7
 8004eba:	bd80      	pop	{r7, pc}
 8004ebc:	200004e4 	.word	0x200004e4
 8004ec0:	40005400 	.word	0x40005400
 8004ec4:	00707cbb 	.word	0x00707cbb

08004ec8 <HAL_I2C_MspInit>:

void HAL_I2C_MspInit(I2C_HandleTypeDef* i2cHandle)
{
 8004ec8:	b580      	push	{r7, lr}
 8004eca:	b088      	sub	sp, #32
 8004ecc:	af00      	add	r7, sp, #0
 8004ece:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8004ed0:	230c      	movs	r3, #12
 8004ed2:	18fb      	adds	r3, r7, r3
 8004ed4:	0018      	movs	r0, r3
 8004ed6:	2314      	movs	r3, #20
 8004ed8:	001a      	movs	r2, r3
 8004eda:	2100      	movs	r1, #0
 8004edc:	f00e f97b 	bl	80131d6 <memset>
  if(i2cHandle->Instance==I2C1)
 8004ee0:	687b      	ldr	r3, [r7, #4]
 8004ee2:	681b      	ldr	r3, [r3, #0]
 8004ee4:	4a18      	ldr	r2, [pc, #96]	; (8004f48 <HAL_I2C_MspInit+0x80>)
 8004ee6:	4293      	cmp	r3, r2
 8004ee8:	d129      	bne.n	8004f3e <HAL_I2C_MspInit+0x76>
  {
  /* USER CODE BEGIN I2C1_MspInit 0 */

  /* USER CODE END I2C1_MspInit 0 */

    __HAL_RCC_GPIOB_CLK_ENABLE();
 8004eea:	4b18      	ldr	r3, [pc, #96]	; (8004f4c <HAL_I2C_MspInit+0x84>)
 8004eec:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8004eee:	4b17      	ldr	r3, [pc, #92]	; (8004f4c <HAL_I2C_MspInit+0x84>)
 8004ef0:	2102      	movs	r1, #2
 8004ef2:	430a      	orrs	r2, r1
 8004ef4:	62da      	str	r2, [r3, #44]	; 0x2c
 8004ef6:	4b15      	ldr	r3, [pc, #84]	; (8004f4c <HAL_I2C_MspInit+0x84>)
 8004ef8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004efa:	2202      	movs	r2, #2
 8004efc:	4013      	ands	r3, r2
 8004efe:	60bb      	str	r3, [r7, #8]
 8004f00:	68bb      	ldr	r3, [r7, #8]
    /**I2C1 GPIO Configuration
    PB8     ------> I2C1_SCL
    PB9     ------> I2C1_SDA
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;
 8004f02:	210c      	movs	r1, #12
 8004f04:	187b      	adds	r3, r7, r1
 8004f06:	22c0      	movs	r2, #192	; 0xc0
 8004f08:	0092      	lsls	r2, r2, #2
 8004f0a:	601a      	str	r2, [r3, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8004f0c:	187b      	adds	r3, r7, r1
 8004f0e:	2212      	movs	r2, #18
 8004f10:	605a      	str	r2, [r3, #4]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8004f12:	187b      	adds	r3, r7, r1
 8004f14:	2201      	movs	r2, #1
 8004f16:	609a      	str	r2, [r3, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8004f18:	187b      	adds	r3, r7, r1
 8004f1a:	2203      	movs	r2, #3
 8004f1c:	60da      	str	r2, [r3, #12]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
 8004f1e:	187b      	adds	r3, r7, r1
 8004f20:	2204      	movs	r2, #4
 8004f22:	611a      	str	r2, [r3, #16]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8004f24:	187b      	adds	r3, r7, r1
 8004f26:	4a0a      	ldr	r2, [pc, #40]	; (8004f50 <HAL_I2C_MspInit+0x88>)
 8004f28:	0019      	movs	r1, r3
 8004f2a:	0010      	movs	r0, r2
 8004f2c:	f00a fc76 	bl	800f81c <HAL_GPIO_Init>

    /* I2C1 clock enable */
    __HAL_RCC_I2C1_CLK_ENABLE();
 8004f30:	4b06      	ldr	r3, [pc, #24]	; (8004f4c <HAL_I2C_MspInit+0x84>)
 8004f32:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8004f34:	4b05      	ldr	r3, [pc, #20]	; (8004f4c <HAL_I2C_MspInit+0x84>)
 8004f36:	2180      	movs	r1, #128	; 0x80
 8004f38:	0389      	lsls	r1, r1, #14
 8004f3a:	430a      	orrs	r2, r1
 8004f3c:	639a      	str	r2, [r3, #56]	; 0x38
  /* USER CODE BEGIN I2C1_MspInit 1 */

  /* USER CODE END I2C1_MspInit 1 */
  }
}
 8004f3e:	46c0      	nop			; (mov r8, r8)
 8004f40:	46bd      	mov	sp, r7
 8004f42:	b008      	add	sp, #32
 8004f44:	bd80      	pop	{r7, pc}
 8004f46:	46c0      	nop			; (mov r8, r8)
 8004f48:	40005400 	.word	0x40005400
 8004f4c:	40021000 	.word	0x40021000
 8004f50:	50000400 	.word	0x50000400

08004f54 <HAL_UART_RxCpltCallback>:
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
//----------Interrupt USART----------------------------------
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
 8004f54:	b580      	push	{r7, lr}
 8004f56:	b082      	sub	sp, #8
 8004f58:	af00      	add	r7, sp, #0
 8004f5a:	6078      	str	r0, [r7, #4]
//USART CEIT-------------------
	if (huart->Instance == USART5) {
 8004f5c:	687b      	ldr	r3, [r7, #4]
 8004f5e:	681b      	ldr	r3, [r3, #0]
 8004f60:	4a4e      	ldr	r2, [pc, #312]	; (800509c <HAL_UART_RxCpltCallback+0x148>)
 8004f62:	4293      	cmp	r3, r2
 8004f64:	d000      	beq.n	8004f68 <HAL_UART_RxCpltCallback+0x14>
 8004f66:	e095      	b.n	8005094 <HAL_UART_RxCpltCallback+0x140>
		HAL_UART_Receive_IT(&huart5, &Char_USART5, 1);
 8004f68:	494d      	ldr	r1, [pc, #308]	; (80050a0 <HAL_UART_RxCpltCallback+0x14c>)
 8004f6a:	4b4e      	ldr	r3, [pc, #312]	; (80050a4 <HAL_UART_RxCpltCallback+0x150>)
 8004f6c:	2201      	movs	r2, #1
 8004f6e:	0018      	movs	r0, r3
 8004f70:	f00d f982 	bl	8012278 <HAL_UART_Receive_IT>
		if(garb){
 8004f74:	4b4c      	ldr	r3, [pc, #304]	; (80050a8 <HAL_UART_RxCpltCallback+0x154>)
 8004f76:	781b      	ldrb	r3, [r3, #0]
 8004f78:	2b00      	cmp	r3, #0
 8004f7a:	d013      	beq.n	8004fa4 <HAL_UART_RxCpltCallback+0x50>
			if(Char_USART5 == 1){
 8004f7c:	4b48      	ldr	r3, [pc, #288]	; (80050a0 <HAL_UART_RxCpltCallback+0x14c>)
 8004f7e:	781b      	ldrb	r3, [r3, #0]
 8004f80:	2b01      	cmp	r3, #1
 8004f82:	d000      	beq.n	8004f86 <HAL_UART_RxCpltCallback+0x32>
 8004f84:	e086      	b.n	8005094 <HAL_UART_RxCpltCallback+0x140>
				garb = 0;
 8004f86:	4b48      	ldr	r3, [pc, #288]	; (80050a8 <HAL_UART_RxCpltCallback+0x154>)
 8004f88:	2200      	movs	r2, #0
 8004f8a:	701a      	strb	r2, [r3, #0]
				stcomceit.Rx_Buffer[0] = Char_USART5;
 8004f8c:	4b44      	ldr	r3, [pc, #272]	; (80050a0 <HAL_UART_RxCpltCallback+0x14c>)
 8004f8e:	7819      	ldrb	r1, [r3, #0]
 8004f90:	4b46      	ldr	r3, [pc, #280]	; (80050ac <HAL_UART_RxCpltCallback+0x158>)
 8004f92:	2271      	movs	r2, #113	; 0x71
 8004f94:	5499      	strb	r1, [r3, r2]
				Cont_USART5++;
 8004f96:	4b46      	ldr	r3, [pc, #280]	; (80050b0 <HAL_UART_RxCpltCallback+0x15c>)
 8004f98:	781b      	ldrb	r3, [r3, #0]
 8004f9a:	3301      	adds	r3, #1
 8004f9c:	b2da      	uxtb	r2, r3
 8004f9e:	4b44      	ldr	r3, [pc, #272]	; (80050b0 <HAL_UART_RxCpltCallback+0x15c>)
 8004fa0:	701a      	strb	r2, [r3, #0]
				HAL_UART_Transmit(&huart2, stcomceit.Rx_Data, sizeof(stcomceit.Rx_Data), 1000);
			}
		}
	}

}
 8004fa2:	e077      	b.n	8005094 <HAL_UART_RxCpltCallback+0x140>
			if (Char_USART5 != 250) {
 8004fa4:	4b3e      	ldr	r3, [pc, #248]	; (80050a0 <HAL_UART_RxCpltCallback+0x14c>)
 8004fa6:	781b      	ldrb	r3, [r3, #0]
 8004fa8:	2bfa      	cmp	r3, #250	; 0xfa
 8004faa:	d04d      	beq.n	8005048 <HAL_UART_RxCpltCallback+0xf4>
				if (Cont_USART5 < 5){
 8004fac:	4b40      	ldr	r3, [pc, #256]	; (80050b0 <HAL_UART_RxCpltCallback+0x15c>)
 8004fae:	781b      	ldrb	r3, [r3, #0]
 8004fb0:	2b04      	cmp	r3, #4
 8004fb2:	d811      	bhi.n	8004fd8 <HAL_UART_RxCpltCallback+0x84>
					stcomceit.Rx_Buffer[Cont_USART5] = Char_USART5;
 8004fb4:	4b3e      	ldr	r3, [pc, #248]	; (80050b0 <HAL_UART_RxCpltCallback+0x15c>)
 8004fb6:	781b      	ldrb	r3, [r3, #0]
 8004fb8:	0018      	movs	r0, r3
 8004fba:	4b39      	ldr	r3, [pc, #228]	; (80050a0 <HAL_UART_RxCpltCallback+0x14c>)
 8004fbc:	7819      	ldrb	r1, [r3, #0]
 8004fbe:	4b3b      	ldr	r3, [pc, #236]	; (80050ac <HAL_UART_RxCpltCallback+0x158>)
 8004fc0:	2271      	movs	r2, #113	; 0x71
 8004fc2:	181b      	adds	r3, r3, r0
 8004fc4:	189b      	adds	r3, r3, r2
 8004fc6:	1c0a      	adds	r2, r1, #0
 8004fc8:	701a      	strb	r2, [r3, #0]
					Cont_USART5++;
 8004fca:	4b39      	ldr	r3, [pc, #228]	; (80050b0 <HAL_UART_RxCpltCallback+0x15c>)
 8004fcc:	781b      	ldrb	r3, [r3, #0]
 8004fce:	3301      	adds	r3, #1
 8004fd0:	b2da      	uxtb	r2, r3
 8004fd2:	4b37      	ldr	r3, [pc, #220]	; (80050b0 <HAL_UART_RxCpltCallback+0x15c>)
 8004fd4:	701a      	strb	r2, [r3, #0]
}
 8004fd6:	e05d      	b.n	8005094 <HAL_UART_RxCpltCallback+0x140>
				}else if (stcomceit.Rx_Buffer[CMD] == GET_DATA) {
 8004fd8:	4b34      	ldr	r3, [pc, #208]	; (80050ac <HAL_UART_RxCpltCallback+0x158>)
 8004fda:	2274      	movs	r2, #116	; 0x74
 8004fdc:	5c9b      	ldrb	r3, [r3, r2]
 8004fde:	2b60      	cmp	r3, #96	; 0x60
 8004fe0:	d11b      	bne.n	800501a <HAL_UART_RxCpltCallback+0xc6>
					stcomceit.Rx_Buffer[Cont_USART5] = Char_USART5;
 8004fe2:	4b33      	ldr	r3, [pc, #204]	; (80050b0 <HAL_UART_RxCpltCallback+0x15c>)
 8004fe4:	781b      	ldrb	r3, [r3, #0]
 8004fe6:	0018      	movs	r0, r3
 8004fe8:	4b2d      	ldr	r3, [pc, #180]	; (80050a0 <HAL_UART_RxCpltCallback+0x14c>)
 8004fea:	7819      	ldrb	r1, [r3, #0]
 8004fec:	4b2f      	ldr	r3, [pc, #188]	; (80050ac <HAL_UART_RxCpltCallback+0x158>)
 8004fee:	2271      	movs	r2, #113	; 0x71
 8004ff0:	181b      	adds	r3, r3, r0
 8004ff2:	189b      	adds	r3, r3, r2
 8004ff4:	1c0a      	adds	r2, r1, #0
 8004ff6:	701a      	strb	r2, [r3, #0]
					HAL_UART_Transmit(&huart2, stcomceit.Rx_Buffer, sizeof(stcomceit.Rx_Buffer), 1000);
 8004ff8:	23fa      	movs	r3, #250	; 0xfa
 8004ffa:	009b      	lsls	r3, r3, #2
 8004ffc:	492d      	ldr	r1, [pc, #180]	; (80050b4 <HAL_UART_RxCpltCallback+0x160>)
 8004ffe:	482e      	ldr	r0, [pc, #184]	; (80050b8 <HAL_UART_RxCpltCallback+0x164>)
 8005000:	2206      	movs	r2, #6
 8005002:	f00d f891 	bl	8012128 <HAL_UART_Transmit>
					Cont_USART5 = 0;
 8005006:	4b2a      	ldr	r3, [pc, #168]	; (80050b0 <HAL_UART_RxCpltCallback+0x15c>)
 8005008:	2200      	movs	r2, #0
 800500a:	701a      	strb	r2, [r3, #0]
					stcomceit.xRxDoneFlag = true;
 800500c:	4b27      	ldr	r3, [pc, #156]	; (80050ac <HAL_UART_RxCpltCallback+0x158>)
 800500e:	2201      	movs	r2, #1
 8005010:	711a      	strb	r2, [r3, #4]
					garb = 1;
 8005012:	4b25      	ldr	r3, [pc, #148]	; (80050a8 <HAL_UART_RxCpltCallback+0x154>)
 8005014:	2201      	movs	r2, #1
 8005016:	701a      	strb	r2, [r3, #0]
}
 8005018:	e03c      	b.n	8005094 <HAL_UART_RxCpltCallback+0x140>
				}else if (stcomceit.Rx_Buffer[CMD] == CONFIG){
 800501a:	4b24      	ldr	r3, [pc, #144]	; (80050ac <HAL_UART_RxCpltCallback+0x158>)
 800501c:	2274      	movs	r2, #116	; 0x74
 800501e:	5c9b      	ldrb	r3, [r3, r2]
 8005020:	2b61      	cmp	r3, #97	; 0x61
 8005022:	d137      	bne.n	8005094 <HAL_UART_RxCpltCallback+0x140>
					stcomceit.Rx_Data[Cont_USART5-5] = Char_USART5;
 8005024:	4b22      	ldr	r3, [pc, #136]	; (80050b0 <HAL_UART_RxCpltCallback+0x15c>)
 8005026:	781b      	ldrb	r3, [r3, #0]
 8005028:	3b05      	subs	r3, #5
 800502a:	4a1d      	ldr	r2, [pc, #116]	; (80050a0 <HAL_UART_RxCpltCallback+0x14c>)
 800502c:	7810      	ldrb	r0, [r2, #0]
 800502e:	4a1f      	ldr	r2, [pc, #124]	; (80050ac <HAL_UART_RxCpltCallback+0x158>)
 8005030:	2177      	movs	r1, #119	; 0x77
 8005032:	18d3      	adds	r3, r2, r3
 8005034:	185b      	adds	r3, r3, r1
 8005036:	1c02      	adds	r2, r0, #0
 8005038:	701a      	strb	r2, [r3, #0]
					Cont_USART5++;
 800503a:	4b1d      	ldr	r3, [pc, #116]	; (80050b0 <HAL_UART_RxCpltCallback+0x15c>)
 800503c:	781b      	ldrb	r3, [r3, #0]
 800503e:	3301      	adds	r3, #1
 8005040:	b2da      	uxtb	r2, r3
 8005042:	4b1b      	ldr	r3, [pc, #108]	; (80050b0 <HAL_UART_RxCpltCallback+0x15c>)
 8005044:	701a      	strb	r2, [r3, #0]
}
 8005046:	e025      	b.n	8005094 <HAL_UART_RxCpltCallback+0x140>
			else if (Char_USART5 == 250) {
 8005048:	4b15      	ldr	r3, [pc, #84]	; (80050a0 <HAL_UART_RxCpltCallback+0x14c>)
 800504a:	781b      	ldrb	r3, [r3, #0]
 800504c:	2bfa      	cmp	r3, #250	; 0xfa
 800504e:	d121      	bne.n	8005094 <HAL_UART_RxCpltCallback+0x140>
				stcomceit.Rx_Data[Cont_USART5-5] = Char_USART5;
 8005050:	4b17      	ldr	r3, [pc, #92]	; (80050b0 <HAL_UART_RxCpltCallback+0x15c>)
 8005052:	781b      	ldrb	r3, [r3, #0]
 8005054:	3b05      	subs	r3, #5
 8005056:	4a12      	ldr	r2, [pc, #72]	; (80050a0 <HAL_UART_RxCpltCallback+0x14c>)
 8005058:	7810      	ldrb	r0, [r2, #0]
 800505a:	4a14      	ldr	r2, [pc, #80]	; (80050ac <HAL_UART_RxCpltCallback+0x158>)
 800505c:	2177      	movs	r1, #119	; 0x77
 800505e:	18d3      	adds	r3, r2, r3
 8005060:	185b      	adds	r3, r3, r1
 8005062:	1c02      	adds	r2, r0, #0
 8005064:	701a      	strb	r2, [r3, #0]
				Cont_USART5 = 0;
 8005066:	4b12      	ldr	r3, [pc, #72]	; (80050b0 <HAL_UART_RxCpltCallback+0x15c>)
 8005068:	2200      	movs	r2, #0
 800506a:	701a      	strb	r2, [r3, #0]
				stcomceit.xRxDoneFlag = true;
 800506c:	4b0f      	ldr	r3, [pc, #60]	; (80050ac <HAL_UART_RxCpltCallback+0x158>)
 800506e:	2201      	movs	r2, #1
 8005070:	711a      	strb	r2, [r3, #4]
				garb = 1;
 8005072:	4b0d      	ldr	r3, [pc, #52]	; (80050a8 <HAL_UART_RxCpltCallback+0x154>)
 8005074:	2201      	movs	r2, #1
 8005076:	701a      	strb	r2, [r3, #0]
				HAL_UART_Transmit(&huart2, stcomceit.Rx_Buffer, sizeof(stcomceit.Rx_Buffer), 1000);
 8005078:	23fa      	movs	r3, #250	; 0xfa
 800507a:	009b      	lsls	r3, r3, #2
 800507c:	490d      	ldr	r1, [pc, #52]	; (80050b4 <HAL_UART_RxCpltCallback+0x160>)
 800507e:	480e      	ldr	r0, [pc, #56]	; (80050b8 <HAL_UART_RxCpltCallback+0x164>)
 8005080:	2206      	movs	r2, #6
 8005082:	f00d f851 	bl	8012128 <HAL_UART_Transmit>
				HAL_UART_Transmit(&huart2, stcomceit.Rx_Data, sizeof(stcomceit.Rx_Data), 1000);
 8005086:	23fa      	movs	r3, #250	; 0xfa
 8005088:	009b      	lsls	r3, r3, #2
 800508a:	490c      	ldr	r1, [pc, #48]	; (80050bc <HAL_UART_RxCpltCallback+0x168>)
 800508c:	480a      	ldr	r0, [pc, #40]	; (80050b8 <HAL_UART_RxCpltCallback+0x164>)
 800508e:	22cb      	movs	r2, #203	; 0xcb
 8005090:	f00d f84a 	bl	8012128 <HAL_UART_Transmit>
}
 8005094:	46c0      	nop			; (mov r8, r8)
 8005096:	46bd      	mov	sp, r7
 8005098:	b002      	add	sp, #8
 800509a:	bd80      	pop	{r7, pc}
 800509c:	40005000 	.word	0x40005000
 80050a0:	20002cfc 	.word	0x20002cfc
 80050a4:	2000317c 	.word	0x2000317c
 80050a8:	20000000 	.word	0x20000000
 80050ac:	20002d00 	.word	0x20002d00
 80050b0:	20000456 	.word	0x20000456
 80050b4:	20002d71 	.word	0x20002d71
 80050b8:	200031fc 	.word	0x200031fc
 80050bc:	20002d77 	.word	0x20002d77

080050c0 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 80050c0:	b590      	push	{r4, r7, lr}
 80050c2:	b083      	sub	sp, #12
 80050c4:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 1 */
	uint8_t sensorOK, respuesta, data=0,i,j;
 80050c6:	1dbb      	adds	r3, r7, #6
 80050c8:	2200      	movs	r2, #0
 80050ca:	701a      	strb	r2, [r3, #0]
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 80050cc:	f00a f9a2 	bl	800f414 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 80050d0:	f000 f8a4 	bl	800521c <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 80050d4:	f7ff fd60 	bl	8004b98 <MX_GPIO_Init>
  MX_I2C1_Init();
 80050d8:	f7ff feb6 	bl	8004e48 <MX_I2C1_Init>
  MX_USART2_UART_Init();
 80050dc:	f000 ffca 	bl	8006074 <MX_USART2_UART_Init>
  MX_USART5_UART_Init();
 80050e0:	f000 fff8 	bl	80060d4 <MX_USART5_UART_Init>
  /* USER CODE BEGIN 2 */
  HAL_UART_Receive_IT(&huart5, &Char_USART5, 1);
 80050e4:	4944      	ldr	r1, [pc, #272]	; (80051f8 <main+0x138>)
 80050e6:	4b45      	ldr	r3, [pc, #276]	; (80051fc <main+0x13c>)
 80050e8:	2201      	movs	r2, #1
 80050ea:	0018      	movs	r0, r3
 80050ec:	f00d f8c4 	bl	8012278 <HAL_UART_Receive_IT>
  Iniciar_EstrucCaptura(&stcaptura);
 80050f0:	4b43      	ldr	r3, [pc, #268]	; (8005200 <main+0x140>)
 80050f2:	0018      	movs	r0, r3
 80050f4:	f7ff fb70 	bl	80047d8 <Iniciar_EstrucCaptura>
  Iniciar_EstrucComCEIT(&stcomceit);
 80050f8:	4b42      	ldr	r3, [pc, #264]	; (8005204 <main+0x144>)
 80050fa:	0018      	movs	r0, r3
 80050fc:	f7ff fbc7 	bl	800488e <Iniciar_EstrucComCEIT>
  Iniciar_EstrucDistancia(&stdistancia);
 8005100:	4b41      	ldr	r3, [pc, #260]	; (8005208 <main+0x148>)
 8005102:	0018      	movs	r0, r3
 8005104:	f7ff fc13 	bl	800492e <Iniciar_EstrucDistancia>
  Iniciar_EstrucMotor(&stmotor);
 8005108:	4b40      	ldr	r3, [pc, #256]	; (800520c <main+0x14c>)
 800510a:	0018      	movs	r0, r3
 800510c:	f7ff fc7a 	bl	8004a04 <Iniciar_EstrucMotor>
  for(i=0; i<RX_DATA_SIZE;i++)
 8005110:	1dfb      	adds	r3, r7, #7
 8005112:	2200      	movs	r2, #0
 8005114:	701a      	strb	r2, [r3, #0]
 8005116:	e010      	b.n	800513a <main+0x7a>
  {
	  stcomceit.Rx_Data[i] = DataRX[i];
 8005118:	1dfb      	adds	r3, r7, #7
 800511a:	781a      	ldrb	r2, [r3, #0]
 800511c:	1dfb      	adds	r3, r7, #7
 800511e:	781b      	ldrb	r3, [r3, #0]
 8005120:	493b      	ldr	r1, [pc, #236]	; (8005210 <main+0x150>)
 8005122:	5c88      	ldrb	r0, [r1, r2]
 8005124:	4a37      	ldr	r2, [pc, #220]	; (8005204 <main+0x144>)
 8005126:	2177      	movs	r1, #119	; 0x77
 8005128:	18d3      	adds	r3, r2, r3
 800512a:	185b      	adds	r3, r3, r1
 800512c:	1c02      	adds	r2, r0, #0
 800512e:	701a      	strb	r2, [r3, #0]
  for(i=0; i<RX_DATA_SIZE;i++)
 8005130:	1dfb      	adds	r3, r7, #7
 8005132:	781a      	ldrb	r2, [r3, #0]
 8005134:	1dfb      	adds	r3, r7, #7
 8005136:	3201      	adds	r2, #1
 8005138:	701a      	strb	r2, [r3, #0]
 800513a:	1dfb      	adds	r3, r7, #7
 800513c:	781b      	ldrb	r3, [r3, #0]
 800513e:	2bca      	cmp	r3, #202	; 0xca
 8005140:	d9ea      	bls.n	8005118 <main+0x58>
  }
  ConfigParrillas(&stcaptura, &stcomceit, &stmotor, &stdistancia);
 8005142:	4b31      	ldr	r3, [pc, #196]	; (8005208 <main+0x148>)
 8005144:	4a31      	ldr	r2, [pc, #196]	; (800520c <main+0x14c>)
 8005146:	492f      	ldr	r1, [pc, #188]	; (8005204 <main+0x144>)
 8005148:	482d      	ldr	r0, [pc, #180]	; (8005200 <main+0x140>)
 800514a:	f7fe f8d9 	bl	8003300 <ConfigParrillas>
  Ordenar(&stmotor,&stdistancia);
 800514e:	4a2e      	ldr	r2, [pc, #184]	; (8005208 <main+0x148>)
 8005150:	4b2e      	ldr	r3, [pc, #184]	; (800520c <main+0x14c>)
 8005152:	0011      	movs	r1, r2
 8005154:	0018      	movs	r0, r3
 8005156:	f7fe fa4b 	bl	80035f0 <Ordenar>
  IniciarSensores(&stdistancia);
 800515a:	4b2b      	ldr	r3, [pc, #172]	; (8005208 <main+0x148>)
 800515c:	0018      	movs	r0, r3
 800515e:	f7ff f849 	bl	80041f4 <IniciarSensores>
  MyMotorInit();
 8005162:	f000 f9d9 	bl	8005518 <MyMotorInit>

//  calib_motor5();
  calib_motor();
 8005166:	f000 fbd1 	bl	800590c <calib_motor>
  calib_motor2();
 800516a:	f000 fc41 	bl	80059f0 <calib_motor2>
  calib_motor4();
 800516e:	f000 fd21 	bl	8005bb4 <calib_motor4>
  calib_motor5();
 8005172:	f000 fd89 	bl	8005c88 <calib_motor5>
  calib_motor3();
 8005176:	f000 fcad 	bl	8005ad4 <calib_motor3>

//  calib_motor6();
  EnableMotors(7);
 800517a:	2007      	movs	r0, #7
 800517c:	f000 fa08 	bl	8005590 <EnableMotors>
  HAL_UART_Transmit(&huart5, Data_CALIB_OK, 8 , 200);
 8005180:	4924      	ldr	r1, [pc, #144]	; (8005214 <main+0x154>)
 8005182:	481e      	ldr	r0, [pc, #120]	; (80051fc <main+0x13c>)
 8005184:	23c8      	movs	r3, #200	; 0xc8
 8005186:	2208      	movs	r2, #8
 8005188:	f00c ffce 	bl	8012128 <HAL_UART_Transmit>
  HAL_UART_Transmit(&huart2, Data_CALIB_OK, 8 , 200);
 800518c:	4921      	ldr	r1, [pc, #132]	; (8005214 <main+0x154>)
 800518e:	4822      	ldr	r0, [pc, #136]	; (8005218 <main+0x158>)
 8005190:	23c8      	movs	r3, #200	; 0xc8
 8005192:	2208      	movs	r2, #8
 8005194:	f00c ffc8 	bl	8012128 <HAL_UART_Transmit>
  /* USER CODE BEGIN WHILE */
	while (1) {
//		sensorsTest();

	 /* Código máquinas de estado */
	  BloqueCOM_CEIT(&stcomceit);
 8005198:	4b1a      	ldr	r3, [pc, #104]	; (8005204 <main+0x144>)
 800519a:	0018      	movs	r0, r3
 800519c:	f7fe fd8e 	bl	8003cbc <BloqueCOM_CEIT>
	  BloqueCaptura(&stcaptura, &stcomceit, &stmotor, &stdistancia);
 80051a0:	4b19      	ldr	r3, [pc, #100]	; (8005208 <main+0x148>)
 80051a2:	4a1a      	ldr	r2, [pc, #104]	; (800520c <main+0x14c>)
 80051a4:	4917      	ldr	r1, [pc, #92]	; (8005204 <main+0x144>)
 80051a6:	4816      	ldr	r0, [pc, #88]	; (8005200 <main+0x140>)
 80051a8:	f7fd febe 	bl	8002f28 <BloqueCaptura>
	  BloqueMotor();
 80051ac:	f000 f8ac 	bl	8005308 <BloqueMotor>
	  /* Bloque distancia */
	  if(stdistancia.bandDistancia){
 80051b0:	4b15      	ldr	r3, [pc, #84]	; (8005208 <main+0x148>)
 80051b2:	781b      	ldrb	r3, [r3, #0]
 80051b4:	2b00      	cmp	r3, #0
 80051b6:	d0ef      	beq.n	8005198 <main+0xd8>
		  stdistancia.contParrilla = stdistancia.sensor[stdistancia.contDistancia];
 80051b8:	4b13      	ldr	r3, [pc, #76]	; (8005208 <main+0x148>)
 80051ba:	2265      	movs	r2, #101	; 0x65
 80051bc:	5c9b      	ldrb	r3, [r3, r2]
 80051be:	0019      	movs	r1, r3
 80051c0:	4a11      	ldr	r2, [pc, #68]	; (8005208 <main+0x148>)
 80051c2:	239d      	movs	r3, #157	; 0x9d
 80051c4:	005b      	lsls	r3, r3, #1
 80051c6:	1852      	adds	r2, r2, r1
 80051c8:	18d3      	adds	r3, r2, r3
 80051ca:	7819      	ldrb	r1, [r3, #0]
 80051cc:	4b0e      	ldr	r3, [pc, #56]	; (8005208 <main+0x148>)
 80051ce:	2266      	movs	r2, #102	; 0x66
 80051d0:	5499      	strb	r1, [r3, r2]
//		  VL53L1_StartMeasurement( &stdistancia.VL53L1_DEV[stdistancia.contParrilla] );
		  sensorOK = BloqueDistancia(&stdistancia);
 80051d2:	1d7c      	adds	r4, r7, #5
 80051d4:	4b0c      	ldr	r3, [pc, #48]	; (8005208 <main+0x148>)
 80051d6:	0018      	movs	r0, r3
 80051d8:	f7fe fe40 	bl	8003e5c <BloqueDistancia>
 80051dc:	0003      	movs	r3, r0
 80051de:	7023      	strb	r3, [r4, #0]
		  stdistancia.bandDistancia = false;
 80051e0:	4b09      	ldr	r3, [pc, #36]	; (8005208 <main+0x148>)
 80051e2:	2200      	movs	r2, #0
 80051e4:	701a      	strb	r2, [r3, #0]
		  stdistancia.contDistancia++;
 80051e6:	4b08      	ldr	r3, [pc, #32]	; (8005208 <main+0x148>)
 80051e8:	2265      	movs	r2, #101	; 0x65
 80051ea:	5c9b      	ldrb	r3, [r3, r2]
 80051ec:	3301      	adds	r3, #1
 80051ee:	b2d9      	uxtb	r1, r3
 80051f0:	4b05      	ldr	r3, [pc, #20]	; (8005208 <main+0x148>)
 80051f2:	2265      	movs	r2, #101	; 0x65
 80051f4:	5499      	strb	r1, [r3, r2]
	  BloqueCOM_CEIT(&stcomceit);
 80051f6:	e7cf      	b.n	8005198 <main+0xd8>
 80051f8:	20002cfc 	.word	0x20002cfc
 80051fc:	2000317c 	.word	0x2000317c
 8005200:	20000530 	.word	0x20000530
 8005204:	20002d00 	.word	0x20002d00
 8005208:	200006c4 	.word	0x200006c4
 800520c:	20002e44 	.word	0x20002e44
 8005210:	2000000c 	.word	0x2000000c
 8005214:	20000004 	.word	0x20000004
 8005218:	200031fc 	.word	0x200031fc

0800521c <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 800521c:	b590      	push	{r4, r7, lr}
 800521e:	b09f      	sub	sp, #124	; 0x7c
 8005220:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8005222:	2440      	movs	r4, #64	; 0x40
 8005224:	193b      	adds	r3, r7, r4
 8005226:	0018      	movs	r0, r3
 8005228:	2338      	movs	r3, #56	; 0x38
 800522a:	001a      	movs	r2, r3
 800522c:	2100      	movs	r1, #0
 800522e:	f00d ffd2 	bl	80131d6 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8005232:	232c      	movs	r3, #44	; 0x2c
 8005234:	18fb      	adds	r3, r7, r3
 8005236:	0018      	movs	r0, r3
 8005238:	2314      	movs	r3, #20
 800523a:	001a      	movs	r2, r3
 800523c:	2100      	movs	r1, #0
 800523e:	f00d ffca 	bl	80131d6 <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8005242:	1d3b      	adds	r3, r7, #4
 8005244:	0018      	movs	r0, r3
 8005246:	2328      	movs	r3, #40	; 0x28
 8005248:	001a      	movs	r2, r3
 800524a:	2100      	movs	r1, #0
 800524c:	f00d ffc3 	bl	80131d6 <memset>

  /** Configure the main internal regulator output voltage
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8005250:	4b2b      	ldr	r3, [pc, #172]	; (8005300 <SystemClock_Config+0xe4>)
 8005252:	681b      	ldr	r3, [r3, #0]
 8005254:	4a2b      	ldr	r2, [pc, #172]	; (8005304 <SystemClock_Config+0xe8>)
 8005256:	401a      	ands	r2, r3
 8005258:	4b29      	ldr	r3, [pc, #164]	; (8005300 <SystemClock_Config+0xe4>)
 800525a:	2180      	movs	r1, #128	; 0x80
 800525c:	0109      	lsls	r1, r1, #4
 800525e:	430a      	orrs	r2, r1
 8005260:	601a      	str	r2, [r3, #0]
  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 8005262:	0021      	movs	r1, r4
 8005264:	187b      	adds	r3, r7, r1
 8005266:	2202      	movs	r2, #2
 8005268:	601a      	str	r2, [r3, #0]
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 800526a:	187b      	adds	r3, r7, r1
 800526c:	2201      	movs	r2, #1
 800526e:	60da      	str	r2, [r3, #12]
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 8005270:	187b      	adds	r3, r7, r1
 8005272:	2210      	movs	r2, #16
 8005274:	611a      	str	r2, [r3, #16]
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8005276:	187b      	adds	r3, r7, r1
 8005278:	2202      	movs	r2, #2
 800527a:	629a      	str	r2, [r3, #40]	; 0x28
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
 800527c:	187b      	adds	r3, r7, r1
 800527e:	2200      	movs	r2, #0
 8005280:	62da      	str	r2, [r3, #44]	; 0x2c
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLLMUL_4;
 8005282:	187b      	adds	r3, r7, r1
 8005284:	2280      	movs	r2, #128	; 0x80
 8005286:	02d2      	lsls	r2, r2, #11
 8005288:	631a      	str	r2, [r3, #48]	; 0x30
  RCC_OscInitStruct.PLL.PLLDIV = RCC_PLLDIV_2;
 800528a:	187b      	adds	r3, r7, r1
 800528c:	2280      	movs	r2, #128	; 0x80
 800528e:	03d2      	lsls	r2, r2, #15
 8005290:	635a      	str	r2, [r3, #52]	; 0x34
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8005292:	187b      	adds	r3, r7, r1
 8005294:	0018      	movs	r0, r3
 8005296:	f00b fa7d 	bl	8010794 <HAL_RCC_OscConfig>
 800529a:	1e03      	subs	r3, r0, #0
 800529c:	d001      	beq.n	80052a2 <SystemClock_Config+0x86>
  {
    Error_Handler();
 800529e:	f000 fd87 	bl	8005db0 <Error_Handler>
  }
  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80052a2:	212c      	movs	r1, #44	; 0x2c
 80052a4:	187b      	adds	r3, r7, r1
 80052a6:	220f      	movs	r2, #15
 80052a8:	601a      	str	r2, [r3, #0]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80052aa:	187b      	adds	r3, r7, r1
 80052ac:	2203      	movs	r2, #3
 80052ae:	605a      	str	r2, [r3, #4]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80052b0:	187b      	adds	r3, r7, r1
 80052b2:	2200      	movs	r2, #0
 80052b4:	609a      	str	r2, [r3, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 80052b6:	187b      	adds	r3, r7, r1
 80052b8:	2200      	movs	r2, #0
 80052ba:	60da      	str	r2, [r3, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 80052bc:	187b      	adds	r3, r7, r1
 80052be:	2200      	movs	r2, #0
 80052c0:	611a      	str	r2, [r3, #16]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 80052c2:	187b      	adds	r3, r7, r1
 80052c4:	2101      	movs	r1, #1
 80052c6:	0018      	movs	r0, r3
 80052c8:	f00b fe34 	bl	8010f34 <HAL_RCC_ClockConfig>
 80052cc:	1e03      	subs	r3, r0, #0
 80052ce:	d001      	beq.n	80052d4 <SystemClock_Config+0xb8>
  {
    Error_Handler();
 80052d0:	f000 fd6e 	bl	8005db0 <Error_Handler>
  }
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2|RCC_PERIPHCLK_I2C1;
 80052d4:	1d3b      	adds	r3, r7, #4
 80052d6:	220a      	movs	r2, #10
 80052d8:	601a      	str	r2, [r3, #0]
  PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
 80052da:	1d3b      	adds	r3, r7, #4
 80052dc:	2200      	movs	r2, #0
 80052de:	611a      	str	r2, [r3, #16]
  PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1;
 80052e0:	1d3b      	adds	r3, r7, #4
 80052e2:	2200      	movs	r2, #0
 80052e4:	619a      	str	r2, [r3, #24]
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 80052e6:	1d3b      	adds	r3, r7, #4
 80052e8:	0018      	movs	r0, r3
 80052ea:	f00c f807 	bl	80112fc <HAL_RCCEx_PeriphCLKConfig>
 80052ee:	1e03      	subs	r3, r0, #0
 80052f0:	d001      	beq.n	80052f6 <SystemClock_Config+0xda>
  {
    Error_Handler();
 80052f2:	f000 fd5d 	bl	8005db0 <Error_Handler>
  }
}
 80052f6:	46c0      	nop			; (mov r8, r8)
 80052f8:	46bd      	mov	sp, r7
 80052fa:	b01f      	add	sp, #124	; 0x7c
 80052fc:	bd90      	pop	{r4, r7, pc}
 80052fe:	46c0      	nop			; (mov r8, r8)
 8005300:	40007000 	.word	0x40007000
 8005304:	ffffe7ff 	.word	0xffffe7ff

08005308 <BloqueMotor>:

/* USER CODE BEGIN 4 */

void BloqueMotor(void) {
 8005308:	b590      	push	{r4, r7, lr}
 800530a:	b085      	sub	sp, #20
 800530c:	af02      	add	r7, sp, #8
	uint8_t unidad, decena, centena, mil;
	uint8_t i,j;

	/* Bloque motor */
	if(stmotor.bandMotor){
 800530e:	4b78      	ldr	r3, [pc, #480]	; (80054f0 <BloqueMotor+0x1e8>)
 8005310:	781b      	ldrb	r3, [r3, #0]
 8005312:	2b00      	cmp	r3, #0
 8005314:	d100      	bne.n	8005318 <BloqueMotor+0x10>
 8005316:	e0e6      	b.n	80054e6 <BloqueMotor+0x1de>
		if(stmotor.posMotor < stmotor.MaxPosMotor){
 8005318:	4b75      	ldr	r3, [pc, #468]	; (80054f0 <BloqueMotor+0x1e8>)
 800531a:	7a1b      	ldrb	r3, [r3, #8]
 800531c:	b25b      	sxtb	r3, r3
 800531e:	0019      	movs	r1, r3
 8005320:	4b73      	ldr	r3, [pc, #460]	; (80054f0 <BloqueMotor+0x1e8>)
 8005322:	4a74      	ldr	r2, [pc, #464]	; (80054f4 <BloqueMotor+0x1ec>)
 8005324:	5c9b      	ldrb	r3, [r3, r2]
 8005326:	4299      	cmp	r1, r3
 8005328:	da1c      	bge.n	8005364 <BloqueMotor+0x5c>
			/* Go next stop */
			BSP_MotorControl_GoTo(MOTOR_ID, stmotor.recorrido[stmotor.posMotor]);
 800532a:	4b71      	ldr	r3, [pc, #452]	; (80054f0 <BloqueMotor+0x1e8>)
 800532c:	7a1b      	ldrb	r3, [r3, #8]
 800532e:	b25b      	sxtb	r3, r3
 8005330:	4a6f      	ldr	r2, [pc, #444]	; (80054f0 <BloqueMotor+0x1e8>)
 8005332:	3368      	adds	r3, #104	; 0x68
 8005334:	009b      	lsls	r3, r3, #2
 8005336:	18d3      	adds	r3, r2, r3
 8005338:	3304      	adds	r3, #4
 800533a:	681b      	ldr	r3, [r3, #0]
 800533c:	0019      	movs	r1, r3
 800533e:	2000      	movs	r0, #0
 8005340:	f009 fd90 	bl	800ee64 <BSP_MotorControl_GoTo>
			BSP_MotorControl_WaitWhileActive(MOTOR_ID);
 8005344:	2000      	movs	r0, #0
 8005346:	f009 ff19 	bl	800f17c <BSP_MotorControl_WaitWhileActive>

			stmotor.posMotor++;
 800534a:	4b69      	ldr	r3, [pc, #420]	; (80054f0 <BloqueMotor+0x1e8>)
 800534c:	7a1b      	ldrb	r3, [r3, #8]
 800534e:	b25b      	sxtb	r3, r3
 8005350:	b2db      	uxtb	r3, r3
 8005352:	3301      	adds	r3, #1
 8005354:	b2db      	uxtb	r3, r3
 8005356:	b25a      	sxtb	r2, r3
 8005358:	4b65      	ldr	r3, [pc, #404]	; (80054f0 <BloqueMotor+0x1e8>)
 800535a:	721a      	strb	r2, [r3, #8]
			stmotor.bandMotor = false;
 800535c:	4b64      	ldr	r3, [pc, #400]	; (80054f0 <BloqueMotor+0x1e8>)
 800535e:	2200      	movs	r2, #0
 8005360:	701a      	strb	r2, [r3, #0]
			  EnableMotors(7);
			  HAL_UART_Transmit(&huart5, Data_CALIB_OK, 8 , 200);
			  HAL_UART_Transmit(&huart2, Data_CALIB_OK, 8 , 200);
		}
	}
}
 8005362:	e0c0      	b.n	80054e6 <BloqueMotor+0x1de>
		}else if(stmotor.posMotor <= stmotor.MaxPosMotor+2){
 8005364:	4b62      	ldr	r3, [pc, #392]	; (80054f0 <BloqueMotor+0x1e8>)
 8005366:	7a1b      	ldrb	r3, [r3, #8]
 8005368:	b25b      	sxtb	r3, r3
 800536a:	0019      	movs	r1, r3
 800536c:	4b60      	ldr	r3, [pc, #384]	; (80054f0 <BloqueMotor+0x1e8>)
 800536e:	4a61      	ldr	r2, [pc, #388]	; (80054f4 <BloqueMotor+0x1ec>)
 8005370:	5c9b      	ldrb	r3, [r3, r2]
 8005372:	3302      	adds	r3, #2
 8005374:	4299      	cmp	r1, r3
 8005376:	dc0c      	bgt.n	8005392 <BloqueMotor+0x8a>
			stmotor.bandMotor = true;
 8005378:	4b5d      	ldr	r3, [pc, #372]	; (80054f0 <BloqueMotor+0x1e8>)
 800537a:	2201      	movs	r2, #1
 800537c:	701a      	strb	r2, [r3, #0]
			stmotor.posMotor++;
 800537e:	4b5c      	ldr	r3, [pc, #368]	; (80054f0 <BloqueMotor+0x1e8>)
 8005380:	7a1b      	ldrb	r3, [r3, #8]
 8005382:	b25b      	sxtb	r3, r3
 8005384:	b2db      	uxtb	r3, r3
 8005386:	3301      	adds	r3, #1
 8005388:	b2db      	uxtb	r3, r3
 800538a:	b25a      	sxtb	r2, r3
 800538c:	4b58      	ldr	r3, [pc, #352]	; (80054f0 <BloqueMotor+0x1e8>)
 800538e:	721a      	strb	r2, [r3, #8]
}
 8005390:	e0a9      	b.n	80054e6 <BloqueMotor+0x1de>
			BSP_MotorControl_GoTo(MOTOR_ID, stmotor.recorrido[0]);
 8005392:	4a57      	ldr	r2, [pc, #348]	; (80054f0 <BloqueMotor+0x1e8>)
 8005394:	23d2      	movs	r3, #210	; 0xd2
 8005396:	005b      	lsls	r3, r3, #1
 8005398:	58d3      	ldr	r3, [r2, r3]
 800539a:	0019      	movs	r1, r3
 800539c:	2000      	movs	r0, #0
 800539e:	f009 fd61 	bl	800ee64 <BSP_MotorControl_GoTo>
			BSP_MotorControl_WaitWhileActive(MOTOR_ID);
 80053a2:	2000      	movs	r0, #0
 80053a4:	f009 feea 	bl	800f17c <BSP_MotorControl_WaitWhileActive>
			BSP_MotorControl_CmdDisable(MOTOR_ID);
 80053a8:	2000      	movs	r0, #0
 80053aa:	f009 ff0b 	bl	800f1c4 <BSP_MotorControl_CmdDisable>
			BSP_MotorControl_SetStopMode(MOTOR_ID, HIZ_MODE);
 80053ae:	2101      	movs	r1, #1
 80053b0:	2000      	movs	r0, #0
 80053b2:	f009 ff57 	bl	800f264 <BSP_MotorControl_SetStopMode>
			stmotor.posMotor = stmotor.posInicial;
 80053b6:	4b4e      	ldr	r3, [pc, #312]	; (80054f0 <BloqueMotor+0x1e8>)
 80053b8:	685b      	ldr	r3, [r3, #4]
 80053ba:	b25a      	sxtb	r2, r3
 80053bc:	4b4c      	ldr	r3, [pc, #304]	; (80054f0 <BloqueMotor+0x1e8>)
 80053be:	721a      	strb	r2, [r3, #8]
			stmotor.bandMotor = false;
 80053c0:	4b4b      	ldr	r3, [pc, #300]	; (80054f0 <BloqueMotor+0x1e8>)
 80053c2:	2200      	movs	r2, #0
 80053c4:	701a      	strb	r2, [r3, #0]
			for(i=1; i<6; i++){
 80053c6:	1cbb      	adds	r3, r7, #2
 80053c8:	2201      	movs	r2, #1
 80053ca:	701a      	strb	r2, [r3, #0]
 80053cc:	e06e      	b.n	80054ac <BloqueMotor+0x1a4>
				HAL_UART_Transmit(&huart2, (uint8_t*)"S", strlen("S"), 20);
 80053ce:	494a      	ldr	r1, [pc, #296]	; (80054f8 <BloqueMotor+0x1f0>)
 80053d0:	484a      	ldr	r0, [pc, #296]	; (80054fc <BloqueMotor+0x1f4>)
 80053d2:	2314      	movs	r3, #20
 80053d4:	2201      	movs	r2, #1
 80053d6:	f00c fea7 	bl	8012128 <HAL_UART_Transmit>
				HAL_UART_Transmit(&huart2, &i, sizeof(i), 50);
 80053da:	1cb9      	adds	r1, r7, #2
 80053dc:	4847      	ldr	r0, [pc, #284]	; (80054fc <BloqueMotor+0x1f4>)
 80053de:	2332      	movs	r3, #50	; 0x32
 80053e0:	2201      	movs	r2, #1
 80053e2:	f00c fea1 	bl	8012128 <HAL_UART_Transmit>
				HAL_UART_Transmit(&huart2, (uint8_t*)"X", strlen("S"), 20);
 80053e6:	4946      	ldr	r1, [pc, #280]	; (8005500 <BloqueMotor+0x1f8>)
 80053e8:	4844      	ldr	r0, [pc, #272]	; (80054fc <BloqueMotor+0x1f4>)
 80053ea:	2314      	movs	r3, #20
 80053ec:	2201      	movs	r2, #1
 80053ee:	f00c fe9b 	bl	8012128 <HAL_UART_Transmit>
				HAL_UART_Transmit(&huart2, (uint8_t*)";", strlen(";"), 20);
 80053f2:	4944      	ldr	r1, [pc, #272]	; (8005504 <BloqueMotor+0x1fc>)
 80053f4:	4841      	ldr	r0, [pc, #260]	; (80054fc <BloqueMotor+0x1f4>)
 80053f6:	2314      	movs	r3, #20
 80053f8:	2201      	movs	r2, #1
 80053fa:	f00c fe95 	bl	8012128 <HAL_UART_Transmit>
				for(j=0; j<stdistancia.cantFilas[i-1]; j++){
 80053fe:	1dfb      	adds	r3, r7, #7
 8005400:	2200      	movs	r2, #0
 8005402:	701a      	strb	r2, [r3, #0]
 8005404:	e03a      	b.n	800547c <BloqueMotor+0x174>
					  Convertir4Cif(stdistancia.datosDistancia[i-1][j], &mil, &centena, &decena, &unidad);
 8005406:	1cbb      	adds	r3, r7, #2
 8005408:	781b      	ldrb	r3, [r3, #0]
 800540a:	1e5a      	subs	r2, r3, #1
 800540c:	1dfb      	adds	r3, r7, #7
 800540e:	7818      	ldrb	r0, [r3, #0]
 8005410:	493d      	ldr	r1, [pc, #244]	; (8005508 <BloqueMotor+0x200>)
 8005412:	0013      	movs	r3, r2
 8005414:	009b      	lsls	r3, r3, #2
 8005416:	189b      	adds	r3, r3, r2
 8005418:	005b      	lsls	r3, r3, #1
 800541a:	181b      	adds	r3, r3, r0
 800541c:	3338      	adds	r3, #56	; 0x38
 800541e:	005b      	lsls	r3, r3, #1
 8005420:	18cb      	adds	r3, r1, r3
 8005422:	3302      	adds	r3, #2
 8005424:	8818      	ldrh	r0, [r3, #0]
 8005426:	1d7c      	adds	r4, r7, #5
 8005428:	1d3a      	adds	r2, r7, #4
 800542a:	1cf9      	adds	r1, r7, #3
 800542c:	1dbb      	adds	r3, r7, #6
 800542e:	9300      	str	r3, [sp, #0]
 8005430:	0023      	movs	r3, r4
 8005432:	f7ff f929 	bl	8004688 <Convertir4Cif>
					  HAL_UART_Transmit(&huart2, &mil, sizeof(centena), 50);
 8005436:	1cf9      	adds	r1, r7, #3
 8005438:	4830      	ldr	r0, [pc, #192]	; (80054fc <BloqueMotor+0x1f4>)
 800543a:	2332      	movs	r3, #50	; 0x32
 800543c:	2201      	movs	r2, #1
 800543e:	f00c fe73 	bl	8012128 <HAL_UART_Transmit>
					  HAL_UART_Transmit(&huart2, &centena, sizeof(centena), 50);
 8005442:	1d39      	adds	r1, r7, #4
 8005444:	482d      	ldr	r0, [pc, #180]	; (80054fc <BloqueMotor+0x1f4>)
 8005446:	2332      	movs	r3, #50	; 0x32
 8005448:	2201      	movs	r2, #1
 800544a:	f00c fe6d 	bl	8012128 <HAL_UART_Transmit>
					  HAL_UART_Transmit(&huart2, &decena, sizeof(decena), 50);
 800544e:	1d79      	adds	r1, r7, #5
 8005450:	482a      	ldr	r0, [pc, #168]	; (80054fc <BloqueMotor+0x1f4>)
 8005452:	2332      	movs	r3, #50	; 0x32
 8005454:	2201      	movs	r2, #1
 8005456:	f00c fe67 	bl	8012128 <HAL_UART_Transmit>
					  HAL_UART_Transmit(&huart2, &unidad, sizeof(unidad), 50);
 800545a:	1db9      	adds	r1, r7, #6
 800545c:	4827      	ldr	r0, [pc, #156]	; (80054fc <BloqueMotor+0x1f4>)
 800545e:	2332      	movs	r3, #50	; 0x32
 8005460:	2201      	movs	r2, #1
 8005462:	f00c fe61 	bl	8012128 <HAL_UART_Transmit>
					  HAL_UART_Transmit(&huart2, (uint8_t*)";", strlen(";"), 20);
 8005466:	4927      	ldr	r1, [pc, #156]	; (8005504 <BloqueMotor+0x1fc>)
 8005468:	4824      	ldr	r0, [pc, #144]	; (80054fc <BloqueMotor+0x1f4>)
 800546a:	2314      	movs	r3, #20
 800546c:	2201      	movs	r2, #1
 800546e:	f00c fe5b 	bl	8012128 <HAL_UART_Transmit>
				for(j=0; j<stdistancia.cantFilas[i-1]; j++){
 8005472:	1dfb      	adds	r3, r7, #7
 8005474:	781a      	ldrb	r2, [r3, #0]
 8005476:	1dfb      	adds	r3, r7, #7
 8005478:	3201      	adds	r2, #1
 800547a:	701a      	strb	r2, [r3, #0]
 800547c:	1cbb      	adds	r3, r7, #2
 800547e:	781b      	ldrb	r3, [r3, #0]
 8005480:	3b01      	subs	r3, #1
 8005482:	4a21      	ldr	r2, [pc, #132]	; (8005508 <BloqueMotor+0x200>)
 8005484:	2167      	movs	r1, #103	; 0x67
 8005486:	18d3      	adds	r3, r2, r3
 8005488:	185b      	adds	r3, r3, r1
 800548a:	781b      	ldrb	r3, [r3, #0]
 800548c:	1dfa      	adds	r2, r7, #7
 800548e:	7812      	ldrb	r2, [r2, #0]
 8005490:	429a      	cmp	r2, r3
 8005492:	d3b8      	bcc.n	8005406 <BloqueMotor+0xfe>
				HAL_UART_Transmit(&huart2, (uint8_t*)"\n", strlen("\n"), 20);
 8005494:	491d      	ldr	r1, [pc, #116]	; (800550c <BloqueMotor+0x204>)
 8005496:	4819      	ldr	r0, [pc, #100]	; (80054fc <BloqueMotor+0x1f4>)
 8005498:	2314      	movs	r3, #20
 800549a:	2201      	movs	r2, #1
 800549c:	f00c fe44 	bl	8012128 <HAL_UART_Transmit>
			for(i=1; i<6; i++){
 80054a0:	1cbb      	adds	r3, r7, #2
 80054a2:	781b      	ldrb	r3, [r3, #0]
 80054a4:	3301      	adds	r3, #1
 80054a6:	b2da      	uxtb	r2, r3
 80054a8:	1cbb      	adds	r3, r7, #2
 80054aa:	701a      	strb	r2, [r3, #0]
 80054ac:	1cbb      	adds	r3, r7, #2
 80054ae:	781b      	ldrb	r3, [r3, #0]
 80054b0:	2b05      	cmp	r3, #5
 80054b2:	d98c      	bls.n	80053ce <BloqueMotor+0xc6>
			  calib_motor();
 80054b4:	f000 fa2a 	bl	800590c <calib_motor>
			  calib_motor2();
 80054b8:	f000 fa9a 	bl	80059f0 <calib_motor2>
			  calib_motor4();
 80054bc:	f000 fb7a 	bl	8005bb4 <calib_motor4>
			  calib_motor5();
 80054c0:	f000 fbe2 	bl	8005c88 <calib_motor5>
			  calib_motor3();
 80054c4:	f000 fb06 	bl	8005ad4 <calib_motor3>
			  EnableMotors(7);
 80054c8:	2007      	movs	r0, #7
 80054ca:	f000 f861 	bl	8005590 <EnableMotors>
			  HAL_UART_Transmit(&huart5, Data_CALIB_OK, 8 , 200);
 80054ce:	4910      	ldr	r1, [pc, #64]	; (8005510 <BloqueMotor+0x208>)
 80054d0:	4810      	ldr	r0, [pc, #64]	; (8005514 <BloqueMotor+0x20c>)
 80054d2:	23c8      	movs	r3, #200	; 0xc8
 80054d4:	2208      	movs	r2, #8
 80054d6:	f00c fe27 	bl	8012128 <HAL_UART_Transmit>
			  HAL_UART_Transmit(&huart2, Data_CALIB_OK, 8 , 200);
 80054da:	490d      	ldr	r1, [pc, #52]	; (8005510 <BloqueMotor+0x208>)
 80054dc:	4807      	ldr	r0, [pc, #28]	; (80054fc <BloqueMotor+0x1f4>)
 80054de:	23c8      	movs	r3, #200	; 0xc8
 80054e0:	2208      	movs	r2, #8
 80054e2:	f00c fe21 	bl	8012128 <HAL_UART_Transmit>
}
 80054e6:	46c0      	nop			; (mov r8, r8)
 80054e8:	46bd      	mov	sp, r7
 80054ea:	b003      	add	sp, #12
 80054ec:	bd90      	pop	{r4, r7, pc}
 80054ee:	46c0      	nop			; (mov r8, r8)
 80054f0:	20002e44 	.word	0x20002e44
 80054f4:	00000335 	.word	0x00000335
 80054f8:	08014cd8 	.word	0x08014cd8
 80054fc:	200031fc 	.word	0x200031fc
 8005500:	08014cdc 	.word	0x08014cdc
 8005504:	08014ce0 	.word	0x08014ce0
 8005508:	200006c4 	.word	0x200006c4
 800550c:	08014ce4 	.word	0x08014ce4
 8005510:	20000004 	.word	0x20000004
 8005514:	2000317c 	.word	0x2000317c

08005518 <MyMotorInit>:

void MyMotorInit(void) {
 8005518:	b580      	push	{r7, lr}
 800551a:	b082      	sub	sp, #8
 800551c:	af00      	add	r7, sp, #0

	uint32_t myFreqPwm;
//----- Init of the Motor control library
	/* Set the STSPIN220 library to use 1 device */
	BSP_MotorControl_SetNbDevices(BSP_MOTOR_CONTROL_BOARD_ID_STSPIN220, 1);
 800551e:	2101      	movs	r1, #1
 8005520:	20dc      	movs	r0, #220	; 0xdc
 8005522:	f009 fecb 	bl	800f2bc <BSP_MotorControl_SetNbDevices>
	/* When BSP_MotorControl_Init is called with NULL pointer,                  */
	/* the STSPIN220 parameters are set with the predefined values from file    */
	/* stspin220_target_config.h, otherwise the parameters are set using the    */
	/* initDeviceParameters structure values.                                   */
	//BSP_MotorControl_Init(BSP_MOTOR_CONTROL_BOARD_ID_STSPIN220, &initDeviceParameters);
	BSP_MotorControl_Init(BSP_MOTOR_CONTROL_BOARD_ID_STSPIN220, NULL);
 8005526:	2100      	movs	r1, #0
 8005528:	20dc      	movs	r0, #220	; 0xdc
 800552a:	f009 fc51 	bl	800edd0 <BSP_MotorControl_Init>
	/* Attach the function MyFlagInterruptHandler (defined below) to the flag interrupt */
	BSP_MotorControl_AttachFlagInterrupt(MyFlagInterruptHandler);
 800552e:	4b14      	ldr	r3, [pc, #80]	; (8005580 <MyMotorInit+0x68>)
 8005530:	0018      	movs	r0, r3
 8005532:	f009 fc0d 	bl	800ed50 <BSP_MotorControl_AttachFlagInterrupt>
	/* Attach the function MyErrorHandler (defined below) to the error Handler*/
	BSP_MotorControl_AttachErrorHandler(MyErrorHandler);
 8005536:	4b13      	ldr	r3, [pc, #76]	; (8005584 <MyMotorInit+0x6c>)
 8005538:	0018      	movs	r0, r3
 800553a:	f009 fbe9 	bl	800ed10 <BSP_MotorControl_AttachErrorHandler>
//----- Configure Button for user interaction
	/* Set Systick Interrupt priority highest to ensure no lock by using HAL_Delay */
	HAL_NVIC_SetPriority(SysTick_IRQn, 0x0, 0x0);
 800553e:	2301      	movs	r3, #1
 8005540:	425b      	negs	r3, r3
 8005542:	2200      	movs	r2, #0
 8005544:	2100      	movs	r1, #0
 8005546:	0018      	movs	r0, r3
 8005548:	f00a f8ce 	bl	800f6e8 <HAL_NVIC_SetPriority>
	/* Get the PWM frequency used for the VREFA and VREFB voltage generation */
	myFreqPwm = BSP_MotorControl_GetBridgeInputPwmFreq(0);
 800554c:	2000      	movs	r0, #0
 800554e:	f009 fe5d 	bl	800f20c <BSP_MotorControl_GetBridgeInputPwmFreq>
 8005552:	0003      	movs	r3, r0
 8005554:	607b      	str	r3, [r7, #4]

	/* Select step mode */
	switch (AJUSTE_REL_PASOS){
	case 1:
		/* Increase acceleration microstep/s^2*/
		BSP_MotorControl_SetAcceleration(MOTOR_ID, 65535);
 8005556:	4b0c      	ldr	r3, [pc, #48]	; (8005588 <MyMotorInit+0x70>)
 8005558:	0019      	movs	r1, r3
 800555a:	2000      	movs	r0, #0
 800555c:	f009 fcfa 	bl	800ef54 <BSP_MotorControl_SetAcceleration>
		/* Increase deceleration microstep/s^2 */
		BSP_MotorControl_SetDeceleration(MOTOR_ID, 65535);
 8005560:	4b09      	ldr	r3, [pc, #36]	; (8005588 <MyMotorInit+0x70>)
 8005562:	0019      	movs	r1, r3
 8005564:	2000      	movs	r0, #0
 8005566:	f009 fd29 	bl	800efbc <BSP_MotorControl_SetDeceleration>
		/* Increase speed microstep/s */
		BSP_MotorControl_SetMaxSpeed(MOTOR_ID, 25000);//25000
 800556a:	4b08      	ldr	r3, [pc, #32]	; (800558c <MyMotorInit+0x74>)
 800556c:	0019      	movs	r1, r3
 800556e:	2000      	movs	r0, #0
 8005570:	f009 fd7e 	bl	800f070 <BSP_MotorControl_SetMaxSpeed>
		break;
 8005574:	46c0      	nop			; (mov r8, r8)
		BSP_MotorControl_SetDeceleration(MOTOR_ID, 65535);
		/* Increase speed microstep/s */
		BSP_MotorControl_SetMaxSpeed(MOTOR_ID, 25000);
		break;
	}
}
 8005576:	46c0      	nop			; (mov r8, r8)
 8005578:	46bd      	mov	sp, r7
 800557a:	b002      	add	sp, #8
 800557c:	bd80      	pop	{r7, pc}
 800557e:	46c0      	nop			; (mov r8, r8)
 8005580:	08005d85 	.word	0x08005d85
 8005584:	08005d95 	.word	0x08005d95
 8005588:	0000ffff 	.word	0x0000ffff
 800558c:	000061a8 	.word	0x000061a8

08005590 <EnableMotors>:

void EnableMotors(uint8_t opc)
{
 8005590:	b580      	push	{r7, lr}
 8005592:	b082      	sub	sp, #8
 8005594:	af00      	add	r7, sp, #0
 8005596:	0002      	movs	r2, r0
 8005598:	1dfb      	adds	r3, r7, #7
 800559a:	701a      	strb	r2, [r3, #0]
	switch(opc)
 800559c:	1dfb      	adds	r3, r7, #7
 800559e:	781b      	ldrb	r3, [r3, #0]
 80055a0:	2b07      	cmp	r3, #7
 80055a2:	d900      	bls.n	80055a6 <EnableMotors+0x16>
 80055a4:	e154      	b.n	8005850 <EnableMotors+0x2c0>
 80055a6:	009a      	lsls	r2, r3, #2
 80055a8:	4bd4      	ldr	r3, [pc, #848]	; (80058fc <EnableMotors+0x36c>)
 80055aa:	18d3      	adds	r3, r2, r3
 80055ac:	681b      	ldr	r3, [r3, #0]
 80055ae:	469f      	mov	pc, r3
	{
		case 1:
			HAL_GPIO_WritePin(DRV_EN_1_GPIO_Port, DRV_EN_1_Pin, GPIO_PIN_SET);
 80055b0:	4bd3      	ldr	r3, [pc, #844]	; (8005900 <EnableMotors+0x370>)
 80055b2:	2201      	movs	r2, #1
 80055b4:	2180      	movs	r1, #128	; 0x80
 80055b6:	0018      	movs	r0, r3
 80055b8:	f00a fbad 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_1_GPIO_Port, DRV_RES_1_Pin, GPIO_PIN_SET);
			HAL_GPIO_WritePin(DRV_EN_2_GPIO_Port, DRV_EN_2_Pin, GPIO_PIN_RESET);
 80055bc:	2380      	movs	r3, #128	; 0x80
 80055be:	00d9      	lsls	r1, r3, #3
 80055c0:	23a0      	movs	r3, #160	; 0xa0
 80055c2:	05db      	lsls	r3, r3, #23
 80055c4:	2200      	movs	r2, #0
 80055c6:	0018      	movs	r0, r3
 80055c8:	f00a fba5 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_2_GPIO_Port, DRV_RES_2_Pin, GPIO_PIN_RESET);
			HAL_GPIO_WritePin(DRV_EN_3_GPIO_Port, DRV_EN_3_Pin, GPIO_PIN_RESET);
 80055cc:	2380      	movs	r3, #128	; 0x80
 80055ce:	019b      	lsls	r3, r3, #6
 80055d0:	48cb      	ldr	r0, [pc, #812]	; (8005900 <EnableMotors+0x370>)
 80055d2:	2200      	movs	r2, #0
 80055d4:	0019      	movs	r1, r3
 80055d6:	f00a fb9e 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_3_GPIO_Port, DRV_RES_3_Pin, GPIO_PIN_RESET);
			HAL_GPIO_WritePin(DRV_EN_4_GPIO_Port, DRV_EN_4_Pin, GPIO_PIN_RESET);
 80055da:	4bc9      	ldr	r3, [pc, #804]	; (8005900 <EnableMotors+0x370>)
 80055dc:	2200      	movs	r2, #0
 80055de:	2101      	movs	r1, #1
 80055e0:	0018      	movs	r0, r3
 80055e2:	f00a fb98 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_4_GPIO_Port, DRV_RES_4_Pin, GPIO_PIN_RESET);
			HAL_GPIO_WritePin(DRV_EN_5_GPIO_Port, DRV_EN_5_Pin, GPIO_PIN_RESET);
 80055e6:	23a0      	movs	r3, #160	; 0xa0
 80055e8:	05db      	lsls	r3, r3, #23
 80055ea:	2200      	movs	r2, #0
 80055ec:	2110      	movs	r1, #16
 80055ee:	0018      	movs	r0, r3
 80055f0:	f00a fb91 	bl	800fd16 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(DRV_RES_5_GPIO_Port, DRV_RES_5_Pin, GPIO_PIN_RESET);
 80055f4:	23a0      	movs	r3, #160	; 0xa0
 80055f6:	05db      	lsls	r3, r3, #23
 80055f8:	2200      	movs	r2, #0
 80055fa:	2102      	movs	r1, #2
 80055fc:	0018      	movs	r0, r3
 80055fe:	f00a fb8a 	bl	800fd16 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(DRV_EN_6_GPIO_Port, DRV_EN_6_Pin, GPIO_PIN_RESET);
 8005602:	4bc0      	ldr	r3, [pc, #768]	; (8005904 <EnableMotors+0x374>)
 8005604:	2200      	movs	r2, #0
 8005606:	2101      	movs	r1, #1
 8005608:	0018      	movs	r0, r3
 800560a:	f00a fb84 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_6_GPIO_Port, DRV_RES_6_Pin, GPIO_PIN_RESET);
			break;
 800560e:	e170      	b.n	80058f2 <EnableMotors+0x362>
		case 2:
			HAL_GPIO_WritePin(DRV_EN_1_GPIO_Port, DRV_EN_1_Pin, GPIO_PIN_RESET);
 8005610:	4bbb      	ldr	r3, [pc, #748]	; (8005900 <EnableMotors+0x370>)
 8005612:	2200      	movs	r2, #0
 8005614:	2180      	movs	r1, #128	; 0x80
 8005616:	0018      	movs	r0, r3
 8005618:	f00a fb7d 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_1_GPIO_Port, DRV_RES_1_Pin, GPIO_PIN_RESET);
			HAL_GPIO_WritePin(DRV_EN_2_GPIO_Port, DRV_EN_2_Pin, GPIO_PIN_SET);
 800561c:	2380      	movs	r3, #128	; 0x80
 800561e:	00d9      	lsls	r1, r3, #3
 8005620:	23a0      	movs	r3, #160	; 0xa0
 8005622:	05db      	lsls	r3, r3, #23
 8005624:	2201      	movs	r2, #1
 8005626:	0018      	movs	r0, r3
 8005628:	f00a fb75 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_2_GPIO_Port, DRV_RES_2_Pin, GPIO_PIN_SET);
			HAL_GPIO_WritePin(DRV_EN_3_GPIO_Port, DRV_EN_3_Pin, GPIO_PIN_RESET);
 800562c:	2380      	movs	r3, #128	; 0x80
 800562e:	019b      	lsls	r3, r3, #6
 8005630:	48b3      	ldr	r0, [pc, #716]	; (8005900 <EnableMotors+0x370>)
 8005632:	2200      	movs	r2, #0
 8005634:	0019      	movs	r1, r3
 8005636:	f00a fb6e 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_3_GPIO_Port, DRV_RES_3_Pin, GPIO_PIN_RESET);
			HAL_GPIO_WritePin(DRV_EN_4_GPIO_Port, DRV_EN_4_Pin, GPIO_PIN_RESET);
 800563a:	4bb1      	ldr	r3, [pc, #708]	; (8005900 <EnableMotors+0x370>)
 800563c:	2200      	movs	r2, #0
 800563e:	2101      	movs	r1, #1
 8005640:	0018      	movs	r0, r3
 8005642:	f00a fb68 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_4_GPIO_Port, DRV_RES_4_Pin, GPIO_PIN_RESET);
			HAL_GPIO_WritePin(DRV_EN_5_GPIO_Port, DRV_EN_5_Pin, GPIO_PIN_RESET);
 8005646:	23a0      	movs	r3, #160	; 0xa0
 8005648:	05db      	lsls	r3, r3, #23
 800564a:	2200      	movs	r2, #0
 800564c:	2110      	movs	r1, #16
 800564e:	0018      	movs	r0, r3
 8005650:	f00a fb61 	bl	800fd16 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(DRV_RES_5_GPIO_Port, DRV_RES_5_Pin, GPIO_PIN_RESET);
 8005654:	23a0      	movs	r3, #160	; 0xa0
 8005656:	05db      	lsls	r3, r3, #23
 8005658:	2200      	movs	r2, #0
 800565a:	2102      	movs	r1, #2
 800565c:	0018      	movs	r0, r3
 800565e:	f00a fb5a 	bl	800fd16 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(DRV_EN_6_GPIO_Port, DRV_EN_6_Pin, GPIO_PIN_RESET);
 8005662:	4ba8      	ldr	r3, [pc, #672]	; (8005904 <EnableMotors+0x374>)
 8005664:	2200      	movs	r2, #0
 8005666:	2101      	movs	r1, #1
 8005668:	0018      	movs	r0, r3
 800566a:	f00a fb54 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_6_GPIO_Port, DRV_RES_6_Pin, GPIO_PIN_RESET);
			break;
 800566e:	e140      	b.n	80058f2 <EnableMotors+0x362>
		case 3:
			HAL_GPIO_WritePin(DRV_EN_1_GPIO_Port, DRV_EN_1_Pin, GPIO_PIN_RESET);
 8005670:	4ba3      	ldr	r3, [pc, #652]	; (8005900 <EnableMotors+0x370>)
 8005672:	2200      	movs	r2, #0
 8005674:	2180      	movs	r1, #128	; 0x80
 8005676:	0018      	movs	r0, r3
 8005678:	f00a fb4d 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_1_GPIO_Port, DRV_RES_1_Pin, GPIO_PIN_RESET);
			HAL_GPIO_WritePin(DRV_EN_2_GPIO_Port, DRV_EN_2_Pin, GPIO_PIN_RESET);
 800567c:	2380      	movs	r3, #128	; 0x80
 800567e:	00d9      	lsls	r1, r3, #3
 8005680:	23a0      	movs	r3, #160	; 0xa0
 8005682:	05db      	lsls	r3, r3, #23
 8005684:	2200      	movs	r2, #0
 8005686:	0018      	movs	r0, r3
 8005688:	f00a fb45 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_2_GPIO_Port, DRV_RES_2_Pin, GPIO_PIN_RESET);
			HAL_GPIO_WritePin(DRV_EN_3_GPIO_Port, DRV_EN_3_Pin, GPIO_PIN_SET);
 800568c:	2380      	movs	r3, #128	; 0x80
 800568e:	019b      	lsls	r3, r3, #6
 8005690:	489b      	ldr	r0, [pc, #620]	; (8005900 <EnableMotors+0x370>)
 8005692:	2201      	movs	r2, #1
 8005694:	0019      	movs	r1, r3
 8005696:	f00a fb3e 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_3_GPIO_Port, DRV_RES_3_Pin, GPIO_PIN_SET);
			HAL_GPIO_WritePin(DRV_EN_4_GPIO_Port, DRV_EN_4_Pin, GPIO_PIN_RESET);
 800569a:	4b99      	ldr	r3, [pc, #612]	; (8005900 <EnableMotors+0x370>)
 800569c:	2200      	movs	r2, #0
 800569e:	2101      	movs	r1, #1
 80056a0:	0018      	movs	r0, r3
 80056a2:	f00a fb38 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_4_GPIO_Port, DRV_RES_4_Pin, GPIO_PIN_RESET);
			HAL_GPIO_WritePin(DRV_EN_5_GPIO_Port, DRV_EN_5_Pin, GPIO_PIN_RESET);
 80056a6:	23a0      	movs	r3, #160	; 0xa0
 80056a8:	05db      	lsls	r3, r3, #23
 80056aa:	2200      	movs	r2, #0
 80056ac:	2110      	movs	r1, #16
 80056ae:	0018      	movs	r0, r3
 80056b0:	f00a fb31 	bl	800fd16 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(DRV_RES_5_GPIO_Port, DRV_RES_5_Pin, GPIO_PIN_RESET);
 80056b4:	23a0      	movs	r3, #160	; 0xa0
 80056b6:	05db      	lsls	r3, r3, #23
 80056b8:	2200      	movs	r2, #0
 80056ba:	2102      	movs	r1, #2
 80056bc:	0018      	movs	r0, r3
 80056be:	f00a fb2a 	bl	800fd16 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(DRV_EN_6_GPIO_Port, DRV_EN_6_Pin, GPIO_PIN_RESET);
 80056c2:	4b90      	ldr	r3, [pc, #576]	; (8005904 <EnableMotors+0x374>)
 80056c4:	2200      	movs	r2, #0
 80056c6:	2101      	movs	r1, #1
 80056c8:	0018      	movs	r0, r3
 80056ca:	f00a fb24 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_6_GPIO_Port, DRV_RES_6_Pin, GPIO_PIN_RESET);
			break;
 80056ce:	e110      	b.n	80058f2 <EnableMotors+0x362>
		case 4:
			HAL_GPIO_WritePin(DRV_EN_1_GPIO_Port, DRV_EN_1_Pin, GPIO_PIN_RESET);
 80056d0:	4b8b      	ldr	r3, [pc, #556]	; (8005900 <EnableMotors+0x370>)
 80056d2:	2200      	movs	r2, #0
 80056d4:	2180      	movs	r1, #128	; 0x80
 80056d6:	0018      	movs	r0, r3
 80056d8:	f00a fb1d 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_1_GPIO_Port, DRV_RES_1_Pin, GPIO_PIN_RESET);
			HAL_GPIO_WritePin(DRV_EN_2_GPIO_Port, DRV_EN_2_Pin, GPIO_PIN_RESET);
 80056dc:	2380      	movs	r3, #128	; 0x80
 80056de:	00d9      	lsls	r1, r3, #3
 80056e0:	23a0      	movs	r3, #160	; 0xa0
 80056e2:	05db      	lsls	r3, r3, #23
 80056e4:	2200      	movs	r2, #0
 80056e6:	0018      	movs	r0, r3
 80056e8:	f00a fb15 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_2_GPIO_Port, DRV_RES_2_Pin, GPIO_PIN_RESET);
			HAL_GPIO_WritePin(DRV_EN_3_GPIO_Port, DRV_EN_3_Pin, GPIO_PIN_RESET);
 80056ec:	2380      	movs	r3, #128	; 0x80
 80056ee:	019b      	lsls	r3, r3, #6
 80056f0:	4883      	ldr	r0, [pc, #524]	; (8005900 <EnableMotors+0x370>)
 80056f2:	2200      	movs	r2, #0
 80056f4:	0019      	movs	r1, r3
 80056f6:	f00a fb0e 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_3_GPIO_Port, DRV_RES_3_Pin, GPIO_PIN_RESET);
			HAL_GPIO_WritePin(DRV_EN_4_GPIO_Port, DRV_EN_4_Pin, GPIO_PIN_SET);
 80056fa:	4b81      	ldr	r3, [pc, #516]	; (8005900 <EnableMotors+0x370>)
 80056fc:	2201      	movs	r2, #1
 80056fe:	2101      	movs	r1, #1
 8005700:	0018      	movs	r0, r3
 8005702:	f00a fb08 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_4_GPIO_Port, DRV_RES_4_Pin, GPIO_PIN_SET);
			HAL_GPIO_WritePin(DRV_EN_5_GPIO_Port, DRV_EN_5_Pin, GPIO_PIN_RESET);
 8005706:	23a0      	movs	r3, #160	; 0xa0
 8005708:	05db      	lsls	r3, r3, #23
 800570a:	2200      	movs	r2, #0
 800570c:	2110      	movs	r1, #16
 800570e:	0018      	movs	r0, r3
 8005710:	f00a fb01 	bl	800fd16 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(DRV_RES_5_GPIO_Port, DRV_RES_5_Pin, GPIO_PIN_RESET);
 8005714:	23a0      	movs	r3, #160	; 0xa0
 8005716:	05db      	lsls	r3, r3, #23
 8005718:	2200      	movs	r2, #0
 800571a:	2102      	movs	r1, #2
 800571c:	0018      	movs	r0, r3
 800571e:	f00a fafa 	bl	800fd16 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(DRV_EN_6_GPIO_Port, DRV_EN_6_Pin, GPIO_PIN_RESET);
 8005722:	4b78      	ldr	r3, [pc, #480]	; (8005904 <EnableMotors+0x374>)
 8005724:	2200      	movs	r2, #0
 8005726:	2101      	movs	r1, #1
 8005728:	0018      	movs	r0, r3
 800572a:	f00a faf4 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_6_GPIO_Port, DRV_RES_6_Pin, GPIO_PIN_RESET);
			break;
 800572e:	e0e0      	b.n	80058f2 <EnableMotors+0x362>
		case 5:
			HAL_GPIO_WritePin(DRV_EN_1_GPIO_Port, DRV_EN_1_Pin, GPIO_PIN_RESET);
 8005730:	4b73      	ldr	r3, [pc, #460]	; (8005900 <EnableMotors+0x370>)
 8005732:	2200      	movs	r2, #0
 8005734:	2180      	movs	r1, #128	; 0x80
 8005736:	0018      	movs	r0, r3
 8005738:	f00a faed 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_1_GPIO_Port, DRV_RES_1_Pin, GPIO_PIN_RESET);
			HAL_GPIO_WritePin(DRV_EN_2_GPIO_Port, DRV_EN_2_Pin, GPIO_PIN_RESET);
 800573c:	2380      	movs	r3, #128	; 0x80
 800573e:	00d9      	lsls	r1, r3, #3
 8005740:	23a0      	movs	r3, #160	; 0xa0
 8005742:	05db      	lsls	r3, r3, #23
 8005744:	2200      	movs	r2, #0
 8005746:	0018      	movs	r0, r3
 8005748:	f00a fae5 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_2_GPIO_Port, DRV_RES_2_Pin, GPIO_PIN_RESET);
			HAL_GPIO_WritePin(DRV_EN_3_GPIO_Port, DRV_EN_3_Pin, GPIO_PIN_RESET);
 800574c:	2380      	movs	r3, #128	; 0x80
 800574e:	019b      	lsls	r3, r3, #6
 8005750:	486b      	ldr	r0, [pc, #428]	; (8005900 <EnableMotors+0x370>)
 8005752:	2200      	movs	r2, #0
 8005754:	0019      	movs	r1, r3
 8005756:	f00a fade 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_3_GPIO_Port, DRV_RES_3_Pin, GPIO_PIN_RESET);
			HAL_GPIO_WritePin(DRV_EN_4_GPIO_Port, DRV_EN_4_Pin, GPIO_PIN_RESET);
 800575a:	4b69      	ldr	r3, [pc, #420]	; (8005900 <EnableMotors+0x370>)
 800575c:	2200      	movs	r2, #0
 800575e:	2101      	movs	r1, #1
 8005760:	0018      	movs	r0, r3
 8005762:	f00a fad8 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_4_GPIO_Port, DRV_RES_4_Pin, GPIO_PIN_RESET);
			HAL_GPIO_WritePin(DRV_EN_5_GPIO_Port, DRV_EN_5_Pin, GPIO_PIN_SET);
 8005766:	23a0      	movs	r3, #160	; 0xa0
 8005768:	05db      	lsls	r3, r3, #23
 800576a:	2201      	movs	r2, #1
 800576c:	2110      	movs	r1, #16
 800576e:	0018      	movs	r0, r3
 8005770:	f00a fad1 	bl	800fd16 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(DRV_RES_5_GPIO_Port, DRV_RES_5_Pin, GPIO_PIN_SET);
 8005774:	23a0      	movs	r3, #160	; 0xa0
 8005776:	05db      	lsls	r3, r3, #23
 8005778:	2201      	movs	r2, #1
 800577a:	2102      	movs	r1, #2
 800577c:	0018      	movs	r0, r3
 800577e:	f00a faca 	bl	800fd16 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(DRV_EN_6_GPIO_Port, DRV_EN_6_Pin, GPIO_PIN_RESET);
 8005782:	4b60      	ldr	r3, [pc, #384]	; (8005904 <EnableMotors+0x374>)
 8005784:	2200      	movs	r2, #0
 8005786:	2101      	movs	r1, #1
 8005788:	0018      	movs	r0, r3
 800578a:	f00a fac4 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_6_GPIO_Port, DRV_RES_6_Pin, GPIO_PIN_RESET);
			break;
 800578e:	e0b0      	b.n	80058f2 <EnableMotors+0x362>
		case 6:
			HAL_GPIO_WritePin(DRV_EN_1_GPIO_Port, DRV_EN_1_Pin, GPIO_PIN_RESET);
 8005790:	4b5b      	ldr	r3, [pc, #364]	; (8005900 <EnableMotors+0x370>)
 8005792:	2200      	movs	r2, #0
 8005794:	2180      	movs	r1, #128	; 0x80
 8005796:	0018      	movs	r0, r3
 8005798:	f00a fabd 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_1_GPIO_Port, DRV_RES_1_Pin, GPIO_PIN_RESET);
			HAL_GPIO_WritePin(DRV_EN_2_GPIO_Port, DRV_EN_2_Pin, GPIO_PIN_RESET);
 800579c:	2380      	movs	r3, #128	; 0x80
 800579e:	00d9      	lsls	r1, r3, #3
 80057a0:	23a0      	movs	r3, #160	; 0xa0
 80057a2:	05db      	lsls	r3, r3, #23
 80057a4:	2200      	movs	r2, #0
 80057a6:	0018      	movs	r0, r3
 80057a8:	f00a fab5 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_2_GPIO_Port, DRV_RES_2_Pin, GPIO_PIN_RESET);
			HAL_GPIO_WritePin(DRV_EN_3_GPIO_Port, DRV_EN_3_Pin, GPIO_PIN_RESET);
 80057ac:	2380      	movs	r3, #128	; 0x80
 80057ae:	019b      	lsls	r3, r3, #6
 80057b0:	4853      	ldr	r0, [pc, #332]	; (8005900 <EnableMotors+0x370>)
 80057b2:	2200      	movs	r2, #0
 80057b4:	0019      	movs	r1, r3
 80057b6:	f00a faae 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_3_GPIO_Port, DRV_RES_3_Pin, GPIO_PIN_RESET);
			HAL_GPIO_WritePin(DRV_EN_4_GPIO_Port, DRV_EN_4_Pin, GPIO_PIN_RESET);
 80057ba:	4b51      	ldr	r3, [pc, #324]	; (8005900 <EnableMotors+0x370>)
 80057bc:	2200      	movs	r2, #0
 80057be:	2101      	movs	r1, #1
 80057c0:	0018      	movs	r0, r3
 80057c2:	f00a faa8 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_4_GPIO_Port, DRV_RES_4_Pin, GPIO_PIN_RESET);
			HAL_GPIO_WritePin(DRV_EN_5_GPIO_Port, DRV_EN_5_Pin, GPIO_PIN_RESET);
 80057c6:	23a0      	movs	r3, #160	; 0xa0
 80057c8:	05db      	lsls	r3, r3, #23
 80057ca:	2200      	movs	r2, #0
 80057cc:	2110      	movs	r1, #16
 80057ce:	0018      	movs	r0, r3
 80057d0:	f00a faa1 	bl	800fd16 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(DRV_RES_5_GPIO_Port, DRV_RES_5_Pin, GPIO_PIN_RESET);
 80057d4:	23a0      	movs	r3, #160	; 0xa0
 80057d6:	05db      	lsls	r3, r3, #23
 80057d8:	2200      	movs	r2, #0
 80057da:	2102      	movs	r1, #2
 80057dc:	0018      	movs	r0, r3
 80057de:	f00a fa9a 	bl	800fd16 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(DRV_EN_6_GPIO_Port, DRV_EN_6_Pin, GPIO_PIN_SET);
 80057e2:	4b48      	ldr	r3, [pc, #288]	; (8005904 <EnableMotors+0x374>)
 80057e4:	2201      	movs	r2, #1
 80057e6:	2101      	movs	r1, #1
 80057e8:	0018      	movs	r0, r3
 80057ea:	f00a fa94 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_6_GPIO_Port, DRV_RES_6_Pin, GPIO_PIN_SET);
			break;
 80057ee:	e080      	b.n	80058f2 <EnableMotors+0x362>
		case 7:
			HAL_GPIO_WritePin(DRV_EN_1_GPIO_Port, DRV_EN_1_Pin, GPIO_PIN_SET);
 80057f0:	4b43      	ldr	r3, [pc, #268]	; (8005900 <EnableMotors+0x370>)
 80057f2:	2201      	movs	r2, #1
 80057f4:	2180      	movs	r1, #128	; 0x80
 80057f6:	0018      	movs	r0, r3
 80057f8:	f00a fa8d 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_1_GPIO_Port, DRV_RES_1_Pin, GPIO_PIN_SET);
			HAL_GPIO_WritePin(DRV_EN_2_GPIO_Port, DRV_EN_2_Pin, GPIO_PIN_SET);
 80057fc:	2380      	movs	r3, #128	; 0x80
 80057fe:	00d9      	lsls	r1, r3, #3
 8005800:	23a0      	movs	r3, #160	; 0xa0
 8005802:	05db      	lsls	r3, r3, #23
 8005804:	2201      	movs	r2, #1
 8005806:	0018      	movs	r0, r3
 8005808:	f00a fa85 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_2_GPIO_Port, DRV_RES_2_Pin, GPIO_PIN_SET);
			HAL_GPIO_WritePin(DRV_EN_3_GPIO_Port, DRV_EN_3_Pin, GPIO_PIN_SET);
 800580c:	2380      	movs	r3, #128	; 0x80
 800580e:	019b      	lsls	r3, r3, #6
 8005810:	483b      	ldr	r0, [pc, #236]	; (8005900 <EnableMotors+0x370>)
 8005812:	2201      	movs	r2, #1
 8005814:	0019      	movs	r1, r3
 8005816:	f00a fa7e 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_3_GPIO_Port, DRV_RES_3_Pin, GPIO_PIN_SET);
			HAL_GPIO_WritePin(DRV_EN_4_GPIO_Port, DRV_EN_4_Pin, GPIO_PIN_SET);
 800581a:	4b39      	ldr	r3, [pc, #228]	; (8005900 <EnableMotors+0x370>)
 800581c:	2201      	movs	r2, #1
 800581e:	2101      	movs	r1, #1
 8005820:	0018      	movs	r0, r3
 8005822:	f00a fa78 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_4_GPIO_Port, DRV_RES_4_Pin, GPIO_PIN_SET);
			HAL_GPIO_WritePin(DRV_EN_5_GPIO_Port, DRV_EN_5_Pin, GPIO_PIN_SET);
 8005826:	23a0      	movs	r3, #160	; 0xa0
 8005828:	05db      	lsls	r3, r3, #23
 800582a:	2201      	movs	r2, #1
 800582c:	2110      	movs	r1, #16
 800582e:	0018      	movs	r0, r3
 8005830:	f00a fa71 	bl	800fd16 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(DRV_RES_5_GPIO_Port, DRV_RES_5_Pin, GPIO_PIN_SET);
 8005834:	23a0      	movs	r3, #160	; 0xa0
 8005836:	05db      	lsls	r3, r3, #23
 8005838:	2201      	movs	r2, #1
 800583a:	2102      	movs	r1, #2
 800583c:	0018      	movs	r0, r3
 800583e:	f00a fa6a 	bl	800fd16 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(DRV_EN_6_GPIO_Port, DRV_EN_6_Pin, GPIO_PIN_SET);
 8005842:	4b30      	ldr	r3, [pc, #192]	; (8005904 <EnableMotors+0x374>)
 8005844:	2201      	movs	r2, #1
 8005846:	2101      	movs	r1, #1
 8005848:	0018      	movs	r0, r3
 800584a:	f00a fa64 	bl	800fd16 <HAL_GPIO_WritePin>
//			HAL_GPIO_WritePin(DRV_RES_6_GPIO_Port, DRV_RES_6_Pin, GPIO_PIN_SET);
			break;
 800584e:	e050      	b.n	80058f2 <EnableMotors+0x362>
		default:
			HAL_GPIO_WritePin(DRV_EN_1_GPIO_Port, DRV_EN_1_Pin, GPIO_PIN_RESET);
 8005850:	4b2b      	ldr	r3, [pc, #172]	; (8005900 <EnableMotors+0x370>)
 8005852:	2200      	movs	r2, #0
 8005854:	2180      	movs	r1, #128	; 0x80
 8005856:	0018      	movs	r0, r3
 8005858:	f00a fa5d 	bl	800fd16 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(DRV_RES_1_GPIO_Port, DRV_RES_1_Pin, GPIO_PIN_RESET);
 800585c:	4b28      	ldr	r3, [pc, #160]	; (8005900 <EnableMotors+0x370>)
 800585e:	2200      	movs	r2, #0
 8005860:	2120      	movs	r1, #32
 8005862:	0018      	movs	r0, r3
 8005864:	f00a fa57 	bl	800fd16 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(DRV_EN_2_GPIO_Port, DRV_EN_2_Pin, GPIO_PIN_RESET);
 8005868:	2380      	movs	r3, #128	; 0x80
 800586a:	00d9      	lsls	r1, r3, #3
 800586c:	23a0      	movs	r3, #160	; 0xa0
 800586e:	05db      	lsls	r3, r3, #23
 8005870:	2200      	movs	r2, #0
 8005872:	0018      	movs	r0, r3
 8005874:	f00a fa4f 	bl	800fd16 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(DRV_RES_2_GPIO_Port, DRV_RES_2_Pin, GPIO_PIN_RESET);
 8005878:	2380      	movs	r3, #128	; 0x80
 800587a:	0099      	lsls	r1, r3, #2
 800587c:	23a0      	movs	r3, #160	; 0xa0
 800587e:	05db      	lsls	r3, r3, #23
 8005880:	2200      	movs	r2, #0
 8005882:	0018      	movs	r0, r3
 8005884:	f00a fa47 	bl	800fd16 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(DRV_EN_3_GPIO_Port, DRV_EN_3_Pin, GPIO_PIN_RESET);
 8005888:	2380      	movs	r3, #128	; 0x80
 800588a:	019b      	lsls	r3, r3, #6
 800588c:	481c      	ldr	r0, [pc, #112]	; (8005900 <EnableMotors+0x370>)
 800588e:	2200      	movs	r2, #0
 8005890:	0019      	movs	r1, r3
 8005892:	f00a fa40 	bl	800fd16 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(DRV_RES_3_GPIO_Port, DRV_RES_3_Pin, GPIO_PIN_RESET);
 8005896:	2380      	movs	r3, #128	; 0x80
 8005898:	015b      	lsls	r3, r3, #5
 800589a:	4819      	ldr	r0, [pc, #100]	; (8005900 <EnableMotors+0x370>)
 800589c:	2200      	movs	r2, #0
 800589e:	0019      	movs	r1, r3
 80058a0:	f00a fa39 	bl	800fd16 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(DRV_EN_4_GPIO_Port, DRV_EN_4_Pin, GPIO_PIN_RESET);
 80058a4:	4b16      	ldr	r3, [pc, #88]	; (8005900 <EnableMotors+0x370>)
 80058a6:	2200      	movs	r2, #0
 80058a8:	2101      	movs	r1, #1
 80058aa:	0018      	movs	r0, r3
 80058ac:	f00a fa33 	bl	800fd16 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(DRV_RES_4_GPIO_Port, DRV_RES_4_Pin, GPIO_PIN_RESET);
 80058b0:	4b14      	ldr	r3, [pc, #80]	; (8005904 <EnableMotors+0x374>)
 80058b2:	2200      	movs	r2, #0
 80058b4:	2120      	movs	r1, #32
 80058b6:	0018      	movs	r0, r3
 80058b8:	f00a fa2d 	bl	800fd16 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(DRV_EN_5_GPIO_Port, DRV_EN_5_Pin, GPIO_PIN_RESET);
 80058bc:	23a0      	movs	r3, #160	; 0xa0
 80058be:	05db      	lsls	r3, r3, #23
 80058c0:	2200      	movs	r2, #0
 80058c2:	2110      	movs	r1, #16
 80058c4:	0018      	movs	r0, r3
 80058c6:	f00a fa26 	bl	800fd16 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(DRV_RES_5_GPIO_Port, DRV_RES_5_Pin, GPIO_PIN_RESET);
 80058ca:	23a0      	movs	r3, #160	; 0xa0
 80058cc:	05db      	lsls	r3, r3, #23
 80058ce:	2200      	movs	r2, #0
 80058d0:	2102      	movs	r1, #2
 80058d2:	0018      	movs	r0, r3
 80058d4:	f00a fa1f 	bl	800fd16 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(DRV_EN_6_GPIO_Port, DRV_EN_6_Pin, GPIO_PIN_RESET);
 80058d8:	4b0a      	ldr	r3, [pc, #40]	; (8005904 <EnableMotors+0x374>)
 80058da:	2200      	movs	r2, #0
 80058dc:	2101      	movs	r1, #1
 80058de:	0018      	movs	r0, r3
 80058e0:	f00a fa19 	bl	800fd16 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(DRV_RES_6_GPIO_Port, DRV_RES_6_Pin, GPIO_PIN_RESET);
 80058e4:	4b08      	ldr	r3, [pc, #32]	; (8005908 <EnableMotors+0x378>)
 80058e6:	2200      	movs	r2, #0
 80058e8:	2102      	movs	r1, #2
 80058ea:	0018      	movs	r0, r3
 80058ec:	f00a fa13 	bl	800fd16 <HAL_GPIO_WritePin>
			break;
 80058f0:	46c0      	nop			; (mov r8, r8)
	}
}
 80058f2:	46c0      	nop			; (mov r8, r8)
 80058f4:	46bd      	mov	sp, r7
 80058f6:	b002      	add	sp, #8
 80058f8:	bd80      	pop	{r7, pc}
 80058fa:	46c0      	nop			; (mov r8, r8)
 80058fc:	08014e98 	.word	0x08014e98
 8005900:	50000400 	.word	0x50000400
 8005904:	50000800 	.word	0x50000800
 8005908:	50001c00 	.word	0x50001c00

0800590c <calib_motor>:


void calib_motor(void) {
 800590c:	b580      	push	{r7, lr}
 800590e:	b082      	sub	sp, #8
 8005910:	af00      	add	r7, sp, #0
	int32_t pos;

	EnableMotors(1);
 8005912:	2001      	movs	r0, #1
 8005914:	f7ff fe3c 	bl	8005590 <EnableMotors>
	//-----Set Home position according FCA
	if (HAL_GPIO_ReadPin(DRV_FCA_1_GPIO_Port, DRV_FCA_1_Pin) == GPIO_PIN_SET) {
 8005918:	2380      	movs	r3, #128	; 0x80
 800591a:	021a      	lsls	r2, r3, #8
 800591c:	23a0      	movs	r3, #160	; 0xa0
 800591e:	05db      	lsls	r3, r3, #23
 8005920:	0011      	movs	r1, r2
 8005922:	0018      	movs	r0, r3
 8005924:	f00a f9da 	bl	800fcdc <HAL_GPIO_ReadPin>
 8005928:	0003      	movs	r3, r0
 800592a:	2b01      	cmp	r3, #1
 800592c:	d114      	bne.n	8005958 <calib_motor+0x4c>
		//-----Move device BACKWARD till get far from FC1
		do {
			BSP_MotorControl_Run(MOTOR_ID, BACKWARD);
 800592e:	2100      	movs	r1, #0
 8005930:	2000      	movs	r0, #0
 8005932:	f009 fae7 	bl	800ef04 <BSP_MotorControl_Run>
			HAL_Delay(T_FC);
 8005936:	20c8      	movs	r0, #200	; 0xc8
 8005938:	f009 fddc 	bl	800f4f4 <HAL_Delay>
		} while (HAL_GPIO_ReadPin(DRV_FCA_1_GPIO_Port, DRV_FCA_1_Pin) == GPIO_PIN_SET);
 800593c:	2380      	movs	r3, #128	; 0x80
 800593e:	021a      	lsls	r2, r3, #8
 8005940:	23a0      	movs	r3, #160	; 0xa0
 8005942:	05db      	lsls	r3, r3, #23
 8005944:	0011      	movs	r1, r2
 8005946:	0018      	movs	r0, r3
 8005948:	f00a f9c8 	bl	800fcdc <HAL_GPIO_ReadPin>
 800594c:	0003      	movs	r3, r0
 800594e:	2b01      	cmp	r3, #1
 8005950:	d0ed      	beq.n	800592e <calib_motor+0x22>

		stopMotor();
 8005952:	f000 fa03 	bl	8005d5c <stopMotor>
 8005956:	e022      	b.n	800599e <calib_motor+0x92>

	} else {
		//-----Move device FORWARD till get to FC1
		do {
			BSP_MotorControl_Run(MOTOR_ID, FORWARD);
 8005958:	2101      	movs	r1, #1
 800595a:	2000      	movs	r0, #0
 800595c:	f009 fad2 	bl	800ef04 <BSP_MotorControl_Run>
			HAL_Delay(T_FC);
 8005960:	20c8      	movs	r0, #200	; 0xc8
 8005962:	f009 fdc7 	bl	800f4f4 <HAL_Delay>
		} while (HAL_GPIO_ReadPin(DRV_FCA_1_GPIO_Port, DRV_FCA_1_Pin)== GPIO_PIN_RESET);
 8005966:	2380      	movs	r3, #128	; 0x80
 8005968:	021a      	lsls	r2, r3, #8
 800596a:	23a0      	movs	r3, #160	; 0xa0
 800596c:	05db      	lsls	r3, r3, #23
 800596e:	0011      	movs	r1, r2
 8005970:	0018      	movs	r0, r3
 8005972:	f00a f9b3 	bl	800fcdc <HAL_GPIO_ReadPin>
 8005976:	1e03      	subs	r3, r0, #0
 8005978:	d0ee      	beq.n	8005958 <calib_motor+0x4c>

		//-----Move device BACKWARD till get far from FC1
		do {
			BSP_MotorControl_Run(MOTOR_ID, BACKWARD);
 800597a:	2100      	movs	r1, #0
 800597c:	2000      	movs	r0, #0
 800597e:	f009 fac1 	bl	800ef04 <BSP_MotorControl_Run>
			HAL_Delay(T_FC);
 8005982:	20c8      	movs	r0, #200	; 0xc8
 8005984:	f009 fdb6 	bl	800f4f4 <HAL_Delay>
		} while (HAL_GPIO_ReadPin(DRV_FCA_1_GPIO_Port, DRV_FCA_1_Pin) == GPIO_PIN_SET);
 8005988:	2380      	movs	r3, #128	; 0x80
 800598a:	021a      	lsls	r2, r3, #8
 800598c:	23a0      	movs	r3, #160	; 0xa0
 800598e:	05db      	lsls	r3, r3, #23
 8005990:	0011      	movs	r1, r2
 8005992:	0018      	movs	r0, r3
 8005994:	f00a f9a2 	bl	800fcdc <HAL_GPIO_ReadPin>
 8005998:	0003      	movs	r3, r0
 800599a:	2b01      	cmp	r3, #1
 800599c:	d0ed      	beq.n	800597a <calib_motor+0x6e>
	}
	if(AJUSTE_INICIAL>=0) {
		BSP_MotorControl_Move(MOTOR_ID, BACKWARD, STEP_1MM *AJUSTE_INICIAL);
	}else {
		BSP_MotorControl_Move(MOTOR_ID, FORWARD, STEP_1MM *-AJUSTE_INICIAL);
 800599e:	4b13      	ldr	r3, [pc, #76]	; (80059ec <calib_motor+0xe0>)
 80059a0:	001a      	movs	r2, r3
 80059a2:	2101      	movs	r1, #1
 80059a4:	2000      	movs	r0, #0
 80059a6:	f009 fa83 	bl	800eeb0 <BSP_MotorControl_Move>
	}
	BSP_MotorControl_WaitWhileActive(MOTOR_ID);
 80059aa:	2000      	movs	r0, #0
 80059ac:	f009 fbe6 	bl	800f17c <BSP_MotorControl_WaitWhileActive>
	if(AJUSTE_INICIAL_M1>=0) {
		BSP_MotorControl_Move(MOTOR_ID, BACKWARD, STEP_1MM *AJUSTE_INICIAL_M1);
 80059b0:	2200      	movs	r2, #0
 80059b2:	2100      	movs	r1, #0
 80059b4:	2000      	movs	r0, #0
 80059b6:	f009 fa7b 	bl	800eeb0 <BSP_MotorControl_Move>
	}else {
		BSP_MotorControl_Move(MOTOR_ID, FORWARD, STEP_1MM *-AJUSTE_INICIAL_M1);
	}
	BSP_MotorControl_WaitWhileActive(MOTOR_ID);
 80059ba:	2000      	movs	r0, #0
 80059bc:	f009 fbde 	bl	800f17c <BSP_MotorControl_WaitWhileActive>
	stopMotor();
 80059c0:	f000 f9cc 	bl	8005d5c <stopMotor>
	/* Get current position */
	pos = BSP_MotorControl_GetPosition(MOTOR_ID);
 80059c4:	2000      	movs	r0, #0
 80059c6:	f009 fa25 	bl	800ee14 <BSP_MotorControl_GetPosition>
 80059ca:	0003      	movs	r3, r0
 80059cc:	607b      	str	r3, [r7, #4]
	/* Set the current position to be the Home position */
	BSP_MotorControl_SetHome(MOTOR_ID, pos);
 80059ce:	687b      	ldr	r3, [r7, #4]
 80059d0:	0019      	movs	r1, r3
 80059d2:	2000      	movs	r0, #0
 80059d4:	f009 fb26 	bl	800f024 <BSP_MotorControl_SetHome>
	HAL_Delay(T_STOP);
 80059d8:	23fa      	movs	r3, #250	; 0xfa
 80059da:	005b      	lsls	r3, r3, #1
 80059dc:	0018      	movs	r0, r3
 80059de:	f009 fd89 	bl	800f4f4 <HAL_Delay>
		BSP_MotorControl_WaitWhileActive(MOTOR_ID);
		/* Get current position */
		pos = BSP_MotorControl_GetPosition(MOTOR_ID);
		stopMotor();
	}
}
 80059e2:	46c0      	nop			; (mov r8, r8)
 80059e4:	46bd      	mov	sp, r7
 80059e6:	b002      	add	sp, #8
 80059e8:	bd80      	pop	{r7, pc}
 80059ea:	46c0      	nop			; (mov r8, r8)
 80059ec:	000015cb 	.word	0x000015cb

080059f0 <calib_motor2>:

void calib_motor2(void) {
 80059f0:	b580      	push	{r7, lr}
 80059f2:	b082      	sub	sp, #8
 80059f4:	af00      	add	r7, sp, #0
	int32_t pos;

	EnableMotors(2);
 80059f6:	2002      	movs	r0, #2
 80059f8:	f7ff fdca 	bl	8005590 <EnableMotors>
	//-----Set Home position according FC1
	if (HAL_GPIO_ReadPin(DRV_FCA_2_GPIO_Port, DRV_FCA_2_Pin) == GPIO_PIN_SET) {
 80059fc:	2380      	movs	r3, #128	; 0x80
 80059fe:	011a      	lsls	r2, r3, #4
 8005a00:	23a0      	movs	r3, #160	; 0xa0
 8005a02:	05db      	lsls	r3, r3, #23
 8005a04:	0011      	movs	r1, r2
 8005a06:	0018      	movs	r0, r3
 8005a08:	f00a f968 	bl	800fcdc <HAL_GPIO_ReadPin>
 8005a0c:	0003      	movs	r3, r0
 8005a0e:	2b01      	cmp	r3, #1
 8005a10:	d114      	bne.n	8005a3c <calib_motor2+0x4c>
		//-----Move device BACKWARD till get far from FC1
		do {
			BSP_MotorControl_Run(MOTOR_ID, BACKWARD);
 8005a12:	2100      	movs	r1, #0
 8005a14:	2000      	movs	r0, #0
 8005a16:	f009 fa75 	bl	800ef04 <BSP_MotorControl_Run>
			HAL_Delay(T_FC);
 8005a1a:	20c8      	movs	r0, #200	; 0xc8
 8005a1c:	f009 fd6a 	bl	800f4f4 <HAL_Delay>
		} while (HAL_GPIO_ReadPin(DRV_FCA_2_GPIO_Port, DRV_FCA_2_Pin) == GPIO_PIN_SET);
 8005a20:	2380      	movs	r3, #128	; 0x80
 8005a22:	011a      	lsls	r2, r3, #4
 8005a24:	23a0      	movs	r3, #160	; 0xa0
 8005a26:	05db      	lsls	r3, r3, #23
 8005a28:	0011      	movs	r1, r2
 8005a2a:	0018      	movs	r0, r3
 8005a2c:	f00a f956 	bl	800fcdc <HAL_GPIO_ReadPin>
 8005a30:	0003      	movs	r3, r0
 8005a32:	2b01      	cmp	r3, #1
 8005a34:	d0ed      	beq.n	8005a12 <calib_motor2+0x22>

		stopMotor();
 8005a36:	f000 f991 	bl	8005d5c <stopMotor>
 8005a3a:	e022      	b.n	8005a82 <calib_motor2+0x92>

	} else {
		//-----Move device FORWARD till get to FC1
		do {
			BSP_MotorControl_Run(MOTOR_ID, FORWARD);
 8005a3c:	2101      	movs	r1, #1
 8005a3e:	2000      	movs	r0, #0
 8005a40:	f009 fa60 	bl	800ef04 <BSP_MotorControl_Run>
			HAL_Delay(T_FC);
 8005a44:	20c8      	movs	r0, #200	; 0xc8
 8005a46:	f009 fd55 	bl	800f4f4 <HAL_Delay>
		} while (HAL_GPIO_ReadPin(DRV_FCA_2_GPIO_Port, DRV_FCA_2_Pin)== GPIO_PIN_RESET);
 8005a4a:	2380      	movs	r3, #128	; 0x80
 8005a4c:	011a      	lsls	r2, r3, #4
 8005a4e:	23a0      	movs	r3, #160	; 0xa0
 8005a50:	05db      	lsls	r3, r3, #23
 8005a52:	0011      	movs	r1, r2
 8005a54:	0018      	movs	r0, r3
 8005a56:	f00a f941 	bl	800fcdc <HAL_GPIO_ReadPin>
 8005a5a:	1e03      	subs	r3, r0, #0
 8005a5c:	d0ee      	beq.n	8005a3c <calib_motor2+0x4c>

		//-----Move device BACKWARD till get far from FC1
		do {
			BSP_MotorControl_Run(MOTOR_ID, BACKWARD);
 8005a5e:	2100      	movs	r1, #0
 8005a60:	2000      	movs	r0, #0
 8005a62:	f009 fa4f 	bl	800ef04 <BSP_MotorControl_Run>
			HAL_Delay(T_FC);
 8005a66:	20c8      	movs	r0, #200	; 0xc8
 8005a68:	f009 fd44 	bl	800f4f4 <HAL_Delay>
		} while (HAL_GPIO_ReadPin(DRV_FCA_2_GPIO_Port, DRV_FCA_2_Pin)
 8005a6c:	2380      	movs	r3, #128	; 0x80
 8005a6e:	011a      	lsls	r2, r3, #4
 8005a70:	23a0      	movs	r3, #160	; 0xa0
 8005a72:	05db      	lsls	r3, r3, #23
 8005a74:	0011      	movs	r1, r2
 8005a76:	0018      	movs	r0, r3
 8005a78:	f00a f930 	bl	800fcdc <HAL_GPIO_ReadPin>
 8005a7c:	0003      	movs	r3, r0
				== GPIO_PIN_SET);
 8005a7e:	2b01      	cmp	r3, #1
 8005a80:	d0ed      	beq.n	8005a5e <calib_motor2+0x6e>
	if(AJUSTE_INICIAL>=0)
	{
		BSP_MotorControl_Move(MOTOR_ID, BACKWARD, STEP_1MM *AJUSTE_INICIAL);
	}else
	{
		BSP_MotorControl_Move(MOTOR_ID, FORWARD, STEP_1MM *-AJUSTE_INICIAL);
 8005a82:	4b13      	ldr	r3, [pc, #76]	; (8005ad0 <calib_motor2+0xe0>)
 8005a84:	001a      	movs	r2, r3
 8005a86:	2101      	movs	r1, #1
 8005a88:	2000      	movs	r0, #0
 8005a8a:	f009 fa11 	bl	800eeb0 <BSP_MotorControl_Move>
	}
	BSP_MotorControl_WaitWhileActive(MOTOR_ID);
 8005a8e:	2000      	movs	r0, #0
 8005a90:	f009 fb74 	bl	800f17c <BSP_MotorControl_WaitWhileActive>
	if(AJUSTE_INICIAL_M2>=0) {
		BSP_MotorControl_Move(MOTOR_ID, BACKWARD, STEP_1MM *AJUSTE_INICIAL_M2);
 8005a94:	2200      	movs	r2, #0
 8005a96:	2100      	movs	r1, #0
 8005a98:	2000      	movs	r0, #0
 8005a9a:	f009 fa09 	bl	800eeb0 <BSP_MotorControl_Move>
	}else {
		BSP_MotorControl_Move(MOTOR_ID, FORWARD, STEP_1MM *-AJUSTE_INICIAL_M2);
	}
	BSP_MotorControl_WaitWhileActive(MOTOR_ID);
 8005a9e:	2000      	movs	r0, #0
 8005aa0:	f009 fb6c 	bl	800f17c <BSP_MotorControl_WaitWhileActive>
//	BSP_MotorControl_Move(MOTOR_ID, FORWARD, STEP_1MM *5);

	stopMotor();
 8005aa4:	f000 f95a 	bl	8005d5c <stopMotor>
	/* Get current position */
	pos = BSP_MotorControl_GetPosition(MOTOR_ID);
 8005aa8:	2000      	movs	r0, #0
 8005aaa:	f009 f9b3 	bl	800ee14 <BSP_MotorControl_GetPosition>
 8005aae:	0003      	movs	r3, r0
 8005ab0:	607b      	str	r3, [r7, #4]
	/* Set the current position to be the Home position */
	BSP_MotorControl_SetHome(MOTOR_ID, pos);
 8005ab2:	687b      	ldr	r3, [r7, #4]
 8005ab4:	0019      	movs	r1, r3
 8005ab6:	2000      	movs	r0, #0
 8005ab8:	f009 fab4 	bl	800f024 <BSP_MotorControl_SetHome>

	HAL_Delay(T_STOP);
 8005abc:	23fa      	movs	r3, #250	; 0xfa
 8005abe:	005b      	lsls	r3, r3, #1
 8005ac0:	0018      	movs	r0, r3
 8005ac2:	f009 fd17 	bl	800f4f4 <HAL_Delay>
		/* Get current position */
		pos = BSP_MotorControl_GetPosition(MOTOR_ID);

		stopMotor();
	}
}
 8005ac6:	46c0      	nop			; (mov r8, r8)
 8005ac8:	46bd      	mov	sp, r7
 8005aca:	b002      	add	sp, #8
 8005acc:	bd80      	pop	{r7, pc}
 8005ace:	46c0      	nop			; (mov r8, r8)
 8005ad0:	000015cb 	.word	0x000015cb

08005ad4 <calib_motor3>:

void calib_motor3(void) {
 8005ad4:	b580      	push	{r7, lr}
 8005ad6:	b082      	sub	sp, #8
 8005ad8:	af00      	add	r7, sp, #0
	int32_t pos;

	EnableMotors(3);
 8005ada:	2003      	movs	r0, #3
 8005adc:	f7ff fd58 	bl	8005590 <EnableMotors>
////-------------------------------------------------------------------------------------------------
	//-----Set Home position according FC1
	if (HAL_GPIO_ReadPin(DRV_FCA_3_GPIO_Port, DRV_FCA_3_Pin) == GPIO_PIN_SET) {
 8005ae0:	2380      	movs	r3, #128	; 0x80
 8005ae2:	021b      	lsls	r3, r3, #8
 8005ae4:	4a31      	ldr	r2, [pc, #196]	; (8005bac <calib_motor3+0xd8>)
 8005ae6:	0019      	movs	r1, r3
 8005ae8:	0010      	movs	r0, r2
 8005aea:	f00a f8f7 	bl	800fcdc <HAL_GPIO_ReadPin>
 8005aee:	0003      	movs	r3, r0
 8005af0:	2b01      	cmp	r3, #1
 8005af2:	d113      	bne.n	8005b1c <calib_motor3+0x48>
//-----Move device BACKWARD till get far from FC1
		do {
			BSP_MotorControl_Run(MOTOR_ID, BACKWARD);
 8005af4:	2100      	movs	r1, #0
 8005af6:	2000      	movs	r0, #0
 8005af8:	f009 fa04 	bl	800ef04 <BSP_MotorControl_Run>
			HAL_Delay(T_FC);
 8005afc:	20c8      	movs	r0, #200	; 0xc8
 8005afe:	f009 fcf9 	bl	800f4f4 <HAL_Delay>
		} while (HAL_GPIO_ReadPin(DRV_FCA_3_GPIO_Port, DRV_FCA_3_Pin) == GPIO_PIN_SET);
 8005b02:	2380      	movs	r3, #128	; 0x80
 8005b04:	021b      	lsls	r3, r3, #8
 8005b06:	4a29      	ldr	r2, [pc, #164]	; (8005bac <calib_motor3+0xd8>)
 8005b08:	0019      	movs	r1, r3
 8005b0a:	0010      	movs	r0, r2
 8005b0c:	f00a f8e6 	bl	800fcdc <HAL_GPIO_ReadPin>
 8005b10:	0003      	movs	r3, r0
 8005b12:	2b01      	cmp	r3, #1
 8005b14:	d0ee      	beq.n	8005af4 <calib_motor3+0x20>
		stopMotor();
 8005b16:	f000 f921 	bl	8005d5c <stopMotor>
 8005b1a:	e020      	b.n	8005b5e <calib_motor3+0x8a>
	} else {
//-----Move device FORWARD till get to FC1
		do {
			BSP_MotorControl_Run(MOTOR_ID, FORWARD);
 8005b1c:	2101      	movs	r1, #1
 8005b1e:	2000      	movs	r0, #0
 8005b20:	f009 f9f0 	bl	800ef04 <BSP_MotorControl_Run>
			HAL_Delay(T_FC);
 8005b24:	20c8      	movs	r0, #200	; 0xc8
 8005b26:	f009 fce5 	bl	800f4f4 <HAL_Delay>
		} while (HAL_GPIO_ReadPin(DRV_FCA_3_GPIO_Port, DRV_FCA_3_Pin)== GPIO_PIN_RESET);
 8005b2a:	2380      	movs	r3, #128	; 0x80
 8005b2c:	021b      	lsls	r3, r3, #8
 8005b2e:	4a1f      	ldr	r2, [pc, #124]	; (8005bac <calib_motor3+0xd8>)
 8005b30:	0019      	movs	r1, r3
 8005b32:	0010      	movs	r0, r2
 8005b34:	f00a f8d2 	bl	800fcdc <HAL_GPIO_ReadPin>
 8005b38:	1e03      	subs	r3, r0, #0
 8005b3a:	d0ef      	beq.n	8005b1c <calib_motor3+0x48>
//-----Move device BACKWARD till get far from FC1
		do {
			BSP_MotorControl_Run(MOTOR_ID, BACKWARD);
 8005b3c:	2100      	movs	r1, #0
 8005b3e:	2000      	movs	r0, #0
 8005b40:	f009 f9e0 	bl	800ef04 <BSP_MotorControl_Run>
			HAL_Delay(T_FC);
 8005b44:	20c8      	movs	r0, #200	; 0xc8
 8005b46:	f009 fcd5 	bl	800f4f4 <HAL_Delay>
		} while (HAL_GPIO_ReadPin(DRV_FCA_3_GPIO_Port, DRV_FCA_3_Pin)
 8005b4a:	2380      	movs	r3, #128	; 0x80
 8005b4c:	021b      	lsls	r3, r3, #8
 8005b4e:	4a17      	ldr	r2, [pc, #92]	; (8005bac <calib_motor3+0xd8>)
 8005b50:	0019      	movs	r1, r3
 8005b52:	0010      	movs	r0, r2
 8005b54:	f00a f8c2 	bl	800fcdc <HAL_GPIO_ReadPin>
 8005b58:	0003      	movs	r3, r0
				== GPIO_PIN_SET);
 8005b5a:	2b01      	cmp	r3, #1
 8005b5c:	d0ee      	beq.n	8005b3c <calib_motor3+0x68>
	if(AJUSTE_INICIAL>=0)
	{
		BSP_MotorControl_Move(MOTOR_ID, BACKWARD, STEP_1MM *AJUSTE_INICIAL);
	}else
	{
		BSP_MotorControl_Move(MOTOR_ID, FORWARD, STEP_1MM *-AJUSTE_INICIAL);
 8005b5e:	4b14      	ldr	r3, [pc, #80]	; (8005bb0 <calib_motor3+0xdc>)
 8005b60:	001a      	movs	r2, r3
 8005b62:	2101      	movs	r1, #1
 8005b64:	2000      	movs	r0, #0
 8005b66:	f009 f9a3 	bl	800eeb0 <BSP_MotorControl_Move>
	}
	BSP_MotorControl_WaitWhileActive(MOTOR_ID);
 8005b6a:	2000      	movs	r0, #0
 8005b6c:	f009 fb06 	bl	800f17c <BSP_MotorControl_WaitWhileActive>
	if(AJUSTE_INICIAL_M3>=0) {
		BSP_MotorControl_Move(MOTOR_ID, BACKWARD, STEP_1MM *AJUSTE_INICIAL_M3);
 8005b70:	2200      	movs	r2, #0
 8005b72:	2100      	movs	r1, #0
 8005b74:	2000      	movs	r0, #0
 8005b76:	f009 f99b 	bl	800eeb0 <BSP_MotorControl_Move>
	}else {
		BSP_MotorControl_Move(MOTOR_ID, FORWARD, STEP_1MM *-AJUSTE_INICIAL_M3);
	}
	BSP_MotorControl_WaitWhileActive(MOTOR_ID);
 8005b7a:	2000      	movs	r0, #0
 8005b7c:	f009 fafe 	bl	800f17c <BSP_MotorControl_WaitWhileActive>
	stopMotor();
 8005b80:	f000 f8ec 	bl	8005d5c <stopMotor>
	/* Get current position */
	pos = BSP_MotorControl_GetPosition(MOTOR_ID);
 8005b84:	2000      	movs	r0, #0
 8005b86:	f009 f945 	bl	800ee14 <BSP_MotorControl_GetPosition>
 8005b8a:	0003      	movs	r3, r0
 8005b8c:	607b      	str	r3, [r7, #4]

	/* Set the current position to be the Home position */
	BSP_MotorControl_SetHome(MOTOR_ID, pos);
 8005b8e:	687b      	ldr	r3, [r7, #4]
 8005b90:	0019      	movs	r1, r3
 8005b92:	2000      	movs	r0, #0
 8005b94:	f009 fa46 	bl	800f024 <BSP_MotorControl_SetHome>

	HAL_Delay(T_STOP);
 8005b98:	23fa      	movs	r3, #250	; 0xfa
 8005b9a:	005b      	lsls	r3, r3, #1
 8005b9c:	0018      	movs	r0, r3
 8005b9e:	f009 fca9 	bl	800f4f4 <HAL_Delay>
		BSP_MotorControl_WaitWhileActive(MOTOR_ID);
		/* Get current position */
		pos = BSP_MotorControl_GetPosition(MOTOR_ID);
		stopMotor();
	}
}
 8005ba2:	46c0      	nop			; (mov r8, r8)
 8005ba4:	46bd      	mov	sp, r7
 8005ba6:	b002      	add	sp, #8
 8005ba8:	bd80      	pop	{r7, pc}
 8005baa:	46c0      	nop			; (mov r8, r8)
 8005bac:	50000400 	.word	0x50000400
 8005bb0:	000015cb 	.word	0x000015cb

08005bb4 <calib_motor4>:

void calib_motor4(void) {
 8005bb4:	b580      	push	{r7, lr}
 8005bb6:	b082      	sub	sp, #8
 8005bb8:	af00      	add	r7, sp, #0
	int32_t pos;

	EnableMotors(4);
 8005bba:	2004      	movs	r0, #4
 8005bbc:	f7ff fce8 	bl	8005590 <EnableMotors>
////-------------------------------------------------------------------------------------------------
	//-----Set Home position according FC1
	if (HAL_GPIO_ReadPin(DRV_FCA_4_GPIO_Port, DRV_FCA_4_Pin) == GPIO_PIN_SET) {
 8005bc0:	23a0      	movs	r3, #160	; 0xa0
 8005bc2:	05db      	lsls	r3, r3, #23
 8005bc4:	2180      	movs	r1, #128	; 0x80
 8005bc6:	0018      	movs	r0, r3
 8005bc8:	f00a f888 	bl	800fcdc <HAL_GPIO_ReadPin>
 8005bcc:	0003      	movs	r3, r0
 8005bce:	2b01      	cmp	r3, #1
 8005bd0:	d112      	bne.n	8005bf8 <calib_motor4+0x44>
//-----Move device BACKWARD till get far from FC1
		do {
			BSP_MotorControl_Run(MOTOR_ID, BACKWARD);
 8005bd2:	2100      	movs	r1, #0
 8005bd4:	2000      	movs	r0, #0
 8005bd6:	f009 f995 	bl	800ef04 <BSP_MotorControl_Run>
			HAL_Delay(T_FC);
 8005bda:	20c8      	movs	r0, #200	; 0xc8
 8005bdc:	f009 fc8a 	bl	800f4f4 <HAL_Delay>
		} while (HAL_GPIO_ReadPin(DRV_FCA_4_GPIO_Port, DRV_FCA_4_Pin) == GPIO_PIN_SET);
 8005be0:	23a0      	movs	r3, #160	; 0xa0
 8005be2:	05db      	lsls	r3, r3, #23
 8005be4:	2180      	movs	r1, #128	; 0x80
 8005be6:	0018      	movs	r0, r3
 8005be8:	f00a f878 	bl	800fcdc <HAL_GPIO_ReadPin>
 8005bec:	0003      	movs	r3, r0
 8005bee:	2b01      	cmp	r3, #1
 8005bf0:	d0ef      	beq.n	8005bd2 <calib_motor4+0x1e>

		stopMotor();
 8005bf2:	f000 f8b3 	bl	8005d5c <stopMotor>
 8005bf6:	e01e      	b.n	8005c36 <calib_motor4+0x82>

	} else {
//-----Move device FORWARD till get to FC1
		do {
			BSP_MotorControl_Run(MOTOR_ID, FORWARD);
 8005bf8:	2101      	movs	r1, #1
 8005bfa:	2000      	movs	r0, #0
 8005bfc:	f009 f982 	bl	800ef04 <BSP_MotorControl_Run>
			HAL_Delay(T_FC);
 8005c00:	20c8      	movs	r0, #200	; 0xc8
 8005c02:	f009 fc77 	bl	800f4f4 <HAL_Delay>
		} while (HAL_GPIO_ReadPin(DRV_FCA_4_GPIO_Port, DRV_FCA_4_Pin)== GPIO_PIN_RESET);
 8005c06:	23a0      	movs	r3, #160	; 0xa0
 8005c08:	05db      	lsls	r3, r3, #23
 8005c0a:	2180      	movs	r1, #128	; 0x80
 8005c0c:	0018      	movs	r0, r3
 8005c0e:	f00a f865 	bl	800fcdc <HAL_GPIO_ReadPin>
 8005c12:	1e03      	subs	r3, r0, #0
 8005c14:	d0f0      	beq.n	8005bf8 <calib_motor4+0x44>

//-----Move device BACKWARD till get far from FC1
		do {
			BSP_MotorControl_Run(MOTOR_ID, BACKWARD);
 8005c16:	2100      	movs	r1, #0
 8005c18:	2000      	movs	r0, #0
 8005c1a:	f009 f973 	bl	800ef04 <BSP_MotorControl_Run>
			HAL_Delay(T_FC);
 8005c1e:	20c8      	movs	r0, #200	; 0xc8
 8005c20:	f009 fc68 	bl	800f4f4 <HAL_Delay>
		} while (HAL_GPIO_ReadPin(DRV_FCA_4_GPIO_Port, DRV_FCA_4_Pin)
 8005c24:	23a0      	movs	r3, #160	; 0xa0
 8005c26:	05db      	lsls	r3, r3, #23
 8005c28:	2180      	movs	r1, #128	; 0x80
 8005c2a:	0018      	movs	r0, r3
 8005c2c:	f00a f856 	bl	800fcdc <HAL_GPIO_ReadPin>
 8005c30:	0003      	movs	r3, r0
				== GPIO_PIN_SET);
 8005c32:	2b01      	cmp	r3, #1
 8005c34:	d0ef      	beq.n	8005c16 <calib_motor4+0x62>
	if(AJUSTE_INICIAL>=0)
	{
		BSP_MotorControl_Move(MOTOR_ID, BACKWARD, STEP_1MM *AJUSTE_INICIAL);
	}else
	{
		BSP_MotorControl_Move(MOTOR_ID, FORWARD, STEP_1MM *-AJUSTE_INICIAL);
 8005c36:	4b13      	ldr	r3, [pc, #76]	; (8005c84 <calib_motor4+0xd0>)
 8005c38:	001a      	movs	r2, r3
 8005c3a:	2101      	movs	r1, #1
 8005c3c:	2000      	movs	r0, #0
 8005c3e:	f009 f937 	bl	800eeb0 <BSP_MotorControl_Move>
	}
	BSP_MotorControl_WaitWhileActive(MOTOR_ID);
 8005c42:	2000      	movs	r0, #0
 8005c44:	f009 fa9a 	bl	800f17c <BSP_MotorControl_WaitWhileActive>
	if(AJUSTE_INICIAL_M4>=0) {
		BSP_MotorControl_Move(MOTOR_ID, BACKWARD, STEP_1MM *AJUSTE_INICIAL_M4);
 8005c48:	2200      	movs	r2, #0
 8005c4a:	2100      	movs	r1, #0
 8005c4c:	2000      	movs	r0, #0
 8005c4e:	f009 f92f 	bl	800eeb0 <BSP_MotorControl_Move>
	}else {
		BSP_MotorControl_Move(MOTOR_ID, FORWARD, STEP_1MM *-AJUSTE_INICIAL_M4);
	}
	BSP_MotorControl_WaitWhileActive(MOTOR_ID);
 8005c52:	2000      	movs	r0, #0
 8005c54:	f009 fa92 	bl	800f17c <BSP_MotorControl_WaitWhileActive>
	stopMotor();
 8005c58:	f000 f880 	bl	8005d5c <stopMotor>

	/* Get current position */
	pos = BSP_MotorControl_GetPosition(MOTOR_ID);
 8005c5c:	2000      	movs	r0, #0
 8005c5e:	f009 f8d9 	bl	800ee14 <BSP_MotorControl_GetPosition>
 8005c62:	0003      	movs	r3, r0
 8005c64:	607b      	str	r3, [r7, #4]

	/* Set the current position to be the Home position */
	BSP_MotorControl_SetHome(MOTOR_ID, pos);
 8005c66:	687b      	ldr	r3, [r7, #4]
 8005c68:	0019      	movs	r1, r3
 8005c6a:	2000      	movs	r0, #0
 8005c6c:	f009 f9da 	bl	800f024 <BSP_MotorControl_SetHome>

	HAL_Delay(T_STOP);
 8005c70:	23fa      	movs	r3, #250	; 0xfa
 8005c72:	005b      	lsls	r3, r3, #1
 8005c74:	0018      	movs	r0, r3
 8005c76:	f009 fc3d 	bl	800f4f4 <HAL_Delay>
		BSP_MotorControl_WaitWhileActive(MOTOR_ID);
		/* Get current position */
		pos = BSP_MotorControl_GetPosition(MOTOR_ID);
		stopMotor();
	}
}
 8005c7a:	46c0      	nop			; (mov r8, r8)
 8005c7c:	46bd      	mov	sp, r7
 8005c7e:	b002      	add	sp, #8
 8005c80:	bd80      	pop	{r7, pc}
 8005c82:	46c0      	nop			; (mov r8, r8)
 8005c84:	000015cb 	.word	0x000015cb

08005c88 <calib_motor5>:

void calib_motor5(void) {
 8005c88:	b580      	push	{r7, lr}
 8005c8a:	b082      	sub	sp, #8
 8005c8c:	af00      	add	r7, sp, #0
	int32_t pos;

	EnableMotors(5);
 8005c8e:	2005      	movs	r0, #5
 8005c90:	f7ff fc7e 	bl	8005590 <EnableMotors>
////-------------------------------------------------------------------------------------------------
	//-----Set Home position according FC1
	if (HAL_GPIO_ReadPin(DRV_FCA_5_GPIO_Port, DRV_FCA_5_Pin) == GPIO_PIN_SET) {
 8005c94:	4b2e      	ldr	r3, [pc, #184]	; (8005d50 <calib_motor5+0xc8>)
 8005c96:	2108      	movs	r1, #8
 8005c98:	0018      	movs	r0, r3
 8005c9a:	f00a f81f 	bl	800fcdc <HAL_GPIO_ReadPin>
 8005c9e:	0003      	movs	r3, r0
 8005ca0:	2b01      	cmp	r3, #1
 8005ca2:	d111      	bne.n	8005cc8 <calib_motor5+0x40>
//-----Move device BACKWARD till get far from FC1
		do {
			BSP_MotorControl_Run(MOTOR_ID, BACKWARD);
 8005ca4:	2100      	movs	r1, #0
 8005ca6:	2000      	movs	r0, #0
 8005ca8:	f009 f92c 	bl	800ef04 <BSP_MotorControl_Run>
			HAL_Delay(T_FC);
 8005cac:	20c8      	movs	r0, #200	; 0xc8
 8005cae:	f009 fc21 	bl	800f4f4 <HAL_Delay>
		} while (HAL_GPIO_ReadPin(DRV_FCA_5_GPIO_Port, DRV_FCA_5_Pin) == GPIO_PIN_SET);
 8005cb2:	4b27      	ldr	r3, [pc, #156]	; (8005d50 <calib_motor5+0xc8>)
 8005cb4:	2108      	movs	r1, #8
 8005cb6:	0018      	movs	r0, r3
 8005cb8:	f00a f810 	bl	800fcdc <HAL_GPIO_ReadPin>
 8005cbc:	0003      	movs	r3, r0
 8005cbe:	2b01      	cmp	r3, #1
 8005cc0:	d0f0      	beq.n	8005ca4 <calib_motor5+0x1c>

		stopMotor();
 8005cc2:	f000 f84b 	bl	8005d5c <stopMotor>
 8005cc6:	e01c      	b.n	8005d02 <calib_motor5+0x7a>

	} else {
//-----Move device FORWARD till get to FC1
		do {
			BSP_MotorControl_Run(MOTOR_ID, FORWARD);
 8005cc8:	2101      	movs	r1, #1
 8005cca:	2000      	movs	r0, #0
 8005ccc:	f009 f91a 	bl	800ef04 <BSP_MotorControl_Run>
			HAL_Delay(T_FC);
 8005cd0:	20c8      	movs	r0, #200	; 0xc8
 8005cd2:	f009 fc0f 	bl	800f4f4 <HAL_Delay>
		} while (HAL_GPIO_ReadPin(DRV_FCA_5_GPIO_Port, DRV_FCA_5_Pin)== GPIO_PIN_RESET);
 8005cd6:	4b1e      	ldr	r3, [pc, #120]	; (8005d50 <calib_motor5+0xc8>)
 8005cd8:	2108      	movs	r1, #8
 8005cda:	0018      	movs	r0, r3
 8005cdc:	f009 fffe 	bl	800fcdc <HAL_GPIO_ReadPin>
 8005ce0:	1e03      	subs	r3, r0, #0
 8005ce2:	d0f1      	beq.n	8005cc8 <calib_motor5+0x40>

//-----Move device BACKWARD till get far from FC1
		do {
			BSP_MotorControl_Run(MOTOR_ID, BACKWARD);
 8005ce4:	2100      	movs	r1, #0
 8005ce6:	2000      	movs	r0, #0
 8005ce8:	f009 f90c 	bl	800ef04 <BSP_MotorControl_Run>
			HAL_Delay(T_FC);
 8005cec:	20c8      	movs	r0, #200	; 0xc8
 8005cee:	f009 fc01 	bl	800f4f4 <HAL_Delay>
		} while (HAL_GPIO_ReadPin(DRV_FCA_5_GPIO_Port, DRV_FCA_5_Pin)
 8005cf2:	4b17      	ldr	r3, [pc, #92]	; (8005d50 <calib_motor5+0xc8>)
 8005cf4:	2108      	movs	r1, #8
 8005cf6:	0018      	movs	r0, r3
 8005cf8:	f009 fff0 	bl	800fcdc <HAL_GPIO_ReadPin>
 8005cfc:	0003      	movs	r3, r0
				== GPIO_PIN_SET);
 8005cfe:	2b01      	cmp	r3, #1
 8005d00:	d0f0      	beq.n	8005ce4 <calib_motor5+0x5c>
	if(AJUSTE_INICIAL>=0)
	{
		BSP_MotorControl_Move(MOTOR_ID, BACKWARD, STEP_1MM *AJUSTE_INICIAL);
	}else
	{
		BSP_MotorControl_Move(MOTOR_ID, FORWARD, STEP_1MM *-AJUSTE_INICIAL);
 8005d02:	4b14      	ldr	r3, [pc, #80]	; (8005d54 <calib_motor5+0xcc>)
 8005d04:	001a      	movs	r2, r3
 8005d06:	2101      	movs	r1, #1
 8005d08:	2000      	movs	r0, #0
 8005d0a:	f009 f8d1 	bl	800eeb0 <BSP_MotorControl_Move>
	}
	BSP_MotorControl_WaitWhileActive(MOTOR_ID);
 8005d0e:	2000      	movs	r0, #0
 8005d10:	f009 fa34 	bl	800f17c <BSP_MotorControl_WaitWhileActive>
	if(AJUSTE_INICIAL_M5>=0) {
		BSP_MotorControl_Move(MOTOR_ID, BACKWARD, STEP_1MM *AJUSTE_INICIAL_M5);
	}else {
		BSP_MotorControl_Move(MOTOR_ID, FORWARD, STEP_1MM *-AJUSTE_INICIAL_M5);
 8005d14:	4b10      	ldr	r3, [pc, #64]	; (8005d58 <calib_motor5+0xd0>)
 8005d16:	001a      	movs	r2, r3
 8005d18:	2101      	movs	r1, #1
 8005d1a:	2000      	movs	r0, #0
 8005d1c:	f009 f8c8 	bl	800eeb0 <BSP_MotorControl_Move>
	}
	BSP_MotorControl_WaitWhileActive(MOTOR_ID);
 8005d20:	2000      	movs	r0, #0
 8005d22:	f009 fa2b 	bl	800f17c <BSP_MotorControl_WaitWhileActive>
	stopMotor();
 8005d26:	f000 f819 	bl	8005d5c <stopMotor>
	/* Get current position */
	pos = BSP_MotorControl_GetPosition(MOTOR_ID);
 8005d2a:	2000      	movs	r0, #0
 8005d2c:	f009 f872 	bl	800ee14 <BSP_MotorControl_GetPosition>
 8005d30:	0003      	movs	r3, r0
 8005d32:	607b      	str	r3, [r7, #4]
	/* Set the current position to be the Home position */
	BSP_MotorControl_SetHome(MOTOR_ID, pos);
 8005d34:	687b      	ldr	r3, [r7, #4]
 8005d36:	0019      	movs	r1, r3
 8005d38:	2000      	movs	r0, #0
 8005d3a:	f009 f973 	bl	800f024 <BSP_MotorControl_SetHome>

	HAL_Delay(T_STOP);
 8005d3e:	23fa      	movs	r3, #250	; 0xfa
 8005d40:	005b      	lsls	r3, r3, #1
 8005d42:	0018      	movs	r0, r3
 8005d44:	f009 fbd6 	bl	800f4f4 <HAL_Delay>
		BSP_MotorControl_WaitWhileActive(MOTOR_ID);
		/* Get current position */
		pos = BSP_MotorControl_GetPosition(MOTOR_ID);
		stopMotor();
	}
}
 8005d48:	46c0      	nop			; (mov r8, r8)
 8005d4a:	46bd      	mov	sp, r7
 8005d4c:	b002      	add	sp, #8
 8005d4e:	bd80      	pop	{r7, pc}
 8005d50:	50000800 	.word	0x50000800
 8005d54:	000015cb 	.word	0x000015cb
 8005d58:	000018e8 	.word	0x000018e8

08005d5c <stopMotor>:
		BSP_MotorControl_WaitWhileActive(MOTOR_ID);
		stopMotor();
	}
}

void stopMotor(void){
 8005d5c:	b580      	push	{r7, lr}
 8005d5e:	af00      	add	r7, sp, #0
	/* Request soft stop */
	BSP_MotorControl_SoftStop(MOTOR_ID);
 8005d60:	2000      	movs	r0, #0
 8005d62:	f009 f9b9 	bl	800f0d8 <BSP_MotorControl_SoftStop>
	/* Disable the power bridges */
	BSP_MotorControl_CmdDisable(MOTOR_ID);
 8005d66:	2000      	movs	r0, #0
 8005d68:	f009 fa2c 	bl	800f1c4 <BSP_MotorControl_CmdDisable>
	/* Wait for 0.5 second */
	HAL_Delay(T_STOP);
 8005d6c:	23fa      	movs	r3, #250	; 0xfa
 8005d6e:	005b      	lsls	r3, r3, #1
 8005d70:	0018      	movs	r0, r3
 8005d72:	f009 fbbf 	bl	800f4f4 <HAL_Delay>
	/* Turn off power bridges when motor is stopped */
	BSP_MotorControl_SetStopMode(MOTOR_ID, HIZ_MODE);
 8005d76:	2101      	movs	r1, #1
 8005d78:	2000      	movs	r0, #0
 8005d7a:	f009 fa73 	bl	800f264 <BSP_MotorControl_SetStopMode>
}
 8005d7e:	46c0      	nop			; (mov r8, r8)
 8005d80:	46bd      	mov	sp, r7
 8005d82:	bd80      	pop	{r7, pc}

08005d84 <MyFlagInterruptHandler>:
/**
 * @brief  This function is the User handler for the flag interrupt
 * @param  None
 * @retval None
 */
void MyFlagInterruptHandler(void) {
 8005d84:	b580      	push	{r7, lr}
 8005d86:	af00      	add	r7, sp, #0
	//When EN pin is forced low by a failure, configure the GPIO as an ouput low
	BSP_MotorControl_CmdDisable(0);
 8005d88:	2000      	movs	r0, #0
 8005d8a:	f009 fa1b 	bl	800f1c4 <BSP_MotorControl_CmdDisable>
}
 8005d8e:	46c0      	nop			; (mov r8, r8)
 8005d90:	46bd      	mov	sp, r7
 8005d92:	bd80      	pop	{r7, pc}

08005d94 <MyErrorHandler>:
/**
 * @brief  This function is executed in case of error occurrence.
 * @param  error number of the error
 * @retval None
 */
void MyErrorHandler(uint16_t error) {
 8005d94:	b580      	push	{r7, lr}
 8005d96:	b082      	sub	sp, #8
 8005d98:	af00      	add	r7, sp, #0
 8005d9a:	0002      	movs	r2, r0
 8005d9c:	1dbb      	adds	r3, r7, #6
 8005d9e:	801a      	strh	r2, [r3, #0]
	/* Backup error number */
	gLastError = error;
 8005da0:	4b02      	ldr	r3, [pc, #8]	; (8005dac <MyErrorHandler+0x18>)
 8005da2:	1dba      	adds	r2, r7, #6
 8005da4:	8812      	ldrh	r2, [r2, #0]
 8005da6:	801a      	strh	r2, [r3, #0]

	/* Infinite loop */
	while (1) {
 8005da8:	e7fe      	b.n	8005da8 <MyErrorHandler+0x14>
 8005daa:	46c0      	nop			; (mov r8, r8)
 8005dac:	20000454 	.word	0x20000454

08005db0 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 8005db0:	b580      	push	{r7, lr}
 8005db2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN Error_Handler_Debug */
	/* User can add his own implementation to report the HAL error return state */

  /* USER CODE END Error_Handler_Debug */
}
 8005db4:	46c0      	nop			; (mov r8, r8)
 8005db6:	46bd      	mov	sp, r7
 8005db8:	bd80      	pop	{r7, pc}
	...

08005dbc <HAL_TIM_PWM_MspInit>:
  * @brief PWM MSP Initialization 
  * @param[in] htim_pwm PWM handle pointer
  * @retval None
  */
void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef* htim_pwm)
{
 8005dbc:	b580      	push	{r7, lr}
 8005dbe:	b088      	sub	sp, #32
 8005dc0:	af00      	add	r7, sp, #0
 8005dc2:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct;

  if(htim_pwm->Instance == BSP_MOTOR_CONTROL_BOARD_PWM_REF)
 8005dc4:	687b      	ldr	r3, [r7, #4]
 8005dc6:	681b      	ldr	r3, [r3, #0]
 8005dc8:	4a11      	ldr	r2, [pc, #68]	; (8005e10 <HAL_TIM_PWM_MspInit+0x54>)
 8005dca:	4293      	cmp	r3, r2
 8005dcc:	d11b      	bne.n	8005e06 <HAL_TIM_PWM_MspInit+0x4a>
  {
    /* Peripheral clock enable */
    __BSP_MOTOR_CONTROL_BOARD_CLCK_ENABLE_PWM_REF();
 8005dce:	4b11      	ldr	r3, [pc, #68]	; (8005e14 <HAL_TIM_PWM_MspInit+0x58>)
 8005dd0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8005dd2:	4b10      	ldr	r3, [pc, #64]	; (8005e14 <HAL_TIM_PWM_MspInit+0x58>)
 8005dd4:	2120      	movs	r1, #32
 8005dd6:	430a      	orrs	r2, r1
 8005dd8:	635a      	str	r2, [r3, #52]	; 0x34
  
    /* GPIO clock enable -----------------------------------------------------*/
    /* already done in STSPIN220 GPIO initialization function */
  
    /* Configure STSPIN220 - PWM for REF pin ---------------------------------*/
    GPIO_InitStruct.Pin = BSP_MOTOR_CONTROL_BOARD_PIN_PWM_REF;
 8005dda:	210c      	movs	r1, #12
 8005ddc:	187b      	adds	r3, r7, r1
 8005dde:	2280      	movs	r2, #128	; 0x80
 8005de0:	601a      	str	r2, [r3, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005de2:	187b      	adds	r3, r7, r1
 8005de4:	2202      	movs	r2, #2
 8005de6:	605a      	str	r2, [r3, #4]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005de8:	187b      	adds	r3, r7, r1
 8005dea:	2200      	movs	r2, #0
 8005dec:	609a      	str	r2, [r3, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_MEDIUM;
 8005dee:	187b      	adds	r3, r7, r1
 8005df0:	2201      	movs	r2, #1
 8005df2:	60da      	str	r2, [r3, #12]
    GPIO_InitStruct.Alternate = BSP_MOTOR_CONTROL_BOARD_AF_PWM_REF;
 8005df4:	187b      	adds	r3, r7, r1
 8005df6:	2200      	movs	r2, #0
 8005df8:	611a      	str	r2, [r3, #16]
    HAL_GPIO_Init(BSP_MOTOR_CONTROL_BOARD_PORT_PWM_REF, &GPIO_InitStruct);
 8005dfa:	187b      	adds	r3, r7, r1
 8005dfc:	4a06      	ldr	r2, [pc, #24]	; (8005e18 <HAL_TIM_PWM_MspInit+0x5c>)
 8005dfe:	0019      	movs	r1, r3
 8005e00:	0010      	movs	r0, r2
 8005e02:	f009 fd0b 	bl	800f81c <HAL_GPIO_Init>
  }
}
 8005e06:	46c0      	nop			; (mov r8, r8)
 8005e08:	46bd      	mov	sp, r7
 8005e0a:	b008      	add	sp, #32
 8005e0c:	bd80      	pop	{r7, pc}
 8005e0e:	46c0      	nop			; (mov r8, r8)
 8005e10:	40011400 	.word	0x40011400
 8005e14:	40021000 	.word	0x40021000
 8005e18:	50000800 	.word	0x50000800

08005e1c <HAL_TIM_OC_MspInit>:
  * @brief TIM MSP Initialization
  * @param[in] htim TIM handle pointer
  * @retval None
  */
void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
{
 8005e1c:	b580      	push	{r7, lr}
 8005e1e:	b088      	sub	sp, #32
 8005e20:	af00      	add	r7, sp, #0
 8005e22:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct;
  
  if(htim->Instance == BSP_MOTOR_CONTROL_BOARD_TIM_STCK)
 8005e24:	687b      	ldr	r3, [r7, #4]
 8005e26:	681a      	ldr	r2, [r3, #0]
 8005e28:	2380      	movs	r3, #128	; 0x80
 8005e2a:	05db      	lsls	r3, r3, #23
 8005e2c:	429a      	cmp	r2, r3
 8005e2e:	d123      	bne.n	8005e78 <HAL_TIM_OC_MspInit+0x5c>
  {
    /* Peripheral clock enable -----------------------------------------------*/
    __BSP_MOTOR_CONTROL_BOARD_CLCK_ENABLE_TIM_STCK();
 8005e30:	4b13      	ldr	r3, [pc, #76]	; (8005e80 <HAL_TIM_OC_MspInit+0x64>)
 8005e32:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8005e34:	4b12      	ldr	r3, [pc, #72]	; (8005e80 <HAL_TIM_OC_MspInit+0x64>)
 8005e36:	2101      	movs	r1, #1
 8005e38:	430a      	orrs	r2, r1
 8005e3a:	639a      	str	r2, [r3, #56]	; 0x38
    
    /* GPIO clock enable -----------------------------------------------------*/
    /* already done in STSPIN220 GPIO initialization function */
  
    /* Configure STSPIN220 - TIMER for STCK pin ------------------------------*/
    GPIO_InitStruct.Pin = BSP_MOTOR_CONTROL_BOARD_PIN_TIM_STCK_MODE3;
 8005e3c:	210c      	movs	r1, #12
 8005e3e:	187b      	adds	r3, r7, r1
 8005e40:	2208      	movs	r2, #8
 8005e42:	601a      	str	r2, [r3, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005e44:	187b      	adds	r3, r7, r1
 8005e46:	2202      	movs	r2, #2
 8005e48:	605a      	str	r2, [r3, #4]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005e4a:	187b      	adds	r3, r7, r1
 8005e4c:	2200      	movs	r2, #0
 8005e4e:	609a      	str	r2, [r3, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_MEDIUM;
 8005e50:	187b      	adds	r3, r7, r1
 8005e52:	2201      	movs	r2, #1
 8005e54:	60da      	str	r2, [r3, #12]
    GPIO_InitStruct.Alternate = BSP_MOTOR_CONTROL_BOARD_AF_TIM_STCK;
 8005e56:	187b      	adds	r3, r7, r1
 8005e58:	2202      	movs	r2, #2
 8005e5a:	611a      	str	r2, [r3, #16]
    HAL_GPIO_Init(BSP_MOTOR_CONTROL_BOARD_PORT_TIM_STCK_MODE3, &GPIO_InitStruct);
 8005e5c:	187b      	adds	r3, r7, r1
 8005e5e:	4a09      	ldr	r2, [pc, #36]	; (8005e84 <HAL_TIM_OC_MspInit+0x68>)
 8005e60:	0019      	movs	r1, r3
 8005e62:	0010      	movs	r0, r2
 8005e64:	f009 fcda 	bl	800f81c <HAL_GPIO_Init>
      
    /* Enable the timer interrupt & set priority -----------------------------*/
    HAL_NVIC_SetPriority(BSP_MOTOR_CONTROL_BOARD_IRQn_TIM_STCK,\
 8005e68:	2200      	movs	r2, #0
 8005e6a:	2102      	movs	r1, #2
 8005e6c:	200f      	movs	r0, #15
 8005e6e:	f009 fc3b 	bl	800f6e8 <HAL_NVIC_SetPriority>
      BSP_MOTOR_CONTROL_BOARD_PRIORITY_TIM_STCK,\
      0);
    HAL_NVIC_EnableIRQ(BSP_MOTOR_CONTROL_BOARD_IRQn_TIM_STCK);
 8005e72:	200f      	movs	r0, #15
 8005e74:	f009 fc4d 	bl	800f712 <HAL_NVIC_EnableIRQ>
  }
}
 8005e78:	46c0      	nop			; (mov r8, r8)
 8005e7a:	46bd      	mov	sp, r7
 8005e7c:	b008      	add	sp, #32
 8005e7e:	bd80      	pop	{r7, pc}
 8005e80:	40021000 	.word	0x40021000
 8005e84:	50000400 	.word	0x50000400

08005e88 <HAL_TIM_OC_MspDeInit>:
  * @brief TIM MSP DeInitialization
  * @param[in] htim TIM handle pointer
  * @retval None
  */
void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
{
 8005e88:	b580      	push	{r7, lr}
 8005e8a:	b082      	sub	sp, #8
 8005e8c:	af00      	add	r7, sp, #0
 8005e8e:	6078      	str	r0, [r7, #4]
  if(htim->Instance == BSP_MOTOR_CONTROL_BOARD_TIM_STCK)
 8005e90:	687b      	ldr	r3, [r7, #4]
 8005e92:	681a      	ldr	r2, [r3, #0]
 8005e94:	2380      	movs	r3, #128	; 0x80
 8005e96:	05db      	lsls	r3, r3, #23
 8005e98:	429a      	cmp	r2, r3
 8005e9a:	d10d      	bne.n	8005eb8 <HAL_TIM_OC_MspDeInit+0x30>
  {
    /* Peripheral clock disable ----------------------------------------------*/
    __BSP_MOTOR_CONTROL_BOARD_CLCK_DISABLE_TIM_STCK();
 8005e9c:	4b08      	ldr	r3, [pc, #32]	; (8005ec0 <HAL_TIM_OC_MspDeInit+0x38>)
 8005e9e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8005ea0:	4b07      	ldr	r3, [pc, #28]	; (8005ec0 <HAL_TIM_OC_MspDeInit+0x38>)
 8005ea2:	2101      	movs	r1, #1
 8005ea4:	438a      	bics	r2, r1
 8005ea6:	639a      	str	r2, [r3, #56]	; 0x38
    
    /* GPIO clock disable ----------------------------------------------------*/
    /* do not disable as the clock is likely used for other HW resources */
  
    /* STCK pin GPIO deinitialization ----------------------------------------*/
    HAL_GPIO_DeInit(BSP_MOTOR_CONTROL_BOARD_PORT_TIM_STCK_MODE3,\
 8005ea8:	4b06      	ldr	r3, [pc, #24]	; (8005ec4 <HAL_TIM_OC_MspDeInit+0x3c>)
 8005eaa:	2108      	movs	r1, #8
 8005eac:	0018      	movs	r0, r3
 8005eae:	f009 fe33 	bl	800fb18 <HAL_GPIO_DeInit>
      BSP_MOTOR_CONTROL_BOARD_PIN_TIM_STCK_MODE3);
      
    /* Disable the timer interrupt -------------------------------------------*/
    HAL_NVIC_DisableIRQ(BSP_MOTOR_CONTROL_BOARD_IRQn_TIM_STCK);
 8005eb2:	200f      	movs	r0, #15
 8005eb4:	f009 fc3d 	bl	800f732 <HAL_NVIC_DisableIRQ>
  }
}
 8005eb8:	46c0      	nop			; (mov r8, r8)
 8005eba:	46bd      	mov	sp, r7
 8005ebc:	b002      	add	sp, #8
 8005ebe:	bd80      	pop	{r7, pc}
 8005ec0:	40021000 	.word	0x40021000
 8005ec4:	50000400 	.word	0x50000400

08005ec8 <HAL_TIM_OC_DelayElapsedCallback>:
  * @brief  Output Compare callback in non blocking mode 
  * @param  htim : TIM OC handle
  * @retval None
  */
void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
{
 8005ec8:	b580      	push	{r7, lr}
 8005eca:	b082      	sub	sp, #8
 8005ecc:	af00      	add	r7, sp, #0
 8005ece:	6078      	str	r0, [r7, #4]
  if((htim->Instance == BSP_MOTOR_CONTROL_BOARD_TIM_STCK)&&\
 8005ed0:	687b      	ldr	r3, [r7, #4]
 8005ed2:	681a      	ldr	r2, [r3, #0]
 8005ed4:	2380      	movs	r3, #128	; 0x80
 8005ed6:	05db      	lsls	r3, r3, #23
 8005ed8:	429a      	cmp	r2, r3
 8005eda:	d106      	bne.n	8005eea <HAL_TIM_OC_DelayElapsedCallback+0x22>
     (htim->Channel == BSP_MOTOR_CONTROL_BOARD_HAL_ACT_CHAN_TIM_STCK))
 8005edc:	687b      	ldr	r3, [r7, #4]
 8005ede:	7e1b      	ldrb	r3, [r3, #24]
  if((htim->Instance == BSP_MOTOR_CONTROL_BOARD_TIM_STCK)&&\
 8005ee0:	2b02      	cmp	r3, #2
 8005ee2:	d102      	bne.n	8005eea <HAL_TIM_OC_DelayElapsedCallback+0x22>
    {
      BSP_MotorControl_StepClockHandler(0);
 8005ee4:	2000      	movs	r0, #0
 8005ee6:	f009 f925 	bl	800f134 <BSP_MotorControl_StepClockHandler>
    }
}
 8005eea:	46c0      	nop			; (mov r8, r8)
 8005eec:	46bd      	mov	sp, r7
 8005eee:	b002      	add	sp, #8
 8005ef0:	bd80      	pop	{r7, pc}
	...

08005ef4 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8005ef4:	b580      	push	{r7, lr}
 8005ef6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8005ef8:	4b07      	ldr	r3, [pc, #28]	; (8005f18 <HAL_MspInit+0x24>)
 8005efa:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8005efc:	4b06      	ldr	r3, [pc, #24]	; (8005f18 <HAL_MspInit+0x24>)
 8005efe:	2101      	movs	r1, #1
 8005f00:	430a      	orrs	r2, r1
 8005f02:	635a      	str	r2, [r3, #52]	; 0x34
  __HAL_RCC_PWR_CLK_ENABLE();
 8005f04:	4b04      	ldr	r3, [pc, #16]	; (8005f18 <HAL_MspInit+0x24>)
 8005f06:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8005f08:	4b03      	ldr	r3, [pc, #12]	; (8005f18 <HAL_MspInit+0x24>)
 8005f0a:	2180      	movs	r1, #128	; 0x80
 8005f0c:	0549      	lsls	r1, r1, #21
 8005f0e:	430a      	orrs	r2, r1
 8005f10:	639a      	str	r2, [r3, #56]	; 0x38
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8005f12:	46c0      	nop			; (mov r8, r8)
 8005f14:	46bd      	mov	sp, r7
 8005f16:	bd80      	pop	{r7, pc}
 8005f18:	40021000 	.word	0x40021000

08005f1c <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable Interrupt.
  */
void NMI_Handler(void)
{
 8005f1c:	b580      	push	{r7, lr}
 8005f1e:	af00      	add	r7, sp, #0

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 8005f20:	46c0      	nop			; (mov r8, r8)
 8005f22:	46bd      	mov	sp, r7
 8005f24:	bd80      	pop	{r7, pc}

08005f26 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8005f26:	b580      	push	{r7, lr}
 8005f28:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8005f2a:	e7fe      	b.n	8005f2a <HardFault_Handler+0x4>

08005f2c <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 8005f2c:	b580      	push	{r7, lr}
 8005f2e:	af00      	add	r7, sp, #0

  /* USER CODE END SVC_IRQn 0 */
  /* USER CODE BEGIN SVC_IRQn 1 */

  /* USER CODE END SVC_IRQn 1 */
}
 8005f30:	46c0      	nop			; (mov r8, r8)
 8005f32:	46bd      	mov	sp, r7
 8005f34:	bd80      	pop	{r7, pc}

08005f36 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 8005f36:	b580      	push	{r7, lr}
 8005f38:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 8005f3a:	46c0      	nop			; (mov r8, r8)
 8005f3c:	46bd      	mov	sp, r7
 8005f3e:	bd80      	pop	{r7, pc}

08005f40 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8005f40:	b580      	push	{r7, lr}
 8005f42:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8005f44:	f009 faba 	bl	800f4bc <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8005f48:	46c0      	nop			; (mov r8, r8)
 8005f4a:	46bd      	mov	sp, r7
 8005f4c:	bd80      	pop	{r7, pc}
	...

08005f50 <USART4_5_IRQHandler>:

/**
  * @brief This function handles USART4 and USART5 interrupt.
  */
void USART4_5_IRQHandler(void)
{
 8005f50:	b580      	push	{r7, lr}
 8005f52:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN USART4_5_IRQn 0 */

  /* USER CODE END USART4_5_IRQn 0 */
  HAL_UART_IRQHandler(&huart5);
 8005f54:	4b03      	ldr	r3, [pc, #12]	; (8005f64 <USART4_5_IRQHandler+0x14>)
 8005f56:	0018      	movs	r0, r3
 8005f58:	f00c fa46 	bl	80123e8 <HAL_UART_IRQHandler>
  /* USER CODE BEGIN USART4_5_IRQn 1 */

  /* USER CODE END USART4_5_IRQn 1 */
}
 8005f5c:	46c0      	nop			; (mov r8, r8)
 8005f5e:	46bd      	mov	sp, r7
 8005f60:	bd80      	pop	{r7, pc}
 8005f62:	46c0      	nop			; (mov r8, r8)
 8005f64:	2000317c 	.word	0x2000317c

08005f68 <EXTI4_15_IRQHandler>:
  * @brief  This function handles interrupt for External lines 4 to 15
  * @param  None
  * @retval None
  */
void EXTI4_15_IRQHandler(void)
{
 8005f68:	b580      	push	{r7, lr}
 8005f6a:	af00      	add	r7, sp, #0
//  HAL_GPIO_EXTI_IRQHandler(BSP_MOTOR_CONTROL_BOARD_PIN_EN_AND_FAULT);
//  HAL_GPIO_EXTI_IRQHandler(KEY_BUTTON_PIN);
}
 8005f6c:	46c0      	nop			; (mov r8, r8)
 8005f6e:	46bd      	mov	sp, r7
 8005f70:	bd80      	pop	{r7, pc}
	...

08005f74 <TIM2_IRQHandler>:

void TIM2_IRQHandler(void)
{
 8005f74:	b580      	push	{r7, lr}
 8005f76:	af00      	add	r7, sp, #0
  HAL_TIM_IRQHandler(&hTimerStepClock);
 8005f78:	4b03      	ldr	r3, [pc, #12]	; (8005f88 <TIM2_IRQHandler+0x14>)
 8005f7a:	0018      	movs	r0, r3
 8005f7c:	f00b fcaa 	bl	80118d4 <HAL_TIM_IRQHandler>
}
 8005f80:	46c0      	nop			; (mov r8, r8)
 8005f82:	46bd      	mov	sp, r7
 8005f84:	bd80      	pop	{r7, pc}
 8005f86:	46c0      	nop			; (mov r8, r8)
 8005f88:	200033c8 	.word	0x200033c8

08005f8c <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 8005f8c:	b580      	push	{r7, lr}
 8005f8e:	b086      	sub	sp, #24
 8005f90:	af00      	add	r7, sp, #0
 8005f92:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8005f94:	4a14      	ldr	r2, [pc, #80]	; (8005fe8 <_sbrk+0x5c>)
 8005f96:	4b15      	ldr	r3, [pc, #84]	; (8005fec <_sbrk+0x60>)
 8005f98:	1ad3      	subs	r3, r2, r3
 8005f9a:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 8005f9c:	697b      	ldr	r3, [r7, #20]
 8005f9e:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initalize heap end at first call */
  if (NULL == __sbrk_heap_end)
 8005fa0:	4b13      	ldr	r3, [pc, #76]	; (8005ff0 <_sbrk+0x64>)
 8005fa2:	681b      	ldr	r3, [r3, #0]
 8005fa4:	2b00      	cmp	r3, #0
 8005fa6:	d102      	bne.n	8005fae <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 8005fa8:	4b11      	ldr	r3, [pc, #68]	; (8005ff0 <_sbrk+0x64>)
 8005faa:	4a12      	ldr	r2, [pc, #72]	; (8005ff4 <_sbrk+0x68>)
 8005fac:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 8005fae:	4b10      	ldr	r3, [pc, #64]	; (8005ff0 <_sbrk+0x64>)
 8005fb0:	681a      	ldr	r2, [r3, #0]
 8005fb2:	687b      	ldr	r3, [r7, #4]
 8005fb4:	18d3      	adds	r3, r2, r3
 8005fb6:	693a      	ldr	r2, [r7, #16]
 8005fb8:	429a      	cmp	r2, r3
 8005fba:	d207      	bcs.n	8005fcc <_sbrk+0x40>
  {
    errno = ENOMEM;
 8005fbc:	f00d f8d8 	bl	8013170 <__errno>
 8005fc0:	0003      	movs	r3, r0
 8005fc2:	220c      	movs	r2, #12
 8005fc4:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 8005fc6:	2301      	movs	r3, #1
 8005fc8:	425b      	negs	r3, r3
 8005fca:	e009      	b.n	8005fe0 <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
 8005fcc:	4b08      	ldr	r3, [pc, #32]	; (8005ff0 <_sbrk+0x64>)
 8005fce:	681b      	ldr	r3, [r3, #0]
 8005fd0:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 8005fd2:	4b07      	ldr	r3, [pc, #28]	; (8005ff0 <_sbrk+0x64>)
 8005fd4:	681a      	ldr	r2, [r3, #0]
 8005fd6:	687b      	ldr	r3, [r7, #4]
 8005fd8:	18d2      	adds	r2, r2, r3
 8005fda:	4b05      	ldr	r3, [pc, #20]	; (8005ff0 <_sbrk+0x64>)
 8005fdc:	601a      	str	r2, [r3, #0]

  return (void *)prev_heap_end;
 8005fde:	68fb      	ldr	r3, [r7, #12]
}
 8005fe0:	0018      	movs	r0, r3
 8005fe2:	46bd      	mov	sp, r7
 8005fe4:	b006      	add	sp, #24
 8005fe6:	bd80      	pop	{r7, pc}
 8005fe8:	20005000 	.word	0x20005000
 8005fec:	00000400 	.word	0x00000400
 8005ff0:	20000458 	.word	0x20000458
 8005ff4:	20003448 	.word	0x20003448

08005ff8 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 8005ff8:	b580      	push	{r7, lr}
 8005ffa:	af00      	add	r7, sp, #0
 /*!< Set MSION bit */
  RCC->CR |= (uint32_t)0x00000100;
 8005ffc:	4b17      	ldr	r3, [pc, #92]	; (800605c <SystemInit+0x64>)
 8005ffe:	681a      	ldr	r2, [r3, #0]
 8006000:	4b16      	ldr	r3, [pc, #88]	; (800605c <SystemInit+0x64>)
 8006002:	2180      	movs	r1, #128	; 0x80
 8006004:	0049      	lsls	r1, r1, #1
 8006006:	430a      	orrs	r2, r1
 8006008:	601a      	str	r2, [r3, #0]

  /*!< Reset SW[1:0], HPRE[3:0], PPRE1[2:0], PPRE2[2:0], MCOSEL[2:0] and MCOPRE[2:0] bits */
  RCC->CFGR &= (uint32_t) 0x88FF400C;
 800600a:	4b14      	ldr	r3, [pc, #80]	; (800605c <SystemInit+0x64>)
 800600c:	68da      	ldr	r2, [r3, #12]
 800600e:	4b13      	ldr	r3, [pc, #76]	; (800605c <SystemInit+0x64>)
 8006010:	4913      	ldr	r1, [pc, #76]	; (8006060 <SystemInit+0x68>)
 8006012:	400a      	ands	r2, r1
 8006014:	60da      	str	r2, [r3, #12]
 
  /*!< Reset HSION, HSIDIVEN, HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFF6;
 8006016:	4b11      	ldr	r3, [pc, #68]	; (800605c <SystemInit+0x64>)
 8006018:	681a      	ldr	r2, [r3, #0]
 800601a:	4b10      	ldr	r3, [pc, #64]	; (800605c <SystemInit+0x64>)
 800601c:	4911      	ldr	r1, [pc, #68]	; (8006064 <SystemInit+0x6c>)
 800601e:	400a      	ands	r2, r1
 8006020:	601a      	str	r2, [r3, #0]

  /*!< Reset HSI48ON  bit */
  RCC->CRRCR &= (uint32_t)0xFFFFFFFE;
 8006022:	4b0e      	ldr	r3, [pc, #56]	; (800605c <SystemInit+0x64>)
 8006024:	689a      	ldr	r2, [r3, #8]
 8006026:	4b0d      	ldr	r3, [pc, #52]	; (800605c <SystemInit+0x64>)
 8006028:	2101      	movs	r1, #1
 800602a:	438a      	bics	r2, r1
 800602c:	609a      	str	r2, [r3, #8]

  /*!< Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 800602e:	4b0b      	ldr	r3, [pc, #44]	; (800605c <SystemInit+0x64>)
 8006030:	681a      	ldr	r2, [r3, #0]
 8006032:	4b0a      	ldr	r3, [pc, #40]	; (800605c <SystemInit+0x64>)
 8006034:	490c      	ldr	r1, [pc, #48]	; (8006068 <SystemInit+0x70>)
 8006036:	400a      	ands	r2, r1
 8006038:	601a      	str	r2, [r3, #0]

  /*!< Reset PLLSRC, PLLMUL[3:0] and PLLDIV[1:0] bits */
  RCC->CFGR &= (uint32_t)0xFF02FFFF;
 800603a:	4b08      	ldr	r3, [pc, #32]	; (800605c <SystemInit+0x64>)
 800603c:	68da      	ldr	r2, [r3, #12]
 800603e:	4b07      	ldr	r3, [pc, #28]	; (800605c <SystemInit+0x64>)
 8006040:	490a      	ldr	r1, [pc, #40]	; (800606c <SystemInit+0x74>)
 8006042:	400a      	ands	r2, r1
 8006044:	60da      	str	r2, [r3, #12]

  /*!< Disable all interrupts */
  RCC->CIER = 0x00000000;
 8006046:	4b05      	ldr	r3, [pc, #20]	; (800605c <SystemInit+0x64>)
 8006048:	2200      	movs	r2, #0
 800604a:	611a      	str	r2, [r3, #16]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800604c:	4b08      	ldr	r3, [pc, #32]	; (8006070 <SystemInit+0x78>)
 800604e:	2280      	movs	r2, #128	; 0x80
 8006050:	0512      	lsls	r2, r2, #20
 8006052:	609a      	str	r2, [r3, #8]
#endif
}
 8006054:	46c0      	nop			; (mov r8, r8)
 8006056:	46bd      	mov	sp, r7
 8006058:	bd80      	pop	{r7, pc}
 800605a:	46c0      	nop			; (mov r8, r8)
 800605c:	40021000 	.word	0x40021000
 8006060:	88ff400c 	.word	0x88ff400c
 8006064:	fef6fff6 	.word	0xfef6fff6
 8006068:	fffbffff 	.word	0xfffbffff
 800606c:	ff02ffff 	.word	0xff02ffff
 8006070:	e000ed00 	.word	0xe000ed00

08006074 <MX_USART2_UART_Init>:
UART_HandleTypeDef huart5;

/* USART2 init function */

void MX_USART2_UART_Init(void)
{
 8006074:	b580      	push	{r7, lr}
 8006076:	af00      	add	r7, sp, #0

  huart2.Instance = USART2;
 8006078:	4b14      	ldr	r3, [pc, #80]	; (80060cc <MX_USART2_UART_Init+0x58>)
 800607a:	4a15      	ldr	r2, [pc, #84]	; (80060d0 <MX_USART2_UART_Init+0x5c>)
 800607c:	601a      	str	r2, [r3, #0]
  huart2.Init.BaudRate = 115200;
 800607e:	4b13      	ldr	r3, [pc, #76]	; (80060cc <MX_USART2_UART_Init+0x58>)
 8006080:	22e1      	movs	r2, #225	; 0xe1
 8006082:	0252      	lsls	r2, r2, #9
 8006084:	605a      	str	r2, [r3, #4]
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 8006086:	4b11      	ldr	r3, [pc, #68]	; (80060cc <MX_USART2_UART_Init+0x58>)
 8006088:	2200      	movs	r2, #0
 800608a:	609a      	str	r2, [r3, #8]
  huart2.Init.StopBits = UART_STOPBITS_1;
 800608c:	4b0f      	ldr	r3, [pc, #60]	; (80060cc <MX_USART2_UART_Init+0x58>)
 800608e:	2200      	movs	r2, #0
 8006090:	60da      	str	r2, [r3, #12]
  huart2.Init.Parity = UART_PARITY_NONE;
 8006092:	4b0e      	ldr	r3, [pc, #56]	; (80060cc <MX_USART2_UART_Init+0x58>)
 8006094:	2200      	movs	r2, #0
 8006096:	611a      	str	r2, [r3, #16]
  huart2.Init.Mode = UART_MODE_TX_RX;
 8006098:	4b0c      	ldr	r3, [pc, #48]	; (80060cc <MX_USART2_UART_Init+0x58>)
 800609a:	220c      	movs	r2, #12
 800609c:	615a      	str	r2, [r3, #20]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 800609e:	4b0b      	ldr	r3, [pc, #44]	; (80060cc <MX_USART2_UART_Init+0x58>)
 80060a0:	2200      	movs	r2, #0
 80060a2:	619a      	str	r2, [r3, #24]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 80060a4:	4b09      	ldr	r3, [pc, #36]	; (80060cc <MX_USART2_UART_Init+0x58>)
 80060a6:	2200      	movs	r2, #0
 80060a8:	61da      	str	r2, [r3, #28]
  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 80060aa:	4b08      	ldr	r3, [pc, #32]	; (80060cc <MX_USART2_UART_Init+0x58>)
 80060ac:	2200      	movs	r2, #0
 80060ae:	621a      	str	r2, [r3, #32]
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 80060b0:	4b06      	ldr	r3, [pc, #24]	; (80060cc <MX_USART2_UART_Init+0x58>)
 80060b2:	2200      	movs	r2, #0
 80060b4:	625a      	str	r2, [r3, #36]	; 0x24
  if (HAL_UART_Init(&huart2) != HAL_OK)
 80060b6:	4b05      	ldr	r3, [pc, #20]	; (80060cc <MX_USART2_UART_Init+0x58>)
 80060b8:	0018      	movs	r0, r3
 80060ba:	f00b ffe1 	bl	8012080 <HAL_UART_Init>
 80060be:	1e03      	subs	r3, r0, #0
 80060c0:	d001      	beq.n	80060c6 <MX_USART2_UART_Init+0x52>
  {
    Error_Handler();
 80060c2:	f7ff fe75 	bl	8005db0 <Error_Handler>
  }

}
 80060c6:	46c0      	nop			; (mov r8, r8)
 80060c8:	46bd      	mov	sp, r7
 80060ca:	bd80      	pop	{r7, pc}
 80060cc:	200031fc 	.word	0x200031fc
 80060d0:	40004400 	.word	0x40004400

080060d4 <MX_USART5_UART_Init>:
/* USART5 init function */

void MX_USART5_UART_Init(void)
{
 80060d4:	b580      	push	{r7, lr}
 80060d6:	af00      	add	r7, sp, #0

  huart5.Instance = USART5;
 80060d8:	4b14      	ldr	r3, [pc, #80]	; (800612c <MX_USART5_UART_Init+0x58>)
 80060da:	4a15      	ldr	r2, [pc, #84]	; (8006130 <MX_USART5_UART_Init+0x5c>)
 80060dc:	601a      	str	r2, [r3, #0]
  huart5.Init.BaudRate = 115200;
 80060de:	4b13      	ldr	r3, [pc, #76]	; (800612c <MX_USART5_UART_Init+0x58>)
 80060e0:	22e1      	movs	r2, #225	; 0xe1
 80060e2:	0252      	lsls	r2, r2, #9
 80060e4:	605a      	str	r2, [r3, #4]
  huart5.Init.WordLength = UART_WORDLENGTH_8B;
 80060e6:	4b11      	ldr	r3, [pc, #68]	; (800612c <MX_USART5_UART_Init+0x58>)
 80060e8:	2200      	movs	r2, #0
 80060ea:	609a      	str	r2, [r3, #8]
  huart5.Init.StopBits = UART_STOPBITS_1;
 80060ec:	4b0f      	ldr	r3, [pc, #60]	; (800612c <MX_USART5_UART_Init+0x58>)
 80060ee:	2200      	movs	r2, #0
 80060f0:	60da      	str	r2, [r3, #12]
  huart5.Init.Parity = UART_PARITY_NONE;
 80060f2:	4b0e      	ldr	r3, [pc, #56]	; (800612c <MX_USART5_UART_Init+0x58>)
 80060f4:	2200      	movs	r2, #0
 80060f6:	611a      	str	r2, [r3, #16]
  huart5.Init.Mode = UART_MODE_TX_RX;
 80060f8:	4b0c      	ldr	r3, [pc, #48]	; (800612c <MX_USART5_UART_Init+0x58>)
 80060fa:	220c      	movs	r2, #12
 80060fc:	615a      	str	r2, [r3, #20]
  huart5.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 80060fe:	4b0b      	ldr	r3, [pc, #44]	; (800612c <MX_USART5_UART_Init+0x58>)
 8006100:	2200      	movs	r2, #0
 8006102:	619a      	str	r2, [r3, #24]
  huart5.Init.OverSampling = UART_OVERSAMPLING_16;
 8006104:	4b09      	ldr	r3, [pc, #36]	; (800612c <MX_USART5_UART_Init+0x58>)
 8006106:	2200      	movs	r2, #0
 8006108:	61da      	str	r2, [r3, #28]
  huart5.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 800610a:	4b08      	ldr	r3, [pc, #32]	; (800612c <MX_USART5_UART_Init+0x58>)
 800610c:	2200      	movs	r2, #0
 800610e:	621a      	str	r2, [r3, #32]
  huart5.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8006110:	4b06      	ldr	r3, [pc, #24]	; (800612c <MX_USART5_UART_Init+0x58>)
 8006112:	2200      	movs	r2, #0
 8006114:	625a      	str	r2, [r3, #36]	; 0x24
  if (HAL_UART_Init(&huart5) != HAL_OK)
 8006116:	4b05      	ldr	r3, [pc, #20]	; (800612c <MX_USART5_UART_Init+0x58>)
 8006118:	0018      	movs	r0, r3
 800611a:	f00b ffb1 	bl	8012080 <HAL_UART_Init>
 800611e:	1e03      	subs	r3, r0, #0
 8006120:	d001      	beq.n	8006126 <MX_USART5_UART_Init+0x52>
  {
    Error_Handler();
 8006122:	f7ff fe45 	bl	8005db0 <Error_Handler>
  }

}
 8006126:	46c0      	nop			; (mov r8, r8)
 8006128:	46bd      	mov	sp, r7
 800612a:	bd80      	pop	{r7, pc}
 800612c:	2000317c 	.word	0x2000317c
 8006130:	40005000 	.word	0x40005000

08006134 <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 8006134:	b590      	push	{r4, r7, lr}
 8006136:	b08b      	sub	sp, #44	; 0x2c
 8006138:	af00      	add	r7, sp, #0
 800613a:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800613c:	2314      	movs	r3, #20
 800613e:	18fb      	adds	r3, r7, r3
 8006140:	0018      	movs	r0, r3
 8006142:	2314      	movs	r3, #20
 8006144:	001a      	movs	r2, r3
 8006146:	2100      	movs	r1, #0
 8006148:	f00d f845 	bl	80131d6 <memset>
  if(uartHandle->Instance==USART2)
 800614c:	687b      	ldr	r3, [r7, #4]
 800614e:	681b      	ldr	r3, [r3, #0]
 8006150:	4a45      	ldr	r2, [pc, #276]	; (8006268 <HAL_UART_MspInit+0x134>)
 8006152:	4293      	cmp	r3, r2
 8006154:	d12a      	bne.n	80061ac <HAL_UART_MspInit+0x78>
  {
  /* USER CODE BEGIN USART2_MspInit 0 */

  /* USER CODE END USART2_MspInit 0 */
    /* USART2 clock enable */
    __HAL_RCC_USART2_CLK_ENABLE();
 8006156:	4b45      	ldr	r3, [pc, #276]	; (800626c <HAL_UART_MspInit+0x138>)
 8006158:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800615a:	4b44      	ldr	r3, [pc, #272]	; (800626c <HAL_UART_MspInit+0x138>)
 800615c:	2180      	movs	r1, #128	; 0x80
 800615e:	0289      	lsls	r1, r1, #10
 8006160:	430a      	orrs	r2, r1
 8006162:	639a      	str	r2, [r3, #56]	; 0x38

    __HAL_RCC_GPIOA_CLK_ENABLE();
 8006164:	4b41      	ldr	r3, [pc, #260]	; (800626c <HAL_UART_MspInit+0x138>)
 8006166:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8006168:	4b40      	ldr	r3, [pc, #256]	; (800626c <HAL_UART_MspInit+0x138>)
 800616a:	2101      	movs	r1, #1
 800616c:	430a      	orrs	r2, r1
 800616e:	62da      	str	r2, [r3, #44]	; 0x2c
 8006170:	4b3e      	ldr	r3, [pc, #248]	; (800626c <HAL_UART_MspInit+0x138>)
 8006172:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006174:	2201      	movs	r2, #1
 8006176:	4013      	ands	r3, r2
 8006178:	613b      	str	r3, [r7, #16]
 800617a:	693b      	ldr	r3, [r7, #16]
    /**USART2 GPIO Configuration
    PA2     ------> USART2_TX
    PA3     ------> USART2_RX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
 800617c:	2114      	movs	r1, #20
 800617e:	187b      	adds	r3, r7, r1
 8006180:	220c      	movs	r2, #12
 8006182:	601a      	str	r2, [r3, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006184:	187b      	adds	r3, r7, r1
 8006186:	2202      	movs	r2, #2
 8006188:	605a      	str	r2, [r3, #4]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800618a:	187b      	adds	r3, r7, r1
 800618c:	2200      	movs	r2, #0
 800618e:	609a      	str	r2, [r3, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8006190:	187b      	adds	r3, r7, r1
 8006192:	2203      	movs	r2, #3
 8006194:	60da      	str	r2, [r3, #12]
    GPIO_InitStruct.Alternate = GPIO_AF4_USART2;
 8006196:	187b      	adds	r3, r7, r1
 8006198:	2204      	movs	r2, #4
 800619a:	611a      	str	r2, [r3, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800619c:	187a      	adds	r2, r7, r1
 800619e:	23a0      	movs	r3, #160	; 0xa0
 80061a0:	05db      	lsls	r3, r3, #23
 80061a2:	0011      	movs	r1, r2
 80061a4:	0018      	movs	r0, r3
 80061a6:	f009 fb39 	bl	800f81c <HAL_GPIO_Init>
    HAL_NVIC_EnableIRQ(USART4_5_IRQn);
  /* USER CODE BEGIN USART5_MspInit 1 */

  /* USER CODE END USART5_MspInit 1 */
  }
}
 80061aa:	e059      	b.n	8006260 <HAL_UART_MspInit+0x12c>
  else if(uartHandle->Instance==USART5)
 80061ac:	687b      	ldr	r3, [r7, #4]
 80061ae:	681b      	ldr	r3, [r3, #0]
 80061b0:	4a2f      	ldr	r2, [pc, #188]	; (8006270 <HAL_UART_MspInit+0x13c>)
 80061b2:	4293      	cmp	r3, r2
 80061b4:	d154      	bne.n	8006260 <HAL_UART_MspInit+0x12c>
    __HAL_RCC_USART5_CLK_ENABLE();
 80061b6:	4b2d      	ldr	r3, [pc, #180]	; (800626c <HAL_UART_MspInit+0x138>)
 80061b8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80061ba:	4b2c      	ldr	r3, [pc, #176]	; (800626c <HAL_UART_MspInit+0x138>)
 80061bc:	2180      	movs	r1, #128	; 0x80
 80061be:	0349      	lsls	r1, r1, #13
 80061c0:	430a      	orrs	r2, r1
 80061c2:	639a      	str	r2, [r3, #56]	; 0x38
    __HAL_RCC_GPIOC_CLK_ENABLE();
 80061c4:	4b29      	ldr	r3, [pc, #164]	; (800626c <HAL_UART_MspInit+0x138>)
 80061c6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80061c8:	4b28      	ldr	r3, [pc, #160]	; (800626c <HAL_UART_MspInit+0x138>)
 80061ca:	2104      	movs	r1, #4
 80061cc:	430a      	orrs	r2, r1
 80061ce:	62da      	str	r2, [r3, #44]	; 0x2c
 80061d0:	4b26      	ldr	r3, [pc, #152]	; (800626c <HAL_UART_MspInit+0x138>)
 80061d2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80061d4:	2204      	movs	r2, #4
 80061d6:	4013      	ands	r3, r2
 80061d8:	60fb      	str	r3, [r7, #12]
 80061da:	68fb      	ldr	r3, [r7, #12]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80061dc:	4b23      	ldr	r3, [pc, #140]	; (800626c <HAL_UART_MspInit+0x138>)
 80061de:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80061e0:	4b22      	ldr	r3, [pc, #136]	; (800626c <HAL_UART_MspInit+0x138>)
 80061e2:	2108      	movs	r1, #8
 80061e4:	430a      	orrs	r2, r1
 80061e6:	62da      	str	r2, [r3, #44]	; 0x2c
 80061e8:	4b20      	ldr	r3, [pc, #128]	; (800626c <HAL_UART_MspInit+0x138>)
 80061ea:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80061ec:	2208      	movs	r2, #8
 80061ee:	4013      	ands	r3, r2
 80061f0:	60bb      	str	r3, [r7, #8]
 80061f2:	68bb      	ldr	r3, [r7, #8]
    GPIO_InitStruct.Pin = GPIO_PIN_12;
 80061f4:	2114      	movs	r1, #20
 80061f6:	187b      	adds	r3, r7, r1
 80061f8:	2280      	movs	r2, #128	; 0x80
 80061fa:	0152      	lsls	r2, r2, #5
 80061fc:	601a      	str	r2, [r3, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80061fe:	187b      	adds	r3, r7, r1
 8006200:	2202      	movs	r2, #2
 8006202:	605a      	str	r2, [r3, #4]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8006204:	187b      	adds	r3, r7, r1
 8006206:	2200      	movs	r2, #0
 8006208:	609a      	str	r2, [r3, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800620a:	187b      	adds	r3, r7, r1
 800620c:	2203      	movs	r2, #3
 800620e:	60da      	str	r2, [r3, #12]
    GPIO_InitStruct.Alternate = GPIO_AF2_USART5;
 8006210:	187b      	adds	r3, r7, r1
 8006212:	2202      	movs	r2, #2
 8006214:	611a      	str	r2, [r3, #16]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8006216:	000c      	movs	r4, r1
 8006218:	187b      	adds	r3, r7, r1
 800621a:	4a16      	ldr	r2, [pc, #88]	; (8006274 <HAL_UART_MspInit+0x140>)
 800621c:	0019      	movs	r1, r3
 800621e:	0010      	movs	r0, r2
 8006220:	f009 fafc 	bl	800f81c <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 8006224:	0021      	movs	r1, r4
 8006226:	187b      	adds	r3, r7, r1
 8006228:	2204      	movs	r2, #4
 800622a:	601a      	str	r2, [r3, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800622c:	187b      	adds	r3, r7, r1
 800622e:	2202      	movs	r2, #2
 8006230:	605a      	str	r2, [r3, #4]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8006232:	187b      	adds	r3, r7, r1
 8006234:	2200      	movs	r2, #0
 8006236:	609a      	str	r2, [r3, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8006238:	187b      	adds	r3, r7, r1
 800623a:	2203      	movs	r2, #3
 800623c:	60da      	str	r2, [r3, #12]
    GPIO_InitStruct.Alternate = GPIO_AF6_USART5;
 800623e:	187b      	adds	r3, r7, r1
 8006240:	2206      	movs	r2, #6
 8006242:	611a      	str	r2, [r3, #16]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8006244:	187b      	adds	r3, r7, r1
 8006246:	4a0c      	ldr	r2, [pc, #48]	; (8006278 <HAL_UART_MspInit+0x144>)
 8006248:	0019      	movs	r1, r3
 800624a:	0010      	movs	r0, r2
 800624c:	f009 fae6 	bl	800f81c <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(USART4_5_IRQn, 0, 0);
 8006250:	2200      	movs	r2, #0
 8006252:	2100      	movs	r1, #0
 8006254:	200e      	movs	r0, #14
 8006256:	f009 fa47 	bl	800f6e8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART4_5_IRQn);
 800625a:	200e      	movs	r0, #14
 800625c:	f009 fa59 	bl	800f712 <HAL_NVIC_EnableIRQ>
}
 8006260:	46c0      	nop			; (mov r8, r8)
 8006262:	46bd      	mov	sp, r7
 8006264:	b00b      	add	sp, #44	; 0x2c
 8006266:	bd90      	pop	{r4, r7, pc}
 8006268:	40004400 	.word	0x40004400
 800626c:	40021000 	.word	0x40021000
 8006270:	40005000 	.word	0x40005000
 8006274:	50000800 	.word	0x50000800
 8006278:	50000c00 	.word	0x50000c00

0800627c <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
   ldr   r0, =_estack
 800627c:	480d      	ldr	r0, [pc, #52]	; (80062b4 <LoopForever+0x2>)
   mov   sp, r0          /* set stack pointer */
 800627e:	4685      	mov	sp, r0

/* Copy the data segment initializers from flash to SRAM */
  movs  r1, #0
 8006280:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 8006282:	e003      	b.n	800628c <LoopCopyDataInit>

08006284 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 8006284:	4b0c      	ldr	r3, [pc, #48]	; (80062b8 <LoopForever+0x6>)
  ldr  r3, [r3, r1]
 8006286:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 8006288:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 800628a:	3104      	adds	r1, #4

0800628c <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr  r0, =_sdata
 800628c:	480b      	ldr	r0, [pc, #44]	; (80062bc <LoopForever+0xa>)
  ldr  r3, =_edata
 800628e:	4b0c      	ldr	r3, [pc, #48]	; (80062c0 <LoopForever+0xe>)
  adds  r2, r0, r1
 8006290:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 8006292:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 8006294:	d3f6      	bcc.n	8006284 <CopyDataInit>
  ldr  r2, =_sbss
 8006296:	4a0b      	ldr	r2, [pc, #44]	; (80062c4 <LoopForever+0x12>)
  b  LoopFillZerobss
 8006298:	e002      	b.n	80062a0 <LoopFillZerobss>

0800629a <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs  r3, #0
 800629a:	2300      	movs	r3, #0
  str  r3, [r2]
 800629c:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 800629e:	3204      	adds	r2, #4

080062a0 <LoopFillZerobss>:


LoopFillZerobss:
  ldr  r3, = _ebss
 80062a0:	4b09      	ldr	r3, [pc, #36]	; (80062c8 <LoopForever+0x16>)
  cmp  r2, r3
 80062a2:	429a      	cmp	r2, r3
  bcc  FillZerobss
 80062a4:	d3f9      	bcc.n	800629a <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit
 80062a6:	f7ff fea7 	bl	8005ff8 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 80062aa:	f00c ff67 	bl	801317c <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 80062ae:	f7fe ff07 	bl	80050c0 <main>

080062b2 <LoopForever>:

LoopForever:
    b LoopForever
 80062b2:	e7fe      	b.n	80062b2 <LoopForever>
   ldr   r0, =_estack
 80062b4:	20005000 	.word	0x20005000
  ldr  r3, =_sidata
 80062b8:	08015438 	.word	0x08015438
  ldr  r0, =_sdata
 80062bc:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 80062c0:	20000438 	.word	0x20000438
  ldr  r2, =_sbss
 80062c4:	20000438 	.word	0x20000438
  ldr  r3, = _ebss
 80062c8:	20003448 	.word	0x20003448

080062cc <ADC1_COMP_IRQHandler>:
 * @retval : None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 80062cc:	e7fe      	b.n	80062cc <ADC1_COMP_IRQHandler>
	...

080062d0 <Stspin220_GetMotorHandle>:
/******************************************************//**
 * @brief Return motor handle (pointer to the STSPIN220 motor driver structure)
 * @retval Pointer to the motorDrv_t structure
 **********************************************************/
motorDrv_t* Stspin220_GetMotorHandle(void)
{
 80062d0:	b580      	push	{r7, lr}
 80062d2:	af00      	add	r7, sp, #0
  return (&stspin220Drv);
 80062d4:	4b01      	ldr	r3, [pc, #4]	; (80062dc <Stspin220_GetMotorHandle+0xc>)
}
 80062d6:	0018      	movs	r0, r3
 80062d8:	46bd      	mov	sp, r7
 80062da:	bd80      	pop	{r7, pc}
 80062dc:	200000dc 	.word	0x200000dc

080062e0 <Stspin220_Init>:
 * @brief Start the STSPIN220 library
 * @param[in] pInit pointer to the initialization data
 * @retval None
 **********************************************************/
void Stspin220_Init(void* pInit)
{
 80062e0:	b580      	push	{r7, lr}
 80062e2:	b082      	sub	sp, #8
 80062e4:	af00      	add	r7, sp, #0
 80062e6:	6078      	str	r0, [r7, #4]
  stspin220DriverInstance++;
 80062e8:	4b0c      	ldr	r3, [pc, #48]	; (800631c <Stspin220_Init+0x3c>)
 80062ea:	881b      	ldrh	r3, [r3, #0]
 80062ec:	3301      	adds	r3, #1
 80062ee:	b29a      	uxth	r2, r3
 80062f0:	4b0a      	ldr	r3, [pc, #40]	; (800631c <Stspin220_Init+0x3c>)
 80062f2:	801a      	strh	r2, [r3, #0]
  
  /* Initialise the GPIOs */
  Stspin220_Board_GpioInit();
 80062f4:	f008 f9a0 	bl	800e638 <Stspin220_Board_GpioInit>

  /* Initialise the timer used for the step clock and ------------------------*/
  /* the PWM for the reference voltage generation ----------------------------*/
  Stspin220_Board_TimStckInit();
 80062f8:	f008 fb10 	bl	800e91c <Stspin220_Board_TimStckInit>
  Stspin220_Board_PwmRefInit();
 80062fc:	f008 fad2 	bl	800e8a4 <Stspin220_Board_PwmRefInit>

  if (pInit == 0)
 8006300:	687b      	ldr	r3, [r7, #4]
 8006302:	2b00      	cmp	r3, #0
 8006304:	d102      	bne.n	800630c <Stspin220_Init+0x2c>
  {
    /* Set all context variables to the predefined values */
    /* from stspin220_target_config.h */
    Stspin220_SetDeviceParamsToPredefinedValues();
 8006306:	f001 f989 	bl	800761c <Stspin220_SetDeviceParamsToPredefinedValues>
  }
  else
  {
    Stspin220_SetDeviceParamsToGivenValues((Stspin220_Init_t*) pInit);
  }
}
 800630a:	e003      	b.n	8006314 <Stspin220_Init+0x34>
    Stspin220_SetDeviceParamsToGivenValues((Stspin220_Init_t*) pInit);
 800630c:	687b      	ldr	r3, [r7, #4]
 800630e:	0018      	movs	r0, r3
 8006310:	f001 f8f0 	bl	80074f4 <Stspin220_SetDeviceParamsToGivenValues>
}
 8006314:	46c0      	nop			; (mov r8, r8)
 8006316:	46bd      	mov	sp, r7
 8006318:	b002      	add	sp, #8
 800631a:	bd80      	pop	{r7, pc}
 800631c:	2000045c 	.word	0x2000045c

08006320 <Stspin220_ReadId>:
/******************************************************//**
 * @brief Read id
 * @retval Id of the stspin220 Driver Instance
 **********************************************************/
uint16_t Stspin220_ReadId(void)
{
 8006320:	b580      	push	{r7, lr}
 8006322:	af00      	add	r7, sp, #0
  return (stspin220DriverInstance);
 8006324:	4b02      	ldr	r3, [pc, #8]	; (8006330 <Stspin220_ReadId+0x10>)
 8006326:	881b      	ldrh	r3, [r3, #0]
}
 8006328:	0018      	movs	r0, r3
 800632a:	46bd      	mov	sp, r7
 800632c:	bd80      	pop	{r7, pc}
 800632e:	46c0      	nop			; (mov r8, r8)
 8006330:	2000045c 	.word	0x2000045c

08006334 <Stspin220_AttachErrorHandler>:
 * @param[in] callback Name of the callback to attach 
 * to the error Hanlder
 * @retval None
 **********************************************************/
void Stspin220_AttachErrorHandler(void (*callback)(uint16_t))
{
 8006334:	b580      	push	{r7, lr}
 8006336:	b082      	sub	sp, #8
 8006338:	af00      	add	r7, sp, #0
 800633a:	6078      	str	r0, [r7, #4]
  errorHandlerCallback = (void (*)(uint16_t))callback;
 800633c:	4b03      	ldr	r3, [pc, #12]	; (800634c <Stspin220_AttachErrorHandler+0x18>)
 800633e:	687a      	ldr	r2, [r7, #4]
 8006340:	601a      	str	r2, [r3, #0]
}
 8006342:	46c0      	nop			; (mov r8, r8)
 8006344:	46bd      	mov	sp, r7
 8006346:	b002      	add	sp, #8
 8006348:	bd80      	pop	{r7, pc}
 800634a:	46c0      	nop			; (mov r8, r8)
 800634c:	200032bc 	.word	0x200032bc

08006350 <Stspin220_AttachFlagInterrupt>:
 * @param[in] callback Name of the callback to attach 
 * to the Flag Interrupt
 * @retval None
 **********************************************************/
void Stspin220_AttachFlagInterrupt(void (*callback)(void))
{
 8006350:	b580      	push	{r7, lr}
 8006352:	b082      	sub	sp, #8
 8006354:	af00      	add	r7, sp, #0
 8006356:	6078      	str	r0, [r7, #4]
  flagInterruptCallback = (void (*)())callback;
 8006358:	4b03      	ldr	r3, [pc, #12]	; (8006368 <Stspin220_AttachFlagInterrupt+0x18>)
 800635a:	687a      	ldr	r2, [r7, #4]
 800635c:	601a      	str	r2, [r3, #0]
}
 800635e:	46c0      	nop			; (mov r8, r8)
 8006360:	46bd      	mov	sp, r7
 8006362:	b002      	add	sp, #8
 8006364:	bd80      	pop	{r7, pc}
 8006366:	46c0      	nop			; (mov r8, r8)
 8006368:	200032c0 	.word	0x200032c0

0800636c <Stspin220_CheckStatusHw>:
/******************************************************//**
 * @brief Check if STSPIN220 has a fault by reading EN pin position.
 * @retval One if STSPIN220 has EN pin down, otherwise zero
 **********************************************************/
uint8_t Stspin220_CheckStatusHw(void)
{
 800636c:	b580      	push	{r7, lr}
 800636e:	af00      	add	r7, sp, #0
	if(!Stspin220_Board_EN_AND_FAULT_PIN_GetState())
 8006370:	f008 fbfa 	bl	800eb68 <Stspin220_Board_EN_AND_FAULT_PIN_GetState>
 8006374:	1e03      	subs	r3, r0, #0
 8006376:	d101      	bne.n	800637c <Stspin220_CheckStatusHw+0x10>
  {
    return 0x01;
 8006378:	2301      	movs	r3, #1
 800637a:	e000      	b.n	800637e <Stspin220_CheckStatusHw+0x12>
  }
  else
  {
    return 0x00;
 800637c:	2300      	movs	r3, #0
  }
}
 800637e:	0018      	movs	r0, r3
 8006380:	46bd      	mov	sp, r7
 8006382:	bd80      	pop	{r7, pc}

08006384 <Stspin220_Disable>:
 * @brief Disable the power bridges (leave the output bridges HiZ)
 * @param[in] deviceId Unused parameter
 * @retval None
 **********************************************************/
void Stspin220_Disable(uint8_t deviceId)
{
 8006384:	b580      	push	{r7, lr}
 8006386:	b082      	sub	sp, #8
 8006388:	af00      	add	r7, sp, #0
 800638a:	0002      	movs	r2, r0
 800638c:	1dfb      	adds	r3, r7, #7
 800638e:	701a      	strb	r2, [r3, #0]
  Stspin220_Board_Disable();
 8006390:	f008 fb80 	bl	800ea94 <Stspin220_Board_Disable>
}
 8006394:	46c0      	nop			; (mov r8, r8)
 8006396:	46bd      	mov	sp, r7
 8006398:	b002      	add	sp, #8
 800639a:	bd80      	pop	{r7, pc}

0800639c <Stspin220_Enable>:
 * @brief Enable the power bridges
 * @param[in] deviceId Unused parameter
 * @retval None
 **********************************************************/
void Stspin220_Enable(uint8_t deviceId)
{
 800639c:	b580      	push	{r7, lr}
 800639e:	b082      	sub	sp, #8
 80063a0:	af00      	add	r7, sp, #0
 80063a2:	0002      	movs	r2, r0
 80063a4:	1dfb      	adds	r3, r7, #7
 80063a6:	701a      	strb	r2, [r3, #0]
  Stspin220_Board_Enable();
 80063a8:	f008 fba0 	bl	800eaec <Stspin220_Board_Enable>
}
 80063ac:	46c0      	nop			; (mov r8, r8)
 80063ae:	46bd      	mov	sp, r7
 80063b0:	b002      	add	sp, #8
 80063b2:	bd80      	pop	{r7, pc}

080063b4 <Stspin220_ErrorHandler>:
 * @brief Error handler which calls the user callback (if defined)
 * @param[in] error Number of the error
 * @retval None
 **********************************************************/
void Stspin220_ErrorHandler(uint16_t error)
{
 80063b4:	b580      	push	{r7, lr}
 80063b6:	b082      	sub	sp, #8
 80063b8:	af00      	add	r7, sp, #0
 80063ba:	0002      	movs	r2, r0
 80063bc:	1dbb      	adds	r3, r7, #6
 80063be:	801a      	strh	r2, [r3, #0]
  if (errorHandlerCallback != 0)
 80063c0:	4b07      	ldr	r3, [pc, #28]	; (80063e0 <Stspin220_ErrorHandler+0x2c>)
 80063c2:	681b      	ldr	r3, [r3, #0]
 80063c4:	2b00      	cmp	r3, #0
 80063c6:	d006      	beq.n	80063d6 <Stspin220_ErrorHandler+0x22>
  {
    (void) errorHandlerCallback(error);
 80063c8:	4b05      	ldr	r3, [pc, #20]	; (80063e0 <Stspin220_ErrorHandler+0x2c>)
 80063ca:	681b      	ldr	r3, [r3, #0]
 80063cc:	1dba      	adds	r2, r7, #6
 80063ce:	8812      	ldrh	r2, [r2, #0]
 80063d0:	0010      	movs	r0, r2
 80063d2:	4798      	blx	r3
    while(1)
    {
      /* Infinite loop */
    }
  }
}
 80063d4:	e000      	b.n	80063d8 <Stspin220_ErrorHandler+0x24>
    while(1)
 80063d6:	e7fe      	b.n	80063d6 <Stspin220_ErrorHandler+0x22>
}
 80063d8:	46bd      	mov	sp, r7
 80063da:	b002      	add	sp, #8
 80063dc:	bd80      	pop	{r7, pc}
 80063de:	46c0      	nop			; (mov r8, r8)
 80063e0:	200032bc 	.word	0x200032bc

080063e4 <Stspin220_ExitDeviceFromStandby>:
 * @brief Exit STSPIN220 device from standby (low power consumption)
 * @param[in] deviceId Unused parameter
 * @retval None
 **********************************************************/
void Stspin220_ExitDeviceFromStandby(uint8_t deviceId)
{
 80063e4:	b580      	push	{r7, lr}
 80063e6:	b084      	sub	sp, #16
 80063e8:	af00      	add	r7, sp, #0
 80063ea:	0002      	movs	r2, r0
 80063ec:	1dfb      	adds	r3, r7, #7
 80063ee:	701a      	strb	r2, [r3, #0]
  uint32_t sequencerPosition = devicePrm.sequencerPosition;
 80063f0:	4b1e      	ldr	r3, [pc, #120]	; (800646c <Stspin220_ExitDeviceFromStandby+0x88>)
 80063f2:	891b      	ldrh	r3, [r3, #8]
 80063f4:	b21b      	sxth	r3, r3
 80063f6:	60fb      	str	r3, [r7, #12]
  
  /* Exit standby and set step mode */
  Stspin220_SetStepModeWithoutReset(0, devicePrm.stepMode);
 80063f8:	4b1c      	ldr	r3, [pc, #112]	; (800646c <Stspin220_ExitDeviceFromStandby+0x88>)
 80063fa:	223d      	movs	r2, #61	; 0x3d
 80063fc:	5c9b      	ldrb	r3, [r3, r2]
 80063fe:	b2db      	uxtb	r3, r3
 8006400:	0019      	movs	r1, r3
 8006402:	2000      	movs	r0, #0
 8006404:	f001 f98e 	bl	8007724 <Stspin220_SetStepModeWithoutReset>
  
  if (devicePrm.sequencerPosition != 0)
 8006408:	4b18      	ldr	r3, [pc, #96]	; (800646c <Stspin220_ExitDeviceFromStandby+0x88>)
 800640a:	891b      	ldrh	r3, [r3, #8]
 800640c:	b21b      	sxth	r3, r3
 800640e:	2b00      	cmp	r3, #0
 8006410:	d024      	beq.n	800645c <Stspin220_ExitDeviceFromStandby+0x78>
  {
    /* Set direction to FORWARD to ensure the HW sequencer is increased at */
    /* each step clock rising edge */
    Stspin220_SetDirection(0, FORWARD);
 8006412:	2101      	movs	r1, #1
 8006414:	2000      	movs	r0, #0
 8006416:	f000 fc13 	bl	8006c40 <Stspin220_SetDirection>
    /* Going out of standby */
    devicePrm.motionState = STANDBYTOINACTIVE;
 800641a:	4b14      	ldr	r3, [pc, #80]	; (800646c <Stspin220_ExitDeviceFromStandby+0x88>)
 800641c:	223c      	movs	r2, #60	; 0x3c
 800641e:	210a      	movs	r1, #10
 8006420:	5499      	strb	r1, [r3, r2]
    /* Initialize the step clock timer */
    Stspin220_Board_TimStckInit();
 8006422:	f008 fa7b 	bl	800e91c <Stspin220_Board_TimStckInit>
    /* Program the step clock */    
    Stspin220_Board_TimStckCompareInit();
 8006426:	f008 f9b9 	bl	800e79c <Stspin220_Board_TimStckCompareInit>
    Stspin220_Board_TimStckSetFreq(STSPIN220_MAX_STCK_FREQ);
 800642a:	4b11      	ldr	r3, [pc, #68]	; (8006470 <Stspin220_ExitDeviceFromStandby+0x8c>)
 800642c:	0018      	movs	r0, r3
 800642e:	f008 f9c3 	bl	800e7b8 <Stspin220_Board_TimStckSetFreq>
    toggleOdd = 0;
 8006432:	4b10      	ldr	r3, [pc, #64]	; (8006474 <Stspin220_ExitDeviceFromStandby+0x90>)
 8006434:	2200      	movs	r2, #0
 8006436:	701a      	strb	r2, [r3, #0]
    Stspin220_Board_TimStckStart();
 8006438:	f008 f98c 	bl	800e754 <Stspin220_Board_TimStckStart>
    while (devicePrm.sequencerPosition != 0);
 800643c:	46c0      	nop			; (mov r8, r8)
 800643e:	4b0b      	ldr	r3, [pc, #44]	; (800646c <Stspin220_ExitDeviceFromStandby+0x88>)
 8006440:	891b      	ldrh	r3, [r3, #8]
 8006442:	b21b      	sxth	r3, r3
 8006444:	2b00      	cmp	r3, #0
 8006446:	d1fa      	bne.n	800643e <Stspin220_ExitDeviceFromStandby+0x5a>
    while (toggleOdd!=0);
 8006448:	46c0      	nop			; (mov r8, r8)
 800644a:	4b0a      	ldr	r3, [pc, #40]	; (8006474 <Stspin220_ExitDeviceFromStandby+0x90>)
 800644c:	781b      	ldrb	r3, [r3, #0]
 800644e:	b2db      	uxtb	r3, r3
 8006450:	2b00      	cmp	r3, #0
 8006452:	d1fa      	bne.n	800644a <Stspin220_ExitDeviceFromStandby+0x66>
    devicePrm.sequencerPosition = sequencerPosition;    
 8006454:	68fb      	ldr	r3, [r7, #12]
 8006456:	b21a      	sxth	r2, r3
 8006458:	4b04      	ldr	r3, [pc, #16]	; (800646c <Stspin220_ExitDeviceFromStandby+0x88>)
 800645a:	811a      	strh	r2, [r3, #8]
  }
  
  devicePrm.motionState = INACTIVE;
 800645c:	4b03      	ldr	r3, [pc, #12]	; (800646c <Stspin220_ExitDeviceFromStandby+0x88>)
 800645e:	223c      	movs	r2, #60	; 0x3c
 8006460:	2108      	movs	r1, #8
 8006462:	5499      	strb	r1, [r3, r2]
}
 8006464:	46c0      	nop			; (mov r8, r8)
 8006466:	46bd      	mov	sp, r7
 8006468:	b004      	add	sp, #16
 800646a:	bd80      	pop	{r7, pc}
 800646c:	2000327c 	.word	0x2000327c
 8006470:	00002710 	.word	0x00002710
 8006474:	2000045f 	.word	0x2000045f

08006478 <Stspin220_GetAcceleration>:
 * @brief Return the acceleration of the specified device
 * @param[in] deviceId Unused parameter
 * @retval Acceleration in pps^2
 **********************************************************/
uint16_t Stspin220_GetAcceleration(uint8_t deviceId)
{                                                  
 8006478:	b580      	push	{r7, lr}
 800647a:	b082      	sub	sp, #8
 800647c:	af00      	add	r7, sp, #0
 800647e:	0002      	movs	r2, r0
 8006480:	1dfb      	adds	r3, r7, #7
 8006482:	701a      	strb	r2, [r3, #0]
  return (devicePrm.acceleration);
 8006484:	4b03      	ldr	r3, [pc, #12]	; (8006494 <Stspin220_GetAcceleration+0x1c>)
 8006486:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 8006488:	b29b      	uxth	r3, r3
}            
 800648a:	0018      	movs	r0, r3
 800648c:	46bd      	mov	sp, r7
 800648e:	b002      	add	sp, #8
 8006490:	bd80      	pop	{r7, pc}
 8006492:	46c0      	nop			; (mov r8, r8)
 8006494:	2000327c 	.word	0x2000327c

08006498 <Stspin220_GetCurrentSpeed>:
 * @brief Return the current speed of the specified device
 * @param[in] deviceId Unused parameter
 * @retval Speed in pps
 **********************************************************/
uint16_t Stspin220_GetCurrentSpeed(uint8_t deviceId)
{
 8006498:	b580      	push	{r7, lr}
 800649a:	b082      	sub	sp, #8
 800649c:	af00      	add	r7, sp, #0
 800649e:	0002      	movs	r2, r0
 80064a0:	1dfb      	adds	r3, r7, #7
 80064a2:	701a      	strb	r2, [r3, #0]
  return devicePrm.speed;
 80064a4:	4b03      	ldr	r3, [pc, #12]	; (80064b4 <Stspin220_GetCurrentSpeed+0x1c>)
 80064a6:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 80064a8:	b29b      	uxth	r3, r3
}
 80064aa:	0018      	movs	r0, r3
 80064ac:	46bd      	mov	sp, r7
 80064ae:	b002      	add	sp, #8
 80064b0:	bd80      	pop	{r7, pc}
 80064b2:	46c0      	nop			; (mov r8, r8)
 80064b4:	2000327c 	.word	0x2000327c

080064b8 <Stspin220_GetDeceleration>:
 * @brief Return the deceleration of the specified device
 * @param[in] deviceId Unused parameter
 * @retval Deceleration in pps^2
 **********************************************************/
uint16_t Stspin220_GetDeceleration(uint8_t deviceId)
{                                                  
 80064b8:	b580      	push	{r7, lr}
 80064ba:	b082      	sub	sp, #8
 80064bc:	af00      	add	r7, sp, #0
 80064be:	0002      	movs	r2, r0
 80064c0:	1dfb      	adds	r3, r7, #7
 80064c2:	701a      	strb	r2, [r3, #0]
  return (devicePrm.deceleration);
 80064c4:	4b03      	ldr	r3, [pc, #12]	; (80064d4 <Stspin220_GetDeceleration+0x1c>)
 80064c6:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 80064c8:	b29b      	uxth	r3, r3
}          
 80064ca:	0018      	movs	r0, r3
 80064cc:	46bd      	mov	sp, r7
 80064ce:	b002      	add	sp, #8
 80064d0:	bd80      	pop	{r7, pc}
 80064d2:	46c0      	nop			; (mov r8, r8)
 80064d4:	2000327c 	.word	0x2000327c

080064d8 <Stspin220_GetDeviceState>:
 * @brief Return the device state
 * @param[in] deviceId Unused parameter
 * @retval State (ACCELERATING, DECELERATING, STEADY or INACTIVE)
 **********************************************************/
motorState_t Stspin220_GetDeviceState(uint8_t deviceId)
{
 80064d8:	b580      	push	{r7, lr}
 80064da:	b082      	sub	sp, #8
 80064dc:	af00      	add	r7, sp, #0
 80064de:	0002      	movs	r2, r0
 80064e0:	1dfb      	adds	r3, r7, #7
 80064e2:	701a      	strb	r2, [r3, #0]
  return devicePrm.motionState;
 80064e4:	4b03      	ldr	r3, [pc, #12]	; (80064f4 <Stspin220_GetDeviceState+0x1c>)
 80064e6:	223c      	movs	r2, #60	; 0x3c
 80064e8:	5c9b      	ldrb	r3, [r3, r2]
 80064ea:	b2db      	uxtb	r3, r3
}
 80064ec:	0018      	movs	r0, r3
 80064ee:	46bd      	mov	sp, r7
 80064f0:	b002      	add	sp, #8
 80064f2:	bd80      	pop	{r7, pc}
 80064f4:	2000327c 	.word	0x2000327c

080064f8 <Stspin220_GetDirection>:
 * @brief Get the motor current direction
 * @param[in] deviceId Unused parameter
 * @retval direction
 **********************************************************/
motorDir_t Stspin220_GetDirection(uint8_t deviceId)
{
 80064f8:	b580      	push	{r7, lr}
 80064fa:	b082      	sub	sp, #8
 80064fc:	af00      	add	r7, sp, #0
 80064fe:	0002      	movs	r2, r0
 8006500:	1dfb      	adds	r3, r7, #7
 8006502:	701a      	strb	r2, [r3, #0]
  return devicePrm.direction;
 8006504:	4b03      	ldr	r3, [pc, #12]	; (8006514 <Stspin220_GetDirection+0x1c>)
 8006506:	223b      	movs	r2, #59	; 0x3b
 8006508:	5c9b      	ldrb	r3, [r3, r2]
 800650a:	b2db      	uxtb	r3, r3
}
 800650c:	0018      	movs	r0, r3
 800650e:	46bd      	mov	sp, r7
 8006510:	b002      	add	sp, #8
 8006512:	bd80      	pop	{r7, pc}
 8006514:	2000327c 	.word	0x2000327c

08006518 <Stspin220_GetFwVersion>:
/******************************************************//**
 * @brief Return the FW version of the library
 * @retval Stspin220_FW_VERSION
 **********************************************************/
uint32_t Stspin220_GetFwVersion(void)
{
 8006518:	b580      	push	{r7, lr}
 800651a:	af00      	add	r7, sp, #0
  return (STSPIN220_FW_VERSION);
 800651c:	4b01      	ldr	r3, [pc, #4]	; (8006524 <Stspin220_GetFwVersion+0xc>)
}
 800651e:	0018      	movs	r0, r3
 8006520:	46bd      	mov	sp, r7
 8006522:	bd80      	pop	{r7, pc}
 8006524:	00010300 	.word	0x00010300

08006528 <Stspin220_GetMark>:
 * @brief Return the mark position of the specified device
 * @param[in] deviceId Unused parameter
 * @retval mark position value
 **********************************************************/
int32_t Stspin220_GetMark(uint8_t deviceId)
{
 8006528:	b580      	push	{r7, lr}
 800652a:	b082      	sub	sp, #8
 800652c:	af00      	add	r7, sp, #0
 800652e:	0002      	movs	r2, r0
 8006530:	1dfb      	adds	r3, r7, #7
 8006532:	701a      	strb	r2, [r3, #0]
  return devicePrm.markPosition;
 8006534:	4b02      	ldr	r3, [pc, #8]	; (8006540 <Stspin220_GetMark+0x18>)
 8006536:	68db      	ldr	r3, [r3, #12]
}
 8006538:	0018      	movs	r0, r3
 800653a:	46bd      	mov	sp, r7
 800653c:	b002      	add	sp, #8
 800653e:	bd80      	pop	{r7, pc}
 8006540:	2000327c 	.word	0x2000327c

08006544 <Stspin220_GetMaxSpeed>:
 * @brief Return the max speed of the specified device
 * @param[in] deviceId Unused parameter
 * @retval maxSpeed in pps
 **********************************************************/
uint16_t Stspin220_GetMaxSpeed(uint8_t deviceId)
{                                                  
 8006544:	b580      	push	{r7, lr}
 8006546:	b082      	sub	sp, #8
 8006548:	af00      	add	r7, sp, #0
 800654a:	0002      	movs	r2, r0
 800654c:	1dfb      	adds	r3, r7, #7
 800654e:	701a      	strb	r2, [r3, #0]
  return (devicePrm.maxSpeed);
 8006550:	4b03      	ldr	r3, [pc, #12]	; (8006560 <Stspin220_GetMaxSpeed+0x1c>)
 8006552:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 8006554:	b29b      	uxth	r3, r3
}
 8006556:	0018      	movs	r0, r3
 8006558:	46bd      	mov	sp, r7
 800655a:	b002      	add	sp, #8
 800655c:	bd80      	pop	{r7, pc}
 800655e:	46c0      	nop			; (mov r8, r8)
 8006560:	2000327c 	.word	0x2000327c

08006564 <Stspin220_GetMinSpeed>:
 * @brief Return the min speed of the specified device
 * @param[in] deviceId Unused parameter
 * @retval minSpeed in pps
 **********************************************************/
uint16_t Stspin220_GetMinSpeed(uint8_t deviceId)
{                                                  
 8006564:	b580      	push	{r7, lr}
 8006566:	b082      	sub	sp, #8
 8006568:	af00      	add	r7, sp, #0
 800656a:	0002      	movs	r2, r0
 800656c:	1dfb      	adds	r3, r7, #7
 800656e:	701a      	strb	r2, [r3, #0]
  return (devicePrm.minSpeed);
 8006570:	4b03      	ldr	r3, [pc, #12]	; (8006580 <Stspin220_GetMinSpeed+0x1c>)
 8006572:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8006574:	b29b      	uxth	r3, r3
}                                                     
 8006576:	0018      	movs	r0, r3
 8006578:	46bd      	mov	sp, r7
 800657a:	b002      	add	sp, #8
 800657c:	bd80      	pop	{r7, pc}
 800657e:	46c0      	nop			; (mov r8, r8)
 8006580:	2000327c 	.word	0x2000327c

08006584 <Stspin220_GetNbDevices>:
/******************************************************//**
 * @brief  Returns the number of devices
 * @retval number of devices
 **********************************************************/
uint8_t Stspin220_GetNbDevices(void)
{
 8006584:	b580      	push	{r7, lr}
 8006586:	af00      	add	r7, sp, #0
  return (stspin220NumberOfDevices);
 8006588:	4b02      	ldr	r3, [pc, #8]	; (8006594 <Stspin220_GetNbDevices+0x10>)
 800658a:	781b      	ldrb	r3, [r3, #0]
}
 800658c:	0018      	movs	r0, r3
 800658e:	46bd      	mov	sp, r7
 8006590:	bd80      	pop	{r7, pc}
 8006592:	46c0      	nop			; (mov r8, r8)
 8006594:	2000045e 	.word	0x2000045e

08006598 <Stspin220_GetPosition>:
 * @brief Return the current position value of the specified device
 * @param[in] deviceId Unused parameter
 * @retval current position value
 **********************************************************/
int32_t Stspin220_GetPosition(uint8_t deviceId)
{
 8006598:	b580      	push	{r7, lr}
 800659a:	b082      	sub	sp, #8
 800659c:	af00      	add	r7, sp, #0
 800659e:	0002      	movs	r2, r0
 80065a0:	1dfb      	adds	r3, r7, #7
 80065a2:	701a      	strb	r2, [r3, #0]
  return devicePrm.currentPosition;
 80065a4:	4b02      	ldr	r3, [pc, #8]	; (80065b0 <Stspin220_GetPosition+0x18>)
 80065a6:	685b      	ldr	r3, [r3, #4]
}
 80065a8:	0018      	movs	r0, r3
 80065aa:	46bd      	mov	sp, r7
 80065ac:	b002      	add	sp, #8
 80065ae:	bd80      	pop	{r7, pc}
 80065b0:	2000327c 	.word	0x2000327c

080065b4 <Stspin220_GetStepMode>:
 * @brief Get the motor step mode
 * @param[in] deviceId Unused parameter
 * @retval step mode
 **********************************************************/
motorStepMode_t Stspin220_GetStepMode(uint8_t deviceId)
{
 80065b4:	b580      	push	{r7, lr}
 80065b6:	b082      	sub	sp, #8
 80065b8:	af00      	add	r7, sp, #0
 80065ba:	0002      	movs	r2, r0
 80065bc:	1dfb      	adds	r3, r7, #7
 80065be:	701a      	strb	r2, [r3, #0]
  return devicePrm.stepMode;
 80065c0:	4b03      	ldr	r3, [pc, #12]	; (80065d0 <Stspin220_GetStepMode+0x1c>)
 80065c2:	223d      	movs	r2, #61	; 0x3d
 80065c4:	5c9b      	ldrb	r3, [r3, r2]
 80065c6:	b2db      	uxtb	r3, r3
}
 80065c8:	0018      	movs	r0, r3
 80065ca:	46bd      	mov	sp, r7
 80065cc:	b002      	add	sp, #8
 80065ce:	bd80      	pop	{r7, pc}
 80065d0:	2000327c 	.word	0x2000327c

080065d4 <Stspin220_GetStopMode>:
 * @brief Get the selected stop mode
 * @param[in] deviceId Unused parameter
 * @retval the selected stop mode
 **********************************************************/
motorStopMode_t Stspin220_GetStopMode(uint8_t deviceId)
{
 80065d4:	b580      	push	{r7, lr}
 80065d6:	b082      	sub	sp, #8
 80065d8:	af00      	add	r7, sp, #0
 80065da:	0002      	movs	r2, r0
 80065dc:	1dfb      	adds	r3, r7, #7
 80065de:	701a      	strb	r2, [r3, #0]
  return devicePrm.stopMode;
 80065e0:	4b03      	ldr	r3, [pc, #12]	; (80065f0 <Stspin220_GetStopMode+0x1c>)
 80065e2:	223f      	movs	r2, #63	; 0x3f
 80065e4:	5c9b      	ldrb	r3, [r3, r2]
}
 80065e6:	0018      	movs	r0, r3
 80065e8:	46bd      	mov	sp, r7
 80065ea:	b002      	add	sp, #8
 80065ec:	bd80      	pop	{r7, pc}
 80065ee:	46c0      	nop			; (mov r8, r8)
 80065f0:	2000327c 	.word	0x2000327c

080065f4 <Stspin220_GetTorque>:
 * @param[in] torqueMode torque mode
 * @retval the torqueValue in % (from 0 to 100)
 * @note
 **********************************************************/
uint8_t Stspin220_GetTorque(uint8_t deviceId, motorTorqueMode_t torqueMode)
{
 80065f4:	b580      	push	{r7, lr}
 80065f6:	b084      	sub	sp, #16
 80065f8:	af00      	add	r7, sp, #0
 80065fa:	0002      	movs	r2, r0
 80065fc:	1dfb      	adds	r3, r7, #7
 80065fe:	701a      	strb	r2, [r3, #0]
 8006600:	1dbb      	adds	r3, r7, #6
 8006602:	1c0a      	adds	r2, r1, #0
 8006604:	701a      	strb	r2, [r3, #0]
  uint8_t torqueValue = 0;
 8006606:	230f      	movs	r3, #15
 8006608:	18fb      	adds	r3, r7, r3
 800660a:	2200      	movs	r2, #0
 800660c:	701a      	strb	r2, [r3, #0]
  switch(torqueMode)
 800660e:	1dbb      	adds	r3, r7, #6
 8006610:	781b      	ldrb	r3, [r3, #0]
 8006612:	2b04      	cmp	r3, #4
 8006614:	d827      	bhi.n	8006666 <Stspin220_GetTorque+0x72>
 8006616:	009a      	lsls	r2, r3, #2
 8006618:	4b17      	ldr	r3, [pc, #92]	; (8006678 <Stspin220_GetTorque+0x84>)
 800661a:	18d3      	adds	r3, r2, r3
 800661c:	681b      	ldr	r3, [r3, #0]
 800661e:	469f      	mov	pc, r3
  {
    case ACC_TORQUE:
      torqueValue = devicePrm.accelTorque;
 8006620:	230f      	movs	r3, #15
 8006622:	18fb      	adds	r3, r7, r3
 8006624:	4a15      	ldr	r2, [pc, #84]	; (800667c <Stspin220_GetTorque+0x88>)
 8006626:	2121      	movs	r1, #33	; 0x21
 8006628:	5c52      	ldrb	r2, [r2, r1]
 800662a:	701a      	strb	r2, [r3, #0]
      break;
 800662c:	e01c      	b.n	8006668 <Stspin220_GetTorque+0x74>
    case DEC_TORQUE:
      torqueValue = devicePrm.decelTorque;
 800662e:	230f      	movs	r3, #15
 8006630:	18fb      	adds	r3, r7, r3
 8006632:	4a12      	ldr	r2, [pc, #72]	; (800667c <Stspin220_GetTorque+0x88>)
 8006634:	2122      	movs	r1, #34	; 0x22
 8006636:	5c52      	ldrb	r2, [r2, r1]
 8006638:	701a      	strb	r2, [r3, #0]
      break;
 800663a:	e015      	b.n	8006668 <Stspin220_GetTorque+0x74>
    case RUN_TORQUE:
      torqueValue = devicePrm.runTorque;
 800663c:	230f      	movs	r3, #15
 800663e:	18fb      	adds	r3, r7, r3
 8006640:	4a0e      	ldr	r2, [pc, #56]	; (800667c <Stspin220_GetTorque+0x88>)
 8006642:	2120      	movs	r1, #32
 8006644:	5c52      	ldrb	r2, [r2, r1]
 8006646:	701a      	strb	r2, [r3, #0]
      break;
 8006648:	e00e      	b.n	8006668 <Stspin220_GetTorque+0x74>
    case HOLD_TORQUE:
      torqueValue = devicePrm.holdTorque;
 800664a:	230f      	movs	r3, #15
 800664c:	18fb      	adds	r3, r7, r3
 800664e:	4a0b      	ldr	r2, [pc, #44]	; (800667c <Stspin220_GetTorque+0x88>)
 8006650:	2123      	movs	r1, #35	; 0x23
 8006652:	5c52      	ldrb	r2, [r2, r1]
 8006654:	701a      	strb	r2, [r3, #0]
      break;
 8006656:	e007      	b.n	8006668 <Stspin220_GetTorque+0x74>
    case CURRENT_TORQUE:
      torqueValue = devicePrm.currentTorque;
 8006658:	230f      	movs	r3, #15
 800665a:	18fb      	adds	r3, r7, r3
 800665c:	4a07      	ldr	r2, [pc, #28]	; (800667c <Stspin220_GetTorque+0x88>)
 800665e:	2124      	movs	r1, #36	; 0x24
 8006660:	5c52      	ldrb	r2, [r2, r1]
 8006662:	701a      	strb	r2, [r3, #0]
      break;
 8006664:	e000      	b.n	8006668 <Stspin220_GetTorque+0x74>
    default:
      break;
 8006666:	46c0      	nop			; (mov r8, r8)
  }
  return torqueValue;
 8006668:	230f      	movs	r3, #15
 800666a:	18fb      	adds	r3, r7, r3
 800666c:	781b      	ldrb	r3, [r3, #0]
}
 800666e:	0018      	movs	r0, r3
 8006670:	46bd      	mov	sp, r7
 8006672:	b004      	add	sp, #16
 8006674:	bd80      	pop	{r7, pc}
 8006676:	46c0      	nop			; (mov r8, r8)
 8006678:	08014edc 	.word	0x08014edc
 800667c:	2000327c 	.word	0x2000327c

08006680 <Stspin220_GetTorqueBoostEnable>:
 * @brief Get the torque boost feature status
 * @param[in] deviceId Unused parameter
 * @retval TRUE if enabled, FALSE if disabled
 **********************************************************/
bool Stspin220_GetTorqueBoostEnable(uint8_t deviceId)
{
 8006680:	b580      	push	{r7, lr}
 8006682:	b082      	sub	sp, #8
 8006684:	af00      	add	r7, sp, #0
 8006686:	0002      	movs	r2, r0
 8006688:	1dfb      	adds	r3, r7, #7
 800668a:	701a      	strb	r2, [r3, #0]
  return devicePrm.torqueBoostEnable;
 800668c:	4b03      	ldr	r3, [pc, #12]	; (800669c <Stspin220_GetTorqueBoostEnable+0x1c>)
 800668e:	222c      	movs	r2, #44	; 0x2c
 8006690:	5c9b      	ldrb	r3, [r3, r2]
 8006692:	b2db      	uxtb	r3, r3
}
 8006694:	0018      	movs	r0, r3
 8006696:	46bd      	mov	sp, r7
 8006698:	b002      	add	sp, #8
 800669a:	bd80      	pop	{r7, pc}
 800669c:	2000327c 	.word	0x2000327c

080066a0 <Stspin220_GetTorqueBoostThreshold>:
 * @param[in] deviceId (from 0 to MAX_NUMBER_OF_DEVICES - 1)
 * @retval the torque boost threshold above which the step mode is
 * changed to full step
 **********************************************************/
uint16_t Stspin220_GetTorqueBoostThreshold(uint8_t deviceId)
{
 80066a0:	b580      	push	{r7, lr}
 80066a2:	b082      	sub	sp, #8
 80066a4:	af00      	add	r7, sp, #0
 80066a6:	0002      	movs	r2, r0
 80066a8:	1dfb      	adds	r3, r7, #7
 80066aa:	701a      	strb	r2, [r3, #0]
  return devicePrm.torqueBoostSpeedThreshold;
 80066ac:	4b03      	ldr	r3, [pc, #12]	; (80066bc <Stspin220_GetTorqueBoostThreshold+0x1c>)
 80066ae:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
 80066b0:	b29b      	uxth	r3, r3
}
 80066b2:	0018      	movs	r0, r3
 80066b4:	46bd      	mov	sp, r7
 80066b6:	b002      	add	sp, #8
 80066b8:	bd80      	pop	{r7, pc}
 80066ba:	46c0      	nop			; (mov r8, r8)
 80066bc:	2000327c 	.word	0x2000327c

080066c0 <Stspin220_GoHome>:
 * @brief Request the motor to move to the home position (ABS_POSITION = 0)
 * @param[in] deviceId Unused parameter
 * @retval None
 **********************************************************/
void Stspin220_GoHome(uint8_t deviceId)
{
 80066c0:	b580      	push	{r7, lr}
 80066c2:	b082      	sub	sp, #8
 80066c4:	af00      	add	r7, sp, #0
 80066c6:	0002      	movs	r2, r0
 80066c8:	1dfb      	adds	r3, r7, #7
 80066ca:	701a      	strb	r2, [r3, #0]
  deviceId = 0;
 80066cc:	1dfb      	adds	r3, r7, #7
 80066ce:	2200      	movs	r2, #0
 80066d0:	701a      	strb	r2, [r3, #0]
  
  Stspin220_GoTo(deviceId, 0);
 80066d2:	1dfb      	adds	r3, r7, #7
 80066d4:	781b      	ldrb	r3, [r3, #0]
 80066d6:	2100      	movs	r1, #0
 80066d8:	0018      	movs	r0, r3
 80066da:	f000 f81d 	bl	8006718 <Stspin220_GoTo>
} 
 80066de:	46c0      	nop			; (mov r8, r8)
 80066e0:	46bd      	mov	sp, r7
 80066e2:	b002      	add	sp, #8
 80066e4:	bd80      	pop	{r7, pc}
	...

080066e8 <Stspin220_GoMark>:
 * @brief Request the motor to move to the mark position 
 * @param[in] deviceId Unused parameter
 * @retval None
 **********************************************************/
void Stspin220_GoMark(uint8_t deviceId)
{
 80066e8:	b580      	push	{r7, lr}
 80066ea:	b082      	sub	sp, #8
 80066ec:	af00      	add	r7, sp, #0
 80066ee:	0002      	movs	r2, r0
 80066f0:	1dfb      	adds	r3, r7, #7
 80066f2:	701a      	strb	r2, [r3, #0]
  deviceId = 0;
 80066f4:	1dfb      	adds	r3, r7, #7
 80066f6:	2200      	movs	r2, #0
 80066f8:	701a      	strb	r2, [r3, #0]
  
	Stspin220_GoTo(deviceId, devicePrm.markPosition);
 80066fa:	4b06      	ldr	r3, [pc, #24]	; (8006714 <Stspin220_GoMark+0x2c>)
 80066fc:	68da      	ldr	r2, [r3, #12]
 80066fe:	1dfb      	adds	r3, r7, #7
 8006700:	781b      	ldrb	r3, [r3, #0]
 8006702:	0011      	movs	r1, r2
 8006704:	0018      	movs	r0, r3
 8006706:	f000 f807 	bl	8006718 <Stspin220_GoTo>
}
 800670a:	46c0      	nop			; (mov r8, r8)
 800670c:	46bd      	mov	sp, r7
 800670e:	b002      	add	sp, #8
 8006710:	bd80      	pop	{r7, pc}
 8006712:	46c0      	nop			; (mov r8, r8)
 8006714:	2000327c 	.word	0x2000327c

08006718 <Stspin220_GoTo>:
 * STEP_MODE_1_64                   : 1/64 step
 * STEP_MODE_1_128                  : 1/128 step
 * STEP_MODE_1_256                  : 1/256 step
 **********************************************************/
void Stspin220_GoTo(uint8_t deviceId, int32_t targetPosition)
{
 8006718:	b580      	push	{r7, lr}
 800671a:	b084      	sub	sp, #16
 800671c:	af00      	add	r7, sp, #0
 800671e:	0002      	movs	r2, r0
 8006720:	6039      	str	r1, [r7, #0]
 8006722:	1dfb      	adds	r3, r7, #7
 8006724:	701a      	strb	r2, [r3, #0]
  motorDir_t direction;
  deviceId = 0;
 8006726:	1dfb      	adds	r3, r7, #7
 8006728:	2200      	movs	r2, #0
 800672a:	701a      	strb	r2, [r3, #0]
  
  /* Exit from standby if needed */
  if (devicePrm.motionState == STANDBY)
 800672c:	4b39      	ldr	r3, [pc, #228]	; (8006814 <Stspin220_GoTo+0xfc>)
 800672e:	223c      	movs	r2, #60	; 0x3c
 8006730:	5c9b      	ldrb	r3, [r3, r2]
 8006732:	b2db      	uxtb	r3, r3
 8006734:	2b09      	cmp	r3, #9
 8006736:	d105      	bne.n	8006744 <Stspin220_GoTo+0x2c>
  {
    Stspin220_ExitDeviceFromStandby(deviceId);
 8006738:	1dfb      	adds	r3, r7, #7
 800673a:	781b      	ldrb	r3, [r3, #0]
 800673c:	0018      	movs	r0, r3
 800673e:	f7ff fe51 	bl	80063e4 <Stspin220_ExitDeviceFromStandby>
 8006742:	e00a      	b.n	800675a <Stspin220_GoTo+0x42>
  }
  /* Deactivate motor if needed */
  else if (devicePrm.motionState != INACTIVE)
 8006744:	4b33      	ldr	r3, [pc, #204]	; (8006814 <Stspin220_GoTo+0xfc>)
 8006746:	223c      	movs	r2, #60	; 0x3c
 8006748:	5c9b      	ldrb	r3, [r3, r2]
 800674a:	b2db      	uxtb	r3, r3
 800674c:	2b08      	cmp	r3, #8
 800674e:	d004      	beq.n	800675a <Stspin220_GoTo+0x42>
  { 
    Stspin220_HardHiZ(deviceId);
 8006750:	1dfb      	adds	r3, r7, #7
 8006752:	781b      	ldrb	r3, [r3, #0]
 8006754:	0018      	movs	r0, r3
 8006756:	f000 f8d5 	bl	8006904 <Stspin220_HardHiZ>
  }
  
  if (targetPosition > devicePrm.currentPosition)
 800675a:	4b2e      	ldr	r3, [pc, #184]	; (8006814 <Stspin220_GoTo+0xfc>)
 800675c:	685b      	ldr	r3, [r3, #4]
 800675e:	683a      	ldr	r2, [r7, #0]
 8006760:	429a      	cmp	r2, r3
 8006762:	dd1a      	ble.n	800679a <Stspin220_GoTo+0x82>
  {
    devicePrm.stepsToTake = targetPosition -\
                                      devicePrm.currentPosition;
 8006764:	4b2b      	ldr	r3, [pc, #172]	; (8006814 <Stspin220_GoTo+0xfc>)
 8006766:	685b      	ldr	r3, [r3, #4]
    devicePrm.stepsToTake = targetPosition -\
 8006768:	683a      	ldr	r2, [r7, #0]
 800676a:	1ad3      	subs	r3, r2, r3
 800676c:	001a      	movs	r2, r3
 800676e:	4b29      	ldr	r3, [pc, #164]	; (8006814 <Stspin220_GoTo+0xfc>)
 8006770:	61da      	str	r2, [r3, #28]
    if (devicePrm.stepsToTake < (STSPIN220_POSITION_RANGE>>1))
 8006772:	4b28      	ldr	r3, [pc, #160]	; (8006814 <Stspin220_GoTo+0xfc>)
 8006774:	69db      	ldr	r3, [r3, #28]
 8006776:	4a28      	ldr	r2, [pc, #160]	; (8006818 <Stspin220_GoTo+0x100>)
 8006778:	4293      	cmp	r3, r2
 800677a:	d804      	bhi.n	8006786 <Stspin220_GoTo+0x6e>
    {
      direction = FORWARD;
 800677c:	230f      	movs	r3, #15
 800677e:	18fb      	adds	r3, r7, r3
 8006780:	2201      	movs	r2, #1
 8006782:	701a      	strb	r2, [r3, #0]
 8006784:	e023      	b.n	80067ce <Stspin220_GoTo+0xb6>
    }
    else
    {
      direction = BACKWARD;
 8006786:	230f      	movs	r3, #15
 8006788:	18fb      	adds	r3, r7, r3
 800678a:	2200      	movs	r2, #0
 800678c:	701a      	strb	r2, [r3, #0]
      devicePrm.stepsToTake = STSPIN220_POSITION_RANGE -\
                                        devicePrm.stepsToTake;
 800678e:	4b21      	ldr	r3, [pc, #132]	; (8006814 <Stspin220_GoTo+0xfc>)
 8006790:	69db      	ldr	r3, [r3, #28]
      devicePrm.stepsToTake = STSPIN220_POSITION_RANGE -\
 8006792:	43da      	mvns	r2, r3
 8006794:	4b1f      	ldr	r3, [pc, #124]	; (8006814 <Stspin220_GoTo+0xfc>)
 8006796:	61da      	str	r2, [r3, #28]
 8006798:	e019      	b.n	80067ce <Stspin220_GoTo+0xb6>
    }
  }
  else
  {
    devicePrm.stepsToTake = devicePrm.currentPosition -\
 800679a:	4b1e      	ldr	r3, [pc, #120]	; (8006814 <Stspin220_GoTo+0xfc>)
 800679c:	685a      	ldr	r2, [r3, #4]
 800679e:	683b      	ldr	r3, [r7, #0]
 80067a0:	1ad3      	subs	r3, r2, r3
 80067a2:	001a      	movs	r2, r3
 80067a4:	4b1b      	ldr	r3, [pc, #108]	; (8006814 <Stspin220_GoTo+0xfc>)
 80067a6:	61da      	str	r2, [r3, #28]
                                      targetPosition;
    if (devicePrm.stepsToTake < (STSPIN220_POSITION_RANGE>>1))
 80067a8:	4b1a      	ldr	r3, [pc, #104]	; (8006814 <Stspin220_GoTo+0xfc>)
 80067aa:	69db      	ldr	r3, [r3, #28]
 80067ac:	4a1a      	ldr	r2, [pc, #104]	; (8006818 <Stspin220_GoTo+0x100>)
 80067ae:	4293      	cmp	r3, r2
 80067b0:	d804      	bhi.n	80067bc <Stspin220_GoTo+0xa4>
    {
      direction = BACKWARD;
 80067b2:	230f      	movs	r3, #15
 80067b4:	18fb      	adds	r3, r7, r3
 80067b6:	2200      	movs	r2, #0
 80067b8:	701a      	strb	r2, [r3, #0]
 80067ba:	e008      	b.n	80067ce <Stspin220_GoTo+0xb6>
    }
    else
    {
      direction = FORWARD; 
 80067bc:	230f      	movs	r3, #15
 80067be:	18fb      	adds	r3, r7, r3
 80067c0:	2201      	movs	r2, #1
 80067c2:	701a      	strb	r2, [r3, #0]
      devicePrm.stepsToTake = STSPIN220_POSITION_RANGE -\
                                        devicePrm.stepsToTake;
 80067c4:	4b13      	ldr	r3, [pc, #76]	; (8006814 <Stspin220_GoTo+0xfc>)
 80067c6:	69db      	ldr	r3, [r3, #28]
      devicePrm.stepsToTake = STSPIN220_POSITION_RANGE -\
 80067c8:	43da      	mvns	r2, r3
 80067ca:	4b12      	ldr	r3, [pc, #72]	; (8006814 <Stspin220_GoTo+0xfc>)
 80067cc:	61da      	str	r2, [r3, #28]
    }
  }
  
  if (devicePrm.stepsToTake != 0) 
 80067ce:	4b11      	ldr	r3, [pc, #68]	; (8006814 <Stspin220_GoTo+0xfc>)
 80067d0:	69db      	ldr	r3, [r3, #28]
 80067d2:	2b00      	cmp	r3, #0
 80067d4:	d019      	beq.n	800680a <Stspin220_GoTo+0xf2>
  {
    devicePrm.commandExecuted = MOVE_CMD;
 80067d6:	4b0f      	ldr	r3, [pc, #60]	; (8006814 <Stspin220_GoTo+0xfc>)
 80067d8:	223a      	movs	r2, #58	; 0x3a
 80067da:	2102      	movs	r1, #2
 80067dc:	5499      	strb	r1, [r3, r2]
    
    /* Direction setup */
    Stspin220_SetDirection(deviceId, direction);
 80067de:	230f      	movs	r3, #15
 80067e0:	18fb      	adds	r3, r7, r3
 80067e2:	781a      	ldrb	r2, [r3, #0]
 80067e4:	1dfb      	adds	r3, r7, #7
 80067e6:	781b      	ldrb	r3, [r3, #0]
 80067e8:	0011      	movs	r1, r2
 80067ea:	0018      	movs	r0, r3
 80067ec:	f000 fa28 	bl	8006c40 <Stspin220_SetDirection>
    
    Stspin220_ComputeSpeedProfile(deviceId, devicePrm.stepsToTake);
 80067f0:	4b08      	ldr	r3, [pc, #32]	; (8006814 <Stspin220_GoTo+0xfc>)
 80067f2:	69da      	ldr	r2, [r3, #28]
 80067f4:	1dfb      	adds	r3, r7, #7
 80067f6:	781b      	ldrb	r3, [r3, #0]
 80067f8:	0011      	movs	r1, r2
 80067fa:	0018      	movs	r0, r3
 80067fc:	f000 fda8 	bl	8007350 <Stspin220_ComputeSpeedProfile>
    
    /* Motor activation */
    Stspin220_StartMovement(deviceId);
 8006800:	1dfb      	adds	r3, r7, #7
 8006802:	781b      	ldrb	r3, [r3, #0]
 8006804:	0018      	movs	r0, r3
 8006806:	f000 fffd 	bl	8007804 <Stspin220_StartMovement>
  }
}
 800680a:	46c0      	nop			; (mov r8, r8)
 800680c:	46bd      	mov	sp, r7
 800680e:	b004      	add	sp, #16
 8006810:	bd80      	pop	{r7, pc}
 8006812:	46c0      	nop			; (mov r8, r8)
 8006814:	2000327c 	.word	0x2000327c
 8006818:	7ffffffe 	.word	0x7ffffffe

0800681c <Stspin220_GoToDir>:
 * STEP_MODE_1_64                   : 1/64 step
 * STEP_MODE_1_128                  : 1/128 step
 * STEP_MODE_1_256                  : 1/256 step
 **********************************************************/
void Stspin220_GoToDir(uint8_t deviceId, motorDir_t direction, int32_t targetPosition)
{
 800681c:	b580      	push	{r7, lr}
 800681e:	b082      	sub	sp, #8
 8006820:	af00      	add	r7, sp, #0
 8006822:	603a      	str	r2, [r7, #0]
 8006824:	1dfb      	adds	r3, r7, #7
 8006826:	1c02      	adds	r2, r0, #0
 8006828:	701a      	strb	r2, [r3, #0]
 800682a:	1dbb      	adds	r3, r7, #6
 800682c:	1c0a      	adds	r2, r1, #0
 800682e:	701a      	strb	r2, [r3, #0]
  deviceId = 0;
 8006830:	1dfb      	adds	r3, r7, #7
 8006832:	2200      	movs	r2, #0
 8006834:	701a      	strb	r2, [r3, #0]
  
  /* Exit from standby if needed */
  if (devicePrm.motionState == STANDBY)
 8006836:	4b32      	ldr	r3, [pc, #200]	; (8006900 <Stspin220_GoToDir+0xe4>)
 8006838:	223c      	movs	r2, #60	; 0x3c
 800683a:	5c9b      	ldrb	r3, [r3, r2]
 800683c:	b2db      	uxtb	r3, r3
 800683e:	2b09      	cmp	r3, #9
 8006840:	d105      	bne.n	800684e <Stspin220_GoToDir+0x32>
  {
    Stspin220_ExitDeviceFromStandby(deviceId);
 8006842:	1dfb      	adds	r3, r7, #7
 8006844:	781b      	ldrb	r3, [r3, #0]
 8006846:	0018      	movs	r0, r3
 8006848:	f7ff fdcc 	bl	80063e4 <Stspin220_ExitDeviceFromStandby>
 800684c:	e00a      	b.n	8006864 <Stspin220_GoToDir+0x48>
  }
  /* Deactivate motor if needed */
  else if (devicePrm.motionState != INACTIVE)
 800684e:	4b2c      	ldr	r3, [pc, #176]	; (8006900 <Stspin220_GoToDir+0xe4>)
 8006850:	223c      	movs	r2, #60	; 0x3c
 8006852:	5c9b      	ldrb	r3, [r3, r2]
 8006854:	b2db      	uxtb	r3, r3
 8006856:	2b08      	cmp	r3, #8
 8006858:	d004      	beq.n	8006864 <Stspin220_GoToDir+0x48>
  { 
    Stspin220_HardHiZ(deviceId);
 800685a:	1dfb      	adds	r3, r7, #7
 800685c:	781b      	ldrb	r3, [r3, #0]
 800685e:	0018      	movs	r0, r3
 8006860:	f000 f850 	bl	8006904 <Stspin220_HardHiZ>
  }
  
  if (direction != BACKWARD)
 8006864:	1dbb      	adds	r3, r7, #6
 8006866:	781b      	ldrb	r3, [r3, #0]
 8006868:	2b00      	cmp	r3, #0
 800686a:	d014      	beq.n	8006896 <Stspin220_GoToDir+0x7a>
  {
    if (targetPosition > devicePrm.currentPosition)
 800686c:	4b24      	ldr	r3, [pc, #144]	; (8006900 <Stspin220_GoToDir+0xe4>)
 800686e:	685b      	ldr	r3, [r3, #4]
 8006870:	683a      	ldr	r2, [r7, #0]
 8006872:	429a      	cmp	r2, r3
 8006874:	dd07      	ble.n	8006886 <Stspin220_GoToDir+0x6a>
    {
      devicePrm.stepsToTake = targetPosition -\
                                        devicePrm.currentPosition;
 8006876:	4b22      	ldr	r3, [pc, #136]	; (8006900 <Stspin220_GoToDir+0xe4>)
 8006878:	685b      	ldr	r3, [r3, #4]
      devicePrm.stepsToTake = targetPosition -\
 800687a:	683a      	ldr	r2, [r7, #0]
 800687c:	1ad3      	subs	r3, r2, r3
 800687e:	001a      	movs	r2, r3
 8006880:	4b1f      	ldr	r3, [pc, #124]	; (8006900 <Stspin220_GoToDir+0xe4>)
 8006882:	61da      	str	r2, [r3, #28]
 8006884:	e01b      	b.n	80068be <Stspin220_GoToDir+0xa2>
    }
    else
    {
      devicePrm.stepsToTake = STSPIN220_POSITION_RANGE +\
                                       (targetPosition -\
                                        devicePrm.currentPosition);
 8006886:	4b1e      	ldr	r3, [pc, #120]	; (8006900 <Stspin220_GoToDir+0xe4>)
 8006888:	685b      	ldr	r3, [r3, #4]
                                       (targetPosition -\
 800688a:	683a      	ldr	r2, [r7, #0]
 800688c:	1ad3      	subs	r3, r2, r3
      devicePrm.stepsToTake = STSPIN220_POSITION_RANGE +\
 800688e:	1e5a      	subs	r2, r3, #1
 8006890:	4b1b      	ldr	r3, [pc, #108]	; (8006900 <Stspin220_GoToDir+0xe4>)
 8006892:	61da      	str	r2, [r3, #28]
 8006894:	e013      	b.n	80068be <Stspin220_GoToDir+0xa2>
    }
  }
  else
  {
    if (targetPosition > devicePrm.currentPosition)
 8006896:	4b1a      	ldr	r3, [pc, #104]	; (8006900 <Stspin220_GoToDir+0xe4>)
 8006898:	685b      	ldr	r3, [r3, #4]
 800689a:	683a      	ldr	r2, [r7, #0]
 800689c:	429a      	cmp	r2, r3
 800689e:	dd07      	ble.n	80068b0 <Stspin220_GoToDir+0x94>
    {
      devicePrm.stepsToTake = STSPIN220_POSITION_RANGE +\
                                        (devicePrm.currentPosition -\
 80068a0:	4b17      	ldr	r3, [pc, #92]	; (8006900 <Stspin220_GoToDir+0xe4>)
 80068a2:	685a      	ldr	r2, [r3, #4]
 80068a4:	683b      	ldr	r3, [r7, #0]
 80068a6:	1ad3      	subs	r3, r2, r3
      devicePrm.stepsToTake = STSPIN220_POSITION_RANGE +\
 80068a8:	1e5a      	subs	r2, r3, #1
 80068aa:	4b15      	ldr	r3, [pc, #84]	; (8006900 <Stspin220_GoToDir+0xe4>)
 80068ac:	61da      	str	r2, [r3, #28]
 80068ae:	e006      	b.n	80068be <Stspin220_GoToDir+0xa2>
                                         targetPosition);
    }
    else
    {
      devicePrm.stepsToTake = devicePrm.currentPosition -\
 80068b0:	4b13      	ldr	r3, [pc, #76]	; (8006900 <Stspin220_GoToDir+0xe4>)
 80068b2:	685a      	ldr	r2, [r3, #4]
 80068b4:	683b      	ldr	r3, [r7, #0]
 80068b6:	1ad3      	subs	r3, r2, r3
 80068b8:	001a      	movs	r2, r3
 80068ba:	4b11      	ldr	r3, [pc, #68]	; (8006900 <Stspin220_GoToDir+0xe4>)
 80068bc:	61da      	str	r2, [r3, #28]
                                        targetPosition;
    }
  }

  if (devicePrm.stepsToTake != 0) 
 80068be:	4b10      	ldr	r3, [pc, #64]	; (8006900 <Stspin220_GoToDir+0xe4>)
 80068c0:	69db      	ldr	r3, [r3, #28]
 80068c2:	2b00      	cmp	r3, #0
 80068c4:	d018      	beq.n	80068f8 <Stspin220_GoToDir+0xdc>
  {
    devicePrm.commandExecuted = MOVE_CMD;
 80068c6:	4b0e      	ldr	r3, [pc, #56]	; (8006900 <Stspin220_GoToDir+0xe4>)
 80068c8:	223a      	movs	r2, #58	; 0x3a
 80068ca:	2102      	movs	r1, #2
 80068cc:	5499      	strb	r1, [r3, r2]
    
    /* Direction setup */
    Stspin220_SetDirection(deviceId, direction);
 80068ce:	1dbb      	adds	r3, r7, #6
 80068d0:	781a      	ldrb	r2, [r3, #0]
 80068d2:	1dfb      	adds	r3, r7, #7
 80068d4:	781b      	ldrb	r3, [r3, #0]
 80068d6:	0011      	movs	r1, r2
 80068d8:	0018      	movs	r0, r3
 80068da:	f000 f9b1 	bl	8006c40 <Stspin220_SetDirection>
    
    Stspin220_ComputeSpeedProfile(deviceId, devicePrm.stepsToTake);
 80068de:	4b08      	ldr	r3, [pc, #32]	; (8006900 <Stspin220_GoToDir+0xe4>)
 80068e0:	69da      	ldr	r2, [r3, #28]
 80068e2:	1dfb      	adds	r3, r7, #7
 80068e4:	781b      	ldrb	r3, [r3, #0]
 80068e6:	0011      	movs	r1, r2
 80068e8:	0018      	movs	r0, r3
 80068ea:	f000 fd31 	bl	8007350 <Stspin220_ComputeSpeedProfile>
    
    /* Motor activation */
    Stspin220_StartMovement(deviceId);
 80068ee:	1dfb      	adds	r3, r7, #7
 80068f0:	781b      	ldrb	r3, [r3, #0]
 80068f2:	0018      	movs	r0, r3
 80068f4:	f000 ff86 	bl	8007804 <Stspin220_StartMovement>
  }  
}
 80068f8:	46c0      	nop			; (mov r8, r8)
 80068fa:	46bd      	mov	sp, r7
 80068fc:	b002      	add	sp, #8
 80068fe:	bd80      	pop	{r7, pc}
 8006900:	2000327c 	.word	0x2000327c

08006904 <Stspin220_HardHiZ>:
 * @brief  Immediatly stop the motor and disable the power bridge
 * @param[in] deviceId Unused parameter
 * @retval None
 **********************************************************/
void Stspin220_HardHiZ(uint8_t deviceId) 
{
 8006904:	b580      	push	{r7, lr}
 8006906:	b082      	sub	sp, #8
 8006908:	af00      	add	r7, sp, #0
 800690a:	0002      	movs	r2, r0
 800690c:	1dfb      	adds	r3, r7, #7
 800690e:	701a      	strb	r2, [r3, #0]
  /* Set inactive state */
  devicePrm.motionState = INACTIVE;
 8006910:	4b1b      	ldr	r3, [pc, #108]	; (8006980 <Stspin220_HardHiZ+0x7c>)
 8006912:	223c      	movs	r2, #60	; 0x3c
 8006914:	2108      	movs	r1, #8
 8006916:	5499      	strb	r1, [r3, r2]
  
  /* Disable step clock */
  if (Stspin220_Board_TimStckStop(&toggleOdd) == 0)
 8006918:	4b1a      	ldr	r3, [pc, #104]	; (8006984 <Stspin220_HardHiZ+0x80>)
 800691a:	0018      	movs	r0, r3
 800691c:	f008 f862 	bl	800e9e4 <Stspin220_Board_TimStckStop>
 8006920:	1e03      	subs	r3, r0, #0
 8006922:	d103      	bne.n	800692c <Stspin220_HardHiZ+0x28>
  {
    Stspin220_ErrorHandler(STSPIN220_ERROR_STEP_CLOCK);
 8006924:	4b18      	ldr	r3, [pc, #96]	; (8006988 <Stspin220_HardHiZ+0x84>)
 8006926:	0018      	movs	r0, r3
 8006928:	f7ff fd44 	bl	80063b4 <Stspin220_ErrorHandler>
  }

  /* Let the PWM REF and bridges enabled at least for DISABLE_DELAY time */
  /* after the last step clock rising edge triggering the last step */
  Stspin220_Board_Delay(DISABLE_DELAY);
 800692c:	2001      	movs	r0, #1
 800692e:	f007 fe77 	bl	800e620 <Stspin220_Board_Delay>
  
  /* Set reference voltage to 0 */
  Stspin220_SetTorque(0, CURRENT_TORQUE, 0);
 8006932:	2200      	movs	r2, #0
 8006934:	2104      	movs	r1, #4
 8006936:	2000      	movs	r0, #0
 8006938:	f000 fad4 	bl	8006ee4 <Stspin220_SetTorque>

  /* Disable power bridges */
  Stspin220_Board_Disable();
 800693c:	f008 f8aa 	bl	800ea94 <Stspin220_Board_Disable>
  
  /* Comeback to nominal step mode */
  if (devicePrm.stepModeLatched != devicePrm.stepMode)
 8006940:	4b0f      	ldr	r3, [pc, #60]	; (8006980 <Stspin220_HardHiZ+0x7c>)
 8006942:	223e      	movs	r2, #62	; 0x3e
 8006944:	5c9a      	ldrb	r2, [r3, r2]
 8006946:	4b0e      	ldr	r3, [pc, #56]	; (8006980 <Stspin220_HardHiZ+0x7c>)
 8006948:	213d      	movs	r1, #61	; 0x3d
 800694a:	5c5b      	ldrb	r3, [r3, r1]
 800694c:	b2db      	uxtb	r3, r3
 800694e:	429a      	cmp	r2, r3
 8006950:	d007      	beq.n	8006962 <Stspin220_HardHiZ+0x5e>
  {
    Stspin220_Board_UnsetFullStep();
 8006952:	f008 f9a5 	bl	800eca0 <Stspin220_Board_UnsetFullStep>
    devicePrm.stepMode = devicePrm.stepModeLatched;
 8006956:	4b0a      	ldr	r3, [pc, #40]	; (8006980 <Stspin220_HardHiZ+0x7c>)
 8006958:	223e      	movs	r2, #62	; 0x3e
 800695a:	5c99      	ldrb	r1, [r3, r2]
 800695c:	4b08      	ldr	r3, [pc, #32]	; (8006980 <Stspin220_HardHiZ+0x7c>)
 800695e:	223d      	movs	r2, #61	; 0x3d
 8006960:	5499      	strb	r1, [r3, r2]
  }

  devicePrm.commandExecuted = NO_CMD;
 8006962:	4b07      	ldr	r3, [pc, #28]	; (8006980 <Stspin220_HardHiZ+0x7c>)
 8006964:	223a      	movs	r2, #58	; 0x3a
 8006966:	2100      	movs	r1, #0
 8006968:	5499      	strb	r1, [r3, r2]
  devicePrm.stepsToTake = 0;  
 800696a:	4b05      	ldr	r3, [pc, #20]	; (8006980 <Stspin220_HardHiZ+0x7c>)
 800696c:	2200      	movs	r2, #0
 800696e:	61da      	str	r2, [r3, #28]
  devicePrm.speed = 0;
 8006970:	4b03      	ldr	r3, [pc, #12]	; (8006980 <Stspin220_HardHiZ+0x7c>)
 8006972:	2200      	movs	r2, #0
 8006974:	871a      	strh	r2, [r3, #56]	; 0x38
}
 8006976:	46c0      	nop			; (mov r8, r8)
 8006978:	46bd      	mov	sp, r7
 800697a:	b002      	add	sp, #8
 800697c:	bd80      	pop	{r7, pc}
 800697e:	46c0      	nop			; (mov r8, r8)
 8006980:	2000327c 	.word	0x2000327c
 8006984:	2000045f 	.word	0x2000045f
 8006988:	0000a00e 	.word	0x0000a00e

0800698c <Stspin220_HardStop>:
 * or call Stspin220_PutDeviceInStandby function when stop mode is STANDBY_MODE
 * @param[in] deviceId Unused parameter
 * @retval None
 **********************************************************/
void Stspin220_HardStop(uint8_t deviceId) 
{
 800698c:	b580      	push	{r7, lr}
 800698e:	b082      	sub	sp, #8
 8006990:	af00      	add	r7, sp, #0
 8006992:	0002      	movs	r2, r0
 8006994:	1dfb      	adds	r3, r7, #7
 8006996:	701a      	strb	r2, [r3, #0]
  deviceId = 0;
 8006998:	1dfb      	adds	r3, r7, #7
 800699a:	2200      	movs	r2, #0
 800699c:	701a      	strb	r2, [r3, #0]
  
  if (devicePrm.stopMode == HOLD_MODE)
 800699e:	4b27      	ldr	r3, [pc, #156]	; (8006a3c <Stspin220_HardStop+0xb0>)
 80069a0:	223f      	movs	r2, #63	; 0x3f
 80069a2:	5c9b      	ldrb	r3, [r3, r2]
 80069a4:	2b00      	cmp	r3, #0
 80069a6:	d12f      	bne.n	8006a08 <Stspin220_HardStop+0x7c>
  {
    /* Set inactive state */
    devicePrm.motionState = INACTIVE;
 80069a8:	4b24      	ldr	r3, [pc, #144]	; (8006a3c <Stspin220_HardStop+0xb0>)
 80069aa:	223c      	movs	r2, #60	; 0x3c
 80069ac:	2108      	movs	r1, #8
 80069ae:	5499      	strb	r1, [r3, r2]

    /* Disable step clock */
    if (Stspin220_Board_TimStckStop(&toggleOdd) == 0)
 80069b0:	4b23      	ldr	r3, [pc, #140]	; (8006a40 <Stspin220_HardStop+0xb4>)
 80069b2:	0018      	movs	r0, r3
 80069b4:	f008 f816 	bl	800e9e4 <Stspin220_Board_TimStckStop>
 80069b8:	1e03      	subs	r3, r0, #0
 80069ba:	d103      	bne.n	80069c4 <Stspin220_HardStop+0x38>
    {
      Stspin220_ErrorHandler(STSPIN220_ERROR_STEP_CLOCK);
 80069bc:	4b21      	ldr	r3, [pc, #132]	; (8006a44 <Stspin220_HardStop+0xb8>)
 80069be:	0018      	movs	r0, r3
 80069c0:	f7ff fcf8 	bl	80063b4 <Stspin220_ErrorHandler>
    }
    
    /* Set holding torque */
    Stspin220_ApplyTorque(deviceId, HOLD_TORQUE);
 80069c4:	1dfb      	adds	r3, r7, #7
 80069c6:	781b      	ldrb	r3, [r3, #0]
 80069c8:	2103      	movs	r1, #3
 80069ca:	0018      	movs	r0, r3
 80069cc:	f000 fc6e 	bl	80072ac <Stspin220_ApplyTorque>
 
    /* Comeback to nominal step mode */
    if (devicePrm.stepModeLatched != devicePrm.stepMode)
 80069d0:	4b1a      	ldr	r3, [pc, #104]	; (8006a3c <Stspin220_HardStop+0xb0>)
 80069d2:	223e      	movs	r2, #62	; 0x3e
 80069d4:	5c9a      	ldrb	r2, [r3, r2]
 80069d6:	4b19      	ldr	r3, [pc, #100]	; (8006a3c <Stspin220_HardStop+0xb0>)
 80069d8:	213d      	movs	r1, #61	; 0x3d
 80069da:	5c5b      	ldrb	r3, [r3, r1]
 80069dc:	b2db      	uxtb	r3, r3
 80069de:	429a      	cmp	r2, r3
 80069e0:	d007      	beq.n	80069f2 <Stspin220_HardStop+0x66>
    {
      Stspin220_Board_UnsetFullStep();
 80069e2:	f008 f95d 	bl	800eca0 <Stspin220_Board_UnsetFullStep>
      devicePrm.stepMode = devicePrm.stepModeLatched;
 80069e6:	4b15      	ldr	r3, [pc, #84]	; (8006a3c <Stspin220_HardStop+0xb0>)
 80069e8:	223e      	movs	r2, #62	; 0x3e
 80069ea:	5c99      	ldrb	r1, [r3, r2]
 80069ec:	4b13      	ldr	r3, [pc, #76]	; (8006a3c <Stspin220_HardStop+0xb0>)
 80069ee:	223d      	movs	r2, #61	; 0x3d
 80069f0:	5499      	strb	r1, [r3, r2]
    }    
    
    devicePrm.commandExecuted = NO_CMD;
 80069f2:	4b12      	ldr	r3, [pc, #72]	; (8006a3c <Stspin220_HardStop+0xb0>)
 80069f4:	223a      	movs	r2, #58	; 0x3a
 80069f6:	2100      	movs	r1, #0
 80069f8:	5499      	strb	r1, [r3, r2]
    devicePrm.stepsToTake = 0;  
 80069fa:	4b10      	ldr	r3, [pc, #64]	; (8006a3c <Stspin220_HardStop+0xb0>)
 80069fc:	2200      	movs	r2, #0
 80069fe:	61da      	str	r2, [r3, #28]
    devicePrm.speed = 0;
 8006a00:	4b0e      	ldr	r3, [pc, #56]	; (8006a3c <Stspin220_HardStop+0xb0>)
 8006a02:	2200      	movs	r2, #0
 8006a04:	871a      	strh	r2, [r3, #56]	; 0x38
  }
  else if (devicePrm.stopMode == STANDBY_MODE)
  {
    Stspin220_PutDeviceInStandby(deviceId);
  }
}
 8006a06:	e014      	b.n	8006a32 <Stspin220_HardStop+0xa6>
  else if (devicePrm.stopMode == HIZ_MODE)
 8006a08:	4b0c      	ldr	r3, [pc, #48]	; (8006a3c <Stspin220_HardStop+0xb0>)
 8006a0a:	223f      	movs	r2, #63	; 0x3f
 8006a0c:	5c9b      	ldrb	r3, [r3, r2]
 8006a0e:	2b01      	cmp	r3, #1
 8006a10:	d105      	bne.n	8006a1e <Stspin220_HardStop+0x92>
    Stspin220_HardHiZ(deviceId);
 8006a12:	1dfb      	adds	r3, r7, #7
 8006a14:	781b      	ldrb	r3, [r3, #0]
 8006a16:	0018      	movs	r0, r3
 8006a18:	f7ff ff74 	bl	8006904 <Stspin220_HardHiZ>
}
 8006a1c:	e009      	b.n	8006a32 <Stspin220_HardStop+0xa6>
  else if (devicePrm.stopMode == STANDBY_MODE)
 8006a1e:	4b07      	ldr	r3, [pc, #28]	; (8006a3c <Stspin220_HardStop+0xb0>)
 8006a20:	223f      	movs	r2, #63	; 0x3f
 8006a22:	5c9b      	ldrb	r3, [r3, r2]
 8006a24:	2b02      	cmp	r3, #2
 8006a26:	d104      	bne.n	8006a32 <Stspin220_HardStop+0xa6>
    Stspin220_PutDeviceInStandby(deviceId);
 8006a28:	1dfb      	adds	r3, r7, #7
 8006a2a:	781b      	ldrb	r3, [r3, #0]
 8006a2c:	0018      	movs	r0, r3
 8006a2e:	f000 f853 	bl	8006ad8 <Stspin220_PutDeviceInStandby>
}
 8006a32:	46c0      	nop			; (mov r8, r8)
 8006a34:	46bd      	mov	sp, r7
 8006a36:	b002      	add	sp, #8
 8006a38:	bd80      	pop	{r7, pc}
 8006a3a:	46c0      	nop			; (mov r8, r8)
 8006a3c:	2000327c 	.word	0x2000327c
 8006a40:	2000045f 	.word	0x2000045f
 8006a44:	0000a00e 	.word	0x0000a00e

08006a48 <Stspin220_Move>:
 * @param[in] direction FORWARD or BACKWARD
 * @param[in] stepCount Number of steps to perform
 * @retval None
 **********************************************************/
void Stspin220_Move(uint8_t deviceId, motorDir_t direction, uint32_t stepCount)
{
 8006a48:	b580      	push	{r7, lr}
 8006a4a:	b082      	sub	sp, #8
 8006a4c:	af00      	add	r7, sp, #0
 8006a4e:	603a      	str	r2, [r7, #0]
 8006a50:	1dfb      	adds	r3, r7, #7
 8006a52:	1c02      	adds	r2, r0, #0
 8006a54:	701a      	strb	r2, [r3, #0]
 8006a56:	1dbb      	adds	r3, r7, #6
 8006a58:	1c0a      	adds	r2, r1, #0
 8006a5a:	701a      	strb	r2, [r3, #0]
  deviceId = 0;
 8006a5c:	1dfb      	adds	r3, r7, #7
 8006a5e:	2200      	movs	r2, #0
 8006a60:	701a      	strb	r2, [r3, #0]
  
  /* Exit from standby if needed */
  if (devicePrm.motionState == STANDBY)
 8006a62:	4b1c      	ldr	r3, [pc, #112]	; (8006ad4 <Stspin220_Move+0x8c>)
 8006a64:	223c      	movs	r2, #60	; 0x3c
 8006a66:	5c9b      	ldrb	r3, [r3, r2]
 8006a68:	b2db      	uxtb	r3, r3
 8006a6a:	2b09      	cmp	r3, #9
 8006a6c:	d105      	bne.n	8006a7a <Stspin220_Move+0x32>
  {
    Stspin220_ExitDeviceFromStandby(deviceId);
 8006a6e:	1dfb      	adds	r3, r7, #7
 8006a70:	781b      	ldrb	r3, [r3, #0]
 8006a72:	0018      	movs	r0, r3
 8006a74:	f7ff fcb6 	bl	80063e4 <Stspin220_ExitDeviceFromStandby>
 8006a78:	e00a      	b.n	8006a90 <Stspin220_Move+0x48>
  }
  /* Deactivate motor if needed */
  else if (devicePrm.motionState != INACTIVE)
 8006a7a:	4b16      	ldr	r3, [pc, #88]	; (8006ad4 <Stspin220_Move+0x8c>)
 8006a7c:	223c      	movs	r2, #60	; 0x3c
 8006a7e:	5c9b      	ldrb	r3, [r3, r2]
 8006a80:	b2db      	uxtb	r3, r3
 8006a82:	2b08      	cmp	r3, #8
 8006a84:	d004      	beq.n	8006a90 <Stspin220_Move+0x48>
  {
    Stspin220_HardHiZ(deviceId);
 8006a86:	1dfb      	adds	r3, r7, #7
 8006a88:	781b      	ldrb	r3, [r3, #0]
 8006a8a:	0018      	movs	r0, r3
 8006a8c:	f7ff ff3a 	bl	8006904 <Stspin220_HardHiZ>
  }
  
  if (stepCount != 0) 
 8006a90:	683b      	ldr	r3, [r7, #0]
 8006a92:	2b00      	cmp	r3, #0
 8006a94:	d01a      	beq.n	8006acc <Stspin220_Move+0x84>
  {
    devicePrm.stepsToTake = stepCount;    
 8006a96:	4b0f      	ldr	r3, [pc, #60]	; (8006ad4 <Stspin220_Move+0x8c>)
 8006a98:	683a      	ldr	r2, [r7, #0]
 8006a9a:	61da      	str	r2, [r3, #28]
    devicePrm.commandExecuted = MOVE_CMD;
 8006a9c:	4b0d      	ldr	r3, [pc, #52]	; (8006ad4 <Stspin220_Move+0x8c>)
 8006a9e:	223a      	movs	r2, #58	; 0x3a
 8006aa0:	2102      	movs	r1, #2
 8006aa2:	5499      	strb	r1, [r3, r2]
    
    /* Direction setup */
    Stspin220_SetDirection(deviceId, direction);
 8006aa4:	1dbb      	adds	r3, r7, #6
 8006aa6:	781a      	ldrb	r2, [r3, #0]
 8006aa8:	1dfb      	adds	r3, r7, #7
 8006aaa:	781b      	ldrb	r3, [r3, #0]
 8006aac:	0011      	movs	r1, r2
 8006aae:	0018      	movs	r0, r3
 8006ab0:	f000 f8c6 	bl	8006c40 <Stspin220_SetDirection>
    
    Stspin220_ComputeSpeedProfile(deviceId, stepCount);
 8006ab4:	683a      	ldr	r2, [r7, #0]
 8006ab6:	1dfb      	adds	r3, r7, #7
 8006ab8:	781b      	ldrb	r3, [r3, #0]
 8006aba:	0011      	movs	r1, r2
 8006abc:	0018      	movs	r0, r3
 8006abe:	f000 fc47 	bl	8007350 <Stspin220_ComputeSpeedProfile>
    
    /* Motor activation */
    Stspin220_StartMovement(deviceId);
 8006ac2:	1dfb      	adds	r3, r7, #7
 8006ac4:	781b      	ldrb	r3, [r3, #0]
 8006ac6:	0018      	movs	r0, r3
 8006ac8:	f000 fe9c 	bl	8007804 <Stspin220_StartMovement>
  }  
}
 8006acc:	46c0      	nop			; (mov r8, r8)
 8006ace:	46bd      	mov	sp, r7
 8006ad0:	b002      	add	sp, #8
 8006ad2:	bd80      	pop	{r7, pc}
 8006ad4:	2000327c 	.word	0x2000327c

08006ad8 <Stspin220_PutDeviceInStandby>:
 * @brief Put STSPIN220 device in standby (low power consumption)
 * @param[in] deviceId Unused parameter
 * @retval None
 **********************************************************/
void Stspin220_PutDeviceInStandby(uint8_t deviceId)
{
 8006ad8:	b580      	push	{r7, lr}
 8006ada:	b082      	sub	sp, #8
 8006adc:	af00      	add	r7, sp, #0
 8006ade:	0002      	movs	r2, r0
 8006ae0:	1dfb      	adds	r3, r7, #7
 8006ae2:	701a      	strb	r2, [r3, #0]
  /* Stop movement */
  Stspin220_HardHiZ(deviceId);
 8006ae4:	1dfb      	adds	r3, r7, #7
 8006ae6:	781b      	ldrb	r3, [r3, #0]
 8006ae8:	0018      	movs	r0, r3
 8006aea:	f7ff ff0b 	bl	8006904 <Stspin220_HardHiZ>
  
  /* Enter standby */
	Stspin220_Board_Reset();
 8006aee:	f007 ffaf 	bl	800ea50 <Stspin220_Board_Reset>
  
  devicePrm.motionState = STANDBY;
 8006af2:	4b04      	ldr	r3, [pc, #16]	; (8006b04 <Stspin220_PutDeviceInStandby+0x2c>)
 8006af4:	223c      	movs	r2, #60	; 0x3c
 8006af6:	2109      	movs	r1, #9
 8006af8:	5499      	strb	r1, [r3, r2]
}
 8006afa:	46c0      	nop			; (mov r8, r8)
 8006afc:	46bd      	mov	sp, r7
 8006afe:	b002      	add	sp, #8
 8006b00:	bd80      	pop	{r7, pc}
 8006b02:	46c0      	nop			; (mov r8, r8)
 8006b04:	2000327c 	.word	0x2000327c

08006b08 <Stspin220_Run>:
 * @param[in] deviceId Unused parameter
 * @param[in] direction FORWARD or BACKWARD
 * @retval None
 **********************************************************/
void Stspin220_Run(uint8_t deviceId, motorDir_t direction)
{
 8006b08:	b580      	push	{r7, lr}
 8006b0a:	b082      	sub	sp, #8
 8006b0c:	af00      	add	r7, sp, #0
 8006b0e:	0002      	movs	r2, r0
 8006b10:	1dfb      	adds	r3, r7, #7
 8006b12:	701a      	strb	r2, [r3, #0]
 8006b14:	1dbb      	adds	r3, r7, #6
 8006b16:	1c0a      	adds	r2, r1, #0
 8006b18:	701a      	strb	r2, [r3, #0]
  /* Exit from standby if needed */
  if (devicePrm.motionState == STANDBY)
 8006b1a:	4b16      	ldr	r3, [pc, #88]	; (8006b74 <Stspin220_Run+0x6c>)
 8006b1c:	223c      	movs	r2, #60	; 0x3c
 8006b1e:	5c9b      	ldrb	r3, [r3, r2]
 8006b20:	b2db      	uxtb	r3, r3
 8006b22:	2b09      	cmp	r3, #9
 8006b24:	d105      	bne.n	8006b32 <Stspin220_Run+0x2a>
  {
    Stspin220_ExitDeviceFromStandby(deviceId);
 8006b26:	1dfb      	adds	r3, r7, #7
 8006b28:	781b      	ldrb	r3, [r3, #0]
 8006b2a:	0018      	movs	r0, r3
 8006b2c:	f7ff fc5a 	bl	80063e4 <Stspin220_ExitDeviceFromStandby>
 8006b30:	e00a      	b.n	8006b48 <Stspin220_Run+0x40>
  }
  /* Deactivate motor if needed */
  else if (devicePrm.motionState != INACTIVE)
 8006b32:	4b10      	ldr	r3, [pc, #64]	; (8006b74 <Stspin220_Run+0x6c>)
 8006b34:	223c      	movs	r2, #60	; 0x3c
 8006b36:	5c9b      	ldrb	r3, [r3, r2]
 8006b38:	b2db      	uxtb	r3, r3
 8006b3a:	2b08      	cmp	r3, #8
 8006b3c:	d004      	beq.n	8006b48 <Stspin220_Run+0x40>
  {
    Stspin220_HardHiZ(deviceId);
 8006b3e:	1dfb      	adds	r3, r7, #7
 8006b40:	781b      	ldrb	r3, [r3, #0]
 8006b42:	0018      	movs	r0, r3
 8006b44:	f7ff fede 	bl	8006904 <Stspin220_HardHiZ>
  }
  
	/* Direction setup */
	Stspin220_SetDirection(deviceId,direction);
 8006b48:	1dbb      	adds	r3, r7, #6
 8006b4a:	781a      	ldrb	r2, [r3, #0]
 8006b4c:	1dfb      	adds	r3, r7, #7
 8006b4e:	781b      	ldrb	r3, [r3, #0]
 8006b50:	0011      	movs	r1, r2
 8006b52:	0018      	movs	r0, r3
 8006b54:	f000 f874 	bl	8006c40 <Stspin220_SetDirection>
	devicePrm.commandExecuted = RUN_CMD;
 8006b58:	4b06      	ldr	r3, [pc, #24]	; (8006b74 <Stspin220_Run+0x6c>)
 8006b5a:	223a      	movs	r2, #58	; 0x3a
 8006b5c:	2101      	movs	r1, #1
 8006b5e:	5499      	strb	r1, [r3, r2]
	/* Motor activation */
	Stspin220_StartMovement(deviceId); 
 8006b60:	1dfb      	adds	r3, r7, #7
 8006b62:	781b      	ldrb	r3, [r3, #0]
 8006b64:	0018      	movs	r0, r3
 8006b66:	f000 fe4d 	bl	8007804 <Stspin220_StartMovement>
}
 8006b6a:	46c0      	nop			; (mov r8, r8)
 8006b6c:	46bd      	mov	sp, r7
 8006b6e:	b002      	add	sp, #8
 8006b70:	bd80      	pop	{r7, pc}
 8006b72:	46c0      	nop			; (mov r8, r8)
 8006b74:	2000327c 	.word	0x2000327c

08006b78 <Stspin220_SetAcceleration>:
 * @retval true if the command is successfully executed, else false
 * @note The command is not performed if the device is executing 
 * a MOVE or GOTO command (but it can be used during a RUN command)
 **********************************************************/
bool Stspin220_SetAcceleration(uint8_t deviceId,uint16_t newAcc)
{                                                  
 8006b78:	b580      	push	{r7, lr}
 8006b7a:	b084      	sub	sp, #16
 8006b7c:	af00      	add	r7, sp, #0
 8006b7e:	0002      	movs	r2, r0
 8006b80:	1dfb      	adds	r3, r7, #7
 8006b82:	701a      	strb	r2, [r3, #0]
 8006b84:	1d3b      	adds	r3, r7, #4
 8006b86:	1c0a      	adds	r2, r1, #0
 8006b88:	801a      	strh	r2, [r3, #0]
  bool cmdExecuted = FALSE;
 8006b8a:	230f      	movs	r3, #15
 8006b8c:	18fb      	adds	r3, r7, r3
 8006b8e:	2200      	movs	r2, #0
 8006b90:	701a      	strb	r2, [r3, #0]
  if ((newAcc != 0)&&
 8006b92:	1d3b      	adds	r3, r7, #4
 8006b94:	881b      	ldrh	r3, [r3, #0]
 8006b96:	2b00      	cmp	r3, #0
 8006b98:	d016      	beq.n	8006bc8 <Stspin220_SetAcceleration+0x50>
      (((devicePrm.motionState & INACTIVE) == INACTIVE)||
 8006b9a:	4b0f      	ldr	r3, [pc, #60]	; (8006bd8 <Stspin220_SetAcceleration+0x60>)
 8006b9c:	223c      	movs	r2, #60	; 0x3c
 8006b9e:	5c9b      	ldrb	r3, [r3, r2]
 8006ba0:	b2db      	uxtb	r3, r3
 8006ba2:	001a      	movs	r2, r3
 8006ba4:	2308      	movs	r3, #8
 8006ba6:	4013      	ands	r3, r2
  if ((newAcc != 0)&&
 8006ba8:	2b08      	cmp	r3, #8
 8006baa:	d005      	beq.n	8006bb8 <Stspin220_SetAcceleration+0x40>
       (devicePrm.commandExecuted == RUN_CMD)))
 8006bac:	4b0a      	ldr	r3, [pc, #40]	; (8006bd8 <Stspin220_SetAcceleration+0x60>)
 8006bae:	223a      	movs	r2, #58	; 0x3a
 8006bb0:	5c9b      	ldrb	r3, [r3, r2]
 8006bb2:	b2db      	uxtb	r3, r3
      (((devicePrm.motionState & INACTIVE) == INACTIVE)||
 8006bb4:	2b01      	cmp	r3, #1
 8006bb6:	d107      	bne.n	8006bc8 <Stspin220_SetAcceleration+0x50>
  {
    devicePrm.acceleration = newAcc;
 8006bb8:	4b07      	ldr	r3, [pc, #28]	; (8006bd8 <Stspin220_SetAcceleration+0x60>)
 8006bba:	1d3a      	adds	r2, r7, #4
 8006bbc:	8812      	ldrh	r2, [r2, #0]
 8006bbe:	861a      	strh	r2, [r3, #48]	; 0x30
    cmdExecuted = TRUE;
 8006bc0:	230f      	movs	r3, #15
 8006bc2:	18fb      	adds	r3, r7, r3
 8006bc4:	2201      	movs	r2, #1
 8006bc6:	701a      	strb	r2, [r3, #0]
  }    
  return cmdExecuted;
 8006bc8:	230f      	movs	r3, #15
 8006bca:	18fb      	adds	r3, r7, r3
 8006bcc:	781b      	ldrb	r3, [r3, #0]
}            
 8006bce:	0018      	movs	r0, r3
 8006bd0:	46bd      	mov	sp, r7
 8006bd2:	b004      	add	sp, #16
 8006bd4:	bd80      	pop	{r7, pc}
 8006bd6:	46c0      	nop			; (mov r8, r8)
 8006bd8:	2000327c 	.word	0x2000327c

08006bdc <Stspin220_SetDeceleration>:
 * @retval true if the command is successfully executed, else false
 * @note The command is not performed if the device is executing 
 * a MOVE or GOTO command (but it can be used during a RUN command)
 **********************************************************/
bool Stspin220_SetDeceleration(uint8_t deviceId, uint16_t newDec)
{                                                  
 8006bdc:	b580      	push	{r7, lr}
 8006bde:	b084      	sub	sp, #16
 8006be0:	af00      	add	r7, sp, #0
 8006be2:	0002      	movs	r2, r0
 8006be4:	1dfb      	adds	r3, r7, #7
 8006be6:	701a      	strb	r2, [r3, #0]
 8006be8:	1d3b      	adds	r3, r7, #4
 8006bea:	1c0a      	adds	r2, r1, #0
 8006bec:	801a      	strh	r2, [r3, #0]
  bool cmdExecuted = FALSE;
 8006bee:	230f      	movs	r3, #15
 8006bf0:	18fb      	adds	r3, r7, r3
 8006bf2:	2200      	movs	r2, #0
 8006bf4:	701a      	strb	r2, [r3, #0]
  if ((newDec != 0)&& 
 8006bf6:	1d3b      	adds	r3, r7, #4
 8006bf8:	881b      	ldrh	r3, [r3, #0]
 8006bfa:	2b00      	cmp	r3, #0
 8006bfc:	d016      	beq.n	8006c2c <Stspin220_SetDeceleration+0x50>
      (((devicePrm.motionState & INACTIVE) == INACTIVE)||
 8006bfe:	4b0f      	ldr	r3, [pc, #60]	; (8006c3c <Stspin220_SetDeceleration+0x60>)
 8006c00:	223c      	movs	r2, #60	; 0x3c
 8006c02:	5c9b      	ldrb	r3, [r3, r2]
 8006c04:	b2db      	uxtb	r3, r3
 8006c06:	001a      	movs	r2, r3
 8006c08:	2308      	movs	r3, #8
 8006c0a:	4013      	ands	r3, r2
  if ((newDec != 0)&& 
 8006c0c:	2b08      	cmp	r3, #8
 8006c0e:	d005      	beq.n	8006c1c <Stspin220_SetDeceleration+0x40>
       (devicePrm.commandExecuted == RUN_CMD)))
 8006c10:	4b0a      	ldr	r3, [pc, #40]	; (8006c3c <Stspin220_SetDeceleration+0x60>)
 8006c12:	223a      	movs	r2, #58	; 0x3a
 8006c14:	5c9b      	ldrb	r3, [r3, r2]
 8006c16:	b2db      	uxtb	r3, r3
      (((devicePrm.motionState & INACTIVE) == INACTIVE)||
 8006c18:	2b01      	cmp	r3, #1
 8006c1a:	d107      	bne.n	8006c2c <Stspin220_SetDeceleration+0x50>
  {
    devicePrm.deceleration = newDec;
 8006c1c:	4b07      	ldr	r3, [pc, #28]	; (8006c3c <Stspin220_SetDeceleration+0x60>)
 8006c1e:	1d3a      	adds	r2, r7, #4
 8006c20:	8812      	ldrh	r2, [r2, #0]
 8006c22:	865a      	strh	r2, [r3, #50]	; 0x32
    cmdExecuted = TRUE;
 8006c24:	230f      	movs	r3, #15
 8006c26:	18fb      	adds	r3, r7, r3
 8006c28:	2201      	movs	r2, #1
 8006c2a:	701a      	strb	r2, [r3, #0]
  }      
  return cmdExecuted;
 8006c2c:	230f      	movs	r3, #15
 8006c2e:	18fb      	adds	r3, r7, r3
 8006c30:	781b      	ldrb	r3, [r3, #0]
}
 8006c32:	0018      	movs	r0, r3
 8006c34:	46bd      	mov	sp, r7
 8006c36:	b004      	add	sp, #16
 8006c38:	bd80      	pop	{r7, pc}
 8006c3a:	46c0      	nop			; (mov r8, r8)
 8006c3c:	2000327c 	.word	0x2000327c

08006c40 <Stspin220_SetDirection>:
 * is in INACTIVE or STANDBY state or if the device is 
 * executing a run command
 * @retval None
 **********************************************************/
void Stspin220_SetDirection(uint8_t deviceId, motorDir_t dir)
{ 
 8006c40:	b580      	push	{r7, lr}
 8006c42:	b082      	sub	sp, #8
 8006c44:	af00      	add	r7, sp, #0
 8006c46:	0002      	movs	r2, r0
 8006c48:	1dfb      	adds	r3, r7, #7
 8006c4a:	701a      	strb	r2, [r3, #0]
 8006c4c:	1dbb      	adds	r3, r7, #6
 8006c4e:	1c0a      	adds	r2, r1, #0
 8006c50:	701a      	strb	r2, [r3, #0]
  if ((devicePrm.motionState == INACTIVE)||\
 8006c52:	4b16      	ldr	r3, [pc, #88]	; (8006cac <Stspin220_SetDirection+0x6c>)
 8006c54:	223c      	movs	r2, #60	; 0x3c
 8006c56:	5c9b      	ldrb	r3, [r3, r2]
 8006c58:	b2db      	uxtb	r3, r3
 8006c5a:	2b08      	cmp	r3, #8
 8006c5c:	d005      	beq.n	8006c6a <Stspin220_SetDirection+0x2a>
      (devicePrm.motionState == STANDBY))
 8006c5e:	4b13      	ldr	r3, [pc, #76]	; (8006cac <Stspin220_SetDirection+0x6c>)
 8006c60:	223c      	movs	r2, #60	; 0x3c
 8006c62:	5c9b      	ldrb	r3, [r3, r2]
 8006c64:	b2db      	uxtb	r3, r3
  if ((devicePrm.motionState == INACTIVE)||\
 8006c66:	2b09      	cmp	r3, #9
 8006c68:	d10a      	bne.n	8006c80 <Stspin220_SetDirection+0x40>
  {
    devicePrm.direction = dir;
 8006c6a:	4b10      	ldr	r3, [pc, #64]	; (8006cac <Stspin220_SetDirection+0x6c>)
 8006c6c:	1dba      	adds	r2, r7, #6
 8006c6e:	213b      	movs	r1, #59	; 0x3b
 8006c70:	7812      	ldrb	r2, [r2, #0]
 8006c72:	545a      	strb	r2, [r3, r1]
    Stspin220_Board_SetDirectionGpio(dir);
 8006c74:	1dbb      	adds	r3, r7, #6
 8006c76:	781b      	ldrb	r3, [r3, #0]
 8006c78:	0018      	movs	r0, r3
 8006c7a:	f007 fef7 	bl	800ea6c <Stspin220_Board_SetDirectionGpio>
  }
  else if ((devicePrm.commandExecuted&RUN_CMD)!=0)
  {
    devicePrm.commandExecuted|=STSPIN220_DIR_CHANGE_BIT_MASK;
  }
}
 8006c7e:	e011      	b.n	8006ca4 <Stspin220_SetDirection+0x64>
  else if ((devicePrm.commandExecuted&RUN_CMD)!=0)
 8006c80:	4b0a      	ldr	r3, [pc, #40]	; (8006cac <Stspin220_SetDirection+0x6c>)
 8006c82:	223a      	movs	r2, #58	; 0x3a
 8006c84:	5c9b      	ldrb	r3, [r3, r2]
 8006c86:	b2db      	uxtb	r3, r3
 8006c88:	001a      	movs	r2, r3
 8006c8a:	2301      	movs	r3, #1
 8006c8c:	4013      	ands	r3, r2
 8006c8e:	d009      	beq.n	8006ca4 <Stspin220_SetDirection+0x64>
    devicePrm.commandExecuted|=STSPIN220_DIR_CHANGE_BIT_MASK;
 8006c90:	4b06      	ldr	r3, [pc, #24]	; (8006cac <Stspin220_SetDirection+0x6c>)
 8006c92:	223a      	movs	r2, #58	; 0x3a
 8006c94:	5c9b      	ldrb	r3, [r3, r2]
 8006c96:	b2db      	uxtb	r3, r3
 8006c98:	2208      	movs	r2, #8
 8006c9a:	4313      	orrs	r3, r2
 8006c9c:	b2d9      	uxtb	r1, r3
 8006c9e:	4b03      	ldr	r3, [pc, #12]	; (8006cac <Stspin220_SetDirection+0x6c>)
 8006ca0:	223a      	movs	r2, #58	; 0x3a
 8006ca2:	5499      	strb	r1, [r3, r2]
}
 8006ca4:	46c0      	nop			; (mov r8, r8)
 8006ca6:	46bd      	mov	sp, r7
 8006ca8:	b002      	add	sp, #8
 8006caa:	bd80      	pop	{r7, pc}
 8006cac:	2000327c 	.word	0x2000327c

08006cb0 <Stspin220_SetHome>:
 * STEP_MODE_1_64                   : 1/64 step
 * STEP_MODE_1_128                  : 1/128 step
 * STEP_MODE_1_256                  : 1/256 step
 **********************************************************/
void Stspin220_SetHome(uint8_t deviceId, int32_t homePosition)
{
 8006cb0:	b580      	push	{r7, lr}
 8006cb2:	b082      	sub	sp, #8
 8006cb4:	af00      	add	r7, sp, #0
 8006cb6:	0002      	movs	r2, r0
 8006cb8:	6039      	str	r1, [r7, #0]
 8006cba:	1dfb      	adds	r3, r7, #7
 8006cbc:	701a      	strb	r2, [r3, #0]
  devicePrm.currentPosition -= homePosition;
 8006cbe:	4b05      	ldr	r3, [pc, #20]	; (8006cd4 <Stspin220_SetHome+0x24>)
 8006cc0:	685a      	ldr	r2, [r3, #4]
 8006cc2:	683b      	ldr	r3, [r7, #0]
 8006cc4:	1ad2      	subs	r2, r2, r3
 8006cc6:	4b03      	ldr	r3, [pc, #12]	; (8006cd4 <Stspin220_SetHome+0x24>)
 8006cc8:	605a      	str	r2, [r3, #4]
}
 8006cca:	46c0      	nop			; (mov r8, r8)
 8006ccc:	46bd      	mov	sp, r7
 8006cce:	b002      	add	sp, #8
 8006cd0:	bd80      	pop	{r7, pc}
 8006cd2:	46c0      	nop			; (mov r8, r8)
 8006cd4:	2000327c 	.word	0x2000327c

08006cd8 <Stspin220_SetMark>:
 * STEP_MODE_1_64                   : 1/64 step
 * STEP_MODE_1_128                  : 1/128 step
 * STEP_MODE_1_256                  : 1/256 step
 **********************************************************/
void Stspin220_SetMark(uint8_t deviceId, int32_t markPosition)
{
 8006cd8:	b580      	push	{r7, lr}
 8006cda:	b082      	sub	sp, #8
 8006cdc:	af00      	add	r7, sp, #0
 8006cde:	0002      	movs	r2, r0
 8006ce0:	6039      	str	r1, [r7, #0]
 8006ce2:	1dfb      	adds	r3, r7, #7
 8006ce4:	701a      	strb	r2, [r3, #0]
  devicePrm.markPosition = markPosition;
 8006ce6:	4b03      	ldr	r3, [pc, #12]	; (8006cf4 <Stspin220_SetMark+0x1c>)
 8006ce8:	683a      	ldr	r2, [r7, #0]
 8006cea:	60da      	str	r2, [r3, #12]
}
 8006cec:	46c0      	nop			; (mov r8, r8)
 8006cee:	46bd      	mov	sp, r7
 8006cf0:	b002      	add	sp, #8
 8006cf2:	bd80      	pop	{r7, pc}
 8006cf4:	2000327c 	.word	0x2000327c

08006cf8 <Stspin220_SetMaxSpeed>:
 * @retval true if the command is successfully executed, else false
 * @note The command is not performed is the device is executing 
 * a MOVE or GOTO command (but it can be used during a RUN command).
 **********************************************************/
bool Stspin220_SetMaxSpeed(uint8_t deviceId, uint16_t newMaxSpeed)
{                                                  
 8006cf8:	b590      	push	{r4, r7, lr}
 8006cfa:	b085      	sub	sp, #20
 8006cfc:	af00      	add	r7, sp, #0
 8006cfe:	0002      	movs	r2, r0
 8006d00:	1dfb      	adds	r3, r7, #7
 8006d02:	701a      	strb	r2, [r3, #0]
 8006d04:	1d3b      	adds	r3, r7, #4
 8006d06:	1c0a      	adds	r2, r1, #0
 8006d08:	801a      	strh	r2, [r3, #0]
  bool cmdExecuted = FALSE;
 8006d0a:	230f      	movs	r3, #15
 8006d0c:	18fb      	adds	r3, r7, r3
 8006d0e:	2200      	movs	r2, #0
 8006d10:	701a      	strb	r2, [r3, #0]
  if ((newMaxSpeed >= STSPIN220_MIN_STCK_FREQ)&&\
 8006d12:	1d3b      	adds	r3, r7, #4
 8006d14:	881b      	ldrh	r3, [r3, #0]
 8006d16:	2b07      	cmp	r3, #7
 8006d18:	d935      	bls.n	8006d86 <Stspin220_SetMaxSpeed+0x8e>
 8006d1a:	1d3b      	adds	r3, r7, #4
 8006d1c:	881b      	ldrh	r3, [r3, #0]
 8006d1e:	4a1d      	ldr	r2, [pc, #116]	; (8006d94 <Stspin220_SetMaxSpeed+0x9c>)
 8006d20:	4293      	cmp	r3, r2
 8006d22:	d912      	bls.n	8006d4a <Stspin220_SetMaxSpeed+0x52>
      ((newMaxSpeed <= STSPIN220_MAX_STCK_FREQ)||\
       ((devicePrm.torqueBoostEnable != FALSE)&&\
 8006d24:	4b1c      	ldr	r3, [pc, #112]	; (8006d98 <Stspin220_SetMaxSpeed+0xa0>)
 8006d26:	222c      	movs	r2, #44	; 0x2c
 8006d28:	5c9b      	ldrb	r3, [r3, r2]
 8006d2a:	b2db      	uxtb	r3, r3
      ((newMaxSpeed <= STSPIN220_MAX_STCK_FREQ)||\
 8006d2c:	2b00      	cmp	r3, #0
 8006d2e:	d02a      	beq.n	8006d86 <Stspin220_SetMaxSpeed+0x8e>
        ((newMaxSpeed>>Stspin220_GetStepMode(deviceId))<= STSPIN220_MAX_STCK_FREQ)))&&\
 8006d30:	1d3b      	adds	r3, r7, #4
 8006d32:	881c      	ldrh	r4, [r3, #0]
 8006d34:	1dfb      	adds	r3, r7, #7
 8006d36:	781b      	ldrb	r3, [r3, #0]
 8006d38:	0018      	movs	r0, r3
 8006d3a:	f7ff fc3b 	bl	80065b4 <Stspin220_GetStepMode>
 8006d3e:	0003      	movs	r3, r0
 8006d40:	411c      	asrs	r4, r3
 8006d42:	0023      	movs	r3, r4
       ((devicePrm.torqueBoostEnable != FALSE)&&\
 8006d44:	4a13      	ldr	r2, [pc, #76]	; (8006d94 <Stspin220_SetMaxSpeed+0x9c>)
 8006d46:	4293      	cmp	r3, r2
 8006d48:	dc1d      	bgt.n	8006d86 <Stspin220_SetMaxSpeed+0x8e>
      (devicePrm.minSpeed <= newMaxSpeed) &&\
 8006d4a:	4b13      	ldr	r3, [pc, #76]	; (8006d98 <Stspin220_SetMaxSpeed+0xa0>)
 8006d4c:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8006d4e:	b29b      	uxth	r3, r3
        ((newMaxSpeed>>Stspin220_GetStepMode(deviceId))<= STSPIN220_MAX_STCK_FREQ)))&&\
 8006d50:	1d3a      	adds	r2, r7, #4
 8006d52:	8812      	ldrh	r2, [r2, #0]
 8006d54:	429a      	cmp	r2, r3
 8006d56:	d316      	bcc.n	8006d86 <Stspin220_SetMaxSpeed+0x8e>
      (((devicePrm.motionState & INACTIVE) == INACTIVE)||\
 8006d58:	4b0f      	ldr	r3, [pc, #60]	; (8006d98 <Stspin220_SetMaxSpeed+0xa0>)
 8006d5a:	223c      	movs	r2, #60	; 0x3c
 8006d5c:	5c9b      	ldrb	r3, [r3, r2]
 8006d5e:	b2db      	uxtb	r3, r3
 8006d60:	001a      	movs	r2, r3
 8006d62:	2308      	movs	r3, #8
 8006d64:	4013      	ands	r3, r2
      (devicePrm.minSpeed <= newMaxSpeed) &&\
 8006d66:	2b08      	cmp	r3, #8
 8006d68:	d005      	beq.n	8006d76 <Stspin220_SetMaxSpeed+0x7e>
      (devicePrm.commandExecuted == RUN_CMD)))
 8006d6a:	4b0b      	ldr	r3, [pc, #44]	; (8006d98 <Stspin220_SetMaxSpeed+0xa0>)
 8006d6c:	223a      	movs	r2, #58	; 0x3a
 8006d6e:	5c9b      	ldrb	r3, [r3, r2]
 8006d70:	b2db      	uxtb	r3, r3
      (((devicePrm.motionState & INACTIVE) == INACTIVE)||\
 8006d72:	2b01      	cmp	r3, #1
 8006d74:	d107      	bne.n	8006d86 <Stspin220_SetMaxSpeed+0x8e>
  {
    devicePrm.maxSpeed = newMaxSpeed;
 8006d76:	4b08      	ldr	r3, [pc, #32]	; (8006d98 <Stspin220_SetMaxSpeed+0xa0>)
 8006d78:	1d3a      	adds	r2, r7, #4
 8006d7a:	8812      	ldrh	r2, [r2, #0]
 8006d7c:	869a      	strh	r2, [r3, #52]	; 0x34
    cmdExecuted = TRUE;
 8006d7e:	230f      	movs	r3, #15
 8006d80:	18fb      	adds	r3, r7, r3
 8006d82:	2201      	movs	r2, #1
 8006d84:	701a      	strb	r2, [r3, #0]
  }
  return cmdExecuted;
 8006d86:	230f      	movs	r3, #15
 8006d88:	18fb      	adds	r3, r7, r3
 8006d8a:	781b      	ldrb	r3, [r3, #0]
}                                                     
 8006d8c:	0018      	movs	r0, r3
 8006d8e:	46bd      	mov	sp, r7
 8006d90:	b005      	add	sp, #20
 8006d92:	bd90      	pop	{r4, r7, pc}
 8006d94:	00002710 	.word	0x00002710
 8006d98:	2000327c 	.word	0x2000327c

08006d9c <Stspin220_SetMinSpeed>:
 * @retval true if the command is successfully executed, else false
 * @note The command is not performed is the device is executing 
 * a MOVE or GOTO command (but it can be used during a RUN command).
 **********************************************************/
bool Stspin220_SetMinSpeed(uint8_t deviceId, uint16_t newMinSpeed)
{                                                  
 8006d9c:	b580      	push	{r7, lr}
 8006d9e:	b084      	sub	sp, #16
 8006da0:	af00      	add	r7, sp, #0
 8006da2:	0002      	movs	r2, r0
 8006da4:	1dfb      	adds	r3, r7, #7
 8006da6:	701a      	strb	r2, [r3, #0]
 8006da8:	1d3b      	adds	r3, r7, #4
 8006daa:	1c0a      	adds	r2, r1, #0
 8006dac:	801a      	strh	r2, [r3, #0]
  bool cmdExecuted = FALSE;
 8006dae:	230f      	movs	r3, #15
 8006db0:	18fb      	adds	r3, r7, r3
 8006db2:	2200      	movs	r2, #0
 8006db4:	701a      	strb	r2, [r3, #0]
  if ((newMinSpeed >= STSPIN220_MIN_STCK_FREQ)&&
 8006db6:	1d3b      	adds	r3, r7, #4
 8006db8:	881b      	ldrh	r3, [r3, #0]
 8006dba:	2b07      	cmp	r3, #7
 8006dbc:	d922      	bls.n	8006e04 <Stspin220_SetMinSpeed+0x68>
 8006dbe:	1d3b      	adds	r3, r7, #4
 8006dc0:	881b      	ldrh	r3, [r3, #0]
 8006dc2:	4a14      	ldr	r2, [pc, #80]	; (8006e14 <Stspin220_SetMinSpeed+0x78>)
 8006dc4:	4293      	cmp	r3, r2
 8006dc6:	d81d      	bhi.n	8006e04 <Stspin220_SetMinSpeed+0x68>
      (newMinSpeed <= STSPIN220_MAX_STCK_FREQ) &&
      (newMinSpeed <= devicePrm.maxSpeed) && 
 8006dc8:	4b13      	ldr	r3, [pc, #76]	; (8006e18 <Stspin220_SetMinSpeed+0x7c>)
 8006dca:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 8006dcc:	b29b      	uxth	r3, r3
      (newMinSpeed <= STSPIN220_MAX_STCK_FREQ) &&
 8006dce:	1d3a      	adds	r2, r7, #4
 8006dd0:	8812      	ldrh	r2, [r2, #0]
 8006dd2:	429a      	cmp	r2, r3
 8006dd4:	d816      	bhi.n	8006e04 <Stspin220_SetMinSpeed+0x68>
      (((devicePrm.motionState & INACTIVE) == INACTIVE)||
 8006dd6:	4b10      	ldr	r3, [pc, #64]	; (8006e18 <Stspin220_SetMinSpeed+0x7c>)
 8006dd8:	223c      	movs	r2, #60	; 0x3c
 8006dda:	5c9b      	ldrb	r3, [r3, r2]
 8006ddc:	b2db      	uxtb	r3, r3
 8006dde:	001a      	movs	r2, r3
 8006de0:	2308      	movs	r3, #8
 8006de2:	4013      	ands	r3, r2
      (newMinSpeed <= devicePrm.maxSpeed) && 
 8006de4:	2b08      	cmp	r3, #8
 8006de6:	d005      	beq.n	8006df4 <Stspin220_SetMinSpeed+0x58>
       (devicePrm.commandExecuted == RUN_CMD)))
 8006de8:	4b0b      	ldr	r3, [pc, #44]	; (8006e18 <Stspin220_SetMinSpeed+0x7c>)
 8006dea:	223a      	movs	r2, #58	; 0x3a
 8006dec:	5c9b      	ldrb	r3, [r3, r2]
 8006dee:	b2db      	uxtb	r3, r3
      (((devicePrm.motionState & INACTIVE) == INACTIVE)||
 8006df0:	2b01      	cmp	r3, #1
 8006df2:	d107      	bne.n	8006e04 <Stspin220_SetMinSpeed+0x68>
  {
    devicePrm.minSpeed = newMinSpeed;
 8006df4:	4b08      	ldr	r3, [pc, #32]	; (8006e18 <Stspin220_SetMinSpeed+0x7c>)
 8006df6:	1d3a      	adds	r2, r7, #4
 8006df8:	8812      	ldrh	r2, [r2, #0]
 8006dfa:	86da      	strh	r2, [r3, #54]	; 0x36
    cmdExecuted = TRUE;
 8006dfc:	230f      	movs	r3, #15
 8006dfe:	18fb      	adds	r3, r7, r3
 8006e00:	2201      	movs	r2, #1
 8006e02:	701a      	strb	r2, [r3, #0]
  }  
  return cmdExecuted;
 8006e04:	230f      	movs	r3, #15
 8006e06:	18fb      	adds	r3, r7, r3
 8006e08:	781b      	ldrb	r3, [r3, #0]
}
 8006e0a:	0018      	movs	r0, r3
 8006e0c:	46bd      	mov	sp, r7
 8006e0e:	b004      	add	sp, #16
 8006e10:	bd80      	pop	{r7, pc}
 8006e12:	46c0      	nop			; (mov r8, r8)
 8006e14:	00002710 	.word	0x00002710
 8006e18:	2000327c 	.word	0x2000327c

08006e1c <Stspin220_SetNbDevices>:
 * @param[in] nbDevices (from 1 to MAX_NUMBER_OF_DEVICES)
 * @retval TRUE if successfull, FALSE if failure, attempt to set a number of 
 * devices greater than MAX_NUMBER_OF_DEVICES
 **********************************************************/
bool Stspin220_SetNbDevices(uint8_t nbDevices)
{
 8006e1c:	b580      	push	{r7, lr}
 8006e1e:	b082      	sub	sp, #8
 8006e20:	af00      	add	r7, sp, #0
 8006e22:	0002      	movs	r2, r0
 8006e24:	1dfb      	adds	r3, r7, #7
 8006e26:	701a      	strb	r2, [r3, #0]
  if (nbDevices <= MAX_NUMBER_OF_DEVICES)
 8006e28:	1dfb      	adds	r3, r7, #7
 8006e2a:	781b      	ldrb	r3, [r3, #0]
 8006e2c:	2b01      	cmp	r3, #1
 8006e2e:	d808      	bhi.n	8006e42 <Stspin220_SetNbDevices+0x26>
  {
    stspin220NumberOfDevices = nbDevices;
 8006e30:	4b06      	ldr	r3, [pc, #24]	; (8006e4c <Stspin220_SetNbDevices+0x30>)
 8006e32:	1dfa      	adds	r2, r7, #7
 8006e34:	7812      	ldrb	r2, [r2, #0]
 8006e36:	701a      	strb	r2, [r3, #0]
    stspin220DriverInstance = 0;
 8006e38:	4b05      	ldr	r3, [pc, #20]	; (8006e50 <Stspin220_SetNbDevices+0x34>)
 8006e3a:	2200      	movs	r2, #0
 8006e3c:	801a      	strh	r2, [r3, #0]
    return TRUE;
 8006e3e:	2301      	movs	r3, #1
 8006e40:	e000      	b.n	8006e44 <Stspin220_SetNbDevices+0x28>
  }
  else
  {
    return FALSE;
 8006e42:	2300      	movs	r3, #0
  }
}
 8006e44:	0018      	movs	r0, r3
 8006e46:	46bd      	mov	sp, r7
 8006e48:	b002      	add	sp, #8
 8006e4a:	bd80      	pop	{r7, pc}
 8006e4c:	2000045e 	.word	0x2000045e
 8006e50:	2000045c 	.word	0x2000045c

08006e54 <Stspin220_SetStepMode>:
 * @param[in] stepMode from full step to 1/256 microstep
 * as specified in enum motorStepMode_t
 * @retval true if the command is successfully executed, else false
 **********************************************************/
bool Stspin220_SetStepMode(uint8_t deviceId, motorStepMode_t stepMode)
{
 8006e54:	b580      	push	{r7, lr}
 8006e56:	b082      	sub	sp, #8
 8006e58:	af00      	add	r7, sp, #0
 8006e5a:	0002      	movs	r2, r0
 8006e5c:	1dfb      	adds	r3, r7, #7
 8006e5e:	701a      	strb	r2, [r3, #0]
 8006e60:	1dbb      	adds	r3, r7, #6
 8006e62:	1c0a      	adds	r2, r1, #0
 8006e64:	701a      	strb	r2, [r3, #0]
  /* Eventually deactivate motor */
  if ((devicePrm.motionState != INACTIVE)&&\
 8006e66:	4b14      	ldr	r3, [pc, #80]	; (8006eb8 <Stspin220_SetStepMode+0x64>)
 8006e68:	223c      	movs	r2, #60	; 0x3c
 8006e6a:	5c9b      	ldrb	r3, [r3, r2]
 8006e6c:	b2db      	uxtb	r3, r3
 8006e6e:	2b08      	cmp	r3, #8
 8006e70:	d00a      	beq.n	8006e88 <Stspin220_SetStepMode+0x34>
      (devicePrm.motionState != STANDBY))
 8006e72:	4b11      	ldr	r3, [pc, #68]	; (8006eb8 <Stspin220_SetStepMode+0x64>)
 8006e74:	223c      	movs	r2, #60	; 0x3c
 8006e76:	5c9b      	ldrb	r3, [r3, r2]
 8006e78:	b2db      	uxtb	r3, r3
  if ((devicePrm.motionState != INACTIVE)&&\
 8006e7a:	2b09      	cmp	r3, #9
 8006e7c:	d004      	beq.n	8006e88 <Stspin220_SetStepMode+0x34>
  {
    Stspin220_HardHiZ(deviceId);
 8006e7e:	1dfb      	adds	r3, r7, #7
 8006e80:	781b      	ldrb	r3, [r3, #0]
 8006e82:	0018      	movs	r0, r3
 8006e84:	f7ff fd3e 	bl	8006904 <Stspin220_HardHiZ>
  }

  /* Enter standby */
  Stspin220_Board_Reset();
 8006e88:	f007 fde2 	bl	800ea50 <Stspin220_Board_Reset>
  
  /* Reset the microstepping sequencer position */
  devicePrm.sequencerPosition = 0;
 8006e8c:	4b0a      	ldr	r3, [pc, #40]	; (8006eb8 <Stspin220_SetStepMode+0x64>)
 8006e8e:	2200      	movs	r2, #0
 8006e90:	811a      	strh	r2, [r3, #8]

  /* Reset current and mark positions */
  devicePrm.currentPosition = 0; 
 8006e92:	4b09      	ldr	r3, [pc, #36]	; (8006eb8 <Stspin220_SetStepMode+0x64>)
 8006e94:	2200      	movs	r2, #0
 8006e96:	605a      	str	r2, [r3, #4]
  devicePrm.markPosition = 0;
 8006e98:	4b07      	ldr	r3, [pc, #28]	; (8006eb8 <Stspin220_SetStepMode+0x64>)
 8006e9a:	2200      	movs	r2, #0
 8006e9c:	60da      	str	r2, [r3, #12]
  
  /* Set the step mode */
  return (Stspin220_SetStepModeWithoutReset(deviceId, stepMode));
 8006e9e:	1dbb      	adds	r3, r7, #6
 8006ea0:	781a      	ldrb	r2, [r3, #0]
 8006ea2:	1dfb      	adds	r3, r7, #7
 8006ea4:	781b      	ldrb	r3, [r3, #0]
 8006ea6:	0011      	movs	r1, r2
 8006ea8:	0018      	movs	r0, r3
 8006eaa:	f000 fc3b 	bl	8007724 <Stspin220_SetStepModeWithoutReset>
 8006eae:	0003      	movs	r3, r0
}
 8006eb0:	0018      	movs	r0, r3
 8006eb2:	46bd      	mov	sp, r7
 8006eb4:	b002      	add	sp, #8
 8006eb6:	bd80      	pop	{r7, pc}
 8006eb8:	2000327c 	.word	0x2000327c

08006ebc <Stspin220_SetStopMode>:
 * @param[in] deviceId Unused parameter
 * @param[in] stopMode HOLD_MODE to let power bridge enabled
 * @retval None
 **********************************************************/
void Stspin220_SetStopMode(uint8_t deviceId, motorStopMode_t stopMode)
{
 8006ebc:	b580      	push	{r7, lr}
 8006ebe:	b082      	sub	sp, #8
 8006ec0:	af00      	add	r7, sp, #0
 8006ec2:	0002      	movs	r2, r0
 8006ec4:	1dfb      	adds	r3, r7, #7
 8006ec6:	701a      	strb	r2, [r3, #0]
 8006ec8:	1dbb      	adds	r3, r7, #6
 8006eca:	1c0a      	adds	r2, r1, #0
 8006ecc:	701a      	strb	r2, [r3, #0]
  devicePrm.stopMode = stopMode;
 8006ece:	4b04      	ldr	r3, [pc, #16]	; (8006ee0 <Stspin220_SetStopMode+0x24>)
 8006ed0:	1dba      	adds	r2, r7, #6
 8006ed2:	213f      	movs	r1, #63	; 0x3f
 8006ed4:	7812      	ldrb	r2, [r2, #0]
 8006ed6:	545a      	strb	r2, [r3, r1]
}
 8006ed8:	46c0      	nop			; (mov r8, r8)
 8006eda:	46bd      	mov	sp, r7
 8006edc:	b002      	add	sp, #8
 8006ede:	bd80      	pop	{r7, pc}
 8006ee0:	2000327c 	.word	0x2000327c

08006ee4 <Stspin220_SetTorque>:
 * @param[in] torqueValue in % (from 0 to 100)
 * @retval None
 * @note
 **********************************************************/
void Stspin220_SetTorque(uint8_t deviceId, motorTorqueMode_t torqueMode, uint8_t torqueValue)
{
 8006ee4:	b590      	push	{r4, r7, lr}
 8006ee6:	b083      	sub	sp, #12
 8006ee8:	af00      	add	r7, sp, #0
 8006eea:	0004      	movs	r4, r0
 8006eec:	0008      	movs	r0, r1
 8006eee:	0011      	movs	r1, r2
 8006ef0:	1dfb      	adds	r3, r7, #7
 8006ef2:	1c22      	adds	r2, r4, #0
 8006ef4:	701a      	strb	r2, [r3, #0]
 8006ef6:	1dbb      	adds	r3, r7, #6
 8006ef8:	1c02      	adds	r2, r0, #0
 8006efa:	701a      	strb	r2, [r3, #0]
 8006efc:	1d7b      	adds	r3, r7, #5
 8006efe:	1c0a      	adds	r2, r1, #0
 8006f00:	701a      	strb	r2, [r3, #0]
  devicePrm.updateTorque = TRUE;
 8006f02:	4b24      	ldr	r3, [pc, #144]	; (8006f94 <Stspin220_SetTorque+0xb0>)
 8006f04:	2225      	movs	r2, #37	; 0x25
 8006f06:	2101      	movs	r1, #1
 8006f08:	5499      	strb	r1, [r3, r2]
  if (torqueValue>100) torqueValue = 100;
 8006f0a:	1d7b      	adds	r3, r7, #5
 8006f0c:	781b      	ldrb	r3, [r3, #0]
 8006f0e:	2b64      	cmp	r3, #100	; 0x64
 8006f10:	d902      	bls.n	8006f18 <Stspin220_SetTorque+0x34>
 8006f12:	1d7b      	adds	r3, r7, #5
 8006f14:	2264      	movs	r2, #100	; 0x64
 8006f16:	701a      	strb	r2, [r3, #0]
  switch(torqueMode)
 8006f18:	1dbb      	adds	r3, r7, #6
 8006f1a:	781b      	ldrb	r3, [r3, #0]
 8006f1c:	2b04      	cmp	r3, #4
 8006f1e:	d82e      	bhi.n	8006f7e <Stspin220_SetTorque+0x9a>
 8006f20:	009a      	lsls	r2, r3, #2
 8006f22:	4b1d      	ldr	r3, [pc, #116]	; (8006f98 <Stspin220_SetTorque+0xb4>)
 8006f24:	18d3      	adds	r3, r2, r3
 8006f26:	681b      	ldr	r3, [r3, #0]
 8006f28:	469f      	mov	pc, r3
  {
    case ACC_TORQUE:
      devicePrm.accelTorque = torqueValue;
 8006f2a:	4b1a      	ldr	r3, [pc, #104]	; (8006f94 <Stspin220_SetTorque+0xb0>)
 8006f2c:	1d7a      	adds	r2, r7, #5
 8006f2e:	2121      	movs	r1, #33	; 0x21
 8006f30:	7812      	ldrb	r2, [r2, #0]
 8006f32:	545a      	strb	r2, [r3, r1]
      break;
 8006f34:	e029      	b.n	8006f8a <Stspin220_SetTorque+0xa6>
    case DEC_TORQUE:
      devicePrm.decelTorque = torqueValue;
 8006f36:	4b17      	ldr	r3, [pc, #92]	; (8006f94 <Stspin220_SetTorque+0xb0>)
 8006f38:	1d7a      	adds	r2, r7, #5
 8006f3a:	2122      	movs	r1, #34	; 0x22
 8006f3c:	7812      	ldrb	r2, [r2, #0]
 8006f3e:	545a      	strb	r2, [r3, r1]
      break;
 8006f40:	e023      	b.n	8006f8a <Stspin220_SetTorque+0xa6>
    case RUN_TORQUE:
      devicePrm.runTorque = torqueValue;
 8006f42:	4b14      	ldr	r3, [pc, #80]	; (8006f94 <Stspin220_SetTorque+0xb0>)
 8006f44:	1d7a      	adds	r2, r7, #5
 8006f46:	2120      	movs	r1, #32
 8006f48:	7812      	ldrb	r2, [r2, #0]
 8006f4a:	545a      	strb	r2, [r3, r1]
      break;
 8006f4c:	e01d      	b.n	8006f8a <Stspin220_SetTorque+0xa6>
    case HOLD_TORQUE:
      devicePrm.holdTorque = torqueValue;
 8006f4e:	4b11      	ldr	r3, [pc, #68]	; (8006f94 <Stspin220_SetTorque+0xb0>)
 8006f50:	1d7a      	adds	r2, r7, #5
 8006f52:	2123      	movs	r1, #35	; 0x23
 8006f54:	7812      	ldrb	r2, [r2, #0]
 8006f56:	545a      	strb	r2, [r3, r1]
      if (devicePrm.motionState != INACTIVE)
 8006f58:	4b0e      	ldr	r3, [pc, #56]	; (8006f94 <Stspin220_SetTorque+0xb0>)
 8006f5a:	223c      	movs	r2, #60	; 0x3c
 8006f5c:	5c9b      	ldrb	r3, [r3, r2]
 8006f5e:	b2db      	uxtb	r3, r3
 8006f60:	2b08      	cmp	r3, #8
 8006f62:	d111      	bne.n	8006f88 <Stspin220_SetTorque+0xa4>
      {
        break;
      }
    case CURRENT_TORQUE:
      devicePrm.currentTorque = torqueValue;
 8006f64:	4b0b      	ldr	r3, [pc, #44]	; (8006f94 <Stspin220_SetTorque+0xb0>)
 8006f66:	1d7a      	adds	r2, r7, #5
 8006f68:	2124      	movs	r1, #36	; 0x24
 8006f6a:	7812      	ldrb	r2, [r2, #0]
 8006f6c:	545a      	strb	r2, [r3, r1]
      Stspin220_Board_PwmRefSetFreqAndDutyCycle(devicePrm.refPwmFreq,torqueValue);
 8006f6e:	4b09      	ldr	r3, [pc, #36]	; (8006f94 <Stspin220_SetTorque+0xb0>)
 8006f70:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8006f72:	1d7b      	adds	r3, r7, #5
 8006f74:	781b      	ldrb	r3, [r3, #0]
 8006f76:	0019      	movs	r1, r3
 8006f78:	0010      	movs	r0, r2
 8006f7a:	f007 fc51 	bl	800e820 <Stspin220_Board_PwmRefSetFreqAndDutyCycle>
    default:
      devicePrm.updateTorque = FALSE;
 8006f7e:	4b05      	ldr	r3, [pc, #20]	; (8006f94 <Stspin220_SetTorque+0xb0>)
 8006f80:	2225      	movs	r2, #37	; 0x25
 8006f82:	2100      	movs	r1, #0
 8006f84:	5499      	strb	r1, [r3, r2]
      break; //ignore error
 8006f86:	e000      	b.n	8006f8a <Stspin220_SetTorque+0xa6>
        break;
 8006f88:	46c0      	nop			; (mov r8, r8)
  }
}
 8006f8a:	46c0      	nop			; (mov r8, r8)
 8006f8c:	46bd      	mov	sp, r7
 8006f8e:	b003      	add	sp, #12
 8006f90:	bd90      	pop	{r4, r7, pc}
 8006f92:	46c0      	nop			; (mov r8, r8)
 8006f94:	2000327c 	.word	0x2000327c
 8006f98:	08014ef0 	.word	0x08014ef0

08006f9c <Stspin220_SetTorqueBoostEnable>:
 * @param[in] deviceId Unused parameter
 * @param[in] enable true to enable torque boost, false to disable
 * @retval None
 **********************************************************/
void Stspin220_SetTorqueBoostEnable(uint8_t deviceId, bool enable)
{
 8006f9c:	b580      	push	{r7, lr}
 8006f9e:	b082      	sub	sp, #8
 8006fa0:	af00      	add	r7, sp, #0
 8006fa2:	0002      	movs	r2, r0
 8006fa4:	1dfb      	adds	r3, r7, #7
 8006fa6:	701a      	strb	r2, [r3, #0]
 8006fa8:	1dbb      	adds	r3, r7, #6
 8006faa:	1c0a      	adds	r2, r1, #0
 8006fac:	701a      	strb	r2, [r3, #0]
  devicePrm.torqueBoostEnable = enable;
 8006fae:	4b04      	ldr	r3, [pc, #16]	; (8006fc0 <Stspin220_SetTorqueBoostEnable+0x24>)
 8006fb0:	1dba      	adds	r2, r7, #6
 8006fb2:	212c      	movs	r1, #44	; 0x2c
 8006fb4:	7812      	ldrb	r2, [r2, #0]
 8006fb6:	545a      	strb	r2, [r3, r1]
}
 8006fb8:	46c0      	nop			; (mov r8, r8)
 8006fba:	46bd      	mov	sp, r7
 8006fbc:	b002      	add	sp, #8
 8006fbe:	bd80      	pop	{r7, pc}
 8006fc0:	2000327c 	.word	0x2000327c

08006fc4 <Stspin220_SetTorqueBoostThreshold>:
 * @param[in] speedThreshold speed threshold above which the step mode is
 * changed to full step
 * @retval None
 **********************************************************/
void Stspin220_SetTorqueBoostThreshold(uint8_t deviceId, uint16_t speedThreshold)
{
 8006fc4:	b580      	push	{r7, lr}
 8006fc6:	b082      	sub	sp, #8
 8006fc8:	af00      	add	r7, sp, #0
 8006fca:	0002      	movs	r2, r0
 8006fcc:	1dfb      	adds	r3, r7, #7
 8006fce:	701a      	strb	r2, [r3, #0]
 8006fd0:	1d3b      	adds	r3, r7, #4
 8006fd2:	1c0a      	adds	r2, r1, #0
 8006fd4:	801a      	strh	r2, [r3, #0]
  devicePrm.torqueBoostSpeedThreshold = speedThreshold;
 8006fd6:	4b04      	ldr	r3, [pc, #16]	; (8006fe8 <Stspin220_SetTorqueBoostThreshold+0x24>)
 8006fd8:	1d3a      	adds	r2, r7, #4
 8006fda:	8812      	ldrh	r2, [r2, #0]
 8006fdc:	85da      	strh	r2, [r3, #46]	; 0x2e
}
 8006fde:	46c0      	nop			; (mov r8, r8)
 8006fe0:	46bd      	mov	sp, r7
 8006fe2:	b002      	add	sp, #8
 8006fe4:	bd80      	pop	{r7, pc}
 8006fe6:	46c0      	nop			; (mov r8, r8)
 8006fe8:	2000327c 	.word	0x2000327c

08006fec <Stspin220_SoftStop>:
 * @retval true if the command is successfully executed, else false
 * @note The command is not performed if the device is in INACTIVE,
 * STANDBYTOINACTIVE or STANDBY state.
 **********************************************************/
bool Stspin220_SoftStop(uint8_t deviceId)
{	
 8006fec:	b580      	push	{r7, lr}
 8006fee:	b084      	sub	sp, #16
 8006ff0:	af00      	add	r7, sp, #0
 8006ff2:	0002      	movs	r2, r0
 8006ff4:	1dfb      	adds	r3, r7, #7
 8006ff6:	701a      	strb	r2, [r3, #0]
  bool cmdExecuted = FALSE;
 8006ff8:	230f      	movs	r3, #15
 8006ffa:	18fb      	adds	r3, r7, r3
 8006ffc:	2200      	movs	r2, #0
 8006ffe:	701a      	strb	r2, [r3, #0]
  if ((devicePrm.motionState & INACTIVE) != INACTIVE)
 8007000:	4b0e      	ldr	r3, [pc, #56]	; (800703c <Stspin220_SoftStop+0x50>)
 8007002:	223c      	movs	r2, #60	; 0x3c
 8007004:	5c9b      	ldrb	r3, [r3, r2]
 8007006:	b2db      	uxtb	r3, r3
 8007008:	001a      	movs	r2, r3
 800700a:	2308      	movs	r3, #8
 800700c:	4013      	ands	r3, r2
 800700e:	2b08      	cmp	r3, #8
 8007010:	d00d      	beq.n	800702e <Stspin220_SoftStop+0x42>
  {
    devicePrm.commandExecuted |= STSPIN220_SOFT_STOP_BIT_MASK;
 8007012:	4b0a      	ldr	r3, [pc, #40]	; (800703c <Stspin220_SoftStop+0x50>)
 8007014:	223a      	movs	r2, #58	; 0x3a
 8007016:	5c9b      	ldrb	r3, [r3, r2]
 8007018:	b2db      	uxtb	r3, r3
 800701a:	2204      	movs	r2, #4
 800701c:	4313      	orrs	r3, r2
 800701e:	b2d9      	uxtb	r1, r3
 8007020:	4b06      	ldr	r3, [pc, #24]	; (800703c <Stspin220_SoftStop+0x50>)
 8007022:	223a      	movs	r2, #58	; 0x3a
 8007024:	5499      	strb	r1, [r3, r2]
    cmdExecuted = TRUE;
 8007026:	230f      	movs	r3, #15
 8007028:	18fb      	adds	r3, r7, r3
 800702a:	2201      	movs	r2, #1
 800702c:	701a      	strb	r2, [r3, #0]
  }
  return (cmdExecuted);
 800702e:	230f      	movs	r3, #15
 8007030:	18fb      	adds	r3, r7, r3
 8007032:	781b      	ldrb	r3, [r3, #0]
}
 8007034:	0018      	movs	r0, r3
 8007036:	46bd      	mov	sp, r7
 8007038:	b004      	add	sp, #16
 800703a:	bd80      	pop	{r7, pc}
 800703c:	2000327c 	.word	0x2000327c

08007040 <Stspin220_VrefPwmGetFreq>:
 * @param[in] deviceId Unused parameter
 * @retval the frequency of REF PWM in Hz
 * @note
 **********************************************************/
uint32_t Stspin220_VrefPwmGetFreq(uint8_t deviceId)
{
 8007040:	b580      	push	{r7, lr}
 8007042:	b082      	sub	sp, #8
 8007044:	af00      	add	r7, sp, #0
 8007046:	0002      	movs	r2, r0
 8007048:	1dfb      	adds	r3, r7, #7
 800704a:	701a      	strb	r2, [r3, #0]
  return devicePrm.refPwmFreq;
 800704c:	4b02      	ldr	r3, [pc, #8]	; (8007058 <Stspin220_VrefPwmGetFreq+0x18>)
 800704e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
}
 8007050:	0018      	movs	r0, r3
 8007052:	46bd      	mov	sp, r7
 8007054:	b002      	add	sp, #8
 8007056:	bd80      	pop	{r7, pc}
 8007058:	2000327c 	.word	0x2000327c

0800705c <Stspin220_VrefPwmSetFreq>:
 * @param[in] newFreq in Hz
 * @retval None
 * @note
 **********************************************************/
void Stspin220_VrefPwmSetFreq(uint8_t deviceId, uint32_t newFreq)
{ 
 800705c:	b580      	push	{r7, lr}
 800705e:	b082      	sub	sp, #8
 8007060:	af00      	add	r7, sp, #0
 8007062:	0002      	movs	r2, r0
 8007064:	6039      	str	r1, [r7, #0]
 8007066:	1dfb      	adds	r3, r7, #7
 8007068:	701a      	strb	r2, [r3, #0]
  devicePrm.refPwmFreq = newFreq;
 800706a:	4b08      	ldr	r3, [pc, #32]	; (800708c <Stspin220_VrefPwmSetFreq+0x30>)
 800706c:	683a      	ldr	r2, [r7, #0]
 800706e:	629a      	str	r2, [r3, #40]	; 0x28
  Stspin220_Board_PwmRefSetFreqAndDutyCycle(newFreq,devicePrm.currentTorque);
 8007070:	4b06      	ldr	r3, [pc, #24]	; (800708c <Stspin220_VrefPwmSetFreq+0x30>)
 8007072:	2224      	movs	r2, #36	; 0x24
 8007074:	5c9b      	ldrb	r3, [r3, r2]
 8007076:	b2da      	uxtb	r2, r3
 8007078:	683b      	ldr	r3, [r7, #0]
 800707a:	0011      	movs	r1, r2
 800707c:	0018      	movs	r0, r3
 800707e:	f007 fbcf 	bl	800e820 <Stspin220_Board_PwmRefSetFreqAndDutyCycle>
}
 8007082:	46c0      	nop			; (mov r8, r8)
 8007084:	46bd      	mov	sp, r7
 8007086:	b002      	add	sp, #8
 8007088:	bd80      	pop	{r7, pc}
 800708a:	46c0      	nop			; (mov r8, r8)
 800708c:	2000327c 	.word	0x2000327c

08007090 <Stspin220_WaitWhileActive>:
 * @brief  Locks until the device state becomes Inactive
 * @param[in] deviceId Unused parameter
 * @retval None
 **********************************************************/
void Stspin220_WaitWhileActive(uint8_t deviceId)
 {
 8007090:	b580      	push	{r7, lr}
 8007092:	b082      	sub	sp, #8
 8007094:	af00      	add	r7, sp, #0
 8007096:	0002      	movs	r2, r0
 8007098:	1dfb      	adds	r3, r7, #7
 800709a:	701a      	strb	r2, [r3, #0]
  /* Wait while motor is running */
  while (((Stspin220_GetDeviceState(deviceId)&INACTIVE)!=INACTIVE)||\
 800709c:	46c0      	nop			; (mov r8, r8)
 800709e:	1dfb      	adds	r3, r7, #7
 80070a0:	781b      	ldrb	r3, [r3, #0]
 80070a2:	0018      	movs	r0, r3
 80070a4:	f7ff fa18 	bl	80064d8 <Stspin220_GetDeviceState>
 80070a8:	0003      	movs	r3, r0
 80070aa:	001a      	movs	r2, r3
 80070ac:	2308      	movs	r3, #8
 80070ae:	4013      	ands	r3, r2
 80070b0:	2b08      	cmp	r3, #8
 80070b2:	d1f4      	bne.n	800709e <Stspin220_WaitWhileActive+0xe>
   (((Stspin220_GetDeviceState(deviceId)&INACTIVE)==INACTIVE)&&(toggleOdd!=0)));
 80070b4:	1dfb      	adds	r3, r7, #7
 80070b6:	781b      	ldrb	r3, [r3, #0]
 80070b8:	0018      	movs	r0, r3
 80070ba:	f7ff fa0d 	bl	80064d8 <Stspin220_GetDeviceState>
 80070be:	0003      	movs	r3, r0
 80070c0:	001a      	movs	r2, r3
 80070c2:	2308      	movs	r3, #8
 80070c4:	4013      	ands	r3, r2
  while (((Stspin220_GetDeviceState(deviceId)&INACTIVE)!=INACTIVE)||\
 80070c6:	2b08      	cmp	r3, #8
 80070c8:	d104      	bne.n	80070d4 <Stspin220_WaitWhileActive+0x44>
   (((Stspin220_GetDeviceState(deviceId)&INACTIVE)==INACTIVE)&&(toggleOdd!=0)));
 80070ca:	4b04      	ldr	r3, [pc, #16]	; (80070dc <Stspin220_WaitWhileActive+0x4c>)
 80070cc:	781b      	ldrb	r3, [r3, #0]
 80070ce:	b2db      	uxtb	r3, r3
 80070d0:	2b00      	cmp	r3, #0
 80070d2:	d1e4      	bne.n	800709e <Stspin220_WaitWhileActive+0xe>
}
 80070d4:	46c0      	nop			; (mov r8, r8)
 80070d6:	46bd      	mov	sp, r7
 80070d8:	b002      	add	sp, #8
 80070da:	bd80      	pop	{r7, pc}
 80070dc:	2000045f 	.word	0x2000045f

080070e0 <Stspin220_ApplySpeed>:
 * @param[in] deviceId Unused parameter
 * @param[in] newSpeed in pps
 * @retval None
 **********************************************************/
void Stspin220_ApplySpeed(uint8_t deviceId, uint16_t newSpeed)
{
 80070e0:	b580      	push	{r7, lr}
 80070e2:	b082      	sub	sp, #8
 80070e4:	af00      	add	r7, sp, #0
 80070e6:	0002      	movs	r2, r0
 80070e8:	1dfb      	adds	r3, r7, #7
 80070ea:	701a      	strb	r2, [r3, #0]
 80070ec:	1d3b      	adds	r3, r7, #4
 80070ee:	1c0a      	adds	r2, r1, #0
 80070f0:	801a      	strh	r2, [r3, #0]
  if (devicePrm.torqueBoostEnable != FALSE)
 80070f2:	4b6b      	ldr	r3, [pc, #428]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 80070f4:	222c      	movs	r2, #44	; 0x2c
 80070f6:	5c9b      	ldrb	r3, [r3, r2]
 80070f8:	b2db      	uxtb	r3, r3
 80070fa:	2b00      	cmp	r3, #0
 80070fc:	d100      	bne.n	8007100 <Stspin220_ApplySpeed+0x20>
 80070fe:	e08f      	b.n	8007220 <Stspin220_ApplySpeed+0x140>
  {
    if (devicePrm.stepMode > STEP_MODE_1_256)
 8007100:	4b67      	ldr	r3, [pc, #412]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 8007102:	223d      	movs	r2, #61	; 0x3d
 8007104:	5c9b      	ldrb	r3, [r3, r2]
 8007106:	b2db      	uxtb	r3, r3
 8007108:	2b08      	cmp	r3, #8
 800710a:	d903      	bls.n	8007114 <Stspin220_ApplySpeed+0x34>
    {
      Stspin220_ErrorHandler(STSPIN220_ERROR_APPLY_SPEED);
 800710c:	4b65      	ldr	r3, [pc, #404]	; (80072a4 <Stspin220_ApplySpeed+0x1c4>)
 800710e:	0018      	movs	r0, r3
 8007110:	f7ff f950 	bl	80063b4 <Stspin220_ErrorHandler>
    }
    if (devicePrm.stepMode != STEP_MODE_FULL)
 8007114:	4b62      	ldr	r3, [pc, #392]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 8007116:	223d      	movs	r2, #61	; 0x3d
 8007118:	5c9b      	ldrb	r3, [r3, r2]
 800711a:	b2db      	uxtb	r3, r3
 800711c:	2b00      	cmp	r3, #0
 800711e:	d042      	beq.n	80071a6 <Stspin220_ApplySpeed+0xc6>
    {
      if (((newSpeed>>devicePrm.stepModeLatched)>\
 8007120:	1d3b      	adds	r3, r7, #4
 8007122:	881b      	ldrh	r3, [r3, #0]
 8007124:	4a5e      	ldr	r2, [pc, #376]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 8007126:	213e      	movs	r1, #62	; 0x3e
 8007128:	5c52      	ldrb	r2, [r2, r1]
 800712a:	4113      	asrs	r3, r2
           devicePrm.torqueBoostSpeedThreshold)&&\
 800712c:	4a5c      	ldr	r2, [pc, #368]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 800712e:	8dd2      	ldrh	r2, [r2, #46]	; 0x2e
 8007130:	b292      	uxth	r2, r2
      if (((newSpeed>>devicePrm.stepModeLatched)>\
 8007132:	4293      	cmp	r3, r2
 8007134:	dc00      	bgt.n	8007138 <Stspin220_ApplySpeed+0x58>
 8007136:	e096      	b.n	8007266 <Stspin220_ApplySpeed+0x186>
          (((devicePrm.commandExecuted & STSPIN220_MOVE_BIT_MASK) != MOVE_CMD) ||\
 8007138:	4b59      	ldr	r3, [pc, #356]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 800713a:	223a      	movs	r2, #58	; 0x3a
 800713c:	5c9b      	ldrb	r3, [r3, r2]
 800713e:	b2db      	uxtb	r3, r3
 8007140:	001a      	movs	r2, r3
 8007142:	2302      	movs	r3, #2
 8007144:	4013      	ands	r3, r2
           devicePrm.torqueBoostSpeedThreshold)&&\
 8007146:	2b02      	cmp	r3, #2
 8007148:	d10a      	bne.n	8007160 <Stspin220_ApplySpeed+0x80>
           ((devicePrm.stepsToTake-devicePrm.relativePos)>=\
 800714a:	4b55      	ldr	r3, [pc, #340]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 800714c:	69da      	ldr	r2, [r3, #28]
 800714e:	4b54      	ldr	r3, [pc, #336]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 8007150:	695b      	ldr	r3, [r3, #20]
 8007152:	1ad3      	subs	r3, r2, r3
            (1<<devicePrm.stepModeLatched))))
 8007154:	4a52      	ldr	r2, [pc, #328]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 8007156:	213e      	movs	r1, #62	; 0x3e
 8007158:	5c52      	ldrb	r2, [r2, r1]
           ((devicePrm.stepsToTake-devicePrm.relativePos)>=\
 800715a:	40d3      	lsrs	r3, r2
          (((devicePrm.commandExecuted & STSPIN220_MOVE_BIT_MASK) != MOVE_CMD) ||\
 800715c:	d100      	bne.n	8007160 <Stspin220_ApplySpeed+0x80>
 800715e:	e082      	b.n	8007266 <Stspin220_ApplySpeed+0x186>
      {
        if ((devicePrm.sequencerPosition & 0xFF) == 0X80)
 8007160:	4b4f      	ldr	r3, [pc, #316]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 8007162:	891b      	ldrh	r3, [r3, #8]
 8007164:	b21b      	sxth	r3, r3
 8007166:	b29b      	uxth	r3, r3
 8007168:	001a      	movs	r2, r3
 800716a:	23ff      	movs	r3, #255	; 0xff
 800716c:	4013      	ands	r3, r2
 800716e:	2b80      	cmp	r3, #128	; 0x80
 8007170:	d000      	beq.n	8007174 <Stspin220_ApplySpeed+0x94>
 8007172:	e078      	b.n	8007266 <Stspin220_ApplySpeed+0x186>
        {
          Stspin220_Board_SetFullStep();
 8007174:	f007 fd80 	bl	800ec78 <Stspin220_Board_SetFullStep>
          devicePrm.stepMode = STEP_MODE_FULL;
 8007178:	4b49      	ldr	r3, [pc, #292]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 800717a:	223d      	movs	r2, #61	; 0x3d
 800717c:	2100      	movs	r1, #0
 800717e:	5499      	strb	r1, [r3, r2]
          devicePrm.accu >>= devicePrm.stepModeLatched;
 8007180:	4b47      	ldr	r3, [pc, #284]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 8007182:	681b      	ldr	r3, [r3, #0]
 8007184:	4a46      	ldr	r2, [pc, #280]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 8007186:	213e      	movs	r1, #62	; 0x3e
 8007188:	5c52      	ldrb	r2, [r2, r1]
 800718a:	40d3      	lsrs	r3, r2
 800718c:	001a      	movs	r2, r3
 800718e:	4b44      	ldr	r3, [pc, #272]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 8007190:	601a      	str	r2, [r3, #0]
          newSpeed >>= devicePrm.stepModeLatched;
 8007192:	1d3b      	adds	r3, r7, #4
 8007194:	881b      	ldrh	r3, [r3, #0]
 8007196:	4a42      	ldr	r2, [pc, #264]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 8007198:	213e      	movs	r1, #62	; 0x3e
 800719a:	5c52      	ldrb	r2, [r2, r1]
 800719c:	4113      	asrs	r3, r2
 800719e:	001a      	movs	r2, r3
 80071a0:	1d3b      	adds	r3, r7, #4
 80071a2:	801a      	strh	r2, [r3, #0]
 80071a4:	e05f      	b.n	8007266 <Stspin220_ApplySpeed+0x186>
        }
      }
    }
    else if (((newSpeed <= devicePrm.torqueBoostSpeedThreshold) &&\
 80071a6:	4b3e      	ldr	r3, [pc, #248]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 80071a8:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
 80071aa:	b29b      	uxth	r3, r3
 80071ac:	1d3a      	adds	r2, r7, #4
 80071ae:	8812      	ldrh	r2, [r2, #0]
 80071b0:	429a      	cmp	r2, r3
 80071b2:	d804      	bhi.n	80071be <Stspin220_ApplySpeed+0xde>
              (devicePrm.stepModeLatched != STEP_MODE_FULL))||\
 80071b4:	4b3a      	ldr	r3, [pc, #232]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 80071b6:	223e      	movs	r2, #62	; 0x3e
 80071b8:	5c9b      	ldrb	r3, [r3, r2]
    else if (((newSpeed <= devicePrm.torqueBoostSpeedThreshold) &&\
 80071ba:	2b00      	cmp	r3, #0
 80071bc:	d115      	bne.n	80071ea <Stspin220_ApplySpeed+0x10a>
             (((devicePrm.commandExecuted & STSPIN220_MOVE_BIT_MASK) == MOVE_CMD)&&\
 80071be:	4b38      	ldr	r3, [pc, #224]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 80071c0:	223a      	movs	r2, #58	; 0x3a
 80071c2:	5c9b      	ldrb	r3, [r3, r2]
 80071c4:	b2db      	uxtb	r3, r3
 80071c6:	001a      	movs	r2, r3
 80071c8:	2302      	movs	r3, #2
 80071ca:	4013      	ands	r3, r2
              (devicePrm.stepModeLatched != STEP_MODE_FULL))||\
 80071cc:	2b02      	cmp	r3, #2
 80071ce:	d14a      	bne.n	8007266 <Stspin220_ApplySpeed+0x186>
               ((devicePrm.stepsToTake-devicePrm.relativePos)<=\
 80071d0:	4b33      	ldr	r3, [pc, #204]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 80071d2:	69da      	ldr	r2, [r3, #28]
 80071d4:	4b32      	ldr	r3, [pc, #200]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 80071d6:	695b      	ldr	r3, [r3, #20]
 80071d8:	1ad3      	subs	r3, r2, r3
                (1<<devicePrm.stepModeLatched))))
 80071da:	4a31      	ldr	r2, [pc, #196]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 80071dc:	213e      	movs	r1, #62	; 0x3e
 80071de:	5c52      	ldrb	r2, [r2, r1]
 80071e0:	0011      	movs	r1, r2
 80071e2:	2201      	movs	r2, #1
 80071e4:	408a      	lsls	r2, r1
             (((devicePrm.commandExecuted & STSPIN220_MOVE_BIT_MASK) == MOVE_CMD)&&\
 80071e6:	4293      	cmp	r3, r2
 80071e8:	d83d      	bhi.n	8007266 <Stspin220_ApplySpeed+0x186>
    {
      Stspin220_Board_UnsetFullStep();
 80071ea:	f007 fd59 	bl	800eca0 <Stspin220_Board_UnsetFullStep>
      devicePrm.stepMode = devicePrm.stepModeLatched;
 80071ee:	4b2c      	ldr	r3, [pc, #176]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 80071f0:	223e      	movs	r2, #62	; 0x3e
 80071f2:	5c99      	ldrb	r1, [r3, r2]
 80071f4:	4b2a      	ldr	r3, [pc, #168]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 80071f6:	223d      	movs	r2, #61	; 0x3d
 80071f8:	5499      	strb	r1, [r3, r2]
      devicePrm.accu <<= devicePrm.stepModeLatched;
 80071fa:	4b29      	ldr	r3, [pc, #164]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 80071fc:	681b      	ldr	r3, [r3, #0]
 80071fe:	4a28      	ldr	r2, [pc, #160]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 8007200:	213e      	movs	r1, #62	; 0x3e
 8007202:	5c52      	ldrb	r2, [r2, r1]
 8007204:	4093      	lsls	r3, r2
 8007206:	001a      	movs	r2, r3
 8007208:	4b25      	ldr	r3, [pc, #148]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 800720a:	601a      	str	r2, [r3, #0]
      newSpeed <<= devicePrm.stepModeLatched;
 800720c:	1d3b      	adds	r3, r7, #4
 800720e:	881b      	ldrh	r3, [r3, #0]
 8007210:	4a23      	ldr	r2, [pc, #140]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 8007212:	213e      	movs	r1, #62	; 0x3e
 8007214:	5c52      	ldrb	r2, [r2, r1]
 8007216:	4093      	lsls	r3, r2
 8007218:	001a      	movs	r2, r3
 800721a:	1d3b      	adds	r3, r7, #4
 800721c:	801a      	strh	r2, [r3, #0]
 800721e:	e022      	b.n	8007266 <Stspin220_ApplySpeed+0x186>
    }
  }
  else if (devicePrm.stepMode != devicePrm.stepModeLatched)
 8007220:	4b1f      	ldr	r3, [pc, #124]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 8007222:	223d      	movs	r2, #61	; 0x3d
 8007224:	5c9b      	ldrb	r3, [r3, r2]
 8007226:	b2da      	uxtb	r2, r3
 8007228:	4b1d      	ldr	r3, [pc, #116]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 800722a:	213e      	movs	r1, #62	; 0x3e
 800722c:	5c5b      	ldrb	r3, [r3, r1]
 800722e:	429a      	cmp	r2, r3
 8007230:	d019      	beq.n	8007266 <Stspin220_ApplySpeed+0x186>
  {
    //torqueBoostEnable has just been disabled
    Stspin220_Board_UnsetFullStep();
 8007232:	f007 fd35 	bl	800eca0 <Stspin220_Board_UnsetFullStep>
    devicePrm.stepMode = devicePrm.stepModeLatched;
 8007236:	4b1a      	ldr	r3, [pc, #104]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 8007238:	223e      	movs	r2, #62	; 0x3e
 800723a:	5c99      	ldrb	r1, [r3, r2]
 800723c:	4b18      	ldr	r3, [pc, #96]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 800723e:	223d      	movs	r2, #61	; 0x3d
 8007240:	5499      	strb	r1, [r3, r2]
    devicePrm.accu <<= devicePrm.stepModeLatched;
 8007242:	4b17      	ldr	r3, [pc, #92]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 8007244:	681b      	ldr	r3, [r3, #0]
 8007246:	4a16      	ldr	r2, [pc, #88]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 8007248:	213e      	movs	r1, #62	; 0x3e
 800724a:	5c52      	ldrb	r2, [r2, r1]
 800724c:	4093      	lsls	r3, r2
 800724e:	001a      	movs	r2, r3
 8007250:	4b13      	ldr	r3, [pc, #76]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 8007252:	601a      	str	r2, [r3, #0]
    newSpeed <<= devicePrm.stepModeLatched;
 8007254:	1d3b      	adds	r3, r7, #4
 8007256:	881b      	ldrh	r3, [r3, #0]
 8007258:	4a11      	ldr	r2, [pc, #68]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 800725a:	213e      	movs	r1, #62	; 0x3e
 800725c:	5c52      	ldrb	r2, [r2, r1]
 800725e:	4093      	lsls	r3, r2
 8007260:	001a      	movs	r2, r3
 8007262:	1d3b      	adds	r3, r7, #4
 8007264:	801a      	strh	r2, [r3, #0]
  }
  
  if (newSpeed < STSPIN220_MIN_STCK_FREQ)
 8007266:	1d3b      	adds	r3, r7, #4
 8007268:	881b      	ldrh	r3, [r3, #0]
 800726a:	2b07      	cmp	r3, #7
 800726c:	d802      	bhi.n	8007274 <Stspin220_ApplySpeed+0x194>
  {
    newSpeed = STSPIN220_MIN_STCK_FREQ;  
 800726e:	1d3b      	adds	r3, r7, #4
 8007270:	2208      	movs	r2, #8
 8007272:	801a      	strh	r2, [r3, #0]
  }
  if (newSpeed > STSPIN220_MAX_STCK_FREQ)
 8007274:	1d3b      	adds	r3, r7, #4
 8007276:	881b      	ldrh	r3, [r3, #0]
 8007278:	4a0b      	ldr	r2, [pc, #44]	; (80072a8 <Stspin220_ApplySpeed+0x1c8>)
 800727a:	4293      	cmp	r3, r2
 800727c:	d902      	bls.n	8007284 <Stspin220_ApplySpeed+0x1a4>
  {
    newSpeed = STSPIN220_MAX_STCK_FREQ;
 800727e:	1d3b      	adds	r3, r7, #4
 8007280:	4a09      	ldr	r2, [pc, #36]	; (80072a8 <Stspin220_ApplySpeed+0x1c8>)
 8007282:	801a      	strh	r2, [r3, #0]
  }
  
  devicePrm.speed = newSpeed;
 8007284:	4b06      	ldr	r3, [pc, #24]	; (80072a0 <Stspin220_ApplySpeed+0x1c0>)
 8007286:	1d3a      	adds	r2, r7, #4
 8007288:	8812      	ldrh	r2, [r2, #0]
 800728a:	871a      	strh	r2, [r3, #56]	; 0x38
  Stspin220_Board_TimStckSetFreq(newSpeed);
 800728c:	1d3b      	adds	r3, r7, #4
 800728e:	881b      	ldrh	r3, [r3, #0]
 8007290:	0018      	movs	r0, r3
 8007292:	f007 fa91 	bl	800e7b8 <Stspin220_Board_TimStckSetFreq>

}
 8007296:	46c0      	nop			; (mov r8, r8)
 8007298:	46bd      	mov	sp, r7
 800729a:	b002      	add	sp, #8
 800729c:	bd80      	pop	{r7, pc}
 800729e:	46c0      	nop			; (mov r8, r8)
 80072a0:	2000327c 	.word	0x2000327c
 80072a4:	0000a00c 	.word	0x0000a00c
 80072a8:	00002710 	.word	0x00002710

080072ac <Stspin220_ApplyTorque>:
 * @param[in] torqueMode torque mode
 * @retval None
 * @note
 **********************************************************/
void Stspin220_ApplyTorque(uint8_t deviceId, motorTorqueMode_t torqueMode)
{
 80072ac:	b580      	push	{r7, lr}
 80072ae:	b084      	sub	sp, #16
 80072b0:	af00      	add	r7, sp, #0
 80072b2:	0002      	movs	r2, r0
 80072b4:	1dfb      	adds	r3, r7, #7
 80072b6:	701a      	strb	r2, [r3, #0]
 80072b8:	1dbb      	adds	r3, r7, #6
 80072ba:	1c0a      	adds	r2, r1, #0
 80072bc:	701a      	strb	r2, [r3, #0]
  uint8_t torqueValue = 0;
 80072be:	230f      	movs	r3, #15
 80072c0:	18fb      	adds	r3, r7, r3
 80072c2:	2200      	movs	r2, #0
 80072c4:	701a      	strb	r2, [r3, #0]
  devicePrm.updateTorque = FALSE;
 80072c6:	4b20      	ldr	r3, [pc, #128]	; (8007348 <Stspin220_ApplyTorque+0x9c>)
 80072c8:	2225      	movs	r2, #37	; 0x25
 80072ca:	2100      	movs	r1, #0
 80072cc:	5499      	strb	r1, [r3, r2]
  switch(torqueMode)
 80072ce:	1dbb      	adds	r3, r7, #6
 80072d0:	781b      	ldrb	r3, [r3, #0]
 80072d2:	2b04      	cmp	r3, #4
 80072d4:	d834      	bhi.n	8007340 <Stspin220_ApplyTorque+0x94>
 80072d6:	009a      	lsls	r2, r3, #2
 80072d8:	4b1c      	ldr	r3, [pc, #112]	; (800734c <Stspin220_ApplyTorque+0xa0>)
 80072da:	18d3      	adds	r3, r2, r3
 80072dc:	681b      	ldr	r3, [r3, #0]
 80072de:	469f      	mov	pc, r3
  {
    case ACC_TORQUE:
      devicePrm.currentTorque = devicePrm.accelTorque;
 80072e0:	4b19      	ldr	r3, [pc, #100]	; (8007348 <Stspin220_ApplyTorque+0x9c>)
 80072e2:	2221      	movs	r2, #33	; 0x21
 80072e4:	5c9b      	ldrb	r3, [r3, r2]
 80072e6:	b2d9      	uxtb	r1, r3
 80072e8:	4b17      	ldr	r3, [pc, #92]	; (8007348 <Stspin220_ApplyTorque+0x9c>)
 80072ea:	2224      	movs	r2, #36	; 0x24
 80072ec:	5499      	strb	r1, [r3, r2]
      break;
 80072ee:	e018      	b.n	8007322 <Stspin220_ApplyTorque+0x76>
    case DEC_TORQUE:
      devicePrm.currentTorque = devicePrm.decelTorque;
 80072f0:	4b15      	ldr	r3, [pc, #84]	; (8007348 <Stspin220_ApplyTorque+0x9c>)
 80072f2:	2222      	movs	r2, #34	; 0x22
 80072f4:	5c9b      	ldrb	r3, [r3, r2]
 80072f6:	b2d9      	uxtb	r1, r3
 80072f8:	4b13      	ldr	r3, [pc, #76]	; (8007348 <Stspin220_ApplyTorque+0x9c>)
 80072fa:	2224      	movs	r2, #36	; 0x24
 80072fc:	5499      	strb	r1, [r3, r2]
      break;
 80072fe:	e010      	b.n	8007322 <Stspin220_ApplyTorque+0x76>
    case RUN_TORQUE:
      devicePrm.currentTorque = devicePrm.runTorque;
 8007300:	4b11      	ldr	r3, [pc, #68]	; (8007348 <Stspin220_ApplyTorque+0x9c>)
 8007302:	2220      	movs	r2, #32
 8007304:	5c9b      	ldrb	r3, [r3, r2]
 8007306:	b2d9      	uxtb	r1, r3
 8007308:	4b0f      	ldr	r3, [pc, #60]	; (8007348 <Stspin220_ApplyTorque+0x9c>)
 800730a:	2224      	movs	r2, #36	; 0x24
 800730c:	5499      	strb	r1, [r3, r2]
      break;
 800730e:	e008      	b.n	8007322 <Stspin220_ApplyTorque+0x76>
    case HOLD_TORQUE:
      devicePrm.currentTorque = devicePrm.holdTorque;
 8007310:	4b0d      	ldr	r3, [pc, #52]	; (8007348 <Stspin220_ApplyTorque+0x9c>)
 8007312:	2223      	movs	r2, #35	; 0x23
 8007314:	5c9b      	ldrb	r3, [r3, r2]
 8007316:	b2d9      	uxtb	r1, r3
 8007318:	4b0b      	ldr	r3, [pc, #44]	; (8007348 <Stspin220_ApplyTorque+0x9c>)
 800731a:	2224      	movs	r2, #36	; 0x24
 800731c:	5499      	strb	r1, [r3, r2]
      break;
 800731e:	e000      	b.n	8007322 <Stspin220_ApplyTorque+0x76>
    case CURRENT_TORQUE:
      break;
 8007320:	46c0      	nop			; (mov r8, r8)
    default:
      return; //ignore error
  }
  torqueValue = devicePrm.currentTorque;
 8007322:	200f      	movs	r0, #15
 8007324:	183b      	adds	r3, r7, r0
 8007326:	4a08      	ldr	r2, [pc, #32]	; (8007348 <Stspin220_ApplyTorque+0x9c>)
 8007328:	2124      	movs	r1, #36	; 0x24
 800732a:	5c52      	ldrb	r2, [r2, r1]
 800732c:	701a      	strb	r2, [r3, #0]
  Stspin220_Board_PwmRefSetFreqAndDutyCycle(devicePrm.refPwmFreq,torqueValue);
 800732e:	4b06      	ldr	r3, [pc, #24]	; (8007348 <Stspin220_ApplyTorque+0x9c>)
 8007330:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8007332:	183b      	adds	r3, r7, r0
 8007334:	781b      	ldrb	r3, [r3, #0]
 8007336:	0019      	movs	r1, r3
 8007338:	0010      	movs	r0, r2
 800733a:	f007 fa71 	bl	800e820 <Stspin220_Board_PwmRefSetFreqAndDutyCycle>
 800733e:	e000      	b.n	8007342 <Stspin220_ApplyTorque+0x96>
      return; //ignore error
 8007340:	46c0      	nop			; (mov r8, r8)
}
 8007342:	46bd      	mov	sp, r7
 8007344:	b004      	add	sp, #16
 8007346:	bd80      	pop	{r7, pc}
 8007348:	2000327c 	.word	0x2000327c
 800734c:	08014f04 	.word	0x08014f04

08007350 <Stspin220_ComputeSpeedProfile>:
 * speed.
 * Else, a triangular move is performed (no steady phase: the maximum speed is never
 * reached.
 **********************************************************/
void Stspin220_ComputeSpeedProfile(uint8_t deviceId, uint32_t nbSteps)
{
 8007350:	b580      	push	{r7, lr}
 8007352:	b088      	sub	sp, #32
 8007354:	af00      	add	r7, sp, #0
 8007356:	0002      	movs	r2, r0
 8007358:	6039      	str	r1, [r7, #0]
 800735a:	1dfb      	adds	r3, r7, #7
 800735c:	701a      	strb	r2, [r3, #0]
  uint32_t reqAccSteps; 
	uint32_t reqDecSteps;
   
  /* compute the number of steps to get the targeted speed */
  uint16_t minSpeed = devicePrm.minSpeed;
 800735e:	211a      	movs	r1, #26
 8007360:	187b      	adds	r3, r7, r1
 8007362:	4a36      	ldr	r2, [pc, #216]	; (800743c <Stspin220_ComputeSpeedProfile+0xec>)
 8007364:	8ed2      	ldrh	r2, [r2, #54]	; 0x36
 8007366:	801a      	strh	r2, [r3, #0]
  reqAccSteps = (devicePrm.maxSpeed - minSpeed);
 8007368:	4b34      	ldr	r3, [pc, #208]	; (800743c <Stspin220_ComputeSpeedProfile+0xec>)
 800736a:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 800736c:	b29b      	uxth	r3, r3
 800736e:	001a      	movs	r2, r3
 8007370:	187b      	adds	r3, r7, r1
 8007372:	881b      	ldrh	r3, [r3, #0]
 8007374:	1ad3      	subs	r3, r2, r3
 8007376:	61fb      	str	r3, [r7, #28]
  reqAccSteps *= (devicePrm.maxSpeed + minSpeed);
 8007378:	4b30      	ldr	r3, [pc, #192]	; (800743c <Stspin220_ComputeSpeedProfile+0xec>)
 800737a:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 800737c:	b29b      	uxth	r3, r3
 800737e:	001a      	movs	r2, r3
 8007380:	187b      	adds	r3, r7, r1
 8007382:	881b      	ldrh	r3, [r3, #0]
 8007384:	18d3      	adds	r3, r2, r3
 8007386:	001a      	movs	r2, r3
 8007388:	69fb      	ldr	r3, [r7, #28]
 800738a:	4353      	muls	r3, r2
 800738c:	61fb      	str	r3, [r7, #28]
  reqDecSteps = reqAccSteps;
 800738e:	69fb      	ldr	r3, [r7, #28]
 8007390:	617b      	str	r3, [r7, #20]
  reqAccSteps /= (uint32_t)devicePrm.acceleration;
 8007392:	4b2a      	ldr	r3, [pc, #168]	; (800743c <Stspin220_ComputeSpeedProfile+0xec>)
 8007394:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 8007396:	b29b      	uxth	r3, r3
 8007398:	0019      	movs	r1, r3
 800739a:	69f8      	ldr	r0, [r7, #28]
 800739c:	f7f8 fec6 	bl	800012c <__udivsi3>
 80073a0:	0003      	movs	r3, r0
 80073a2:	61fb      	str	r3, [r7, #28]
  reqAccSteps /= 2;
 80073a4:	69fb      	ldr	r3, [r7, #28]
 80073a6:	085b      	lsrs	r3, r3, #1
 80073a8:	61fb      	str	r3, [r7, #28]

  /* compute the number of steps to stop */
  reqDecSteps /= (uint32_t)devicePrm.deceleration;
 80073aa:	4b24      	ldr	r3, [pc, #144]	; (800743c <Stspin220_ComputeSpeedProfile+0xec>)
 80073ac:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 80073ae:	b29b      	uxth	r3, r3
 80073b0:	0019      	movs	r1, r3
 80073b2:	6978      	ldr	r0, [r7, #20]
 80073b4:	f7f8 feba 	bl	800012c <__udivsi3>
 80073b8:	0003      	movs	r3, r0
 80073ba:	617b      	str	r3, [r7, #20]
  reqDecSteps /= 2;
 80073bc:	697b      	ldr	r3, [r7, #20]
 80073be:	085b      	lsrs	r3, r3, #1
 80073c0:	617b      	str	r3, [r7, #20]

	if(( reqAccSteps + reqDecSteps ) > nbSteps)
 80073c2:	69fa      	ldr	r2, [r7, #28]
 80073c4:	697b      	ldr	r3, [r7, #20]
 80073c6:	18d3      	adds	r3, r2, r3
 80073c8:	683a      	ldr	r2, [r7, #0]
 80073ca:	429a      	cmp	r2, r3
 80073cc:	d228      	bcs.n	8007420 <Stspin220_ComputeSpeedProfile+0xd0>
	{	
    /* Triangular move  */
    /* reqDecSteps = (Pos * Dec) /(Dec+Acc) */
    uint32_t dec = devicePrm.deceleration;
 80073ce:	4b1b      	ldr	r3, [pc, #108]	; (800743c <Stspin220_ComputeSpeedProfile+0xec>)
 80073d0:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 80073d2:	b29b      	uxth	r3, r3
 80073d4:	613b      	str	r3, [r7, #16]
    uint32_t acc = devicePrm.acceleration;
 80073d6:	4b19      	ldr	r3, [pc, #100]	; (800743c <Stspin220_ComputeSpeedProfile+0xec>)
 80073d8:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 80073da:	b29b      	uxth	r3, r3
 80073dc:	60fb      	str	r3, [r7, #12]
    
    reqDecSteps =  ((uint32_t) dec * nbSteps) / (acc + dec);
 80073de:	693b      	ldr	r3, [r7, #16]
 80073e0:	683a      	ldr	r2, [r7, #0]
 80073e2:	435a      	muls	r2, r3
 80073e4:	0010      	movs	r0, r2
 80073e6:	68fa      	ldr	r2, [r7, #12]
 80073e8:	693b      	ldr	r3, [r7, #16]
 80073ea:	18d3      	adds	r3, r2, r3
 80073ec:	0019      	movs	r1, r3
 80073ee:	f7f8 fe9d 	bl	800012c <__udivsi3>
 80073f2:	0003      	movs	r3, r0
 80073f4:	617b      	str	r3, [r7, #20]
    if (reqDecSteps > 1)
 80073f6:	697b      	ldr	r3, [r7, #20]
 80073f8:	2b01      	cmp	r3, #1
 80073fa:	d908      	bls.n	800740e <Stspin220_ComputeSpeedProfile+0xbe>
    {
      reqAccSteps = reqDecSteps - 1;
 80073fc:	697b      	ldr	r3, [r7, #20]
 80073fe:	3b01      	subs	r3, #1
 8007400:	61fb      	str	r3, [r7, #28]
      if(reqAccSteps == 0)
 8007402:	69fb      	ldr	r3, [r7, #28]
 8007404:	2b00      	cmp	r3, #0
 8007406:	d104      	bne.n	8007412 <Stspin220_ComputeSpeedProfile+0xc2>
      {
        reqAccSteps = 1;
 8007408:	2301      	movs	r3, #1
 800740a:	61fb      	str	r3, [r7, #28]
 800740c:	e001      	b.n	8007412 <Stspin220_ComputeSpeedProfile+0xc2>
      }      
    }
    else
    {
      reqAccSteps = 0;
 800740e:	2300      	movs	r3, #0
 8007410:	61fb      	str	r3, [r7, #28]
    }
    devicePrm.endAccPos = reqAccSteps;
 8007412:	4b0a      	ldr	r3, [pc, #40]	; (800743c <Stspin220_ComputeSpeedProfile+0xec>)
 8007414:	69fa      	ldr	r2, [r7, #28]
 8007416:	611a      	str	r2, [r3, #16]
    devicePrm.startDecPos = reqDecSteps;
 8007418:	4b08      	ldr	r3, [pc, #32]	; (800743c <Stspin220_ComputeSpeedProfile+0xec>)
 800741a:	697a      	ldr	r2, [r7, #20]
 800741c:	619a      	str	r2, [r3, #24]
    /* steady phase from  endAccPos to startDecPos */
    /* decelerating from startDecPos to stepsToTake*/
    devicePrm.endAccPos = reqAccSteps;
    devicePrm.startDecPos = nbSteps - reqDecSteps - 1;
	}
}
 800741e:	e008      	b.n	8007432 <Stspin220_ComputeSpeedProfile+0xe2>
    devicePrm.endAccPos = reqAccSteps;
 8007420:	4b06      	ldr	r3, [pc, #24]	; (800743c <Stspin220_ComputeSpeedProfile+0xec>)
 8007422:	69fa      	ldr	r2, [r7, #28]
 8007424:	611a      	str	r2, [r3, #16]
    devicePrm.startDecPos = nbSteps - reqDecSteps - 1;
 8007426:	683a      	ldr	r2, [r7, #0]
 8007428:	697b      	ldr	r3, [r7, #20]
 800742a:	1ad3      	subs	r3, r2, r3
 800742c:	1e5a      	subs	r2, r3, #1
 800742e:	4b03      	ldr	r3, [pc, #12]	; (800743c <Stspin220_ComputeSpeedProfile+0xec>)
 8007430:	619a      	str	r2, [r3, #24]
}
 8007432:	46c0      	nop			; (mov r8, r8)
 8007434:	46bd      	mov	sp, r7
 8007436:	b008      	add	sp, #32
 8007438:	bd80      	pop	{r7, pc}
 800743a:	46c0      	nop			; (mov r8, r8)
 800743c:	2000327c 	.word	0x2000327c

08007440 <Stspin220_FlagInterruptHandler>:
/******************************************************//**
 * @brief  Handlers of the flag interrupt which calls the user callback (if defined)
 * @retval None
 **********************************************************/
void Stspin220_FlagInterruptHandler(void)
{
 8007440:	b580      	push	{r7, lr}
 8007442:	af00      	add	r7, sp, #0
  if (flagInterruptCallback != 0)
 8007444:	4b04      	ldr	r3, [pc, #16]	; (8007458 <Stspin220_FlagInterruptHandler+0x18>)
 8007446:	681b      	ldr	r3, [r3, #0]
 8007448:	2b00      	cmp	r3, #0
 800744a:	d002      	beq.n	8007452 <Stspin220_FlagInterruptHandler+0x12>
  {
    flagInterruptCallback();
 800744c:	4b02      	ldr	r3, [pc, #8]	; (8007458 <Stspin220_FlagInterruptHandler+0x18>)
 800744e:	681b      	ldr	r3, [r3, #0]
 8007450:	4798      	blx	r3
  }
}
 8007452:	46c0      	nop			; (mov r8, r8)
 8007454:	46bd      	mov	sp, r7
 8007456:	bd80      	pop	{r7, pc}
 8007458:	200032c0 	.word	0x200032c0

0800745c <Stspin220_SetDeviceParamsOtherValues>:
 * @brief  Set the parameters of the device whose values are not defined in
 * stspin220_target_config.h
 * @retval None
 **********************************************************/
void Stspin220_SetDeviceParamsOtherValues(void)
{
 800745c:	b580      	push	{r7, lr}
 800745e:	b082      	sub	sp, #8
 8007460:	af00      	add	r7, sp, #0
  uint16_t tmp;

  devicePrm.accu = 0;
 8007462:	4b21      	ldr	r3, [pc, #132]	; (80074e8 <Stspin220_SetDeviceParamsOtherValues+0x8c>)
 8007464:	2200      	movs	r2, #0
 8007466:	601a      	str	r2, [r3, #0]
  devicePrm.currentPosition = 0;
 8007468:	4b1f      	ldr	r3, [pc, #124]	; (80074e8 <Stspin220_SetDeviceParamsOtherValues+0x8c>)
 800746a:	2200      	movs	r2, #0
 800746c:	605a      	str	r2, [r3, #4]
  devicePrm.sequencerPosition = 0;
 800746e:	4b1e      	ldr	r3, [pc, #120]	; (80074e8 <Stspin220_SetDeviceParamsOtherValues+0x8c>)
 8007470:	2200      	movs	r2, #0
 8007472:	811a      	strh	r2, [r3, #8]
  devicePrm.endAccPos = 0;
 8007474:	4b1c      	ldr	r3, [pc, #112]	; (80074e8 <Stspin220_SetDeviceParamsOtherValues+0x8c>)
 8007476:	2200      	movs	r2, #0
 8007478:	611a      	str	r2, [r3, #16]
  devicePrm.relativePos = 0;
 800747a:	4b1b      	ldr	r3, [pc, #108]	; (80074e8 <Stspin220_SetDeviceParamsOtherValues+0x8c>)
 800747c:	2200      	movs	r2, #0
 800747e:	615a      	str	r2, [r3, #20]
  devicePrm.startDecPos = 0;
 8007480:	4b19      	ldr	r3, [pc, #100]	; (80074e8 <Stspin220_SetDeviceParamsOtherValues+0x8c>)
 8007482:	2200      	movs	r2, #0
 8007484:	619a      	str	r2, [r3, #24]
  devicePrm.stepsToTake = 0;
 8007486:	4b18      	ldr	r3, [pc, #96]	; (80074e8 <Stspin220_SetDeviceParamsOtherValues+0x8c>)
 8007488:	2200      	movs	r2, #0
 800748a:	61da      	str	r2, [r3, #28]
  devicePrm.updateTorque = FALSE;
 800748c:	4b16      	ldr	r3, [pc, #88]	; (80074e8 <Stspin220_SetDeviceParamsOtherValues+0x8c>)
 800748e:	2225      	movs	r2, #37	; 0x25
 8007490:	2100      	movs	r1, #0
 8007492:	5499      	strb	r1, [r3, r2]
  devicePrm.speed = 0;
 8007494:	4b14      	ldr	r3, [pc, #80]	; (80074e8 <Stspin220_SetDeviceParamsOtherValues+0x8c>)
 8007496:	2200      	movs	r2, #0
 8007498:	871a      	strh	r2, [r3, #56]	; 0x38
  devicePrm.commandExecuted = NO_CMD;
 800749a:	4b13      	ldr	r3, [pc, #76]	; (80074e8 <Stspin220_SetDeviceParamsOtherValues+0x8c>)
 800749c:	223a      	movs	r2, #58	; 0x3a
 800749e:	2100      	movs	r1, #0
 80074a0:	5499      	strb	r1, [r3, r2]
  devicePrm.direction = FORWARD;
 80074a2:	4b11      	ldr	r3, [pc, #68]	; (80074e8 <Stspin220_SetDeviceParamsOtherValues+0x8c>)
 80074a4:	223b      	movs	r2, #59	; 0x3b
 80074a6:	2101      	movs	r1, #1
 80074a8:	5499      	strb	r1, [r3, r2]
  tmp = devicePrm.minSpeed;
 80074aa:	1dbb      	adds	r3, r7, #6
 80074ac:	4a0e      	ldr	r2, [pc, #56]	; (80074e8 <Stspin220_SetDeviceParamsOtherValues+0x8c>)
 80074ae:	8ed2      	ldrh	r2, [r2, #54]	; 0x36
 80074b0:	801a      	strh	r2, [r3, #0]
  if (((devicePrm.torqueBoostEnable != FALSE)&&\
 80074b2:	4b0d      	ldr	r3, [pc, #52]	; (80074e8 <Stspin220_SetDeviceParamsOtherValues+0x8c>)
 80074b4:	222c      	movs	r2, #44	; 0x2c
 80074b6:	5c9b      	ldrb	r3, [r3, r2]
 80074b8:	b2db      	uxtb	r3, r3
 80074ba:	2b00      	cmp	r3, #0
 80074bc:	d005      	beq.n	80074ca <Stspin220_SetDeviceParamsOtherValues+0x6e>
       (devicePrm.torqueBoostSpeedThreshold>STSPIN220_MAX_STCK_FREQ))||\
 80074be:	4b0a      	ldr	r3, [pc, #40]	; (80074e8 <Stspin220_SetDeviceParamsOtherValues+0x8c>)
 80074c0:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
 80074c2:	b29b      	uxth	r3, r3
  if (((devicePrm.torqueBoostEnable != FALSE)&&\
 80074c4:	4a09      	ldr	r2, [pc, #36]	; (80074ec <Stspin220_SetDeviceParamsOtherValues+0x90>)
 80074c6:	4293      	cmp	r3, r2
 80074c8:	d806      	bhi.n	80074d8 <Stspin220_SetDeviceParamsOtherValues+0x7c>
      (tmp>devicePrm.maxSpeed))
 80074ca:	4b07      	ldr	r3, [pc, #28]	; (80074e8 <Stspin220_SetDeviceParamsOtherValues+0x8c>)
 80074cc:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 80074ce:	b29b      	uxth	r3, r3
       (devicePrm.torqueBoostSpeedThreshold>STSPIN220_MAX_STCK_FREQ))||\
 80074d0:	1dba      	adds	r2, r7, #6
 80074d2:	8812      	ldrh	r2, [r2, #0]
 80074d4:	429a      	cmp	r2, r3
 80074d6:	d903      	bls.n	80074e0 <Stspin220_SetDeviceParamsOtherValues+0x84>
  {
    Stspin220_ErrorHandler(STSPIN220_ERROR_INIT);
 80074d8:	4b05      	ldr	r3, [pc, #20]	; (80074f0 <Stspin220_SetDeviceParamsOtherValues+0x94>)
 80074da:	0018      	movs	r0, r3
 80074dc:	f7fe ff6a 	bl	80063b4 <Stspin220_ErrorHandler>
  }
}
 80074e0:	46c0      	nop			; (mov r8, r8)
 80074e2:	46bd      	mov	sp, r7
 80074e4:	b002      	add	sp, #8
 80074e6:	bd80      	pop	{r7, pc}
 80074e8:	2000327c 	.word	0x2000327c
 80074ec:	00002710 	.word	0x00002710
 80074f0:	0000a009 	.word	0x0000a009

080074f4 <Stspin220_SetDeviceParamsToGivenValues>:
 * @param pInitDevicePrm structure containing values to initialize the device 
 * parameters
 * @retval None
 **********************************************************/
void Stspin220_SetDeviceParamsToGivenValues(Stspin220_Init_t* pInitDevicePrm)
{
 80074f4:	b580      	push	{r7, lr}
 80074f6:	b082      	sub	sp, #8
 80074f8:	af00      	add	r7, sp, #0
 80074fa:	6078      	str	r0, [r7, #4]
  devicePrm.motionState = STANDBY;;
 80074fc:	4b42      	ldr	r3, [pc, #264]	; (8007608 <Stspin220_SetDeviceParamsToGivenValues+0x114>)
 80074fe:	223c      	movs	r2, #60	; 0x3c
 8007500:	2109      	movs	r1, #9
 8007502:	5499      	strb	r1, [r3, r2]

  if (Stspin220_SetAcceleration(0,pInitDevicePrm->acceleration)==FALSE) Stspin220_ErrorHandler(STSPIN220_ERROR_SET_ACCELERATION); 
 8007504:	687b      	ldr	r3, [r7, #4]
 8007506:	881b      	ldrh	r3, [r3, #0]
 8007508:	0019      	movs	r1, r3
 800750a:	2000      	movs	r0, #0
 800750c:	f7ff fb34 	bl	8006b78 <Stspin220_SetAcceleration>
 8007510:	0003      	movs	r3, r0
 8007512:	001a      	movs	r2, r3
 8007514:	2301      	movs	r3, #1
 8007516:	4053      	eors	r3, r2
 8007518:	b2db      	uxtb	r3, r3
 800751a:	2b00      	cmp	r3, #0
 800751c:	d003      	beq.n	8007526 <Stspin220_SetDeviceParamsToGivenValues+0x32>
 800751e:	4b3b      	ldr	r3, [pc, #236]	; (800760c <Stspin220_SetDeviceParamsToGivenValues+0x118>)
 8007520:	0018      	movs	r0, r3
 8007522:	f7fe ff47 	bl	80063b4 <Stspin220_ErrorHandler>
  if (Stspin220_SetDeceleration(0,pInitDevicePrm->deceleration)==FALSE) Stspin220_ErrorHandler(STSPIN220_ERROR_SET_DECELERATION);
 8007526:	687b      	ldr	r3, [r7, #4]
 8007528:	885b      	ldrh	r3, [r3, #2]
 800752a:	0019      	movs	r1, r3
 800752c:	2000      	movs	r0, #0
 800752e:	f7ff fb55 	bl	8006bdc <Stspin220_SetDeceleration>
 8007532:	0003      	movs	r3, r0
 8007534:	001a      	movs	r2, r3
 8007536:	2301      	movs	r3, #1
 8007538:	4053      	eors	r3, r2
 800753a:	b2db      	uxtb	r3, r3
 800753c:	2b00      	cmp	r3, #0
 800753e:	d003      	beq.n	8007548 <Stspin220_SetDeviceParamsToGivenValues+0x54>
 8007540:	4b33      	ldr	r3, [pc, #204]	; (8007610 <Stspin220_SetDeviceParamsToGivenValues+0x11c>)
 8007542:	0018      	movs	r0, r3
 8007544:	f7fe ff36 	bl	80063b4 <Stspin220_ErrorHandler>
  if (Stspin220_SetMaxSpeed(0,pInitDevicePrm->maxSpeed)==FALSE) Stspin220_ErrorHandler(STSPIN220_ERROR_SET_MAX_SPEED);
 8007548:	687b      	ldr	r3, [r7, #4]
 800754a:	889b      	ldrh	r3, [r3, #4]
 800754c:	0019      	movs	r1, r3
 800754e:	2000      	movs	r0, #0
 8007550:	f7ff fbd2 	bl	8006cf8 <Stspin220_SetMaxSpeed>
 8007554:	0003      	movs	r3, r0
 8007556:	001a      	movs	r2, r3
 8007558:	2301      	movs	r3, #1
 800755a:	4053      	eors	r3, r2
 800755c:	b2db      	uxtb	r3, r3
 800755e:	2b00      	cmp	r3, #0
 8007560:	d003      	beq.n	800756a <Stspin220_SetDeviceParamsToGivenValues+0x76>
 8007562:	4b2c      	ldr	r3, [pc, #176]	; (8007614 <Stspin220_SetDeviceParamsToGivenValues+0x120>)
 8007564:	0018      	movs	r0, r3
 8007566:	f7fe ff25 	bl	80063b4 <Stspin220_ErrorHandler>
  if (Stspin220_SetMinSpeed(0,pInitDevicePrm->minSpeed)==FALSE) Stspin220_ErrorHandler(STSPIN220_ERROR_SET_MIN_SPEED);
 800756a:	687b      	ldr	r3, [r7, #4]
 800756c:	88db      	ldrh	r3, [r3, #6]
 800756e:	0019      	movs	r1, r3
 8007570:	2000      	movs	r0, #0
 8007572:	f7ff fc13 	bl	8006d9c <Stspin220_SetMinSpeed>
 8007576:	0003      	movs	r3, r0
 8007578:	001a      	movs	r2, r3
 800757a:	2301      	movs	r3, #1
 800757c:	4053      	eors	r3, r2
 800757e:	b2db      	uxtb	r3, r3
 8007580:	2b00      	cmp	r3, #0
 8007582:	d003      	beq.n	800758c <Stspin220_SetDeviceParamsToGivenValues+0x98>
 8007584:	4b24      	ldr	r3, [pc, #144]	; (8007618 <Stspin220_SetDeviceParamsToGivenValues+0x124>)
 8007586:	0018      	movs	r0, r3
 8007588:	f7fe ff14 	bl	80063b4 <Stspin220_ErrorHandler>
 
  Stspin220_VrefPwmSetFreq(0,pInitDevicePrm->vrefPwmFreq);
 800758c:	687b      	ldr	r3, [r7, #4]
 800758e:	695b      	ldr	r3, [r3, #20]
 8007590:	0019      	movs	r1, r3
 8007592:	2000      	movs	r0, #0
 8007594:	f7ff fd62 	bl	800705c <Stspin220_VrefPwmSetFreq>
  Stspin220_SetTorque(0,ACC_TORQUE,pInitDevicePrm->accelTorque);
 8007598:	687b      	ldr	r3, [r7, #4]
 800759a:	7a1b      	ldrb	r3, [r3, #8]
 800759c:	001a      	movs	r2, r3
 800759e:	2100      	movs	r1, #0
 80075a0:	2000      	movs	r0, #0
 80075a2:	f7ff fc9f 	bl	8006ee4 <Stspin220_SetTorque>
  Stspin220_SetTorque(0,DEC_TORQUE,pInitDevicePrm->decelTorque);
 80075a6:	687b      	ldr	r3, [r7, #4]
 80075a8:	7a5b      	ldrb	r3, [r3, #9]
 80075aa:	001a      	movs	r2, r3
 80075ac:	2101      	movs	r1, #1
 80075ae:	2000      	movs	r0, #0
 80075b0:	f7ff fc98 	bl	8006ee4 <Stspin220_SetTorque>
  Stspin220_SetTorque(0,RUN_TORQUE,pInitDevicePrm->runTorque);
 80075b4:	687b      	ldr	r3, [r7, #4]
 80075b6:	7a9b      	ldrb	r3, [r3, #10]
 80075b8:	001a      	movs	r2, r3
 80075ba:	2102      	movs	r1, #2
 80075bc:	2000      	movs	r0, #0
 80075be:	f7ff fc91 	bl	8006ee4 <Stspin220_SetTorque>
  Stspin220_SetTorque(0,HOLD_TORQUE,pInitDevicePrm->holdTorque);
 80075c2:	687b      	ldr	r3, [r7, #4]
 80075c4:	7adb      	ldrb	r3, [r3, #11]
 80075c6:	001a      	movs	r2, r3
 80075c8:	2103      	movs	r1, #3
 80075ca:	2000      	movs	r0, #0
 80075cc:	f7ff fc8a 	bl	8006ee4 <Stspin220_SetTorque>
  devicePrm.torqueBoostEnable = pInitDevicePrm->torqueBoostEnable;
 80075d0:	687b      	ldr	r3, [r7, #4]
 80075d2:	7b19      	ldrb	r1, [r3, #12]
 80075d4:	4b0c      	ldr	r3, [pc, #48]	; (8007608 <Stspin220_SetDeviceParamsToGivenValues+0x114>)
 80075d6:	222c      	movs	r2, #44	; 0x2c
 80075d8:	5499      	strb	r1, [r3, r2]
  devicePrm.torqueBoostSpeedThreshold = pInitDevicePrm->torqueBoostSpeedThreshold;
 80075da:	687b      	ldr	r3, [r7, #4]
 80075dc:	89da      	ldrh	r2, [r3, #14]
 80075de:	4b0a      	ldr	r3, [pc, #40]	; (8007608 <Stspin220_SetDeviceParamsToGivenValues+0x114>)
 80075e0:	85da      	strh	r2, [r3, #46]	; 0x2e
  Stspin220_SetStopMode(0,pInitDevicePrm->stopMode);
 80075e2:	687b      	ldr	r3, [r7, #4]
 80075e4:	7c5b      	ldrb	r3, [r3, #17]
 80075e6:	0019      	movs	r1, r3
 80075e8:	2000      	movs	r0, #0
 80075ea:	f7ff fc67 	bl	8006ebc <Stspin220_SetStopMode>

  Stspin220_SetDeviceParamsOtherValues();
 80075ee:	f7ff ff35 	bl	800745c <Stspin220_SetDeviceParamsOtherValues>
  
  /* Set predefined step mode */
  /* Standby-reset deactivation included to latch the MODEX inputs */
  Stspin220_SetStepMode(0, pInitDevicePrm->stepMode);
 80075f2:	687b      	ldr	r3, [r7, #4]
 80075f4:	7c1b      	ldrb	r3, [r3, #16]
 80075f6:	0019      	movs	r1, r3
 80075f8:	2000      	movs	r0, #0
 80075fa:	f7ff fc2b 	bl	8006e54 <Stspin220_SetStepMode>
}
 80075fe:	46c0      	nop			; (mov r8, r8)
 8007600:	46bd      	mov	sp, r7
 8007602:	b002      	add	sp, #8
 8007604:	bd80      	pop	{r7, pc}
 8007606:	46c0      	nop			; (mov r8, r8)
 8007608:	2000327c 	.word	0x2000327c
 800760c:	0000a003 	.word	0x0000a003
 8007610:	0000a004 	.word	0x0000a004
 8007614:	0000a001 	.word	0x0000a001
 8007618:	0000a002 	.word	0x0000a002

0800761c <Stspin220_SetDeviceParamsToPredefinedValues>:
 * @brief  Sets the parameters of the device to predefined values
 * from stspin220_target_config.h
 * @retval None
 **********************************************************/
void Stspin220_SetDeviceParamsToPredefinedValues(void)
{
 800761c:	b580      	push	{r7, lr}
 800761e:	af00      	add	r7, sp, #0
  devicePrm.motionState = STANDBY;
 8007620:	4b3a      	ldr	r3, [pc, #232]	; (800770c <Stspin220_SetDeviceParamsToPredefinedValues+0xf0>)
 8007622:	223c      	movs	r2, #60	; 0x3c
 8007624:	2109      	movs	r1, #9
 8007626:	5499      	strb	r1, [r3, r2]

  if (Stspin220_SetAcceleration(0,STSPIN220_CONF_PARAM_ACC)==FALSE) Stspin220_ErrorHandler(STSPIN220_ERROR_SET_ACCELERATION);
 8007628:	23f0      	movs	r3, #240	; 0xf0
 800762a:	005b      	lsls	r3, r3, #1
 800762c:	0019      	movs	r1, r3
 800762e:	2000      	movs	r0, #0
 8007630:	f7ff faa2 	bl	8006b78 <Stspin220_SetAcceleration>
 8007634:	0003      	movs	r3, r0
 8007636:	001a      	movs	r2, r3
 8007638:	2301      	movs	r3, #1
 800763a:	4053      	eors	r3, r2
 800763c:	b2db      	uxtb	r3, r3
 800763e:	2b00      	cmp	r3, #0
 8007640:	d003      	beq.n	800764a <Stspin220_SetDeviceParamsToPredefinedValues+0x2e>
 8007642:	4b33      	ldr	r3, [pc, #204]	; (8007710 <Stspin220_SetDeviceParamsToPredefinedValues+0xf4>)
 8007644:	0018      	movs	r0, r3
 8007646:	f7fe feb5 	bl	80063b4 <Stspin220_ErrorHandler>
  if (Stspin220_SetDeceleration(0,STSPIN220_CONF_PARAM_DEC)==FALSE) Stspin220_ErrorHandler(STSPIN220_ERROR_SET_DECELERATION);
 800764a:	23f0      	movs	r3, #240	; 0xf0
 800764c:	005b      	lsls	r3, r3, #1
 800764e:	0019      	movs	r1, r3
 8007650:	2000      	movs	r0, #0
 8007652:	f7ff fac3 	bl	8006bdc <Stspin220_SetDeceleration>
 8007656:	0003      	movs	r3, r0
 8007658:	001a      	movs	r2, r3
 800765a:	2301      	movs	r3, #1
 800765c:	4053      	eors	r3, r2
 800765e:	b2db      	uxtb	r3, r3
 8007660:	2b00      	cmp	r3, #0
 8007662:	d003      	beq.n	800766c <Stspin220_SetDeviceParamsToPredefinedValues+0x50>
 8007664:	4b2b      	ldr	r3, [pc, #172]	; (8007714 <Stspin220_SetDeviceParamsToPredefinedValues+0xf8>)
 8007666:	0018      	movs	r0, r3
 8007668:	f7fe fea4 	bl	80063b4 <Stspin220_ErrorHandler>
  if (Stspin220_SetMaxSpeed(0,STSPIN220_CONF_PARAM_RUNNING_SPEED)==FALSE) Stspin220_ErrorHandler(STSPIN220_ERROR_SET_MAX_SPEED);
 800766c:	23c8      	movs	r3, #200	; 0xc8
 800766e:	00db      	lsls	r3, r3, #3
 8007670:	0019      	movs	r1, r3
 8007672:	2000      	movs	r0, #0
 8007674:	f7ff fb40 	bl	8006cf8 <Stspin220_SetMaxSpeed>
 8007678:	0003      	movs	r3, r0
 800767a:	001a      	movs	r2, r3
 800767c:	2301      	movs	r3, #1
 800767e:	4053      	eors	r3, r2
 8007680:	b2db      	uxtb	r3, r3
 8007682:	2b00      	cmp	r3, #0
 8007684:	d003      	beq.n	800768e <Stspin220_SetDeviceParamsToPredefinedValues+0x72>
 8007686:	4b24      	ldr	r3, [pc, #144]	; (8007718 <Stspin220_SetDeviceParamsToPredefinedValues+0xfc>)
 8007688:	0018      	movs	r0, r3
 800768a:	f7fe fe93 	bl	80063b4 <Stspin220_ErrorHandler>
  if (Stspin220_SetMinSpeed(0,STSPIN220_CONF_PARAM_MIN_SPEED)==FALSE) Stspin220_ErrorHandler(STSPIN220_ERROR_SET_MIN_SPEED);
 800768e:	23c8      	movs	r3, #200	; 0xc8
 8007690:	005b      	lsls	r3, r3, #1
 8007692:	0019      	movs	r1, r3
 8007694:	2000      	movs	r0, #0
 8007696:	f7ff fb81 	bl	8006d9c <Stspin220_SetMinSpeed>
 800769a:	0003      	movs	r3, r0
 800769c:	001a      	movs	r2, r3
 800769e:	2301      	movs	r3, #1
 80076a0:	4053      	eors	r3, r2
 80076a2:	b2db      	uxtb	r3, r3
 80076a4:	2b00      	cmp	r3, #0
 80076a6:	d003      	beq.n	80076b0 <Stspin220_SetDeviceParamsToPredefinedValues+0x94>
 80076a8:	4b1c      	ldr	r3, [pc, #112]	; (800771c <Stspin220_SetDeviceParamsToPredefinedValues+0x100>)
 80076aa:	0018      	movs	r0, r3
 80076ac:	f7fe fe82 	bl	80063b4 <Stspin220_ErrorHandler>

  Stspin220_VrefPwmSetFreq(0,STSPIN220_CONF_PARAM_REF_PWM_FREQUENCY);
 80076b0:	4b1b      	ldr	r3, [pc, #108]	; (8007720 <Stspin220_SetDeviceParamsToPredefinedValues+0x104>)
 80076b2:	0019      	movs	r1, r3
 80076b4:	2000      	movs	r0, #0
 80076b6:	f7ff fcd1 	bl	800705c <Stspin220_VrefPwmSetFreq>
  Stspin220_SetTorque(0,ACC_TORQUE,STSPIN220_CONF_PARAM_ACC_TORQUE);
 80076ba:	2214      	movs	r2, #20
 80076bc:	2100      	movs	r1, #0
 80076be:	2000      	movs	r0, #0
 80076c0:	f7ff fc10 	bl	8006ee4 <Stspin220_SetTorque>
  Stspin220_SetTorque(0,DEC_TORQUE,STSPIN220_CONF_PARAM_DEC_TORQUE);
 80076c4:	220f      	movs	r2, #15
 80076c6:	2101      	movs	r1, #1
 80076c8:	2000      	movs	r0, #0
 80076ca:	f7ff fc0b 	bl	8006ee4 <Stspin220_SetTorque>
  Stspin220_SetTorque(0,RUN_TORQUE,STSPIN220_CONF_PARAM_RUNNING_TORQUE);
 80076ce:	220a      	movs	r2, #10
 80076d0:	2102      	movs	r1, #2
 80076d2:	2000      	movs	r0, #0
 80076d4:	f7ff fc06 	bl	8006ee4 <Stspin220_SetTorque>
  Stspin220_SetTorque(0,HOLD_TORQUE,STSPIN220_CONF_PARAM_HOLDING_TORQUE);
 80076d8:	2219      	movs	r2, #25
 80076da:	2103      	movs	r1, #3
 80076dc:	2000      	movs	r0, #0
 80076de:	f7ff fc01 	bl	8006ee4 <Stspin220_SetTorque>
  devicePrm.torqueBoostEnable = STSPIN220_CONF_PARAM_TORQUE_BOOST_EN;
 80076e2:	4b0a      	ldr	r3, [pc, #40]	; (800770c <Stspin220_SetDeviceParamsToPredefinedValues+0xf0>)
 80076e4:	222c      	movs	r2, #44	; 0x2c
 80076e6:	2101      	movs	r1, #1
 80076e8:	5499      	strb	r1, [r3, r2]
  devicePrm.torqueBoostSpeedThreshold = STSPIN220_CONF_PARAM_TORQUE_BOOST_TH;
 80076ea:	4b08      	ldr	r3, [pc, #32]	; (800770c <Stspin220_SetDeviceParamsToPredefinedValues+0xf0>)
 80076ec:	22c8      	movs	r2, #200	; 0xc8
 80076ee:	85da      	strh	r2, [r3, #46]	; 0x2e
  Stspin220_SetStopMode(0,STSPIN220_CONF_PARAM_AUTO_HIZ_STOP);
 80076f0:	2100      	movs	r1, #0
 80076f2:	2000      	movs	r0, #0
 80076f4:	f7ff fbe2 	bl	8006ebc <Stspin220_SetStopMode>

  Stspin220_SetDeviceParamsOtherValues();
 80076f8:	f7ff feb0 	bl	800745c <Stspin220_SetDeviceParamsOtherValues>
  
  /* Set predefined step mode */
  /* Standby-reset deactivation included to latch the MODEX inputs */
  Stspin220_SetStepMode(0, STSPIN220_CONF_PARAM_STEP_MODE);
 80076fc:	2105      	movs	r1, #5
 80076fe:	2000      	movs	r0, #0
 8007700:	f7ff fba8 	bl	8006e54 <Stspin220_SetStepMode>
}
 8007704:	46c0      	nop			; (mov r8, r8)
 8007706:	46bd      	mov	sp, r7
 8007708:	bd80      	pop	{r7, pc}
 800770a:	46c0      	nop			; (mov r8, r8)
 800770c:	2000327c 	.word	0x2000327c
 8007710:	0000a003 	.word	0x0000a003
 8007714:	0000a004 	.word	0x0000a004
 8007718:	0000a001 	.word	0x0000a001
 800771c:	0000a002 	.word	0x0000a002
 8007720:	000186a0 	.word	0x000186a0

08007724 <Stspin220_SetStepModeWithoutReset>:
 * @param[in] stepMode from full step to 1/256 microstep
 * as specified in enum motorStepMode_t
 * @retval true if the command is successfully executed, else false
 **********************************************************/
bool Stspin220_SetStepModeWithoutReset(uint8_t deviceId, motorStepMode_t stepMode)
{
 8007724:	b580      	push	{r7, lr}
 8007726:	b082      	sub	sp, #8
 8007728:	af00      	add	r7, sp, #0
 800772a:	0002      	movs	r2, r0
 800772c:	1dfb      	adds	r3, r7, #7
 800772e:	701a      	strb	r2, [r3, #0]
 8007730:	1dbb      	adds	r3, r7, #6
 8007732:	1c0a      	adds	r2, r1, #0
 8007734:	701a      	strb	r2, [r3, #0]
  /* Store step mode */
  devicePrm.stepMode = stepMode;
 8007736:	4b31      	ldr	r3, [pc, #196]	; (80077fc <Stspin220_SetStepModeWithoutReset+0xd8>)
 8007738:	1dba      	adds	r2, r7, #6
 800773a:	213d      	movs	r1, #61	; 0x3d
 800773c:	7812      	ldrb	r2, [r2, #0]
 800773e:	545a      	strb	r2, [r3, r1]
  devicePrm.stepModeLatched = stepMode;
 8007740:	4b2e      	ldr	r3, [pc, #184]	; (80077fc <Stspin220_SetStepModeWithoutReset+0xd8>)
 8007742:	1dba      	adds	r2, r7, #6
 8007744:	213e      	movs	r1, #62	; 0x3e
 8007746:	7812      	ldrb	r2, [r2, #0]
 8007748:	545a      	strb	r2, [r3, r1]
  
  /* Set the mode pins to the levels corresponding to the selected step mode */
  switch (stepMode)
 800774a:	1dbb      	adds	r3, r7, #6
 800774c:	781b      	ldrb	r3, [r3, #0]
 800774e:	2b08      	cmp	r3, #8
 8007750:	d83f      	bhi.n	80077d2 <Stspin220_SetStepModeWithoutReset+0xae>
 8007752:	009a      	lsls	r2, r3, #2
 8007754:	4b2a      	ldr	r3, [pc, #168]	; (8007800 <Stspin220_SetStepModeWithoutReset+0xdc>)
 8007756:	18d3      	adds	r3, r2, r3
 8007758:	681b      	ldr	r3, [r3, #0]
 800775a:	469f      	mov	pc, r3
  {
    case STEP_MODE_FULL:
      Stspin220_Board_SetFullStep();
 800775c:	f007 fa8c 	bl	800ec78 <Stspin220_Board_SetFullStep>
      break;
 8007760:	e039      	b.n	80077d6 <Stspin220_SetStepModeWithoutReset+0xb2>
    case STEP_MODE_HALF:
      Stspin220_Board_SetModePins(1, 0, 1, 0);
 8007762:	2300      	movs	r3, #0
 8007764:	2201      	movs	r2, #1
 8007766:	2100      	movs	r1, #0
 8007768:	2001      	movs	r0, #1
 800776a:	f007 fa0d 	bl	800eb88 <Stspin220_Board_SetModePins>
      break;    
 800776e:	e032      	b.n	80077d6 <Stspin220_SetStepModeWithoutReset+0xb2>
    case STEP_MODE_1_4:
      Stspin220_Board_SetModePins(0, 1, 0, 1);
 8007770:	2301      	movs	r3, #1
 8007772:	2200      	movs	r2, #0
 8007774:	2101      	movs	r1, #1
 8007776:	2000      	movs	r0, #0
 8007778:	f007 fa06 	bl	800eb88 <Stspin220_Board_SetModePins>
      break;        
 800777c:	e02b      	b.n	80077d6 <Stspin220_SetStepModeWithoutReset+0xb2>
    case STEP_MODE_1_8:
      Stspin220_Board_SetModePins(1, 1, 1, 0);
 800777e:	2300      	movs	r3, #0
 8007780:	2201      	movs	r2, #1
 8007782:	2101      	movs	r1, #1
 8007784:	2001      	movs	r0, #1
 8007786:	f007 f9ff 	bl	800eb88 <Stspin220_Board_SetModePins>
      break;
 800778a:	e024      	b.n	80077d6 <Stspin220_SetStepModeWithoutReset+0xb2>
    case STEP_MODE_1_16:
      Stspin220_Board_SetModePins(1, 1, 1, 1);
 800778c:	2301      	movs	r3, #1
 800778e:	2201      	movs	r2, #1
 8007790:	2101      	movs	r1, #1
 8007792:	2001      	movs	r0, #1
 8007794:	f007 f9f8 	bl	800eb88 <Stspin220_Board_SetModePins>
      break;   
 8007798:	e01d      	b.n	80077d6 <Stspin220_SetStepModeWithoutReset+0xb2>
    case STEP_MODE_1_32:
      Stspin220_Board_SetModePins(0, 0, 0, 1);
 800779a:	2301      	movs	r3, #1
 800779c:	2200      	movs	r2, #0
 800779e:	2100      	movs	r1, #0
 80077a0:	2000      	movs	r0, #0
 80077a2:	f007 f9f1 	bl	800eb88 <Stspin220_Board_SetModePins>
      break;   
 80077a6:	e016      	b.n	80077d6 <Stspin220_SetStepModeWithoutReset+0xb2>
    case STEP_MODE_1_64:
      Stspin220_Board_SetModePins(1, 1, 0, 1);
 80077a8:	2301      	movs	r3, #1
 80077aa:	2200      	movs	r2, #0
 80077ac:	2101      	movs	r1, #1
 80077ae:	2001      	movs	r0, #1
 80077b0:	f007 f9ea 	bl	800eb88 <Stspin220_Board_SetModePins>
      break;
 80077b4:	e00f      	b.n	80077d6 <Stspin220_SetStepModeWithoutReset+0xb2>
    case STEP_MODE_1_128:
      Stspin220_Board_SetModePins(0, 0, 1, 0);
 80077b6:	2300      	movs	r3, #0
 80077b8:	2201      	movs	r2, #1
 80077ba:	2100      	movs	r1, #0
 80077bc:	2000      	movs	r0, #0
 80077be:	f007 f9e3 	bl	800eb88 <Stspin220_Board_SetModePins>
      break;  
 80077c2:	e008      	b.n	80077d6 <Stspin220_SetStepModeWithoutReset+0xb2>
    case STEP_MODE_1_256:
      Stspin220_Board_SetModePins(1, 1, 0, 0);
 80077c4:	2300      	movs	r3, #0
 80077c6:	2200      	movs	r2, #0
 80077c8:	2101      	movs	r1, #1
 80077ca:	2001      	movs	r0, #1
 80077cc:	f007 f9dc 	bl	800eb88 <Stspin220_Board_SetModePins>
      break;
 80077d0:	e001      	b.n	80077d6 <Stspin220_SetStepModeWithoutReset+0xb2>
    default:
      return FALSE;
 80077d2:	2300      	movs	r3, #0
 80077d4:	e00e      	b.n	80077f4 <Stspin220_SetStepModeWithoutReset+0xd0>
  }

  /* Wait */
  Stspin220_Board_Delay(SELECT_STEP_MODE_DELAY);
 80077d6:	2001      	movs	r0, #1
 80077d8:	f006 ff22 	bl	800e620 <Stspin220_Board_Delay>
  
  /* Exit standby, selected step mode is latched */
  Stspin220_Board_ReleaseReset();
 80077dc:	f007 f92a 	bl	800ea34 <Stspin220_Board_ReleaseReset>
  
  /* Let a delay after reset release and step mode latching*/
  Stspin220_Board_Delay(AFTER_STANDBY_EXIT_DEAD_TIME);
 80077e0:	2001      	movs	r0, #1
 80077e2:	f006 ff1d 	bl	800e620 <Stspin220_Board_Delay>
  
  /* If full step mode is not selected, do not keep MODE1 = MODE2 = 0 */
  /* after the device quit the standby condition */
  if (stepMode!=STEP_MODE_FULL)
 80077e6:	1dbb      	adds	r3, r7, #6
 80077e8:	781b      	ldrb	r3, [r3, #0]
 80077ea:	2b00      	cmp	r3, #0
 80077ec:	d001      	beq.n	80077f2 <Stspin220_SetStepModeWithoutReset+0xce>
  {
    Stspin220_Board_UnsetFullStep();
 80077ee:	f007 fa57 	bl	800eca0 <Stspin220_Board_UnsetFullStep>
  }

  return TRUE;
 80077f2:	2301      	movs	r3, #1
}
 80077f4:	0018      	movs	r0, r3
 80077f6:	46bd      	mov	sp, r7
 80077f8:	b002      	add	sp, #8
 80077fa:	bd80      	pop	{r7, pc}
 80077fc:	2000327c 	.word	0x2000327c
 8007800:	08014f18 	.word	0x08014f18

08007804 <Stspin220_StartMovement>:
 * and enable the power bridge
 * @param[in] deviceId Unused parameter
 * @retval None
 **********************************************************/
void Stspin220_StartMovement(uint8_t deviceId)  
{
 8007804:	b580      	push	{r7, lr}
 8007806:	b082      	sub	sp, #8
 8007808:	af00      	add	r7, sp, #0
 800780a:	0002      	movs	r2, r0
 800780c:	1dfb      	adds	r3, r7, #7
 800780e:	701a      	strb	r2, [r3, #0]
  deviceId = 0;
 8007810:	1dfb      	adds	r3, r7, #7
 8007812:	2200      	movs	r2, #0
 8007814:	701a      	strb	r2, [r3, #0]
  
  /* Enable STSPIN220 powerstage */
  Stspin220_Enable(deviceId);
 8007816:	1dfb      	adds	r3, r7, #7
 8007818:	781b      	ldrb	r3, [r3, #0]
 800781a:	0018      	movs	r0, r3
 800781c:	f7fe fdbe 	bl	800639c <Stspin220_Enable>
  toggleOdd = 0;
 8007820:	4b1e      	ldr	r3, [pc, #120]	; (800789c <Stspin220_StartMovement+0x98>)
 8007822:	2200      	movs	r2, #0
 8007824:	701a      	strb	r2, [r3, #0]
  devicePrm.accu = 0;
 8007826:	4b1e      	ldr	r3, [pc, #120]	; (80078a0 <Stspin220_StartMovement+0x9c>)
 8007828:	2200      	movs	r2, #0
 800782a:	601a      	str	r2, [r3, #0]
  devicePrm.relativePos = 0;  
 800782c:	4b1c      	ldr	r3, [pc, #112]	; (80078a0 <Stspin220_StartMovement+0x9c>)
 800782e:	2200      	movs	r2, #0
 8007830:	615a      	str	r2, [r3, #20]
  if ((devicePrm.endAccPos == 0)&&\
 8007832:	4b1b      	ldr	r3, [pc, #108]	; (80078a0 <Stspin220_StartMovement+0x9c>)
 8007834:	691b      	ldr	r3, [r3, #16]
 8007836:	2b00      	cmp	r3, #0
 8007838:	d110      	bne.n	800785c <Stspin220_StartMovement+0x58>
      (devicePrm.commandExecuted != RUN_CMD))
 800783a:	4b19      	ldr	r3, [pc, #100]	; (80078a0 <Stspin220_StartMovement+0x9c>)
 800783c:	223a      	movs	r2, #58	; 0x3a
 800783e:	5c9b      	ldrb	r3, [r3, r2]
 8007840:	b2db      	uxtb	r3, r3
  if ((devicePrm.endAccPos == 0)&&\
 8007842:	2b01      	cmp	r3, #1
 8007844:	d00a      	beq.n	800785c <Stspin220_StartMovement+0x58>
  {
    devicePrm.motionState = DECELERATING;
 8007846:	4b16      	ldr	r3, [pc, #88]	; (80078a0 <Stspin220_StartMovement+0x9c>)
 8007848:	223c      	movs	r2, #60	; 0x3c
 800784a:	2102      	movs	r1, #2
 800784c:	5499      	strb	r1, [r3, r2]
    Stspin220_ApplyTorque(deviceId, DEC_TORQUE);
 800784e:	1dfb      	adds	r3, r7, #7
 8007850:	781b      	ldrb	r3, [r3, #0]
 8007852:	2101      	movs	r1, #1
 8007854:	0018      	movs	r0, r3
 8007856:	f7ff fd29 	bl	80072ac <Stspin220_ApplyTorque>
 800785a:	e009      	b.n	8007870 <Stspin220_StartMovement+0x6c>
  }
  else
  {
    devicePrm.motionState = ACCELERATING;
 800785c:	4b10      	ldr	r3, [pc, #64]	; (80078a0 <Stspin220_StartMovement+0x9c>)
 800785e:	223c      	movs	r2, #60	; 0x3c
 8007860:	2100      	movs	r1, #0
 8007862:	5499      	strb	r1, [r3, r2]
    Stspin220_ApplyTorque(deviceId, ACC_TORQUE);
 8007864:	1dfb      	adds	r3, r7, #7
 8007866:	781b      	ldrb	r3, [r3, #0]
 8007868:	2100      	movs	r1, #0
 800786a:	0018      	movs	r0, r3
 800786c:	f7ff fd1e 	bl	80072ac <Stspin220_ApplyTorque>
  }
  Stspin220_Board_PwmRefStart();
 8007870:	f006 ffc6 	bl	800e800 <Stspin220_Board_PwmRefStart>
  /* Initialize the step clock timer */
  Stspin220_Board_TimStckInit();
 8007874:	f007 f852 	bl	800e91c <Stspin220_Board_TimStckInit>
  /* Program the step clock */
  Stspin220_Board_TimStckCompareInit();
 8007878:	f006 ff90 	bl	800e79c <Stspin220_Board_TimStckCompareInit>
  Stspin220_ApplySpeed(deviceId, devicePrm.minSpeed);
 800787c:	4b08      	ldr	r3, [pc, #32]	; (80078a0 <Stspin220_StartMovement+0x9c>)
 800787e:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8007880:	b29a      	uxth	r2, r3
 8007882:	1dfb      	adds	r3, r7, #7
 8007884:	781b      	ldrb	r3, [r3, #0]
 8007886:	0011      	movs	r1, r2
 8007888:	0018      	movs	r0, r3
 800788a:	f7ff fc29 	bl	80070e0 <Stspin220_ApplySpeed>
  Stspin220_Board_TimStckStart();
 800788e:	f006 ff61 	bl	800e754 <Stspin220_Board_TimStckStart>
}
 8007892:	46c0      	nop			; (mov r8, r8)
 8007894:	46bd      	mov	sp, r7
 8007896:	b002      	add	sp, #8
 8007898:	bd80      	pop	{r7, pc}
 800789a:	46c0      	nop			; (mov r8, r8)
 800789c:	2000045f 	.word	0x2000045f
 80078a0:	2000327c 	.word	0x2000327c

080078a4 <Stspin220_StepClockHandler>:
 * @param[in] deviceId Unused parameter
 * @retval None
 * @note Must only be called by the timer ISR
 **********************************************************/
void Stspin220_StepClockHandler(uint8_t deviceId)
{
 80078a4:	b590      	push	{r4, r7, lr}
 80078a6:	b08d      	sub	sp, #52	; 0x34
 80078a8:	af00      	add	r7, sp, #0
 80078aa:	0002      	movs	r2, r0
 80078ac:	1dfb      	adds	r3, r7, #7
 80078ae:	701a      	strb	r2, [r3, #0]
  uint32_t stepModeShift = devicePrm.stepModeLatched - devicePrm.stepMode;
 80078b0:	4bc4      	ldr	r3, [pc, #784]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 80078b2:	223e      	movs	r2, #62	; 0x3e
 80078b4:	5c9b      	ldrb	r3, [r3, r2]
 80078b6:	0019      	movs	r1, r3
 80078b8:	4bc2      	ldr	r3, [pc, #776]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 80078ba:	223d      	movs	r2, #61	; 0x3d
 80078bc:	5c9b      	ldrb	r3, [r3, r2]
 80078be:	b2db      	uxtb	r3, r3
 80078c0:	1acb      	subs	r3, r1, r3
 80078c2:	627b      	str	r3, [r7, #36]	; 0x24
  uint16_t tmp;
  deviceId = 0;
 80078c4:	1dfb      	adds	r3, r7, #7
 80078c6:	2200      	movs	r2, #0
 80078c8:	701a      	strb	r2, [r3, #0]
  
  if (devicePrm.motionState == STANDBYTOINACTIVE)
 80078ca:	4bbe      	ldr	r3, [pc, #760]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 80078cc:	223c      	movs	r2, #60	; 0x3c
 80078ce:	5c9b      	ldrb	r3, [r3, r2]
 80078d0:	b2db      	uxtb	r3, r3
 80078d2:	2b0a      	cmp	r3, #10
 80078d4:	d137      	bne.n	8007946 <Stspin220_StepClockHandler+0xa2>
  {
    if (toggleOdd != 0)
 80078d6:	4bbc      	ldr	r3, [pc, #752]	; (8007bc8 <Stspin220_StepClockHandler+0x324>)
 80078d8:	781b      	ldrb	r3, [r3, #0]
 80078da:	b2db      	uxtb	r3, r3
 80078dc:	2b00      	cmp	r3, #0
 80078de:	d013      	beq.n	8007908 <Stspin220_StepClockHandler+0x64>
    {
      toggleOdd = 0;
 80078e0:	4bb9      	ldr	r3, [pc, #740]	; (8007bc8 <Stspin220_StepClockHandler+0x324>)
 80078e2:	2200      	movs	r2, #0
 80078e4:	701a      	strb	r2, [r3, #0]
      if (devicePrm.sequencerPosition == 0)
 80078e6:	4bb7      	ldr	r3, [pc, #732]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 80078e8:	891b      	ldrh	r3, [r3, #8]
 80078ea:	b21b      	sxth	r3, r3
 80078ec:	2b00      	cmp	r3, #0
 80078ee:	d125      	bne.n	800793c <Stspin220_StepClockHandler+0x98>
      {
        if (Stspin220_Board_TimStckStop(&toggleOdd) == 0)
 80078f0:	4bb5      	ldr	r3, [pc, #724]	; (8007bc8 <Stspin220_StepClockHandler+0x324>)
 80078f2:	0018      	movs	r0, r3
 80078f4:	f007 f876 	bl	800e9e4 <Stspin220_Board_TimStckStop>
 80078f8:	1e03      	subs	r3, r0, #0
 80078fa:	d000      	beq.n	80078fe <Stspin220_StepClockHandler+0x5a>
 80078fc:	e318      	b.n	8007f30 <Stspin220_StepClockHandler+0x68c>
        {
          Stspin220_ErrorHandler(STSPIN220_ERROR_STEP_CLOCK);
 80078fe:	4bb3      	ldr	r3, [pc, #716]	; (8007bcc <Stspin220_StepClockHandler+0x328>)
 8007900:	0018      	movs	r0, r3
 8007902:	f7fe fd57 	bl	80063b4 <Stspin220_ErrorHandler>
        }
        return;
 8007906:	e313      	b.n	8007f30 <Stspin220_StepClockHandler+0x68c>
      }      
    }
    else
    {
      toggleOdd = 1;
 8007908:	4baf      	ldr	r3, [pc, #700]	; (8007bc8 <Stspin220_StepClockHandler+0x324>)
 800790a:	2201      	movs	r2, #1
 800790c:	701a      	strb	r2, [r3, #0]
      tmp = (1 << (STEP_MODE_1_256-devicePrm.stepMode));
 800790e:	4bad      	ldr	r3, [pc, #692]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 8007910:	223d      	movs	r2, #61	; 0x3d
 8007912:	5c9b      	ldrb	r3, [r3, r2]
 8007914:	b2db      	uxtb	r3, r3
 8007916:	001a      	movs	r2, r3
 8007918:	2308      	movs	r3, #8
 800791a:	1a9b      	subs	r3, r3, r2
 800791c:	2201      	movs	r2, #1
 800791e:	409a      	lsls	r2, r3
 8007920:	2122      	movs	r1, #34	; 0x22
 8007922:	187b      	adds	r3, r7, r1
 8007924:	801a      	strh	r2, [r3, #0]
      devicePrm.sequencerPosition -= tmp;
 8007926:	4ba7      	ldr	r3, [pc, #668]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 8007928:	891b      	ldrh	r3, [r3, #8]
 800792a:	b21b      	sxth	r3, r3
 800792c:	b29a      	uxth	r2, r3
 800792e:	187b      	adds	r3, r7, r1
 8007930:	881b      	ldrh	r3, [r3, #0]
 8007932:	1ad3      	subs	r3, r2, r3
 8007934:	b29b      	uxth	r3, r3
 8007936:	b21a      	sxth	r2, r3
 8007938:	4ba2      	ldr	r3, [pc, #648]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 800793a:	811a      	strh	r2, [r3, #8]
    }
    Stspin220_Board_TimStckSetFreq(STSPIN220_MAX_STCK_FREQ);
 800793c:	4ba4      	ldr	r3, [pc, #656]	; (8007bd0 <Stspin220_StepClockHandler+0x32c>)
 800793e:	0018      	movs	r0, r3
 8007940:	f006 ff3a 	bl	800e7b8 <Stspin220_Board_TimStckSetFreq>
    return;
 8007944:	e2f5      	b.n	8007f32 <Stspin220_StepClockHandler+0x68e>
  }  
  
  if (toggleOdd == 0)
 8007946:	4ba0      	ldr	r3, [pc, #640]	; (8007bc8 <Stspin220_StepClockHandler+0x324>)
 8007948:	781b      	ldrb	r3, [r3, #0]
 800794a:	b2db      	uxtb	r3, r3
 800794c:	2b00      	cmp	r3, #0
 800794e:	d103      	bne.n	8007958 <Stspin220_StepClockHandler+0xb4>
  {
    toggleOdd = 1;
 8007950:	4b9d      	ldr	r3, [pc, #628]	; (8007bc8 <Stspin220_StepClockHandler+0x324>)
 8007952:	2201      	movs	r2, #1
 8007954:	701a      	strb	r2, [r3, #0]
 8007956:	e2c3      	b.n	8007ee0 <Stspin220_StepClockHandler+0x63c>
  }
  else
  {
    toggleOdd = 0;
 8007958:	4b9b      	ldr	r3, [pc, #620]	; (8007bc8 <Stspin220_StepClockHandler+0x324>)
 800795a:	2200      	movs	r2, #0
 800795c:	701a      	strb	r2, [r3, #0]
    /* Incrementation of the relative position */
    devicePrm.relativePos += (1 << stepModeShift);
 800795e:	4b99      	ldr	r3, [pc, #612]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 8007960:	695b      	ldr	r3, [r3, #20]
 8007962:	2101      	movs	r1, #1
 8007964:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8007966:	4091      	lsls	r1, r2
 8007968:	000a      	movs	r2, r1
 800796a:	189a      	adds	r2, r3, r2
 800796c:	4b95      	ldr	r3, [pc, #596]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 800796e:	615a      	str	r2, [r3, #20]

    /* Incrementation of the current position */
    if (devicePrm.direction != BACKWARD)
 8007970:	4b94      	ldr	r3, [pc, #592]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 8007972:	223b      	movs	r2, #59	; 0x3b
 8007974:	5c9b      	ldrb	r3, [r3, r2]
 8007976:	b2db      	uxtb	r3, r3
 8007978:	2b00      	cmp	r3, #0
 800797a:	d031      	beq.n	80079e0 <Stspin220_StepClockHandler+0x13c>
    {
      devicePrm.currentPosition += (1 << stepModeShift);
 800797c:	4b91      	ldr	r3, [pc, #580]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 800797e:	685a      	ldr	r2, [r3, #4]
 8007980:	2101      	movs	r1, #1
 8007982:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007984:	4099      	lsls	r1, r3
 8007986:	000b      	movs	r3, r1
 8007988:	18d2      	adds	r2, r2, r3
 800798a:	4b8e      	ldr	r3, [pc, #568]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 800798c:	605a      	str	r2, [r3, #4]
      tmp = (1 << (STEP_MODE_1_256-devicePrm.stepMode));
 800798e:	4b8d      	ldr	r3, [pc, #564]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 8007990:	223d      	movs	r2, #61	; 0x3d
 8007992:	5c9b      	ldrb	r3, [r3, r2]
 8007994:	b2db      	uxtb	r3, r3
 8007996:	001a      	movs	r2, r3
 8007998:	2308      	movs	r3, #8
 800799a:	1a9b      	subs	r3, r3, r2
 800799c:	2201      	movs	r2, #1
 800799e:	409a      	lsls	r2, r3
 80079a0:	2122      	movs	r1, #34	; 0x22
 80079a2:	187b      	adds	r3, r7, r1
 80079a4:	801a      	strh	r2, [r3, #0]
      devicePrm.sequencerPosition += tmp;
 80079a6:	4b87      	ldr	r3, [pc, #540]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 80079a8:	891b      	ldrh	r3, [r3, #8]
 80079aa:	b21b      	sxth	r3, r3
 80079ac:	b29a      	uxth	r2, r3
 80079ae:	187b      	adds	r3, r7, r1
 80079b0:	881b      	ldrh	r3, [r3, #0]
 80079b2:	18d3      	adds	r3, r2, r3
 80079b4:	b29b      	uxth	r3, r3
 80079b6:	b21a      	sxth	r2, r3
 80079b8:	4b82      	ldr	r3, [pc, #520]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 80079ba:	811a      	strh	r2, [r3, #8]
      if (devicePrm.sequencerPosition >= (SEQUENCER_MAX_VALUE+1))
 80079bc:	4b81      	ldr	r3, [pc, #516]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 80079be:	891b      	ldrh	r3, [r3, #8]
 80079c0:	b21b      	sxth	r3, r3
 80079c2:	4a84      	ldr	r2, [pc, #528]	; (8007bd4 <Stspin220_StepClockHandler+0x330>)
 80079c4:	4293      	cmp	r3, r2
 80079c6:	dd3c      	ble.n	8007a42 <Stspin220_StepClockHandler+0x19e>
      {
        devicePrm.sequencerPosition -= (SEQUENCER_MAX_VALUE+1);
 80079c8:	4b7e      	ldr	r3, [pc, #504]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 80079ca:	891b      	ldrh	r3, [r3, #8]
 80079cc:	b21b      	sxth	r3, r3
 80079ce:	b29b      	uxth	r3, r3
 80079d0:	4a81      	ldr	r2, [pc, #516]	; (8007bd8 <Stspin220_StepClockHandler+0x334>)
 80079d2:	4694      	mov	ip, r2
 80079d4:	4463      	add	r3, ip
 80079d6:	b29b      	uxth	r3, r3
 80079d8:	b21a      	sxth	r2, r3
 80079da:	4b7a      	ldr	r3, [pc, #488]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 80079dc:	811a      	strh	r2, [r3, #8]
 80079de:	e030      	b.n	8007a42 <Stspin220_StepClockHandler+0x19e>
      }
    }
    else
    {
      devicePrm.currentPosition -= (1 << stepModeShift);
 80079e0:	4b78      	ldr	r3, [pc, #480]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 80079e2:	685a      	ldr	r2, [r3, #4]
 80079e4:	2101      	movs	r1, #1
 80079e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80079e8:	4099      	lsls	r1, r3
 80079ea:	000b      	movs	r3, r1
 80079ec:	1ad2      	subs	r2, r2, r3
 80079ee:	4b75      	ldr	r3, [pc, #468]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 80079f0:	605a      	str	r2, [r3, #4]
      tmp = (1 << (STEP_MODE_1_256-devicePrm.stepMode));
 80079f2:	4b74      	ldr	r3, [pc, #464]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 80079f4:	223d      	movs	r2, #61	; 0x3d
 80079f6:	5c9b      	ldrb	r3, [r3, r2]
 80079f8:	b2db      	uxtb	r3, r3
 80079fa:	001a      	movs	r2, r3
 80079fc:	2308      	movs	r3, #8
 80079fe:	1a9b      	subs	r3, r3, r2
 8007a00:	2201      	movs	r2, #1
 8007a02:	409a      	lsls	r2, r3
 8007a04:	2122      	movs	r1, #34	; 0x22
 8007a06:	187b      	adds	r3, r7, r1
 8007a08:	801a      	strh	r2, [r3, #0]
      devicePrm.sequencerPosition -= tmp;
 8007a0a:	4b6e      	ldr	r3, [pc, #440]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 8007a0c:	891b      	ldrh	r3, [r3, #8]
 8007a0e:	b21b      	sxth	r3, r3
 8007a10:	b29a      	uxth	r2, r3
 8007a12:	187b      	adds	r3, r7, r1
 8007a14:	881b      	ldrh	r3, [r3, #0]
 8007a16:	1ad3      	subs	r3, r2, r3
 8007a18:	b29b      	uxth	r3, r3
 8007a1a:	b21a      	sxth	r2, r3
 8007a1c:	4b69      	ldr	r3, [pc, #420]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 8007a1e:	811a      	strh	r2, [r3, #8]
      if (devicePrm.sequencerPosition < 0)
 8007a20:	4b68      	ldr	r3, [pc, #416]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 8007a22:	891b      	ldrh	r3, [r3, #8]
 8007a24:	b21b      	sxth	r3, r3
 8007a26:	2b00      	cmp	r3, #0
 8007a28:	da0b      	bge.n	8007a42 <Stspin220_StepClockHandler+0x19e>
      {
        devicePrm.sequencerPosition += (SEQUENCER_MAX_VALUE+1);
 8007a2a:	4b66      	ldr	r3, [pc, #408]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 8007a2c:	891b      	ldrh	r3, [r3, #8]
 8007a2e:	b21b      	sxth	r3, r3
 8007a30:	b29b      	uxth	r3, r3
 8007a32:	2280      	movs	r2, #128	; 0x80
 8007a34:	00d2      	lsls	r2, r2, #3
 8007a36:	4694      	mov	ip, r2
 8007a38:	4463      	add	r3, ip
 8007a3a:	b29b      	uxth	r3, r3
 8007a3c:	b21a      	sxth	r2, r3
 8007a3e:	4b61      	ldr	r3, [pc, #388]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 8007a40:	811a      	strh	r2, [r3, #8]
      }
    }

    switch (devicePrm.motionState) 
 8007a42:	4b60      	ldr	r3, [pc, #384]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 8007a44:	223c      	movs	r2, #60	; 0x3c
 8007a46:	5c9b      	ldrb	r3, [r3, r2]
 8007a48:	b2db      	uxtb	r3, r3
 8007a4a:	2b02      	cmp	r3, #2
 8007a4c:	d100      	bne.n	8007a50 <Stspin220_StepClockHandler+0x1ac>
 8007a4e:	e12e      	b.n	8007cae <Stspin220_StepClockHandler+0x40a>
 8007a50:	2b03      	cmp	r3, #3
 8007a52:	d100      	bne.n	8007a56 <Stspin220_StepClockHandler+0x1b2>
 8007a54:	e0c6      	b.n	8007be4 <Stspin220_StepClockHandler+0x340>
 8007a56:	2b00      	cmp	r3, #0
 8007a58:	d000      	beq.n	8007a5c <Stspin220_StepClockHandler+0x1b8>
        }
        break;
      }
      default: 
      {
        break;
 8007a5a:	e241      	b.n	8007ee0 <Stspin220_StepClockHandler+0x63c>
          uint32_t relPos = devicePrm.relativePos;
 8007a5c:	4b59      	ldr	r3, [pc, #356]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 8007a5e:	695b      	ldr	r3, [r3, #20]
 8007a60:	613b      	str	r3, [r7, #16]
          uint32_t endAccPos = devicePrm.endAccPos;
 8007a62:	4b58      	ldr	r3, [pc, #352]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 8007a64:	691b      	ldr	r3, [r3, #16]
 8007a66:	60fb      	str	r3, [r7, #12]
          uint16_t speed = devicePrm.speed;
 8007a68:	232e      	movs	r3, #46	; 0x2e
 8007a6a:	18fb      	adds	r3, r7, r3
 8007a6c:	4a55      	ldr	r2, [pc, #340]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 8007a6e:	8f12      	ldrh	r2, [r2, #56]	; 0x38
 8007a70:	801a      	strh	r2, [r3, #0]
          uint32_t acc = ((uint32_t)devicePrm.acceleration << 16)>>stepModeShift;
 8007a72:	4b54      	ldr	r3, [pc, #336]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 8007a74:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 8007a76:	b29b      	uxth	r3, r3
 8007a78:	041a      	lsls	r2, r3, #16
 8007a7a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007a7c:	40da      	lsrs	r2, r3
 8007a7e:	0013      	movs	r3, r2
 8007a80:	60bb      	str	r3, [r7, #8]
          if (((devicePrm.commandExecuted&(STSPIN220_SOFT_STOP_BIT_MASK|STSPIN220_DIR_CHANGE_BIT_MASK))!=0)||\
 8007a82:	4b50      	ldr	r3, [pc, #320]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 8007a84:	223a      	movs	r2, #58	; 0x3a
 8007a86:	5c9b      	ldrb	r3, [r3, r2]
 8007a88:	b2db      	uxtb	r3, r3
 8007a8a:	001a      	movs	r2, r3
 8007a8c:	230c      	movs	r3, #12
 8007a8e:	4013      	ands	r3, r2
 8007a90:	d10a      	bne.n	8007aa8 <Stspin220_StepClockHandler+0x204>
              ((devicePrm.commandExecuted==MOVE_CMD)&&(relPos>=devicePrm.startDecPos)))
 8007a92:	4b4c      	ldr	r3, [pc, #304]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 8007a94:	223a      	movs	r2, #58	; 0x3a
 8007a96:	5c9b      	ldrb	r3, [r3, r2]
 8007a98:	b2db      	uxtb	r3, r3
          if (((devicePrm.commandExecuted&(STSPIN220_SOFT_STOP_BIT_MASK|STSPIN220_DIR_CHANGE_BIT_MASK))!=0)||\
 8007a9a:	2b02      	cmp	r3, #2
 8007a9c:	d112      	bne.n	8007ac4 <Stspin220_StepClockHandler+0x220>
              ((devicePrm.commandExecuted==MOVE_CMD)&&(relPos>=devicePrm.startDecPos)))
 8007a9e:	4b49      	ldr	r3, [pc, #292]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 8007aa0:	699b      	ldr	r3, [r3, #24]
 8007aa2:	693a      	ldr	r2, [r7, #16]
 8007aa4:	429a      	cmp	r2, r3
 8007aa6:	d30d      	bcc.n	8007ac4 <Stspin220_StepClockHandler+0x220>
            devicePrm.motionState = DECELERATING;
 8007aa8:	4b46      	ldr	r3, [pc, #280]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 8007aaa:	223c      	movs	r2, #60	; 0x3c
 8007aac:	2102      	movs	r1, #2
 8007aae:	5499      	strb	r1, [r3, r2]
            devicePrm.accu = 0;
 8007ab0:	4b44      	ldr	r3, [pc, #272]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 8007ab2:	2200      	movs	r2, #0
 8007ab4:	601a      	str	r2, [r3, #0]
            Stspin220_ApplyTorque(deviceId, DEC_TORQUE);
 8007ab6:	1dfb      	adds	r3, r7, #7
 8007ab8:	781b      	ldrb	r3, [r3, #0]
 8007aba:	2101      	movs	r1, #1
 8007abc:	0018      	movs	r0, r3
 8007abe:	f7ff fbf5 	bl	80072ac <Stspin220_ApplyTorque>
 8007ac2:	e07d      	b.n	8007bc0 <Stspin220_StepClockHandler+0x31c>
          else if ((speed>=(devicePrm.maxSpeed>>stepModeShift))||\
 8007ac4:	232e      	movs	r3, #46	; 0x2e
 8007ac6:	18fb      	adds	r3, r7, r3
 8007ac8:	881a      	ldrh	r2, [r3, #0]
 8007aca:	4b3e      	ldr	r3, [pc, #248]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 8007acc:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 8007ace:	b29b      	uxth	r3, r3
 8007ad0:	0019      	movs	r1, r3
 8007ad2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007ad4:	4119      	asrs	r1, r3
 8007ad6:	000b      	movs	r3, r1
 8007ad8:	429a      	cmp	r2, r3
 8007ada:	da09      	bge.n	8007af0 <Stspin220_StepClockHandler+0x24c>
                   ((devicePrm.commandExecuted==MOVE_CMD)&&(relPos >= endAccPos)))
 8007adc:	4b39      	ldr	r3, [pc, #228]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 8007ade:	223a      	movs	r2, #58	; 0x3a
 8007ae0:	5c9b      	ldrb	r3, [r3, r2]
 8007ae2:	b2db      	uxtb	r3, r3
          else if ((speed>=(devicePrm.maxSpeed>>stepModeShift))||\
 8007ae4:	2b02      	cmp	r3, #2
 8007ae6:	d10e      	bne.n	8007b06 <Stspin220_StepClockHandler+0x262>
                   ((devicePrm.commandExecuted==MOVE_CMD)&&(relPos >= endAccPos)))
 8007ae8:	693a      	ldr	r2, [r7, #16]
 8007aea:	68fb      	ldr	r3, [r7, #12]
 8007aec:	429a      	cmp	r2, r3
 8007aee:	d30a      	bcc.n	8007b06 <Stspin220_StepClockHandler+0x262>
            devicePrm.motionState = STEADY;
 8007af0:	4b34      	ldr	r3, [pc, #208]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 8007af2:	223c      	movs	r2, #60	; 0x3c
 8007af4:	2103      	movs	r1, #3
 8007af6:	5499      	strb	r1, [r3, r2]
            Stspin220_ApplyTorque(deviceId, RUN_TORQUE);
 8007af8:	1dfb      	adds	r3, r7, #7
 8007afa:	781b      	ldrb	r3, [r3, #0]
 8007afc:	2102      	movs	r1, #2
 8007afe:	0018      	movs	r0, r3
 8007b00:	f7ff fbd4 	bl	80072ac <Stspin220_ApplyTorque>
 8007b04:	e05c      	b.n	8007bc0 <Stspin220_StepClockHandler+0x31c>
            bool speedUpdated = FALSE;
 8007b06:	232d      	movs	r3, #45	; 0x2d
 8007b08:	18fb      	adds	r3, r7, r3
 8007b0a:	2200      	movs	r2, #0
 8007b0c:	701a      	strb	r2, [r3, #0]
            if (speed==0) speed =1;
 8007b0e:	232e      	movs	r3, #46	; 0x2e
 8007b10:	18fb      	adds	r3, r7, r3
 8007b12:	881b      	ldrh	r3, [r3, #0]
 8007b14:	2b00      	cmp	r3, #0
 8007b16:	d103      	bne.n	8007b20 <Stspin220_StepClockHandler+0x27c>
 8007b18:	232e      	movs	r3, #46	; 0x2e
 8007b1a:	18fb      	adds	r3, r7, r3
 8007b1c:	2201      	movs	r2, #1
 8007b1e:	801a      	strh	r2, [r3, #0]
            devicePrm.accu += acc / speed;
 8007b20:	4b28      	ldr	r3, [pc, #160]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 8007b22:	681c      	ldr	r4, [r3, #0]
 8007b24:	232e      	movs	r3, #46	; 0x2e
 8007b26:	18fb      	adds	r3, r7, r3
 8007b28:	881b      	ldrh	r3, [r3, #0]
 8007b2a:	0019      	movs	r1, r3
 8007b2c:	68b8      	ldr	r0, [r7, #8]
 8007b2e:	f7f8 fafd 	bl	800012c <__udivsi3>
 8007b32:	0003      	movs	r3, r0
 8007b34:	18e2      	adds	r2, r4, r3
 8007b36:	4b23      	ldr	r3, [pc, #140]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 8007b38:	601a      	str	r2, [r3, #0]
            while (devicePrm.accu>=(0X10000L))
 8007b3a:	e00f      	b.n	8007b5c <Stspin220_StepClockHandler+0x2b8>
              devicePrm.accu -= (0X10000L);
 8007b3c:	4b21      	ldr	r3, [pc, #132]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 8007b3e:	681b      	ldr	r3, [r3, #0]
 8007b40:	4a26      	ldr	r2, [pc, #152]	; (8007bdc <Stspin220_StepClockHandler+0x338>)
 8007b42:	189a      	adds	r2, r3, r2
 8007b44:	4b1f      	ldr	r3, [pc, #124]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 8007b46:	601a      	str	r2, [r3, #0]
              speed +=1;
 8007b48:	222e      	movs	r2, #46	; 0x2e
 8007b4a:	18bb      	adds	r3, r7, r2
 8007b4c:	18ba      	adds	r2, r7, r2
 8007b4e:	8812      	ldrh	r2, [r2, #0]
 8007b50:	3201      	adds	r2, #1
 8007b52:	801a      	strh	r2, [r3, #0]
              speedUpdated = TRUE;
 8007b54:	232d      	movs	r3, #45	; 0x2d
 8007b56:	18fb      	adds	r3, r7, r3
 8007b58:	2201      	movs	r2, #1
 8007b5a:	701a      	strb	r2, [r3, #0]
            while (devicePrm.accu>=(0X10000L))
 8007b5c:	4b19      	ldr	r3, [pc, #100]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 8007b5e:	681b      	ldr	r3, [r3, #0]
 8007b60:	4a1f      	ldr	r2, [pc, #124]	; (8007be0 <Stspin220_StepClockHandler+0x33c>)
 8007b62:	4293      	cmp	r3, r2
 8007b64:	d8ea      	bhi.n	8007b3c <Stspin220_StepClockHandler+0x298>
            if (speedUpdated)
 8007b66:	232d      	movs	r3, #45	; 0x2d
 8007b68:	18fb      	adds	r3, r7, r3
 8007b6a:	781b      	ldrb	r3, [r3, #0]
 8007b6c:	2b00      	cmp	r3, #0
 8007b6e:	d019      	beq.n	8007ba4 <Stspin220_StepClockHandler+0x300>
              if (speed>(devicePrm.maxSpeed>>stepModeShift))
 8007b70:	232e      	movs	r3, #46	; 0x2e
 8007b72:	18fb      	adds	r3, r7, r3
 8007b74:	881a      	ldrh	r2, [r3, #0]
 8007b76:	4b13      	ldr	r3, [pc, #76]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 8007b78:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 8007b7a:	b29b      	uxth	r3, r3
 8007b7c:	0019      	movs	r1, r3
 8007b7e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007b80:	4119      	asrs	r1, r3
 8007b82:	000b      	movs	r3, r1
 8007b84:	429a      	cmp	r2, r3
 8007b86:	dd08      	ble.n	8007b9a <Stspin220_StepClockHandler+0x2f6>
                speed = devicePrm.maxSpeed>>stepModeShift;
 8007b88:	4b0e      	ldr	r3, [pc, #56]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 8007b8a:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 8007b8c:	b29b      	uxth	r3, r3
 8007b8e:	001a      	movs	r2, r3
 8007b90:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007b92:	411a      	asrs	r2, r3
 8007b94:	232e      	movs	r3, #46	; 0x2e
 8007b96:	18fb      	adds	r3, r7, r3
 8007b98:	801a      	strh	r2, [r3, #0]
              devicePrm.speed = speed;
 8007b9a:	4b0a      	ldr	r3, [pc, #40]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 8007b9c:	222e      	movs	r2, #46	; 0x2e
 8007b9e:	18ba      	adds	r2, r7, r2
 8007ba0:	8812      	ldrh	r2, [r2, #0]
 8007ba2:	871a      	strh	r2, [r3, #56]	; 0x38
            if (devicePrm.updateTorque!=FALSE)
 8007ba4:	4b07      	ldr	r3, [pc, #28]	; (8007bc4 <Stspin220_StepClockHandler+0x320>)
 8007ba6:	2225      	movs	r2, #37	; 0x25
 8007ba8:	5c9b      	ldrb	r3, [r3, r2]
 8007baa:	b2db      	uxtb	r3, r3
 8007bac:	2b00      	cmp	r3, #0
 8007bae:	d100      	bne.n	8007bb2 <Stspin220_StepClockHandler+0x30e>
 8007bb0:	e191      	b.n	8007ed6 <Stspin220_StepClockHandler+0x632>
              Stspin220_ApplyTorque(deviceId, ACC_TORQUE);              
 8007bb2:	1dfb      	adds	r3, r7, #7
 8007bb4:	781b      	ldrb	r3, [r3, #0]
 8007bb6:	2100      	movs	r1, #0
 8007bb8:	0018      	movs	r0, r3
 8007bba:	f7ff fb77 	bl	80072ac <Stspin220_ApplyTorque>
          break;
 8007bbe:	e18a      	b.n	8007ed6 <Stspin220_StepClockHandler+0x632>
 8007bc0:	e189      	b.n	8007ed6 <Stspin220_StepClockHandler+0x632>
 8007bc2:	46c0      	nop			; (mov r8, r8)
 8007bc4:	2000327c 	.word	0x2000327c
 8007bc8:	2000045f 	.word	0x2000045f
 8007bcc:	0000a00e 	.word	0x0000a00e
 8007bd0:	00002710 	.word	0x00002710
 8007bd4:	000003ff 	.word	0x000003ff
 8007bd8:	fffffc00 	.word	0xfffffc00
 8007bdc:	ffff0000 	.word	0xffff0000
 8007be0:	0000ffff 	.word	0x0000ffff
        uint16_t maxSpeed = devicePrm.maxSpeed>>stepModeShift;
 8007be4:	4bcd      	ldr	r3, [pc, #820]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007be6:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 8007be8:	b29b      	uxth	r3, r3
 8007bea:	001a      	movs	r2, r3
 8007bec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007bee:	411a      	asrs	r2, r3
 8007bf0:	2320      	movs	r3, #32
 8007bf2:	18fb      	adds	r3, r7, r3
 8007bf4:	801a      	strh	r2, [r3, #0]
        uint32_t relativePos = devicePrm.relativePos;
 8007bf6:	4bc9      	ldr	r3, [pc, #804]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007bf8:	695b      	ldr	r3, [r3, #20]
 8007bfa:	61fb      	str	r3, [r7, #28]
        if (devicePrm.updateTorque!=FALSE)
 8007bfc:	4bc7      	ldr	r3, [pc, #796]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007bfe:	2225      	movs	r2, #37	; 0x25
 8007c00:	5c9b      	ldrb	r3, [r3, r2]
 8007c02:	b2db      	uxtb	r3, r3
 8007c04:	2b00      	cmp	r3, #0
 8007c06:	d005      	beq.n	8007c14 <Stspin220_StepClockHandler+0x370>
          Stspin220_ApplyTorque(deviceId, RUN_TORQUE);
 8007c08:	1dfb      	adds	r3, r7, #7
 8007c0a:	781b      	ldrb	r3, [r3, #0]
 8007c0c:	2102      	movs	r1, #2
 8007c0e:	0018      	movs	r0, r3
 8007c10:	f7ff fb4c 	bl	80072ac <Stspin220_ApplyTorque>
        if  (((devicePrm.commandExecuted&(STSPIN220_SOFT_STOP_BIT_MASK|STSPIN220_DIR_CHANGE_BIT_MASK))!=0)||\
 8007c14:	4bc1      	ldr	r3, [pc, #772]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007c16:	223a      	movs	r2, #58	; 0x3a
 8007c18:	5c9b      	ldrb	r3, [r3, r2]
 8007c1a:	b2db      	uxtb	r3, r3
 8007c1c:	001a      	movs	r2, r3
 8007c1e:	230c      	movs	r3, #12
 8007c20:	4013      	ands	r3, r2
 8007c22:	d118      	bne.n	8007c56 <Stspin220_StepClockHandler+0x3b2>
             ((devicePrm.commandExecuted==MOVE_CMD)&&\
 8007c24:	4bbd      	ldr	r3, [pc, #756]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007c26:	223a      	movs	r2, #58	; 0x3a
 8007c28:	5c9b      	ldrb	r3, [r3, r2]
 8007c2a:	b2db      	uxtb	r3, r3
        if  (((devicePrm.commandExecuted&(STSPIN220_SOFT_STOP_BIT_MASK|STSPIN220_DIR_CHANGE_BIT_MASK))!=0)||\
 8007c2c:	2b02      	cmp	r3, #2
 8007c2e:	d104      	bne.n	8007c3a <Stspin220_StepClockHandler+0x396>
              (relativePos>=(devicePrm.startDecPos)))||\
 8007c30:	4bba      	ldr	r3, [pc, #744]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007c32:	699b      	ldr	r3, [r3, #24]
             ((devicePrm.commandExecuted==MOVE_CMD)&&\
 8007c34:	69fa      	ldr	r2, [r7, #28]
 8007c36:	429a      	cmp	r2, r3
 8007c38:	d20d      	bcs.n	8007c56 <Stspin220_StepClockHandler+0x3b2>
             ((devicePrm.commandExecuted==RUN_CMD)&&\
 8007c3a:	4bb8      	ldr	r3, [pc, #736]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007c3c:	223a      	movs	r2, #58	; 0x3a
 8007c3e:	5c9b      	ldrb	r3, [r3, r2]
 8007c40:	b2db      	uxtb	r3, r3
              (relativePos>=(devicePrm.startDecPos)))||\
 8007c42:	2b01      	cmp	r3, #1
 8007c44:	d115      	bne.n	8007c72 <Stspin220_StepClockHandler+0x3ce>
              (devicePrm.speed>maxSpeed)))
 8007c46:	4bb5      	ldr	r3, [pc, #724]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007c48:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8007c4a:	b29b      	uxth	r3, r3
             ((devicePrm.commandExecuted==RUN_CMD)&&\
 8007c4c:	2220      	movs	r2, #32
 8007c4e:	18ba      	adds	r2, r7, r2
 8007c50:	8812      	ldrh	r2, [r2, #0]
 8007c52:	429a      	cmp	r2, r3
 8007c54:	d20d      	bcs.n	8007c72 <Stspin220_StepClockHandler+0x3ce>
          devicePrm.motionState = DECELERATING;
 8007c56:	4bb1      	ldr	r3, [pc, #708]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007c58:	223c      	movs	r2, #60	; 0x3c
 8007c5a:	2102      	movs	r1, #2
 8007c5c:	5499      	strb	r1, [r3, r2]
          devicePrm.accu = 0;
 8007c5e:	4baf      	ldr	r3, [pc, #700]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007c60:	2200      	movs	r2, #0
 8007c62:	601a      	str	r2, [r3, #0]
          Stspin220_ApplyTorque(deviceId, DEC_TORQUE);
 8007c64:	1dfb      	adds	r3, r7, #7
 8007c66:	781b      	ldrb	r3, [r3, #0]
 8007c68:	2101      	movs	r1, #1
 8007c6a:	0018      	movs	r0, r3
 8007c6c:	f7ff fb1e 	bl	80072ac <Stspin220_ApplyTorque>
        break;
 8007c70:	e133      	b.n	8007eda <Stspin220_StepClockHandler+0x636>
        else if ((devicePrm.commandExecuted==RUN_CMD)&&(devicePrm.speed<maxSpeed))
 8007c72:	4baa      	ldr	r3, [pc, #680]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007c74:	223a      	movs	r2, #58	; 0x3a
 8007c76:	5c9b      	ldrb	r3, [r3, r2]
 8007c78:	b2db      	uxtb	r3, r3
 8007c7a:	2b01      	cmp	r3, #1
 8007c7c:	d000      	beq.n	8007c80 <Stspin220_StepClockHandler+0x3dc>
 8007c7e:	e12c      	b.n	8007eda <Stspin220_StepClockHandler+0x636>
 8007c80:	4ba6      	ldr	r3, [pc, #664]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007c82:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8007c84:	b29b      	uxth	r3, r3
 8007c86:	2220      	movs	r2, #32
 8007c88:	18ba      	adds	r2, r7, r2
 8007c8a:	8812      	ldrh	r2, [r2, #0]
 8007c8c:	429a      	cmp	r2, r3
 8007c8e:	d800      	bhi.n	8007c92 <Stspin220_StepClockHandler+0x3ee>
 8007c90:	e123      	b.n	8007eda <Stspin220_StepClockHandler+0x636>
          devicePrm.motionState = ACCELERATING;
 8007c92:	4ba2      	ldr	r3, [pc, #648]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007c94:	223c      	movs	r2, #60	; 0x3c
 8007c96:	2100      	movs	r1, #0
 8007c98:	5499      	strb	r1, [r3, r2]
          devicePrm.accu = 0;
 8007c9a:	4ba0      	ldr	r3, [pc, #640]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007c9c:	2200      	movs	r2, #0
 8007c9e:	601a      	str	r2, [r3, #0]
          Stspin220_ApplyTorque(deviceId, ACC_TORQUE);
 8007ca0:	1dfb      	adds	r3, r7, #7
 8007ca2:	781b      	ldrb	r3, [r3, #0]
 8007ca4:	2100      	movs	r1, #0
 8007ca6:	0018      	movs	r0, r3
 8007ca8:	f7ff fb00 	bl	80072ac <Stspin220_ApplyTorque>
        break;
 8007cac:	e115      	b.n	8007eda <Stspin220_StepClockHandler+0x636>
        uint32_t relativePos = devicePrm.relativePos;
 8007cae:	4b9b      	ldr	r3, [pc, #620]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007cb0:	695b      	ldr	r3, [r3, #20]
 8007cb2:	61bb      	str	r3, [r7, #24]
        uint16_t speed = devicePrm.speed;
 8007cb4:	232a      	movs	r3, #42	; 0x2a
 8007cb6:	18fb      	adds	r3, r7, r3
 8007cb8:	4a98      	ldr	r2, [pc, #608]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007cba:	8f12      	ldrh	r2, [r2, #56]	; 0x38
 8007cbc:	801a      	strh	r2, [r3, #0]
        uint32_t dec = ((uint32_t)devicePrm.deceleration << 16)>>stepModeShift;
 8007cbe:	4b97      	ldr	r3, [pc, #604]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007cc0:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8007cc2:	b29b      	uxth	r3, r3
 8007cc4:	041a      	lsls	r2, r3, #16
 8007cc6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007cc8:	40da      	lsrs	r2, r3
 8007cca:	0013      	movs	r3, r2
 8007ccc:	617b      	str	r3, [r7, #20]
        if ((((devicePrm.commandExecuted&(STSPIN220_SOFT_STOP_BIT_MASK|STSPIN220_DIR_CHANGE_BIT_MASK))!=0)&&\
 8007cce:	4b93      	ldr	r3, [pc, #588]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007cd0:	223a      	movs	r2, #58	; 0x3a
 8007cd2:	5c9b      	ldrb	r3, [r3, r2]
 8007cd4:	b2db      	uxtb	r3, r3
 8007cd6:	001a      	movs	r2, r3
 8007cd8:	230c      	movs	r3, #12
 8007cda:	4013      	ands	r3, r2
 8007cdc:	d00b      	beq.n	8007cf6 <Stspin220_StepClockHandler+0x452>
             (speed<=(devicePrm.minSpeed>>stepModeShift)))||\
 8007cde:	232a      	movs	r3, #42	; 0x2a
 8007ce0:	18fb      	adds	r3, r7, r3
 8007ce2:	881a      	ldrh	r2, [r3, #0]
 8007ce4:	4b8d      	ldr	r3, [pc, #564]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007ce6:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8007ce8:	b29b      	uxth	r3, r3
 8007cea:	0019      	movs	r1, r3
 8007cec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007cee:	4119      	asrs	r1, r3
 8007cf0:	000b      	movs	r3, r1
        if ((((devicePrm.commandExecuted&(STSPIN220_SOFT_STOP_BIT_MASK|STSPIN220_DIR_CHANGE_BIT_MASK))!=0)&&\
 8007cf2:	429a      	cmp	r2, r3
 8007cf4:	dd0a      	ble.n	8007d0c <Stspin220_StepClockHandler+0x468>
            ((devicePrm.commandExecuted==MOVE_CMD)&&(relativePos>=devicePrm.stepsToTake)))
 8007cf6:	4b89      	ldr	r3, [pc, #548]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007cf8:	223a      	movs	r2, #58	; 0x3a
 8007cfa:	5c9b      	ldrb	r3, [r3, r2]
 8007cfc:	b2db      	uxtb	r3, r3
             (speed<=(devicePrm.minSpeed>>stepModeShift)))||\
 8007cfe:	2b02      	cmp	r3, #2
 8007d00:	d15e      	bne.n	8007dc0 <Stspin220_StepClockHandler+0x51c>
            ((devicePrm.commandExecuted==MOVE_CMD)&&(relativePos>=devicePrm.stepsToTake)))
 8007d02:	4b86      	ldr	r3, [pc, #536]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007d04:	69db      	ldr	r3, [r3, #28]
 8007d06:	69ba      	ldr	r2, [r7, #24]
 8007d08:	429a      	cmp	r2, r3
 8007d0a:	d359      	bcc.n	8007dc0 <Stspin220_StepClockHandler+0x51c>
          if ((devicePrm.commandExecuted&STSPIN220_DIR_CHANGE_BIT_MASK)!=0)
 8007d0c:	4b83      	ldr	r3, [pc, #524]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007d0e:	223a      	movs	r2, #58	; 0x3a
 8007d10:	5c9b      	ldrb	r3, [r3, r2]
 8007d12:	b2db      	uxtb	r3, r3
 8007d14:	001a      	movs	r2, r3
 8007d16:	2308      	movs	r3, #8
 8007d18:	4013      	ands	r3, r2
 8007d1a:	d035      	beq.n	8007d88 <Stspin220_StepClockHandler+0x4e4>
            devicePrm.commandExecuted&=~STSPIN220_DIR_CHANGE_BIT_MASK;
 8007d1c:	4b7f      	ldr	r3, [pc, #508]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007d1e:	223a      	movs	r2, #58	; 0x3a
 8007d20:	5c9b      	ldrb	r3, [r3, r2]
 8007d22:	b2db      	uxtb	r3, r3
 8007d24:	2208      	movs	r2, #8
 8007d26:	4393      	bics	r3, r2
 8007d28:	b2d9      	uxtb	r1, r3
 8007d2a:	4b7c      	ldr	r3, [pc, #496]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007d2c:	223a      	movs	r2, #58	; 0x3a
 8007d2e:	5499      	strb	r1, [r3, r2]
            if (devicePrm.direction==BACKWARD) devicePrm.direction=FORWARD;
 8007d30:	4b7a      	ldr	r3, [pc, #488]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007d32:	223b      	movs	r2, #59	; 0x3b
 8007d34:	5c9b      	ldrb	r3, [r3, r2]
 8007d36:	b2db      	uxtb	r3, r3
 8007d38:	2b00      	cmp	r3, #0
 8007d3a:	d104      	bne.n	8007d46 <Stspin220_StepClockHandler+0x4a2>
 8007d3c:	4b77      	ldr	r3, [pc, #476]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007d3e:	223b      	movs	r2, #59	; 0x3b
 8007d40:	2101      	movs	r1, #1
 8007d42:	5499      	strb	r1, [r3, r2]
 8007d44:	e003      	b.n	8007d4e <Stspin220_StepClockHandler+0x4aa>
            else devicePrm.direction=BACKWARD;
 8007d46:	4b75      	ldr	r3, [pc, #468]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007d48:	223b      	movs	r2, #59	; 0x3b
 8007d4a:	2100      	movs	r1, #0
 8007d4c:	5499      	strb	r1, [r3, r2]
            Stspin220_Board_SetDirectionGpio(devicePrm.direction);
 8007d4e:	4b73      	ldr	r3, [pc, #460]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007d50:	223b      	movs	r2, #59	; 0x3b
 8007d52:	5c9b      	ldrb	r3, [r3, r2]
 8007d54:	b2db      	uxtb	r3, r3
 8007d56:	0018      	movs	r0, r3
 8007d58:	f006 fe88 	bl	800ea6c <Stspin220_Board_SetDirectionGpio>
            if ((devicePrm.commandExecuted&STSPIN220_SOFT_STOP_BIT_MASK)==0)
 8007d5c:	4b6f      	ldr	r3, [pc, #444]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007d5e:	223a      	movs	r2, #58	; 0x3a
 8007d60:	5c9b      	ldrb	r3, [r3, r2]
 8007d62:	b2db      	uxtb	r3, r3
 8007d64:	001a      	movs	r2, r3
 8007d66:	2304      	movs	r3, #4
 8007d68:	4013      	ands	r3, r2
 8007d6a:	d10d      	bne.n	8007d88 <Stspin220_StepClockHandler+0x4e4>
              devicePrm.motionState = ACCELERATING;
 8007d6c:	4b6b      	ldr	r3, [pc, #428]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007d6e:	223c      	movs	r2, #60	; 0x3c
 8007d70:	2100      	movs	r1, #0
 8007d72:	5499      	strb	r1, [r3, r2]
              devicePrm.accu = 0;
 8007d74:	4b69      	ldr	r3, [pc, #420]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007d76:	2200      	movs	r2, #0
 8007d78:	601a      	str	r2, [r3, #0]
              Stspin220_ApplyTorque(deviceId, ACC_TORQUE);
 8007d7a:	1dfb      	adds	r3, r7, #7
 8007d7c:	781b      	ldrb	r3, [r3, #0]
 8007d7e:	2100      	movs	r1, #0
 8007d80:	0018      	movs	r0, r3
 8007d82:	f7ff fa93 	bl	80072ac <Stspin220_ApplyTorque>
              break;
 8007d86:	e0ab      	b.n	8007ee0 <Stspin220_StepClockHandler+0x63c>
          if (devicePrm.stopMode==HOLD_MODE)
 8007d88:	4b64      	ldr	r3, [pc, #400]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007d8a:	223f      	movs	r2, #63	; 0x3f
 8007d8c:	5c9b      	ldrb	r3, [r3, r2]
 8007d8e:	2b00      	cmp	r3, #0
 8007d90:	d105      	bne.n	8007d9e <Stspin220_StepClockHandler+0x4fa>
            Stspin220_HardStop(deviceId);
 8007d92:	1dfb      	adds	r3, r7, #7
 8007d94:	781b      	ldrb	r3, [r3, #0]
 8007d96:	0018      	movs	r0, r3
 8007d98:	f7fe fdf8 	bl	800698c <Stspin220_HardStop>
          if (devicePrm.stopMode==HOLD_MODE)
 8007d9c:	e09a      	b.n	8007ed4 <Stspin220_StepClockHandler+0x630>
          else if (devicePrm.stopMode==STANDBY_MODE)
 8007d9e:	4b5f      	ldr	r3, [pc, #380]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007da0:	223f      	movs	r2, #63	; 0x3f
 8007da2:	5c9b      	ldrb	r3, [r3, r2]
 8007da4:	2b02      	cmp	r3, #2
 8007da6:	d105      	bne.n	8007db4 <Stspin220_StepClockHandler+0x510>
            Stspin220_PutDeviceInStandby(deviceId);
 8007da8:	1dfb      	adds	r3, r7, #7
 8007daa:	781b      	ldrb	r3, [r3, #0]
 8007dac:	0018      	movs	r0, r3
 8007dae:	f7fe fe93 	bl	8006ad8 <Stspin220_PutDeviceInStandby>
          if (devicePrm.stopMode==HOLD_MODE)
 8007db2:	e08f      	b.n	8007ed4 <Stspin220_StepClockHandler+0x630>
            Stspin220_HardHiZ(deviceId);
 8007db4:	1dfb      	adds	r3, r7, #7
 8007db6:	781b      	ldrb	r3, [r3, #0]
 8007db8:	0018      	movs	r0, r3
 8007dba:	f7fe fda3 	bl	8006904 <Stspin220_HardHiZ>
          if (devicePrm.stopMode==HOLD_MODE)
 8007dbe:	e089      	b.n	8007ed4 <Stspin220_StepClockHandler+0x630>
        else if ((devicePrm.commandExecuted==RUN_CMD)&&
 8007dc0:	4b56      	ldr	r3, [pc, #344]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007dc2:	223a      	movs	r2, #58	; 0x3a
 8007dc4:	5c9b      	ldrb	r3, [r3, r2]
 8007dc6:	b2db      	uxtb	r3, r3
 8007dc8:	2b01      	cmp	r3, #1
 8007dca:	d116      	bne.n	8007dfa <Stspin220_StepClockHandler+0x556>
                 (speed<=(devicePrm.maxSpeed>>stepModeShift)))
 8007dcc:	232a      	movs	r3, #42	; 0x2a
 8007dce:	18fb      	adds	r3, r7, r3
 8007dd0:	881a      	ldrh	r2, [r3, #0]
 8007dd2:	4b52      	ldr	r3, [pc, #328]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007dd4:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 8007dd6:	b29b      	uxth	r3, r3
 8007dd8:	0019      	movs	r1, r3
 8007dda:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007ddc:	4119      	asrs	r1, r3
 8007dde:	000b      	movs	r3, r1
        else if ((devicePrm.commandExecuted==RUN_CMD)&&
 8007de0:	429a      	cmp	r2, r3
 8007de2:	dc0a      	bgt.n	8007dfa <Stspin220_StepClockHandler+0x556>
          devicePrm.motionState = STEADY;
 8007de4:	4b4d      	ldr	r3, [pc, #308]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007de6:	223c      	movs	r2, #60	; 0x3c
 8007de8:	2103      	movs	r1, #3
 8007dea:	5499      	strb	r1, [r3, r2]
          Stspin220_ApplyTorque(deviceId, RUN_TORQUE);
 8007dec:	1dfb      	adds	r3, r7, #7
 8007dee:	781b      	ldrb	r3, [r3, #0]
 8007df0:	2102      	movs	r1, #2
 8007df2:	0018      	movs	r0, r3
 8007df4:	f7ff fa5a 	bl	80072ac <Stspin220_ApplyTorque>
 8007df8:	e06c      	b.n	8007ed4 <Stspin220_StepClockHandler+0x630>
          if (speed>(devicePrm.minSpeed>>stepModeShift))
 8007dfa:	232a      	movs	r3, #42	; 0x2a
 8007dfc:	18fb      	adds	r3, r7, r3
 8007dfe:	881a      	ldrh	r2, [r3, #0]
 8007e00:	4b46      	ldr	r3, [pc, #280]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007e02:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8007e04:	b29b      	uxth	r3, r3
 8007e06:	0019      	movs	r1, r3
 8007e08:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007e0a:	4119      	asrs	r1, r3
 8007e0c:	000b      	movs	r3, r1
 8007e0e:	429a      	cmp	r2, r3
 8007e10:	dd65      	ble.n	8007ede <Stspin220_StepClockHandler+0x63a>
            bool speedUpdated = FALSE;
 8007e12:	2329      	movs	r3, #41	; 0x29
 8007e14:	18fb      	adds	r3, r7, r3
 8007e16:	2200      	movs	r2, #0
 8007e18:	701a      	strb	r2, [r3, #0]
            if (speed==0) speed =1;
 8007e1a:	232a      	movs	r3, #42	; 0x2a
 8007e1c:	18fb      	adds	r3, r7, r3
 8007e1e:	881b      	ldrh	r3, [r3, #0]
 8007e20:	2b00      	cmp	r3, #0
 8007e22:	d103      	bne.n	8007e2c <Stspin220_StepClockHandler+0x588>
 8007e24:	232a      	movs	r3, #42	; 0x2a
 8007e26:	18fb      	adds	r3, r7, r3
 8007e28:	2201      	movs	r2, #1
 8007e2a:	801a      	strh	r2, [r3, #0]
            devicePrm.accu += dec / speed;
 8007e2c:	4b3b      	ldr	r3, [pc, #236]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007e2e:	681c      	ldr	r4, [r3, #0]
 8007e30:	232a      	movs	r3, #42	; 0x2a
 8007e32:	18fb      	adds	r3, r7, r3
 8007e34:	881b      	ldrh	r3, [r3, #0]
 8007e36:	0019      	movs	r1, r3
 8007e38:	6978      	ldr	r0, [r7, #20]
 8007e3a:	f7f8 f977 	bl	800012c <__udivsi3>
 8007e3e:	0003      	movs	r3, r0
 8007e40:	18e2      	adds	r2, r4, r3
 8007e42:	4b36      	ldr	r3, [pc, #216]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007e44:	601a      	str	r2, [r3, #0]
            while (devicePrm.accu>=(0X10000L))
 8007e46:	e014      	b.n	8007e72 <Stspin220_StepClockHandler+0x5ce>
              devicePrm.accu -= (0X10000L);
 8007e48:	4b34      	ldr	r3, [pc, #208]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007e4a:	681b      	ldr	r3, [r3, #0]
 8007e4c:	4a34      	ldr	r2, [pc, #208]	; (8007f20 <Stspin220_StepClockHandler+0x67c>)
 8007e4e:	189a      	adds	r2, r3, r2
 8007e50:	4b32      	ldr	r3, [pc, #200]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007e52:	601a      	str	r2, [r3, #0]
              if (speed>1)
 8007e54:	232a      	movs	r3, #42	; 0x2a
 8007e56:	18fb      	adds	r3, r7, r3
 8007e58:	881b      	ldrh	r3, [r3, #0]
 8007e5a:	2b01      	cmp	r3, #1
 8007e5c:	d905      	bls.n	8007e6a <Stspin220_StepClockHandler+0x5c6>
                speed -=1;
 8007e5e:	222a      	movs	r2, #42	; 0x2a
 8007e60:	18bb      	adds	r3, r7, r2
 8007e62:	18ba      	adds	r2, r7, r2
 8007e64:	8812      	ldrh	r2, [r2, #0]
 8007e66:	3a01      	subs	r2, #1
 8007e68:	801a      	strh	r2, [r3, #0]
              speedUpdated = TRUE;
 8007e6a:	2329      	movs	r3, #41	; 0x29
 8007e6c:	18fb      	adds	r3, r7, r3
 8007e6e:	2201      	movs	r2, #1
 8007e70:	701a      	strb	r2, [r3, #0]
            while (devicePrm.accu>=(0X10000L))
 8007e72:	4b2a      	ldr	r3, [pc, #168]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007e74:	681b      	ldr	r3, [r3, #0]
 8007e76:	4a2b      	ldr	r2, [pc, #172]	; (8007f24 <Stspin220_StepClockHandler+0x680>)
 8007e78:	4293      	cmp	r3, r2
 8007e7a:	d8e5      	bhi.n	8007e48 <Stspin220_StepClockHandler+0x5a4>
            if (speedUpdated)
 8007e7c:	2329      	movs	r3, #41	; 0x29
 8007e7e:	18fb      	adds	r3, r7, r3
 8007e80:	781b      	ldrb	r3, [r3, #0]
 8007e82:	2b00      	cmp	r3, #0
 8007e84:	d019      	beq.n	8007eba <Stspin220_StepClockHandler+0x616>
              if (speed<(devicePrm.minSpeed>>stepModeShift))
 8007e86:	232a      	movs	r3, #42	; 0x2a
 8007e88:	18fb      	adds	r3, r7, r3
 8007e8a:	881a      	ldrh	r2, [r3, #0]
 8007e8c:	4b23      	ldr	r3, [pc, #140]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007e8e:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8007e90:	b29b      	uxth	r3, r3
 8007e92:	0019      	movs	r1, r3
 8007e94:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007e96:	4119      	asrs	r1, r3
 8007e98:	000b      	movs	r3, r1
 8007e9a:	429a      	cmp	r2, r3
 8007e9c:	da08      	bge.n	8007eb0 <Stspin220_StepClockHandler+0x60c>
                speed = devicePrm.minSpeed>>stepModeShift;
 8007e9e:	4b1f      	ldr	r3, [pc, #124]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007ea0:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8007ea2:	b29b      	uxth	r3, r3
 8007ea4:	001a      	movs	r2, r3
 8007ea6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007ea8:	411a      	asrs	r2, r3
 8007eaa:	232a      	movs	r3, #42	; 0x2a
 8007eac:	18fb      	adds	r3, r7, r3
 8007eae:	801a      	strh	r2, [r3, #0]
              devicePrm.speed = speed;
 8007eb0:	4b1a      	ldr	r3, [pc, #104]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007eb2:	222a      	movs	r2, #42	; 0x2a
 8007eb4:	18ba      	adds	r2, r7, r2
 8007eb6:	8812      	ldrh	r2, [r2, #0]
 8007eb8:	871a      	strh	r2, [r3, #56]	; 0x38
            if (devicePrm.updateTorque!=FALSE)
 8007eba:	4b18      	ldr	r3, [pc, #96]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007ebc:	2225      	movs	r2, #37	; 0x25
 8007ebe:	5c9b      	ldrb	r3, [r3, r2]
 8007ec0:	b2db      	uxtb	r3, r3
 8007ec2:	2b00      	cmp	r3, #0
 8007ec4:	d00b      	beq.n	8007ede <Stspin220_StepClockHandler+0x63a>
              Stspin220_ApplyTorque(deviceId, DEC_TORQUE);
 8007ec6:	1dfb      	adds	r3, r7, #7
 8007ec8:	781b      	ldrb	r3, [r3, #0]
 8007eca:	2101      	movs	r1, #1
 8007ecc:	0018      	movs	r0, r3
 8007ece:	f7ff f9ed 	bl	80072ac <Stspin220_ApplyTorque>
        break;
 8007ed2:	e004      	b.n	8007ede <Stspin220_StepClockHandler+0x63a>
 8007ed4:	e003      	b.n	8007ede <Stspin220_StepClockHandler+0x63a>
          break;
 8007ed6:	46c0      	nop			; (mov r8, r8)
 8007ed8:	e002      	b.n	8007ee0 <Stspin220_StepClockHandler+0x63c>
        break;
 8007eda:	46c0      	nop			; (mov r8, r8)
 8007edc:	e000      	b.n	8007ee0 <Stspin220_StepClockHandler+0x63c>
        break;
 8007ede:	46c0      	nop			; (mov r8, r8)
      }
    }
  }
  if ((devicePrm.motionState & INACTIVE) != INACTIVE)
 8007ee0:	4b0e      	ldr	r3, [pc, #56]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007ee2:	223c      	movs	r2, #60	; 0x3c
 8007ee4:	5c9b      	ldrb	r3, [r3, r2]
 8007ee6:	b2db      	uxtb	r3, r3
 8007ee8:	001a      	movs	r2, r3
 8007eea:	2308      	movs	r3, #8
 8007eec:	4013      	ands	r3, r2
 8007eee:	2b08      	cmp	r3, #8
 8007ef0:	d009      	beq.n	8007f06 <Stspin220_StepClockHandler+0x662>
  {
    Stspin220_ApplySpeed(deviceId, devicePrm.speed);
 8007ef2:	4b0a      	ldr	r3, [pc, #40]	; (8007f1c <Stspin220_StepClockHandler+0x678>)
 8007ef4:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8007ef6:	b29a      	uxth	r2, r3
 8007ef8:	1dfb      	adds	r3, r7, #7
 8007efa:	781b      	ldrb	r3, [r3, #0]
 8007efc:	0011      	movs	r1, r2
 8007efe:	0018      	movs	r0, r3
 8007f00:	f7ff f8ee 	bl	80070e0 <Stspin220_ApplySpeed>
 8007f04:	e015      	b.n	8007f32 <Stspin220_StepClockHandler+0x68e>
  }
  else
  {
    if (Stspin220_Board_TimStckStop(&toggleOdd) == 0)
 8007f06:	4b08      	ldr	r3, [pc, #32]	; (8007f28 <Stspin220_StepClockHandler+0x684>)
 8007f08:	0018      	movs	r0, r3
 8007f0a:	f006 fd6b 	bl	800e9e4 <Stspin220_Board_TimStckStop>
 8007f0e:	1e03      	subs	r3, r0, #0
 8007f10:	d10f      	bne.n	8007f32 <Stspin220_StepClockHandler+0x68e>
    {
      Stspin220_ErrorHandler(STSPIN220_ERROR_STEP_CLOCK);
 8007f12:	4b06      	ldr	r3, [pc, #24]	; (8007f2c <Stspin220_StepClockHandler+0x688>)
 8007f14:	0018      	movs	r0, r3
 8007f16:	f7fe fa4d 	bl	80063b4 <Stspin220_ErrorHandler>
 8007f1a:	e00a      	b.n	8007f32 <Stspin220_StepClockHandler+0x68e>
 8007f1c:	2000327c 	.word	0x2000327c
 8007f20:	ffff0000 	.word	0xffff0000
 8007f24:	0000ffff 	.word	0x0000ffff
 8007f28:	2000045f 	.word	0x2000045f
 8007f2c:	0000a00e 	.word	0x0000a00e
        return;
 8007f30:	46c0      	nop			; (mov r8, r8)
    }
  }
}
 8007f32:	46bd      	mov	sp, r7
 8007f34:	b00d      	add	sp, #52	; 0x34
 8007f36:	bd90      	pop	{r4, r7, pc}

08007f38 <CheckValidRectRoi>:
 *   0------------------------- >15
 *   check Rectangle definition conforms to the (0,15,15) coordinate system
 *   with a minimum of 4x4 size
 */
static VL53L1_Error CheckValidRectRoi(VL53L1_UserRoi_t ROI)
{
 8007f38:	b580      	push	{r7, lr}
 8007f3a:	b084      	sub	sp, #16
 8007f3c:	af00      	add	r7, sp, #0
 8007f3e:	1d3b      	adds	r3, r7, #4
 8007f40:	6018      	str	r0, [r3, #0]
	VL53L1_Error Status = VL53L1_ERROR_NONE;
 8007f42:	230f      	movs	r3, #15
 8007f44:	18fb      	adds	r3, r7, r3
 8007f46:	2200      	movs	r2, #0
 8007f48:	701a      	strb	r2, [r3, #0]

	LOG_FUNCTION_START("");

	/* Negative check are not necessary because value is unsigned */
	if ((ROI.TopLeftX > 15) || (ROI.TopLeftY > 15) ||
 8007f4a:	1d3b      	adds	r3, r7, #4
 8007f4c:	781b      	ldrb	r3, [r3, #0]
 8007f4e:	2b0f      	cmp	r3, #15
 8007f50:	d80b      	bhi.n	8007f6a <CheckValidRectRoi+0x32>
 8007f52:	1d3b      	adds	r3, r7, #4
 8007f54:	785b      	ldrb	r3, [r3, #1]
 8007f56:	2b0f      	cmp	r3, #15
 8007f58:	d807      	bhi.n	8007f6a <CheckValidRectRoi+0x32>
		(ROI.BotRightX > 15) || (ROI.BotRightY > 15))
 8007f5a:	1d3b      	adds	r3, r7, #4
 8007f5c:	789b      	ldrb	r3, [r3, #2]
	if ((ROI.TopLeftX > 15) || (ROI.TopLeftY > 15) ||
 8007f5e:	2b0f      	cmp	r3, #15
 8007f60:	d803      	bhi.n	8007f6a <CheckValidRectRoi+0x32>
		(ROI.BotRightX > 15) || (ROI.BotRightY > 15))
 8007f62:	1d3b      	adds	r3, r7, #4
 8007f64:	78db      	ldrb	r3, [r3, #3]
 8007f66:	2b0f      	cmp	r3, #15
 8007f68:	d903      	bls.n	8007f72 <CheckValidRectRoi+0x3a>
		Status = VL53L1_ERROR_INVALID_PARAMS;
 8007f6a:	230f      	movs	r3, #15
 8007f6c:	18fb      	adds	r3, r7, r3
 8007f6e:	22fc      	movs	r2, #252	; 0xfc
 8007f70:	701a      	strb	r2, [r3, #0]

	if ((ROI.TopLeftX > ROI.BotRightX) || (ROI.TopLeftY < ROI.BotRightY))
 8007f72:	1d3b      	adds	r3, r7, #4
 8007f74:	781a      	ldrb	r2, [r3, #0]
 8007f76:	1d3b      	adds	r3, r7, #4
 8007f78:	789b      	ldrb	r3, [r3, #2]
 8007f7a:	429a      	cmp	r2, r3
 8007f7c:	d805      	bhi.n	8007f8a <CheckValidRectRoi+0x52>
 8007f7e:	1d3b      	adds	r3, r7, #4
 8007f80:	785a      	ldrb	r2, [r3, #1]
 8007f82:	1d3b      	adds	r3, r7, #4
 8007f84:	78db      	ldrb	r3, [r3, #3]
 8007f86:	429a      	cmp	r2, r3
 8007f88:	d203      	bcs.n	8007f92 <CheckValidRectRoi+0x5a>
		Status = VL53L1_ERROR_INVALID_PARAMS;
 8007f8a:	230f      	movs	r3, #15
 8007f8c:	18fb      	adds	r3, r7, r3
 8007f8e:	22fc      	movs	r2, #252	; 0xfc
 8007f90:	701a      	strb	r2, [r3, #0]

	LOG_FUNCTION_END(Status);
	return Status;
 8007f92:	230f      	movs	r3, #15
 8007f94:	18fb      	adds	r3, r7, r3
 8007f96:	781b      	ldrb	r3, [r3, #0]
 8007f98:	b25b      	sxtb	r3, r3
}
 8007f9a:	0018      	movs	r0, r3
 8007f9c:	46bd      	mov	sp, r7
 8007f9e:	b004      	add	sp, #16
 8007fa0:	bd80      	pop	{r7, pc}

08007fa2 <VL53L1_SetDeviceAddress>:

/* End Group PAL General Functions */

/* Group PAL Init Functions */
VL53L1_Error VL53L1_SetDeviceAddress(VL53L1_DEV Dev, uint8_t DeviceAddress)
{
 8007fa2:	b5b0      	push	{r4, r5, r7, lr}
 8007fa4:	b084      	sub	sp, #16
 8007fa6:	af00      	add	r7, sp, #0
 8007fa8:	6078      	str	r0, [r7, #4]
 8007faa:	000a      	movs	r2, r1
 8007fac:	1cfb      	adds	r3, r7, #3
 8007fae:	701a      	strb	r2, [r3, #0]
	VL53L1_Error Status = VL53L1_ERROR_NONE;
 8007fb0:	210f      	movs	r1, #15
 8007fb2:	187b      	adds	r3, r7, r1
 8007fb4:	2200      	movs	r2, #0
 8007fb6:	701a      	strb	r2, [r3, #0]

	LOG_FUNCTION_START("");

	Status = VL53L1_WrByte(Dev, VL53L1_I2C_SLAVE__DEVICE_ADDRESS,
 8007fb8:	1cfb      	adds	r3, r7, #3
 8007fba:	781b      	ldrb	r3, [r3, #0]
 8007fbc:	085b      	lsrs	r3, r3, #1
 8007fbe:	b2da      	uxtb	r2, r3
 8007fc0:	000d      	movs	r5, r1
 8007fc2:	187c      	adds	r4, r7, r1
 8007fc4:	687b      	ldr	r3, [r7, #4]
 8007fc6:	2101      	movs	r1, #1
 8007fc8:	0018      	movs	r0, r3
 8007fca:	f006 f951 	bl	800e270 <VL53L1_WrByte>
 8007fce:	0003      	movs	r3, r0
 8007fd0:	7023      	strb	r3, [r4, #0]
			DeviceAddress / 2);

	LOG_FUNCTION_END(Status);
	return Status;
 8007fd2:	0029      	movs	r1, r5
 8007fd4:	187b      	adds	r3, r7, r1
 8007fd6:	781b      	ldrb	r3, [r3, #0]
 8007fd8:	b25b      	sxtb	r3, r3
}
 8007fda:	0018      	movs	r0, r3
 8007fdc:	46bd      	mov	sp, r7
 8007fde:	b004      	add	sp, #16
 8007fe0:	bdb0      	pop	{r4, r5, r7, pc}

08007fe2 <VL53L1_DataInit>:

VL53L1_Error VL53L1_DataInit(VL53L1_DEV Dev)
{
 8007fe2:	b590      	push	{r4, r7, lr}
 8007fe4:	b085      	sub	sp, #20
 8007fe6:	af00      	add	r7, sp, #0
 8007fe8:	6078      	str	r0, [r7, #4]
	VL53L1_Error Status = VL53L1_ERROR_NONE;
 8007fea:	210f      	movs	r1, #15
 8007fec:	187b      	adds	r3, r7, r1
 8007fee:	2200      	movs	r2, #0
 8007ff0:	701a      	strb	r2, [r3, #0]
		Status = VL53L1_WrByte(Dev, VL53L1_PAD_I2C_HV__EXTSUP_CONFIG,
				i);
	}
#endif

	if (Status == VL53L1_ERROR_NONE)
 8007ff2:	187b      	adds	r3, r7, r1
 8007ff4:	781b      	ldrb	r3, [r3, #0]
 8007ff6:	b25b      	sxtb	r3, r3
 8007ff8:	2b00      	cmp	r3, #0
 8007ffa:	d108      	bne.n	800800e <VL53L1_DataInit+0x2c>
		Status = VL53L1_data_init(Dev, 1);
 8007ffc:	230f      	movs	r3, #15
 8007ffe:	18fc      	adds	r4, r7, r3
 8008000:	687b      	ldr	r3, [r7, #4]
 8008002:	2101      	movs	r1, #1
 8008004:	0018      	movs	r0, r3
 8008006:	f001 faed 	bl	80095e4 <VL53L1_data_init>
 800800a:	0003      	movs	r3, r0
 800800c:	7023      	strb	r3, [r4, #0]

	if (Status == VL53L1_ERROR_NONE) {
 800800e:	230f      	movs	r3, #15
 8008010:	18fb      	adds	r3, r7, r3
 8008012:	781b      	ldrb	r3, [r3, #0]
 8008014:	b25b      	sxtb	r3, r3
 8008016:	2b00      	cmp	r3, #0
 8008018:	d109      	bne.n	800802e <VL53L1_DataInit+0x4c>
		VL53L1DevDataSet(Dev, PalState, VL53L1_STATE_WAIT_STATICINIT);
 800801a:	687a      	ldr	r2, [r7, #4]
 800801c:	23de      	movs	r3, #222	; 0xde
 800801e:	009b      	lsls	r3, r3, #2
 8008020:	2101      	movs	r1, #1
 8008022:	54d1      	strb	r1, [r2, r3]
		VL53L1DevDataSet(Dev, CurrentParameters.PresetMode,
 8008024:	687a      	ldr	r2, [r7, #4]
 8008026:	23df      	movs	r3, #223	; 0xdf
 8008028:	009b      	lsls	r3, r3, #2
 800802a:	2108      	movs	r1, #8
 800802c:	54d1      	strb	r1, [r2, r3]
				VL53L1_PRESETMODE_LOWPOWER_AUTONOMOUS);
	}

	/* Enable all check */
	for (i = 0; i < VL53L1_CHECKENABLE_NUMBER_OF_CHECKS; i++) {
 800802e:	230e      	movs	r3, #14
 8008030:	18fb      	adds	r3, r7, r3
 8008032:	2200      	movs	r2, #0
 8008034:	701a      	strb	r2, [r3, #0]
 8008036:	e01b      	b.n	8008070 <VL53L1_DataInit+0x8e>
		if (Status == VL53L1_ERROR_NONE)
 8008038:	230f      	movs	r3, #15
 800803a:	18fb      	adds	r3, r7, r3
 800803c:	781b      	ldrb	r3, [r3, #0]
 800803e:	b25b      	sxtb	r3, r3
 8008040:	2b00      	cmp	r3, #0
 8008042:	d11b      	bne.n	800807c <VL53L1_DataInit+0x9a>
			Status |= VL53L1_SetLimitCheckEnable(Dev, i, 1);
 8008044:	240e      	movs	r4, #14
 8008046:	193b      	adds	r3, r7, r4
 8008048:	781b      	ldrb	r3, [r3, #0]
 800804a:	b299      	uxth	r1, r3
 800804c:	687b      	ldr	r3, [r7, #4]
 800804e:	2201      	movs	r2, #1
 8008050:	0018      	movs	r0, r3
 8008052:	f000 fd20 	bl	8008a96 <VL53L1_SetLimitCheckEnable>
 8008056:	0003      	movs	r3, r0
 8008058:	0019      	movs	r1, r3
 800805a:	220f      	movs	r2, #15
 800805c:	18bb      	adds	r3, r7, r2
 800805e:	18ba      	adds	r2, r7, r2
 8008060:	7812      	ldrb	r2, [r2, #0]
 8008062:	430a      	orrs	r2, r1
 8008064:	701a      	strb	r2, [r3, #0]
	for (i = 0; i < VL53L1_CHECKENABLE_NUMBER_OF_CHECKS; i++) {
 8008066:	193b      	adds	r3, r7, r4
 8008068:	781a      	ldrb	r2, [r3, #0]
 800806a:	193b      	adds	r3, r7, r4
 800806c:	3201      	adds	r2, #1
 800806e:	701a      	strb	r2, [r3, #0]
 8008070:	230e      	movs	r3, #14
 8008072:	18fb      	adds	r3, r7, r3
 8008074:	781b      	ldrb	r3, [r3, #0]
 8008076:	2b01      	cmp	r3, #1
 8008078:	d9de      	bls.n	8008038 <VL53L1_DataInit+0x56>
 800807a:	e000      	b.n	800807e <VL53L1_DataInit+0x9c>
		else
			break;
 800807c:	46c0      	nop			; (mov r8, r8)

	}

	/* Limit default values */
	if (Status == VL53L1_ERROR_NONE) {
 800807e:	230f      	movs	r3, #15
 8008080:	18fb      	adds	r3, r7, r3
 8008082:	781b      	ldrb	r3, [r3, #0]
 8008084:	b25b      	sxtb	r3, r3
 8008086:	2b00      	cmp	r3, #0
 8008088:	d10a      	bne.n	80080a0 <VL53L1_DataInit+0xbe>
		Status = VL53L1_SetLimitCheckValue(Dev,
 800808a:	230f      	movs	r3, #15
 800808c:	18fc      	adds	r4, r7, r3
 800808e:	2390      	movs	r3, #144	; 0x90
 8008090:	035a      	lsls	r2, r3, #13
 8008092:	687b      	ldr	r3, [r7, #4]
 8008094:	2100      	movs	r1, #0
 8008096:	0018      	movs	r0, r3
 8008098:	f000 fd81 	bl	8008b9e <VL53L1_SetLimitCheckValue>
 800809c:	0003      	movs	r3, r0
 800809e:	7023      	strb	r3, [r4, #0]
			VL53L1_CHECKENABLE_SIGMA_FINAL_RANGE,
				(FixPoint1616_t)(18 * 65536));
	}
	if (Status == VL53L1_ERROR_NONE) {
 80080a0:	230f      	movs	r3, #15
 80080a2:	18fb      	adds	r3, r7, r3
 80080a4:	781b      	ldrb	r3, [r3, #0]
 80080a6:	b25b      	sxtb	r3, r3
 80080a8:	2b00      	cmp	r3, #0
 80080aa:	d10a      	bne.n	80080c2 <VL53L1_DataInit+0xe0>
		Status = VL53L1_SetLimitCheckValue(Dev,
 80080ac:	230f      	movs	r3, #15
 80080ae:	18fc      	adds	r4, r7, r3
 80080b0:	2380      	movs	r3, #128	; 0x80
 80080b2:	01da      	lsls	r2, r3, #7
 80080b4:	687b      	ldr	r3, [r7, #4]
 80080b6:	2101      	movs	r1, #1
 80080b8:	0018      	movs	r0, r3
 80080ba:	f000 fd70 	bl	8008b9e <VL53L1_SetLimitCheckValue>
 80080be:	0003      	movs	r3, r0
 80080c0:	7023      	strb	r3, [r4, #0]
				(FixPoint1616_t)(25 * 65536 / 100));
				/* 0.25 * 65536 */
	}

	LOG_FUNCTION_END(Status);
	return Status;
 80080c2:	230f      	movs	r3, #15
 80080c4:	18fb      	adds	r3, r7, r3
 80080c6:	781b      	ldrb	r3, [r3, #0]
 80080c8:	b25b      	sxtb	r3, r3
}
 80080ca:	0018      	movs	r0, r3
 80080cc:	46bd      	mov	sp, r7
 80080ce:	b005      	add	sp, #20
 80080d0:	bd90      	pop	{r4, r7, pc}
	...

080080d4 <VL53L1_StaticInit>:


VL53L1_Error VL53L1_StaticInit(VL53L1_DEV Dev)
{
 80080d4:	b5b0      	push	{r4, r5, r7, lr}
 80080d6:	b084      	sub	sp, #16
 80080d8:	af00      	add	r7, sp, #0
 80080da:	6078      	str	r0, [r7, #4]
	VL53L1_Error Status = VL53L1_ERROR_NONE;
 80080dc:	200f      	movs	r0, #15
 80080de:	183b      	adds	r3, r7, r0
 80080e0:	2200      	movs	r2, #0
 80080e2:	701a      	strb	r2, [r3, #0]
	uint8_t  measurement_mode;

	LOG_FUNCTION_START("");

	VL53L1DevDataSet(Dev, PalState, VL53L1_STATE_IDLE);
 80080e4:	687a      	ldr	r2, [r7, #4]
 80080e6:	23de      	movs	r3, #222	; 0xde
 80080e8:	009b      	lsls	r3, r3, #2
 80080ea:	2103      	movs	r1, #3
 80080ec:	54d1      	strb	r1, [r2, r3]

	measurement_mode  = VL53L1_DEVICEMEASUREMENTMODE_BACKTOBACK;
 80080ee:	210e      	movs	r1, #14
 80080f0:	187b      	adds	r3, r7, r1
 80080f2:	2220      	movs	r2, #32
 80080f4:	701a      	strb	r2, [r3, #0]
	VL53L1DevDataSet(Dev, LLData.measurement_mode, measurement_mode);
 80080f6:	687b      	ldr	r3, [r7, #4]
 80080f8:	187a      	adds	r2, r7, r1
 80080fa:	7812      	ldrb	r2, [r2, #0]
 80080fc:	709a      	strb	r2, [r3, #2]

	VL53L1DevDataSet(Dev, CurrentParameters.NewDistanceMode,
 80080fe:	687b      	ldr	r3, [r7, #4]
 8008100:	4a0d      	ldr	r2, [pc, #52]	; (8008138 <VL53L1_StaticInit+0x64>)
 8008102:	2103      	movs	r1, #3
 8008104:	5499      	strb	r1, [r3, r2]
			VL53L1_DISTANCEMODE_LONG);

	VL53L1DevDataSet(Dev, CurrentParameters.InternalDistanceMode,
 8008106:	687b      	ldr	r3, [r7, #4]
 8008108:	4a0c      	ldr	r2, [pc, #48]	; (800813c <VL53L1_StaticInit+0x68>)
 800810a:	2103      	movs	r1, #3
 800810c:	5499      	strb	r1, [r3, r2]
			VL53L1_DISTANCEMODE_LONG);

	VL53L1DevDataSet(Dev, CurrentParameters.DistanceMode,
 800810e:	687b      	ldr	r3, [r7, #4]
 8008110:	4a0b      	ldr	r2, [pc, #44]	; (8008140 <VL53L1_StaticInit+0x6c>)
 8008112:	2103      	movs	r1, #3
 8008114:	5499      	strb	r1, [r3, r2]
			VL53L1_DISTANCEMODE_LONG);

	/* ticket 472728 fix */
	Status = VL53L1_SetPresetMode(Dev,
 8008116:	0005      	movs	r5, r0
 8008118:	183c      	adds	r4, r7, r0
 800811a:	687b      	ldr	r3, [r7, #4]
 800811c:	2108      	movs	r1, #8
 800811e:	0018      	movs	r0, r3
 8008120:	f000 f928 	bl	8008374 <VL53L1_SetPresetMode>
 8008124:	0003      	movs	r3, r0
 8008126:	7023      	strb	r3, [r4, #0]
			VL53L1_PRESETMODE_LOWPOWER_AUTONOMOUS);
	/* end of ticket 472728 fix */
	LOG_FUNCTION_END(Status);
	return Status;
 8008128:	0028      	movs	r0, r5
 800812a:	183b      	adds	r3, r7, r0
 800812c:	781b      	ldrb	r3, [r3, #0]
 800812e:	b25b      	sxtb	r3, r3
}
 8008130:	0018      	movs	r0, r3
 8008132:	46bd      	mov	sp, r7
 8008134:	b004      	add	sp, #16
 8008136:	bdb0      	pop	{r4, r5, r7, pc}
 8008138:	0000037f 	.word	0x0000037f
 800813c:	0000037e 	.word	0x0000037e
 8008140:	0000037d 	.word	0x0000037d

08008144 <VL53L1_WaitDeviceBooted>:

VL53L1_Error VL53L1_WaitDeviceBooted(VL53L1_DEV Dev)
{
 8008144:	b5b0      	push	{r4, r5, r7, lr}
 8008146:	b084      	sub	sp, #16
 8008148:	af00      	add	r7, sp, #0
 800814a:	6078      	str	r0, [r7, #4]
	VL53L1_Error Status = VL53L1_ERROR_NONE;
 800814c:	250f      	movs	r5, #15
 800814e:	197b      	adds	r3, r7, r5
 8008150:	2200      	movs	r2, #0
 8008152:	701a      	strb	r2, [r3, #0]

	LOG_FUNCTION_START("");

	Status = VL53L1_poll_for_boot_completion(Dev,
 8008154:	197c      	adds	r4, r7, r5
 8008156:	23fa      	movs	r3, #250	; 0xfa
 8008158:	005a      	lsls	r2, r3, #1
 800815a:	687b      	ldr	r3, [r7, #4]
 800815c:	0011      	movs	r1, r2
 800815e:	0018      	movs	r0, r3
 8008160:	f005 ff3c 	bl	800dfdc <VL53L1_poll_for_boot_completion>
 8008164:	0003      	movs	r3, r0
 8008166:	7023      	strb	r3, [r4, #0]
			VL53L1_BOOT_COMPLETION_POLLING_TIMEOUT_MS);

	LOG_FUNCTION_END(Status);
	return Status;
 8008168:	197b      	adds	r3, r7, r5
 800816a:	781b      	ldrb	r3, [r3, #0]
 800816c:	b25b      	sxtb	r3, r3
}
 800816e:	0018      	movs	r0, r3
 8008170:	46bd      	mov	sp, r7
 8008172:	b004      	add	sp, #16
 8008174:	bdb0      	pop	{r4, r5, r7, pc}
	...

08008178 <ComputeDevicePresetMode>:
/* Group PAL Parameters Functions */
static VL53L1_Error ComputeDevicePresetMode(
		VL53L1_PresetModes PresetMode,
		VL53L1_DistanceModes DistanceMode,
		VL53L1_DevicePresetModes *pDevicePresetMode)
{
 8008178:	b580      	push	{r7, lr}
 800817a:	b086      	sub	sp, #24
 800817c:	af00      	add	r7, sp, #0
 800817e:	603a      	str	r2, [r7, #0]
 8008180:	1dfb      	adds	r3, r7, #7
 8008182:	1c02      	adds	r2, r0, #0
 8008184:	701a      	strb	r2, [r3, #0]
 8008186:	1dbb      	adds	r3, r7, #6
 8008188:	1c0a      	adds	r2, r1, #0
 800818a:	701a      	strb	r2, [r3, #0]
	VL53L1_Error Status = VL53L1_ERROR_NONE;
 800818c:	2317      	movs	r3, #23
 800818e:	18fb      	adds	r3, r7, r3
 8008190:	2200      	movs	r2, #0
 8008192:	701a      	strb	r2, [r3, #0]

	uint8_t DistIdx;
	VL53L1_DevicePresetModes LightModes[3] = {
 8008194:	2310      	movs	r3, #16
 8008196:	18fb      	adds	r3, r7, r3
 8008198:	4a2d      	ldr	r2, [pc, #180]	; (8008250 <ComputeDevicePresetMode+0xd8>)
 800819a:	8811      	ldrh	r1, [r2, #0]
 800819c:	8019      	strh	r1, [r3, #0]
 800819e:	7892      	ldrb	r2, [r2, #2]
 80081a0:	709a      	strb	r2, [r3, #2]
		VL53L1_DEVICEPRESETMODE_STANDARD_RANGING_SHORT_RANGE,
		VL53L1_DEVICEPRESETMODE_STANDARD_RANGING,
		VL53L1_DEVICEPRESETMODE_STANDARD_RANGING_LONG_RANGE};


	VL53L1_DevicePresetModes TimedModes[3] = {
 80081a2:	230c      	movs	r3, #12
 80081a4:	18fb      	adds	r3, r7, r3
 80081a6:	4a2b      	ldr	r2, [pc, #172]	; (8008254 <ComputeDevicePresetMode+0xdc>)
 80081a8:	8811      	ldrh	r1, [r2, #0]
 80081aa:	8019      	strh	r1, [r3, #0]
 80081ac:	7892      	ldrb	r2, [r2, #2]
 80081ae:	709a      	strb	r2, [r3, #2]
		VL53L1_DEVICEPRESETMODE_TIMED_RANGING_SHORT_RANGE,
		VL53L1_DEVICEPRESETMODE_TIMED_RANGING,
		VL53L1_DEVICEPRESETMODE_TIMED_RANGING_LONG_RANGE};

	VL53L1_DevicePresetModes LowPowerTimedModes[3] = {
 80081b0:	2308      	movs	r3, #8
 80081b2:	18fb      	adds	r3, r7, r3
 80081b4:	4a28      	ldr	r2, [pc, #160]	; (8008258 <ComputeDevicePresetMode+0xe0>)
 80081b6:	8811      	ldrh	r1, [r2, #0]
 80081b8:	8019      	strh	r1, [r3, #0]
 80081ba:	7892      	ldrb	r2, [r2, #2]
 80081bc:	709a      	strb	r2, [r3, #2]
		VL53L1_DEVICEPRESETMODE_LOWPOWERAUTO_SHORT_RANGE,
		VL53L1_DEVICEPRESETMODE_LOWPOWERAUTO_MEDIUM_RANGE,
		VL53L1_DEVICEPRESETMODE_LOWPOWERAUTO_LONG_RANGE};

	*pDevicePresetMode = VL53L1_DEVICEPRESETMODE_STANDARD_RANGING;
 80081be:	683b      	ldr	r3, [r7, #0]
 80081c0:	2201      	movs	r2, #1
 80081c2:	701a      	strb	r2, [r3, #0]

	switch (DistanceMode) {
 80081c4:	1dbb      	adds	r3, r7, #6
 80081c6:	781b      	ldrb	r3, [r3, #0]
 80081c8:	2b01      	cmp	r3, #1
 80081ca:	d002      	beq.n	80081d2 <ComputeDevicePresetMode+0x5a>
 80081cc:	2b02      	cmp	r3, #2
 80081ce:	d005      	beq.n	80081dc <ComputeDevicePresetMode+0x64>
 80081d0:	e009      	b.n	80081e6 <ComputeDevicePresetMode+0x6e>
	case VL53L1_DISTANCEMODE_SHORT:
		DistIdx = 0;
 80081d2:	2316      	movs	r3, #22
 80081d4:	18fb      	adds	r3, r7, r3
 80081d6:	2200      	movs	r2, #0
 80081d8:	701a      	strb	r2, [r3, #0]
		break;
 80081da:	e008      	b.n	80081ee <ComputeDevicePresetMode+0x76>
	case VL53L1_DISTANCEMODE_MEDIUM:
		DistIdx = 1;
 80081dc:	2316      	movs	r3, #22
 80081de:	18fb      	adds	r3, r7, r3
 80081e0:	2201      	movs	r2, #1
 80081e2:	701a      	strb	r2, [r3, #0]
		break;
 80081e4:	e003      	b.n	80081ee <ComputeDevicePresetMode+0x76>
	default:
		DistIdx = 2;
 80081e6:	2316      	movs	r3, #22
 80081e8:	18fb      	adds	r3, r7, r3
 80081ea:	2202      	movs	r2, #2
 80081ec:	701a      	strb	r2, [r3, #0]
	}

	switch (PresetMode) {
 80081ee:	1dfb      	adds	r3, r7, #7
 80081f0:	781b      	ldrb	r3, [r3, #0]
 80081f2:	2b04      	cmp	r3, #4
 80081f4:	d004      	beq.n	8008200 <ComputeDevicePresetMode+0x88>
 80081f6:	2b08      	cmp	r3, #8
 80081f8:	d014      	beq.n	8008224 <ComputeDevicePresetMode+0xac>
 80081fa:	2b03      	cmp	r3, #3
 80081fc:	d009      	beq.n	8008212 <ComputeDevicePresetMode+0x9a>
 80081fe:	e01a      	b.n	8008236 <ComputeDevicePresetMode+0xbe>
	case VL53L1_PRESETMODE_LITE_RANGING:
		*pDevicePresetMode = LightModes[DistIdx];
 8008200:	2316      	movs	r3, #22
 8008202:	18fb      	adds	r3, r7, r3
 8008204:	781b      	ldrb	r3, [r3, #0]
 8008206:	2210      	movs	r2, #16
 8008208:	18ba      	adds	r2, r7, r2
 800820a:	5cd2      	ldrb	r2, [r2, r3]
 800820c:	683b      	ldr	r3, [r7, #0]
 800820e:	701a      	strb	r2, [r3, #0]
		break;
 8008210:	e015      	b.n	800823e <ComputeDevicePresetMode+0xc6>


	case VL53L1_PRESETMODE_AUTONOMOUS:
		*pDevicePresetMode = TimedModes[DistIdx];
 8008212:	2316      	movs	r3, #22
 8008214:	18fb      	adds	r3, r7, r3
 8008216:	781b      	ldrb	r3, [r3, #0]
 8008218:	220c      	movs	r2, #12
 800821a:	18ba      	adds	r2, r7, r2
 800821c:	5cd2      	ldrb	r2, [r2, r3]
 800821e:	683b      	ldr	r3, [r7, #0]
 8008220:	701a      	strb	r2, [r3, #0]
		break;
 8008222:	e00c      	b.n	800823e <ComputeDevicePresetMode+0xc6>

	case VL53L1_PRESETMODE_LOWPOWER_AUTONOMOUS:
		*pDevicePresetMode = LowPowerTimedModes[DistIdx];
 8008224:	2316      	movs	r3, #22
 8008226:	18fb      	adds	r3, r7, r3
 8008228:	781b      	ldrb	r3, [r3, #0]
 800822a:	2208      	movs	r2, #8
 800822c:	18ba      	adds	r2, r7, r2
 800822e:	5cd2      	ldrb	r2, [r2, r3]
 8008230:	683b      	ldr	r3, [r7, #0]
 8008232:	701a      	strb	r2, [r3, #0]
		break;
 8008234:	e003      	b.n	800823e <ComputeDevicePresetMode+0xc6>

	default:
		/* Unsupported mode */
		Status = VL53L1_ERROR_MODE_NOT_SUPPORTED;
 8008236:	2317      	movs	r3, #23
 8008238:	18fb      	adds	r3, r7, r3
 800823a:	22f8      	movs	r2, #248	; 0xf8
 800823c:	701a      	strb	r2, [r3, #0]
	}

	return Status;
 800823e:	2317      	movs	r3, #23
 8008240:	18fb      	adds	r3, r7, r3
 8008242:	781b      	ldrb	r3, [r3, #0]
 8008244:	b25b      	sxtb	r3, r3
}
 8008246:	0018      	movs	r0, r3
 8008248:	46bd      	mov	sp, r7
 800824a:	b006      	add	sp, #24
 800824c:	bd80      	pop	{r7, pc}
 800824e:	46c0      	nop			; (mov r8, r8)
 8008250:	08014d30 	.word	0x08014d30
 8008254:	08014d34 	.word	0x08014d34
 8008258:	08014d38 	.word	0x08014d38

0800825c <SetPresetMode>:

static VL53L1_Error SetPresetMode(VL53L1_DEV Dev,
		VL53L1_PresetModes PresetMode,
		VL53L1_DistanceModes DistanceMode,
		uint32_t inter_measurement_period_ms)
{
 800825c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800825e:	b08f      	sub	sp, #60	; 0x3c
 8008260:	af04      	add	r7, sp, #16
 8008262:	60f8      	str	r0, [r7, #12]
 8008264:	0008      	movs	r0, r1
 8008266:	0011      	movs	r1, r2
 8008268:	607b      	str	r3, [r7, #4]
 800826a:	240b      	movs	r4, #11
 800826c:	193b      	adds	r3, r7, r4
 800826e:	1c02      	adds	r2, r0, #0
 8008270:	701a      	strb	r2, [r3, #0]
 8008272:	230a      	movs	r3, #10
 8008274:	18fb      	adds	r3, r7, r3
 8008276:	1c0a      	adds	r2, r1, #0
 8008278:	701a      	strb	r2, [r3, #0]
	VL53L1_Error Status = VL53L1_ERROR_NONE;
 800827a:	2327      	movs	r3, #39	; 0x27
 800827c:	18fb      	adds	r3, r7, r3
 800827e:	2200      	movs	r2, #0
 8008280:	701a      	strb	r2, [r3, #0]
	uint32_t mm_config_timeout_us;
	uint32_t lld_range_config_timeout_us;

	LOG_FUNCTION_START("%d", (int)PresetMode);

	if ((PresetMode == VL53L1_PRESETMODE_AUTONOMOUS) ||
 8008282:	193b      	adds	r3, r7, r4
 8008284:	781b      	ldrb	r3, [r3, #0]
 8008286:	2b03      	cmp	r3, #3
 8008288:	d004      	beq.n	8008294 <SetPresetMode+0x38>
 800828a:	230b      	movs	r3, #11
 800828c:	18fb      	adds	r3, r7, r3
 800828e:	781b      	ldrb	r3, [r3, #0]
 8008290:	2b08      	cmp	r3, #8
 8008292:	d104      	bne.n	800829e <SetPresetMode+0x42>
		(PresetMode == VL53L1_PRESETMODE_LOWPOWER_AUTONOMOUS))
		measurement_mode  = VL53L1_DEVICEMEASUREMENTMODE_TIMED;
 8008294:	2326      	movs	r3, #38	; 0x26
 8008296:	18fb      	adds	r3, r7, r3
 8008298:	2240      	movs	r2, #64	; 0x40
 800829a:	701a      	strb	r2, [r3, #0]
 800829c:	e003      	b.n	80082a6 <SetPresetMode+0x4a>
	else
		measurement_mode  = VL53L1_DEVICEMEASUREMENTMODE_BACKTOBACK;
 800829e:	2326      	movs	r3, #38	; 0x26
 80082a0:	18fb      	adds	r3, r7, r3
 80082a2:	2220      	movs	r2, #32
 80082a4:	701a      	strb	r2, [r3, #0]


	Status = ComputeDevicePresetMode(PresetMode, DistanceMode,
 80082a6:	2527      	movs	r5, #39	; 0x27
 80082a8:	197c      	adds	r4, r7, r5
 80082aa:	2325      	movs	r3, #37	; 0x25
 80082ac:	18fa      	adds	r2, r7, r3
 80082ae:	230a      	movs	r3, #10
 80082b0:	18fb      	adds	r3, r7, r3
 80082b2:	7819      	ldrb	r1, [r3, #0]
 80082b4:	230b      	movs	r3, #11
 80082b6:	18fb      	adds	r3, r7, r3
 80082b8:	781b      	ldrb	r3, [r3, #0]
 80082ba:	0018      	movs	r0, r3
 80082bc:	f7ff ff5c 	bl	8008178 <ComputeDevicePresetMode>
 80082c0:	0003      	movs	r3, r0
 80082c2:	7023      	strb	r3, [r4, #0]
			&device_preset_mode);

	if (Status == VL53L1_ERROR_NONE)
 80082c4:	197b      	adds	r3, r7, r5
 80082c6:	781b      	ldrb	r3, [r3, #0]
 80082c8:	b25b      	sxtb	r3, r3
 80082ca:	2b00      	cmp	r3, #0
 80082cc:	d114      	bne.n	80082f8 <SetPresetMode+0x9c>
		Status =  VL53L1_get_preset_mode_timing_cfg(Dev,
 80082ce:	2325      	movs	r3, #37	; 0x25
 80082d0:	18fb      	adds	r3, r7, r3
 80082d2:	7819      	ldrb	r1, [r3, #0]
 80082d4:	2327      	movs	r3, #39	; 0x27
 80082d6:	18fc      	adds	r4, r7, r3
 80082d8:	231c      	movs	r3, #28
 80082da:	18fd      	adds	r5, r7, r3
 80082dc:	2322      	movs	r3, #34	; 0x22
 80082de:	18fa      	adds	r2, r7, r3
 80082e0:	68f8      	ldr	r0, [r7, #12]
 80082e2:	2314      	movs	r3, #20
 80082e4:	18fb      	adds	r3, r7, r3
 80082e6:	9301      	str	r3, [sp, #4]
 80082e8:	2318      	movs	r3, #24
 80082ea:	18fb      	adds	r3, r7, r3
 80082ec:	9300      	str	r3, [sp, #0]
 80082ee:	002b      	movs	r3, r5
 80082f0:	f001 fcf2 	bl	8009cd8 <VL53L1_get_preset_mode_timing_cfg>
 80082f4:	0003      	movs	r3, r0
 80082f6:	7023      	strb	r3, [r4, #0]
				&dss_config__target_total_rate_mcps,
				&phasecal_config_timeout_us,
				&mm_config_timeout_us,
				&lld_range_config_timeout_us);

	if (Status == VL53L1_ERROR_NONE)
 80082f8:	2327      	movs	r3, #39	; 0x27
 80082fa:	18fb      	adds	r3, r7, r3
 80082fc:	781b      	ldrb	r3, [r3, #0]
 80082fe:	b25b      	sxtb	r3, r3
 8008300:	2b00      	cmp	r3, #0
 8008302:	d117      	bne.n	8008334 <SetPresetMode+0xd8>
		Status = VL53L1_set_preset_mode(
 8008304:	2325      	movs	r3, #37	; 0x25
 8008306:	18fb      	adds	r3, r7, r3
 8008308:	781d      	ldrb	r5, [r3, #0]
 800830a:	2322      	movs	r3, #34	; 0x22
 800830c:	18fb      	adds	r3, r7, r3
 800830e:	881e      	ldrh	r6, [r3, #0]
 8008310:	69fb      	ldr	r3, [r7, #28]
 8008312:	469c      	mov	ip, r3
 8008314:	69bb      	ldr	r3, [r7, #24]
 8008316:	697a      	ldr	r2, [r7, #20]
 8008318:	2127      	movs	r1, #39	; 0x27
 800831a:	187c      	adds	r4, r7, r1
 800831c:	68f8      	ldr	r0, [r7, #12]
 800831e:	6879      	ldr	r1, [r7, #4]
 8008320:	9102      	str	r1, [sp, #8]
 8008322:	9201      	str	r2, [sp, #4]
 8008324:	9300      	str	r3, [sp, #0]
 8008326:	4663      	mov	r3, ip
 8008328:	0032      	movs	r2, r6
 800832a:	0029      	movs	r1, r5
 800832c:	f001 fd3c 	bl	8009da8 <VL53L1_set_preset_mode>
 8008330:	0003      	movs	r3, r0
 8008332:	7023      	strb	r3, [r4, #0]
				phasecal_config_timeout_us,
				mm_config_timeout_us,
				lld_range_config_timeout_us,
				inter_measurement_period_ms);

	if (Status == VL53L1_ERROR_NONE)
 8008334:	2327      	movs	r3, #39	; 0x27
 8008336:	18fb      	adds	r3, r7, r3
 8008338:	781b      	ldrb	r3, [r3, #0]
 800833a:	b25b      	sxtb	r3, r3
 800833c:	2b00      	cmp	r3, #0
 800833e:	d104      	bne.n	800834a <SetPresetMode+0xee>
		VL53L1DevDataSet(Dev, LLData.measurement_mode, measurement_mode);
 8008340:	68fb      	ldr	r3, [r7, #12]
 8008342:	2226      	movs	r2, #38	; 0x26
 8008344:	18ba      	adds	r2, r7, r2
 8008346:	7812      	ldrb	r2, [r2, #0]
 8008348:	709a      	strb	r2, [r3, #2]

	if (Status == VL53L1_ERROR_NONE)
 800834a:	2327      	movs	r3, #39	; 0x27
 800834c:	18fb      	adds	r3, r7, r3
 800834e:	781b      	ldrb	r3, [r3, #0]
 8008350:	b25b      	sxtb	r3, r3
 8008352:	2b00      	cmp	r3, #0
 8008354:	d106      	bne.n	8008364 <SetPresetMode+0x108>
		VL53L1DevDataSet(Dev, CurrentParameters.PresetMode, PresetMode);
 8008356:	68fa      	ldr	r2, [r7, #12]
 8008358:	230b      	movs	r3, #11
 800835a:	18f9      	adds	r1, r7, r3
 800835c:	23df      	movs	r3, #223	; 0xdf
 800835e:	009b      	lsls	r3, r3, #2
 8008360:	7809      	ldrb	r1, [r1, #0]
 8008362:	54d1      	strb	r1, [r2, r3]

	LOG_FUNCTION_END(Status);
	return Status;
 8008364:	2327      	movs	r3, #39	; 0x27
 8008366:	18fb      	adds	r3, r7, r3
 8008368:	781b      	ldrb	r3, [r3, #0]
 800836a:	b25b      	sxtb	r3, r3
}
 800836c:	0018      	movs	r0, r3
 800836e:	46bd      	mov	sp, r7
 8008370:	b00b      	add	sp, #44	; 0x2c
 8008372:	bdf0      	pop	{r4, r5, r6, r7, pc}

08008374 <VL53L1_SetPresetMode>:

VL53L1_Error VL53L1_SetPresetMode(VL53L1_DEV Dev, VL53L1_PresetModes PresetMode)
{
 8008374:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008376:	b085      	sub	sp, #20
 8008378:	af00      	add	r7, sp, #0
 800837a:	6078      	str	r0, [r7, #4]
 800837c:	000a      	movs	r2, r1
 800837e:	1cfb      	adds	r3, r7, #3
 8008380:	701a      	strb	r2, [r3, #0]
	VL53L1_Error Status = VL53L1_ERROR_NONE;
 8008382:	260f      	movs	r6, #15
 8008384:	19bb      	adds	r3, r7, r6
 8008386:	2200      	movs	r2, #0
 8008388:	701a      	strb	r2, [r3, #0]
	VL53L1_DistanceModes DistanceMode = VL53L1_DISTANCEMODE_LONG;
 800838a:	210e      	movs	r1, #14
 800838c:	187b      	adds	r3, r7, r1
 800838e:	2203      	movs	r2, #3
 8008390:	701a      	strb	r2, [r3, #0]

	LOG_FUNCTION_START("%d", (int)PresetMode);

	Status = SetPresetMode(Dev,
 8008392:	19bc      	adds	r4, r7, r6
 8008394:	23fa      	movs	r3, #250	; 0xfa
 8008396:	009d      	lsls	r5, r3, #2
 8008398:	187b      	adds	r3, r7, r1
 800839a:	781a      	ldrb	r2, [r3, #0]
 800839c:	1cfb      	adds	r3, r7, #3
 800839e:	7819      	ldrb	r1, [r3, #0]
 80083a0:	6878      	ldr	r0, [r7, #4]
 80083a2:	002b      	movs	r3, r5
 80083a4:	f7ff ff5a 	bl	800825c <SetPresetMode>
 80083a8:	0003      	movs	r3, r0
 80083aa:	7023      	strb	r3, [r4, #0]
			PresetMode,
			DistanceMode,
			1000);

	if (Status == VL53L1_ERROR_NONE) {
 80083ac:	19bb      	adds	r3, r7, r6
 80083ae:	781b      	ldrb	r3, [r3, #0]
 80083b0:	b25b      	sxtb	r3, r3
 80083b2:	2b00      	cmp	r3, #0
 80083b4:	d12b      	bne.n	800840e <VL53L1_SetPresetMode+0x9a>
		VL53L1DevDataSet(Dev, CurrentParameters.InternalDistanceMode,
 80083b6:	687b      	ldr	r3, [r7, #4]
 80083b8:	200e      	movs	r0, #14
 80083ba:	183a      	adds	r2, r7, r0
 80083bc:	4920      	ldr	r1, [pc, #128]	; (8008440 <VL53L1_SetPresetMode+0xcc>)
 80083be:	7812      	ldrb	r2, [r2, #0]
 80083c0:	545a      	strb	r2, [r3, r1]
				DistanceMode);

		VL53L1DevDataSet(Dev, CurrentParameters.NewDistanceMode,
 80083c2:	687b      	ldr	r3, [r7, #4]
 80083c4:	183a      	adds	r2, r7, r0
 80083c6:	491f      	ldr	r1, [pc, #124]	; (8008444 <VL53L1_SetPresetMode+0xd0>)
 80083c8:	7812      	ldrb	r2, [r2, #0]
 80083ca:	545a      	strb	r2, [r3, r1]
				DistanceMode);

		if ((PresetMode == VL53L1_PRESETMODE_LITE_RANGING) ||
 80083cc:	1cfb      	adds	r3, r7, #3
 80083ce:	781b      	ldrb	r3, [r3, #0]
 80083d0:	2b04      	cmp	r3, #4
 80083d2:	d007      	beq.n	80083e4 <VL53L1_SetPresetMode+0x70>
 80083d4:	1cfb      	adds	r3, r7, #3
 80083d6:	781b      	ldrb	r3, [r3, #0]
 80083d8:	2b03      	cmp	r3, #3
 80083da:	d003      	beq.n	80083e4 <VL53L1_SetPresetMode+0x70>
			(PresetMode == VL53L1_PRESETMODE_AUTONOMOUS) ||
 80083dc:	1cfb      	adds	r3, r7, #3
 80083de:	781b      	ldrb	r3, [r3, #0]
 80083e0:	2b08      	cmp	r3, #8
 80083e2:	d10a      	bne.n	80083fa <VL53L1_SetPresetMode+0x86>
			(PresetMode == VL53L1_PRESETMODE_LOWPOWER_AUTONOMOUS))
			Status = VL53L1_SetMeasurementTimingBudgetMicroSeconds(
 80083e4:	230f      	movs	r3, #15
 80083e6:	18fc      	adds	r4, r7, r3
 80083e8:	4a17      	ldr	r2, [pc, #92]	; (8008448 <VL53L1_SetPresetMode+0xd4>)
 80083ea:	687b      	ldr	r3, [r7, #4]
 80083ec:	0011      	movs	r1, r2
 80083ee:	0018      	movs	r0, r3
 80083f0:	f000 f8f0 	bl	80085d4 <VL53L1_SetMeasurementTimingBudgetMicroSeconds>
 80083f4:	0003      	movs	r3, r0
 80083f6:	7023      	strb	r3, [r4, #0]
 80083f8:	e009      	b.n	800840e <VL53L1_SetPresetMode+0x9a>
				Dev, 41000);
		else
			/* Set default timing budget to 30Hz (33.33 ms)*/
			Status = VL53L1_SetMeasurementTimingBudgetMicroSeconds(
 80083fa:	230f      	movs	r3, #15
 80083fc:	18fc      	adds	r4, r7, r3
 80083fe:	4a13      	ldr	r2, [pc, #76]	; (800844c <VL53L1_SetPresetMode+0xd8>)
 8008400:	687b      	ldr	r3, [r7, #4]
 8008402:	0011      	movs	r1, r2
 8008404:	0018      	movs	r0, r3
 8008406:	f000 f8e5 	bl	80085d4 <VL53L1_SetMeasurementTimingBudgetMicroSeconds>
 800840a:	0003      	movs	r3, r0
 800840c:	7023      	strb	r3, [r4, #0]
				Dev, 33333);
	}

	if (Status == VL53L1_ERROR_NONE) {
 800840e:	230f      	movs	r3, #15
 8008410:	18fb      	adds	r3, r7, r3
 8008412:	781b      	ldrb	r3, [r3, #0]
 8008414:	b25b      	sxtb	r3, r3
 8008416:	2b00      	cmp	r3, #0
 8008418:	d10a      	bne.n	8008430 <VL53L1_SetPresetMode+0xbc>
		/* Set default intermeasurement period to 1000 ms */
		Status = VL53L1_SetInterMeasurementPeriodMilliSeconds(Dev,
 800841a:	230f      	movs	r3, #15
 800841c:	18fc      	adds	r4, r7, r3
 800841e:	23fa      	movs	r3, #250	; 0xfa
 8008420:	009a      	lsls	r2, r3, #2
 8008422:	687b      	ldr	r3, [r7, #4]
 8008424:	0011      	movs	r1, r2
 8008426:	0018      	movs	r0, r3
 8008428:	f000 faaa 	bl	8008980 <VL53L1_SetInterMeasurementPeriodMilliSeconds>
 800842c:	0003      	movs	r3, r0
 800842e:	7023      	strb	r3, [r4, #0]
				1000);
	}

	LOG_FUNCTION_END(Status);
	return Status;
 8008430:	230f      	movs	r3, #15
 8008432:	18fb      	adds	r3, r7, r3
 8008434:	781b      	ldrb	r3, [r3, #0]
 8008436:	b25b      	sxtb	r3, r3
}
 8008438:	0018      	movs	r0, r3
 800843a:	46bd      	mov	sp, r7
 800843c:	b005      	add	sp, #20
 800843e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008440:	0000037e 	.word	0x0000037e
 8008444:	0000037f 	.word	0x0000037f
 8008448:	0000a028 	.word	0x0000a028
 800844c:	00008235 	.word	0x00008235

08008450 <VL53L1_SetDistanceMode>:
	return Status;
}

VL53L1_Error VL53L1_SetDistanceMode(VL53L1_DEV Dev,
		VL53L1_DistanceModes DistanceMode)
{
 8008450:	b5b0      	push	{r4, r5, r7, lr}
 8008452:	b088      	sub	sp, #32
 8008454:	af00      	add	r7, sp, #0
 8008456:	6078      	str	r0, [r7, #4]
 8008458:	000a      	movs	r2, r1
 800845a:	1cfb      	adds	r3, r7, #3
 800845c:	701a      	strb	r2, [r3, #0]
	VL53L1_Error Status = VL53L1_ERROR_NONE;
 800845e:	231f      	movs	r3, #31
 8008460:	18fb      	adds	r3, r7, r3
 8008462:	2200      	movs	r2, #0
 8008464:	701a      	strb	r2, [r3, #0]
	uint32_t PhaseCalTimeoutUs;
	VL53L1_user_zone_t user_zone;

	LOG_FUNCTION_START("%d", (int)DistanceMode);

	PresetMode = VL53L1DevDataGet(Dev, CurrentParameters.PresetMode);
 8008466:	231d      	movs	r3, #29
 8008468:	18fb      	adds	r3, r7, r3
 800846a:	6879      	ldr	r1, [r7, #4]
 800846c:	22df      	movs	r2, #223	; 0xdf
 800846e:	0092      	lsls	r2, r2, #2
 8008470:	5c8a      	ldrb	r2, [r1, r2]
 8008472:	701a      	strb	r2, [r3, #0]
	/* when the distance mode is valid:
	 * Manual Mode: all modes
	 * AUTO AUTO_LITE : LITE_RANGING, RANGING
	 */

	if ((DistanceMode != VL53L1_DISTANCEMODE_SHORT) &&
 8008474:	1cfb      	adds	r3, r7, #3
 8008476:	781b      	ldrb	r3, [r3, #0]
 8008478:	2b01      	cmp	r3, #1
 800847a:	d00a      	beq.n	8008492 <VL53L1_SetDistanceMode+0x42>
 800847c:	1cfb      	adds	r3, r7, #3
 800847e:	781b      	ldrb	r3, [r3, #0]
 8008480:	2b02      	cmp	r3, #2
 8008482:	d006      	beq.n	8008492 <VL53L1_SetDistanceMode+0x42>
		(DistanceMode != VL53L1_DISTANCEMODE_MEDIUM) &&
 8008484:	1cfb      	adds	r3, r7, #3
 8008486:	781b      	ldrb	r3, [r3, #0]
 8008488:	2b03      	cmp	r3, #3
 800848a:	d002      	beq.n	8008492 <VL53L1_SetDistanceMode+0x42>
		(DistanceMode != VL53L1_DISTANCEMODE_LONG))
		return VL53L1_ERROR_INVALID_PARAMS;
 800848c:	2304      	movs	r3, #4
 800848e:	425b      	negs	r3, r3
 8008490:	e096      	b.n	80085c0 <VL53L1_SetDistanceMode+0x170>

	/* The internal distance mode is limited to Short, Medium or
	 * long only
	*/
	if (Status == VL53L1_ERROR_NONE) {
 8008492:	231f      	movs	r3, #31
 8008494:	18fb      	adds	r3, r7, r3
 8008496:	781b      	ldrb	r3, [r3, #0]
 8008498:	b25b      	sxtb	r3, r3
 800849a:	2b00      	cmp	r3, #0
 800849c:	d111      	bne.n	80084c2 <VL53L1_SetDistanceMode+0x72>
		if ((DistanceMode == VL53L1_DISTANCEMODE_SHORT) ||
 800849e:	1cfb      	adds	r3, r7, #3
 80084a0:	781b      	ldrb	r3, [r3, #0]
 80084a2:	2b01      	cmp	r3, #1
 80084a4:	d003      	beq.n	80084ae <VL53L1_SetDistanceMode+0x5e>
 80084a6:	1cfb      	adds	r3, r7, #3
 80084a8:	781b      	ldrb	r3, [r3, #0]
 80084aa:	2b02      	cmp	r3, #2
 80084ac:	d105      	bne.n	80084ba <VL53L1_SetDistanceMode+0x6a>
			(DistanceMode == VL53L1_DISTANCEMODE_MEDIUM))
			InternalDistanceMode = DistanceMode;
 80084ae:	231e      	movs	r3, #30
 80084b0:	18fb      	adds	r3, r7, r3
 80084b2:	1cfa      	adds	r2, r7, #3
 80084b4:	7812      	ldrb	r2, [r2, #0]
 80084b6:	701a      	strb	r2, [r3, #0]
 80084b8:	e003      	b.n	80084c2 <VL53L1_SetDistanceMode+0x72>
		else /* (DistanceMode == VL53L1_DISTANCEMODE_LONG) */
			InternalDistanceMode = VL53L1_DISTANCEMODE_LONG;
 80084ba:	231e      	movs	r3, #30
 80084bc:	18fb      	adds	r3, r7, r3
 80084be:	2203      	movs	r2, #3
 80084c0:	701a      	strb	r2, [r3, #0]
	}

	if (Status == VL53L1_ERROR_NONE)
 80084c2:	231f      	movs	r3, #31
 80084c4:	18fb      	adds	r3, r7, r3
 80084c6:	781b      	ldrb	r3, [r3, #0]
 80084c8:	b25b      	sxtb	r3, r3
 80084ca:	2b00      	cmp	r3, #0
 80084cc:	d10a      	bne.n	80084e4 <VL53L1_SetDistanceMode+0x94>
		Status = VL53L1_get_user_zone(Dev, &user_zone);
 80084ce:	231f      	movs	r3, #31
 80084d0:	18fc      	adds	r4, r7, r3
 80084d2:	2308      	movs	r3, #8
 80084d4:	18fa      	adds	r2, r7, r3
 80084d6:	687b      	ldr	r3, [r7, #4]
 80084d8:	0011      	movs	r1, r2
 80084da:	0018      	movs	r0, r3
 80084dc:	f001 fb8b 	bl	8009bf6 <VL53L1_get_user_zone>
 80084e0:	0003      	movs	r3, r0
 80084e2:	7023      	strb	r3, [r4, #0]

	inter_measurement_period_ms =  VL53L1DevDataGet(Dev,
 80084e4:	687b      	ldr	r3, [r7, #4]
 80084e6:	695b      	ldr	r3, [r3, #20]
 80084e8:	61bb      	str	r3, [r7, #24]
				LLData.inter_measurement_period_ms);

	if (Status == VL53L1_ERROR_NONE)
 80084ea:	231f      	movs	r3, #31
 80084ec:	18fb      	adds	r3, r7, r3
 80084ee:	781b      	ldrb	r3, [r3, #0]
 80084f0:	b25b      	sxtb	r3, r3
 80084f2:	2b00      	cmp	r3, #0
 80084f4:	d10c      	bne.n	8008510 <VL53L1_SetDistanceMode+0xc0>
		Status = VL53L1_get_timeouts_us(Dev, &PhaseCalTimeoutUs,
 80084f6:	231f      	movs	r3, #31
 80084f8:	18fc      	adds	r4, r7, r3
 80084fa:	2314      	movs	r3, #20
 80084fc:	18fb      	adds	r3, r7, r3
 80084fe:	2210      	movs	r2, #16
 8008500:	18ba      	adds	r2, r7, r2
 8008502:	210c      	movs	r1, #12
 8008504:	1879      	adds	r1, r7, r1
 8008506:	6878      	ldr	r0, [r7, #4]
 8008508:	f001 fa77 	bl	80099fa <VL53L1_get_timeouts_us>
 800850c:	0003      	movs	r3, r0
 800850e:	7023      	strb	r3, [r4, #0]
			&MmTimeoutUs, &TimingBudget);

	if (Status == VL53L1_ERROR_NONE)
 8008510:	231f      	movs	r3, #31
 8008512:	18fb      	adds	r3, r7, r3
 8008514:	781b      	ldrb	r3, [r3, #0]
 8008516:	b25b      	sxtb	r3, r3
 8008518:	2b00      	cmp	r3, #0
 800851a:	d10e      	bne.n	800853a <VL53L1_SetDistanceMode+0xea>
		Status = SetPresetMode(Dev,
 800851c:	231f      	movs	r3, #31
 800851e:	18fc      	adds	r4, r7, r3
 8008520:	69bd      	ldr	r5, [r7, #24]
 8008522:	231e      	movs	r3, #30
 8008524:	18fb      	adds	r3, r7, r3
 8008526:	781a      	ldrb	r2, [r3, #0]
 8008528:	231d      	movs	r3, #29
 800852a:	18fb      	adds	r3, r7, r3
 800852c:	7819      	ldrb	r1, [r3, #0]
 800852e:	6878      	ldr	r0, [r7, #4]
 8008530:	002b      	movs	r3, r5
 8008532:	f7ff fe93 	bl	800825c <SetPresetMode>
 8008536:	0003      	movs	r3, r0
 8008538:	7023      	strb	r3, [r4, #0]
				PresetMode,
				InternalDistanceMode,
				inter_measurement_period_ms);

	if (Status == VL53L1_ERROR_NONE) {
 800853a:	231f      	movs	r3, #31
 800853c:	18fb      	adds	r3, r7, r3
 800853e:	781b      	ldrb	r3, [r3, #0]
 8008540:	b25b      	sxtb	r3, r3
 8008542:	2b00      	cmp	r3, #0
 8008544:	d10f      	bne.n	8008566 <VL53L1_SetDistanceMode+0x116>
		VL53L1DevDataSet(Dev, CurrentParameters.InternalDistanceMode,
 8008546:	687b      	ldr	r3, [r7, #4]
 8008548:	201e      	movs	r0, #30
 800854a:	183a      	adds	r2, r7, r0
 800854c:	491e      	ldr	r1, [pc, #120]	; (80085c8 <VL53L1_SetDistanceMode+0x178>)
 800854e:	7812      	ldrb	r2, [r2, #0]
 8008550:	545a      	strb	r2, [r3, r1]
				InternalDistanceMode);
		VL53L1DevDataSet(Dev, CurrentParameters.NewDistanceMode,
 8008552:	687b      	ldr	r3, [r7, #4]
 8008554:	183a      	adds	r2, r7, r0
 8008556:	491d      	ldr	r1, [pc, #116]	; (80085cc <VL53L1_SetDistanceMode+0x17c>)
 8008558:	7812      	ldrb	r2, [r2, #0]
 800855a:	545a      	strb	r2, [r3, r1]
				InternalDistanceMode);
		VL53L1DevDataSet(Dev, CurrentParameters.DistanceMode,
 800855c:	687b      	ldr	r3, [r7, #4]
 800855e:	1cfa      	adds	r2, r7, #3
 8008560:	491b      	ldr	r1, [pc, #108]	; (80085d0 <VL53L1_SetDistanceMode+0x180>)
 8008562:	7812      	ldrb	r2, [r2, #0]
 8008564:	545a      	strb	r2, [r3, r1]
				DistanceMode);
	}

	if (Status == VL53L1_ERROR_NONE) {
 8008566:	231f      	movs	r3, #31
 8008568:	18fb      	adds	r3, r7, r3
 800856a:	781b      	ldrb	r3, [r3, #0]
 800856c:	b25b      	sxtb	r3, r3
 800856e:	2b00      	cmp	r3, #0
 8008570:	d111      	bne.n	8008596 <VL53L1_SetDistanceMode+0x146>
		Status = VL53L1_set_timeouts_us(Dev, PhaseCalTimeoutUs,
 8008572:	68f9      	ldr	r1, [r7, #12]
 8008574:	693a      	ldr	r2, [r7, #16]
 8008576:	697b      	ldr	r3, [r7, #20]
 8008578:	251f      	movs	r5, #31
 800857a:	197c      	adds	r4, r7, r5
 800857c:	6878      	ldr	r0, [r7, #4]
 800857e:	f001 f9f7 	bl	8009970 <VL53L1_set_timeouts_us>
 8008582:	0003      	movs	r3, r0
 8008584:	7023      	strb	r3, [r4, #0]
			MmTimeoutUs, TimingBudget);

		if (Status == VL53L1_ERROR_NONE)
 8008586:	197b      	adds	r3, r7, r5
 8008588:	781b      	ldrb	r3, [r3, #0]
 800858a:	b25b      	sxtb	r3, r3
 800858c:	2b00      	cmp	r3, #0
 800858e:	d102      	bne.n	8008596 <VL53L1_SetDistanceMode+0x146>
			VL53L1DevDataSet(Dev, LLData.range_config_timeout_us,
 8008590:	697a      	ldr	r2, [r7, #20]
 8008592:	687b      	ldr	r3, [r7, #4]
 8008594:	611a      	str	r2, [r3, #16]
				TimingBudget);
	}

	if (Status == VL53L1_ERROR_NONE)
 8008596:	231f      	movs	r3, #31
 8008598:	18fb      	adds	r3, r7, r3
 800859a:	781b      	ldrb	r3, [r3, #0]
 800859c:	b25b      	sxtb	r3, r3
 800859e:	2b00      	cmp	r3, #0
 80085a0:	d10a      	bne.n	80085b8 <VL53L1_SetDistanceMode+0x168>
		Status = VL53L1_set_user_zone(Dev, &user_zone);
 80085a2:	231f      	movs	r3, #31
 80085a4:	18fc      	adds	r4, r7, r3
 80085a6:	2308      	movs	r3, #8
 80085a8:	18fa      	adds	r2, r7, r3
 80085aa:	687b      	ldr	r3, [r7, #4]
 80085ac:	0011      	movs	r1, r2
 80085ae:	0018      	movs	r0, r3
 80085b0:	f001 fafb 	bl	8009baa <VL53L1_set_user_zone>
 80085b4:	0003      	movs	r3, r0
 80085b6:	7023      	strb	r3, [r4, #0]

	LOG_FUNCTION_END(Status);
	return Status;
 80085b8:	231f      	movs	r3, #31
 80085ba:	18fb      	adds	r3, r7, r3
 80085bc:	781b      	ldrb	r3, [r3, #0]
 80085be:	b25b      	sxtb	r3, r3
}
 80085c0:	0018      	movs	r0, r3
 80085c2:	46bd      	mov	sp, r7
 80085c4:	b008      	add	sp, #32
 80085c6:	bdb0      	pop	{r4, r5, r7, pc}
 80085c8:	0000037e 	.word	0x0000037e
 80085cc:	0000037f 	.word	0x0000037f
 80085d0:	0000037d 	.word	0x0000037d

080085d4 <VL53L1_SetMeasurementTimingBudgetMicroSeconds>:



VL53L1_Error VL53L1_SetMeasurementTimingBudgetMicroSeconds(VL53L1_DEV Dev,
	uint32_t MeasurementTimingBudgetMicroSeconds)
{
 80085d4:	b590      	push	{r4, r7, lr}
 80085d6:	b08d      	sub	sp, #52	; 0x34
 80085d8:	af00      	add	r7, sp, #0
 80085da:	6078      	str	r0, [r7, #4]
 80085dc:	6039      	str	r1, [r7, #0]
	VL53L1_Error Status = VL53L1_ERROR_NONE;
 80085de:	232f      	movs	r3, #47	; 0x2f
 80085e0:	18fb      	adds	r3, r7, r3
 80085e2:	2200      	movs	r2, #0
 80085e4:	701a      	strb	r2, [r3, #0]
	uint32_t MmTimeoutUs;
	VL53L1_PresetModes PresetMode;
	uint32_t PhaseCalTimeoutUs;
	uint32_t vhv;
	int32_t vhv_loops;
	uint32_t FDAMaxTimingBudgetUs = FDA_MAX_TIMING_BUDGET_US;
 80085e6:	4b75      	ldr	r3, [pc, #468]	; (80087bc <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0x1e8>)
 80085e8:	61fb      	str	r3, [r7, #28]

	LOG_FUNCTION_START("");

	/* Timing budget is limited to 10 seconds */
	if (MeasurementTimingBudgetMicroSeconds > 10000000)
 80085ea:	683b      	ldr	r3, [r7, #0]
 80085ec:	4a74      	ldr	r2, [pc, #464]	; (80087c0 <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0x1ec>)
 80085ee:	4293      	cmp	r3, r2
 80085f0:	d903      	bls.n	80085fa <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0x26>
		Status = VL53L1_ERROR_INVALID_PARAMS;
 80085f2:	232f      	movs	r3, #47	; 0x2f
 80085f4:	18fb      	adds	r3, r7, r3
 80085f6:	22fc      	movs	r2, #252	; 0xfc
 80085f8:	701a      	strb	r2, [r3, #0]

	if (Status == VL53L1_ERROR_NONE) {
 80085fa:	232f      	movs	r3, #47	; 0x2f
 80085fc:	18fb      	adds	r3, r7, r3
 80085fe:	781b      	ldrb	r3, [r3, #0]
 8008600:	b25b      	sxtb	r3, r3
 8008602:	2b00      	cmp	r3, #0
 8008604:	d10a      	bne.n	800861c <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0x48>
		Status = VL53L1_GetSequenceStepEnable(Dev,
 8008606:	232f      	movs	r3, #47	; 0x2f
 8008608:	18fc      	adds	r4, r7, r3
 800860a:	231a      	movs	r3, #26
 800860c:	18fa      	adds	r2, r7, r3
 800860e:	687b      	ldr	r3, [r7, #4]
 8008610:	2105      	movs	r1, #5
 8008612:	0018      	movs	r0, r3
 8008614:	f000 fc00 	bl	8008e18 <VL53L1_GetSequenceStepEnable>
 8008618:	0003      	movs	r3, r0
 800861a:	7023      	strb	r3, [r4, #0]
			VL53L1_SEQUENCESTEP_MM1, &Mm1Enabled);
	}

	if (Status == VL53L1_ERROR_NONE) {
 800861c:	232f      	movs	r3, #47	; 0x2f
 800861e:	18fb      	adds	r3, r7, r3
 8008620:	781b      	ldrb	r3, [r3, #0]
 8008622:	b25b      	sxtb	r3, r3
 8008624:	2b00      	cmp	r3, #0
 8008626:	d10a      	bne.n	800863e <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0x6a>
		Status = VL53L1_GetSequenceStepEnable(Dev,
 8008628:	232f      	movs	r3, #47	; 0x2f
 800862a:	18fc      	adds	r4, r7, r3
 800862c:	2319      	movs	r3, #25
 800862e:	18fa      	adds	r2, r7, r3
 8008630:	687b      	ldr	r3, [r7, #4]
 8008632:	2106      	movs	r1, #6
 8008634:	0018      	movs	r0, r3
 8008636:	f000 fbef 	bl	8008e18 <VL53L1_GetSequenceStepEnable>
 800863a:	0003      	movs	r3, r0
 800863c:	7023      	strb	r3, [r4, #0]
			VL53L1_SEQUENCESTEP_MM2, &Mm2Enabled);
	}

	if (Status == VL53L1_ERROR_NONE)
 800863e:	232f      	movs	r3, #47	; 0x2f
 8008640:	18fb      	adds	r3, r7, r3
 8008642:	781b      	ldrb	r3, [r3, #0]
 8008644:	b25b      	sxtb	r3, r3
 8008646:	2b00      	cmp	r3, #0
 8008648:	d10c      	bne.n	8008664 <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0x90>
		Status = VL53L1_get_timeouts_us(Dev,
 800864a:	232f      	movs	r3, #47	; 0x2f
 800864c:	18fc      	adds	r4, r7, r3
 800864e:	2314      	movs	r3, #20
 8008650:	18fb      	adds	r3, r7, r3
 8008652:	2210      	movs	r2, #16
 8008654:	18ba      	adds	r2, r7, r2
 8008656:	210c      	movs	r1, #12
 8008658:	1879      	adds	r1, r7, r1
 800865a:	6878      	ldr	r0, [r7, #4]
 800865c:	f001 f9cd 	bl	80099fa <VL53L1_get_timeouts_us>
 8008660:	0003      	movs	r3, r0
 8008662:	7023      	strb	r3, [r4, #0]
			&PhaseCalTimeoutUs,
			&MmTimeoutUs,
			&TimingBudget);

	if (Status == VL53L1_ERROR_NONE) {
 8008664:	232f      	movs	r3, #47	; 0x2f
 8008666:	18fb      	adds	r3, r7, r3
 8008668:	781b      	ldrb	r3, [r3, #0]
 800866a:	b25b      	sxtb	r3, r3
 800866c:	2b00      	cmp	r3, #0
 800866e:	d000      	beq.n	8008672 <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0x9e>
 8008670:	e091      	b.n	8008796 <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0x1c2>
		PresetMode = VL53L1DevDataGet(Dev, CurrentParameters.PresetMode);
 8008672:	201b      	movs	r0, #27
 8008674:	183b      	adds	r3, r7, r0
 8008676:	6879      	ldr	r1, [r7, #4]
 8008678:	22df      	movs	r2, #223	; 0xdf
 800867a:	0092      	lsls	r2, r2, #2
 800867c:	5c8a      	ldrb	r2, [r1, r2]
 800867e:	701a      	strb	r2, [r3, #0]

		TimingGuard = 0;
 8008680:	2300      	movs	r3, #0
 8008682:	62bb      	str	r3, [r7, #40]	; 0x28
		divisor = 1;
 8008684:	2301      	movs	r3, #1
 8008686:	627b      	str	r3, [r7, #36]	; 0x24
		switch (PresetMode) {
 8008688:	183b      	adds	r3, r7, r0
 800868a:	781b      	ldrb	r3, [r3, #0]
 800868c:	2b04      	cmp	r3, #4
 800868e:	d004      	beq.n	800869a <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0xc6>
 8008690:	2b08      	cmp	r3, #8
 8008692:	d028      	beq.n	80086e6 <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0x112>
 8008694:	2b03      	cmp	r3, #3
 8008696:	d011      	beq.n	80086bc <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0xe8>
 8008698:	e043      	b.n	8008722 <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0x14e>
		case VL53L1_PRESETMODE_LITE_RANGING:
			if ((Mm1Enabled == 1) || (Mm2Enabled == 1))
 800869a:	231a      	movs	r3, #26
 800869c:	18fb      	adds	r3, r7, r3
 800869e:	781b      	ldrb	r3, [r3, #0]
 80086a0:	2b01      	cmp	r3, #1
 80086a2:	d004      	beq.n	80086ae <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0xda>
 80086a4:	2319      	movs	r3, #25
 80086a6:	18fb      	adds	r3, r7, r3
 80086a8:	781b      	ldrb	r3, [r3, #0]
 80086aa:	2b01      	cmp	r3, #1
 80086ac:	d102      	bne.n	80086b4 <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0xe0>
				TimingGuard = 5000;
 80086ae:	4b45      	ldr	r3, [pc, #276]	; (80087c4 <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0x1f0>)
 80086b0:	62bb      	str	r3, [r7, #40]	; 0x28
			else
				TimingGuard = 1000;
		break;
 80086b2:	e03a      	b.n	800872a <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0x156>
				TimingGuard = 1000;
 80086b4:	23fa      	movs	r3, #250	; 0xfa
 80086b6:	009b      	lsls	r3, r3, #2
 80086b8:	62bb      	str	r3, [r7, #40]	; 0x28
		break;
 80086ba:	e036      	b.n	800872a <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0x156>

		case VL53L1_PRESETMODE_AUTONOMOUS:
			FDAMaxTimingBudgetUs *= 2;
 80086bc:	69fb      	ldr	r3, [r7, #28]
 80086be:	005b      	lsls	r3, r3, #1
 80086c0:	61fb      	str	r3, [r7, #28]
			if ((Mm1Enabled == 1) || (Mm2Enabled == 1))
 80086c2:	231a      	movs	r3, #26
 80086c4:	18fb      	adds	r3, r7, r3
 80086c6:	781b      	ldrb	r3, [r3, #0]
 80086c8:	2b01      	cmp	r3, #1
 80086ca:	d004      	beq.n	80086d6 <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0x102>
 80086cc:	2319      	movs	r3, #25
 80086ce:	18fb      	adds	r3, r7, r3
 80086d0:	781b      	ldrb	r3, [r3, #0]
 80086d2:	2b01      	cmp	r3, #1
 80086d4:	d102      	bne.n	80086dc <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0x108>
				TimingGuard = 26600;
 80086d6:	4b3c      	ldr	r3, [pc, #240]	; (80087c8 <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0x1f4>)
 80086d8:	62bb      	str	r3, [r7, #40]	; 0x28
 80086da:	e001      	b.n	80086e0 <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0x10c>
			else
				TimingGuard = 21600;
 80086dc:	4b3b      	ldr	r3, [pc, #236]	; (80087cc <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0x1f8>)
 80086de:	62bb      	str	r3, [r7, #40]	; 0x28
			divisor = 2;
 80086e0:	2302      	movs	r3, #2
 80086e2:	627b      	str	r3, [r7, #36]	; 0x24
		break;
 80086e4:	e021      	b.n	800872a <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0x156>

		case VL53L1_PRESETMODE_LOWPOWER_AUTONOMOUS:
			FDAMaxTimingBudgetUs *= 2;
 80086e6:	69fb      	ldr	r3, [r7, #28]
 80086e8:	005b      	lsls	r3, r3, #1
 80086ea:	61fb      	str	r3, [r7, #28]
			vhv = LOWPOWER_AUTO_VHV_LOOP_DURATION_US;
 80086ec:	23f5      	movs	r3, #245	; 0xf5
 80086ee:	623b      	str	r3, [r7, #32]
			VL53L1_get_tuning_parm(Dev,
 80086f0:	2308      	movs	r3, #8
 80086f2:	18fa      	adds	r2, r7, r3
 80086f4:	4936      	ldr	r1, [pc, #216]	; (80087d0 <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0x1fc>)
 80086f6:	687b      	ldr	r3, [r7, #4]
 80086f8:	0018      	movs	r0, r3
 80086fa:	f002 fbab 	bl	800ae54 <VL53L1_get_tuning_parm>
				VL53L1_TUNINGPARM_LOWPOWERAUTO_VHV_LOOP_BOUND,
				&vhv_loops);
			if (vhv_loops > 0) {
 80086fe:	68bb      	ldr	r3, [r7, #8]
 8008700:	2b00      	cmp	r3, #0
 8008702:	dd06      	ble.n	8008712 <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0x13e>
				vhv += vhv_loops *
 8008704:	68bb      	ldr	r3, [r7, #8]
 8008706:	22f5      	movs	r2, #245	; 0xf5
 8008708:	4353      	muls	r3, r2
 800870a:	001a      	movs	r2, r3
 800870c:	6a3b      	ldr	r3, [r7, #32]
 800870e:	189b      	adds	r3, r3, r2
 8008710:	623b      	str	r3, [r7, #32]
					LOWPOWER_AUTO_VHV_LOOP_DURATION_US;
			}
			TimingGuard = LOWPOWER_AUTO_OVERHEAD_BEFORE_A_RANGING +
 8008712:	6a3b      	ldr	r3, [r7, #32]
 8008714:	4a2f      	ldr	r2, [pc, #188]	; (80087d4 <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0x200>)
 8008716:	4694      	mov	ip, r2
 8008718:	4463      	add	r3, ip
 800871a:	62bb      	str	r3, [r7, #40]	; 0x28
				LOWPOWER_AUTO_OVERHEAD_BETWEEN_A_B_RANGING +
				vhv;
			divisor = 2;
 800871c:	2302      	movs	r3, #2
 800871e:	627b      	str	r3, [r7, #36]	; 0x24
		break;
 8008720:	e003      	b.n	800872a <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0x156>

		default:
			/* Unsupported mode */
			Status = VL53L1_ERROR_MODE_NOT_SUPPORTED;
 8008722:	232f      	movs	r3, #47	; 0x2f
 8008724:	18fb      	adds	r3, r7, r3
 8008726:	22f8      	movs	r2, #248	; 0xf8
 8008728:	701a      	strb	r2, [r3, #0]
		}

		if (MeasurementTimingBudgetMicroSeconds <= TimingGuard)
 800872a:	683a      	ldr	r2, [r7, #0]
 800872c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800872e:	429a      	cmp	r2, r3
 8008730:	d804      	bhi.n	800873c <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0x168>
			Status = VL53L1_ERROR_INVALID_PARAMS;
 8008732:	232f      	movs	r3, #47	; 0x2f
 8008734:	18fb      	adds	r3, r7, r3
 8008736:	22fc      	movs	r2, #252	; 0xfc
 8008738:	701a      	strb	r2, [r3, #0]
 800873a:	e003      	b.n	8008744 <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0x170>
		else {
			TimingBudget = (MeasurementTimingBudgetMicroSeconds
					- TimingGuard);
 800873c:	683a      	ldr	r2, [r7, #0]
 800873e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008740:	1ad3      	subs	r3, r2, r3
			TimingBudget = (MeasurementTimingBudgetMicroSeconds
 8008742:	617b      	str	r3, [r7, #20]
		}

		if (Status == VL53L1_ERROR_NONE) {
 8008744:	232f      	movs	r3, #47	; 0x2f
 8008746:	18fb      	adds	r3, r7, r3
 8008748:	781b      	ldrb	r3, [r3, #0]
 800874a:	b25b      	sxtb	r3, r3
 800874c:	2b00      	cmp	r3, #0
 800874e:	d122      	bne.n	8008796 <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0x1c2>
			if (TimingBudget > FDAMaxTimingBudgetUs)
 8008750:	697b      	ldr	r3, [r7, #20]
 8008752:	69fa      	ldr	r2, [r7, #28]
 8008754:	429a      	cmp	r2, r3
 8008756:	d204      	bcs.n	8008762 <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0x18e>
				Status = VL53L1_ERROR_INVALID_PARAMS;
 8008758:	232f      	movs	r3, #47	; 0x2f
 800875a:	18fb      	adds	r3, r7, r3
 800875c:	22fc      	movs	r2, #252	; 0xfc
 800875e:	701a      	strb	r2, [r3, #0]
 8008760:	e010      	b.n	8008784 <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0x1b0>
			else {
				TimingBudget /= divisor;
 8008762:	697b      	ldr	r3, [r7, #20]
 8008764:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8008766:	0018      	movs	r0, r3
 8008768:	f7f7 fce0 	bl	800012c <__udivsi3>
 800876c:	0003      	movs	r3, r0
 800876e:	617b      	str	r3, [r7, #20]
				Status = VL53L1_set_timeouts_us(
 8008770:	68f9      	ldr	r1, [r7, #12]
 8008772:	693a      	ldr	r2, [r7, #16]
 8008774:	697b      	ldr	r3, [r7, #20]
 8008776:	202f      	movs	r0, #47	; 0x2f
 8008778:	183c      	adds	r4, r7, r0
 800877a:	6878      	ldr	r0, [r7, #4]
 800877c:	f001 f8f8 	bl	8009970 <VL53L1_set_timeouts_us>
 8008780:	0003      	movs	r3, r0
 8008782:	7023      	strb	r3, [r4, #0]
					PhaseCalTimeoutUs,
					MmTimeoutUs,
					TimingBudget);
			}

			if (Status == VL53L1_ERROR_NONE)
 8008784:	232f      	movs	r3, #47	; 0x2f
 8008786:	18fb      	adds	r3, r7, r3
 8008788:	781b      	ldrb	r3, [r3, #0]
 800878a:	b25b      	sxtb	r3, r3
 800878c:	2b00      	cmp	r3, #0
 800878e:	d102      	bne.n	8008796 <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0x1c2>
				VL53L1DevDataSet(Dev,
 8008790:	697a      	ldr	r2, [r7, #20]
 8008792:	687b      	ldr	r3, [r7, #4]
 8008794:	611a      	str	r2, [r3, #16]
					LLData.range_config_timeout_us,
					TimingBudget);
		}
	}
	if (Status == VL53L1_ERROR_NONE) {
 8008796:	232f      	movs	r3, #47	; 0x2f
 8008798:	18fb      	adds	r3, r7, r3
 800879a:	781b      	ldrb	r3, [r3, #0]
 800879c:	b25b      	sxtb	r3, r3
 800879e:	2b00      	cmp	r3, #0
 80087a0:	d104      	bne.n	80087ac <VL53L1_SetMeasurementTimingBudgetMicroSeconds+0x1d8>
		VL53L1DevDataSet(Dev,
 80087a2:	687a      	ldr	r2, [r7, #4]
 80087a4:	23e0      	movs	r3, #224	; 0xe0
 80087a6:	009b      	lsls	r3, r3, #2
 80087a8:	6839      	ldr	r1, [r7, #0]
 80087aa:	50d1      	str	r1, [r2, r3]
			CurrentParameters.MeasurementTimingBudgetMicroSeconds,
			MeasurementTimingBudgetMicroSeconds);
	}

	LOG_FUNCTION_END(Status);
	return Status;
 80087ac:	232f      	movs	r3, #47	; 0x2f
 80087ae:	18fb      	adds	r3, r7, r3
 80087b0:	781b      	ldrb	r3, [r3, #0]
 80087b2:	b25b      	sxtb	r3, r3
}
 80087b4:	0018      	movs	r0, r3
 80087b6:	46bd      	mov	sp, r7
 80087b8:	b00d      	add	sp, #52	; 0x34
 80087ba:	bd90      	pop	{r4, r7, pc}
 80087bc:	00086470 	.word	0x00086470
 80087c0:	00989680 	.word	0x00989680
 80087c4:	00001388 	.word	0x00001388
 80087c8:	000067e8 	.word	0x000067e8
 80087cc:	00005460 	.word	0x00005460
 80087d0:	00008036 	.word	0x00008036
 80087d4:	00000ddc 	.word	0x00000ddc

080087d8 <VL53L1_GetMeasurementTimingBudgetMicroSeconds>:


VL53L1_Error VL53L1_GetMeasurementTimingBudgetMicroSeconds(VL53L1_DEV Dev,
	uint32_t *pMeasurementTimingBudgetMicroSeconds)
{
 80087d8:	b590      	push	{r4, r7, lr}
 80087da:	b08d      	sub	sp, #52	; 0x34
 80087dc:	af00      	add	r7, sp, #0
 80087de:	6078      	str	r0, [r7, #4]
 80087e0:	6039      	str	r1, [r7, #0]
	VL53L1_Error Status = VL53L1_ERROR_NONE;
 80087e2:	212f      	movs	r1, #47	; 0x2f
 80087e4:	187b      	adds	r3, r7, r1
 80087e6:	2200      	movs	r2, #0
 80087e8:	701a      	strb	r2, [r3, #0]
	uint8_t Mm1Enabled = 0;
 80087ea:	231b      	movs	r3, #27
 80087ec:	18fb      	adds	r3, r7, r3
 80087ee:	2200      	movs	r2, #0
 80087f0:	701a      	strb	r2, [r3, #0]
	uint8_t Mm2Enabled = 0;
 80087f2:	231a      	movs	r3, #26
 80087f4:	18fb      	adds	r3, r7, r3
 80087f6:	2200      	movs	r2, #0
 80087f8:	701a      	strb	r2, [r3, #0]
	uint32_t  MmTimeoutUs = 0;
 80087fa:	2300      	movs	r3, #0
 80087fc:	617b      	str	r3, [r7, #20]
	uint32_t  RangeTimeoutUs = 0;
 80087fe:	2300      	movs	r3, #0
 8008800:	613b      	str	r3, [r7, #16]
	uint32_t  MeasTimingBdg = 0;
 8008802:	2300      	movs	r3, #0
 8008804:	62bb      	str	r3, [r7, #40]	; 0x28
	uint32_t PhaseCalTimeoutUs = 0;
 8008806:	2300      	movs	r3, #0
 8008808:	60fb      	str	r3, [r7, #12]
	uint32_t vhv;
	int32_t vhv_loops;

	LOG_FUNCTION_START("");

	*pMeasurementTimingBudgetMicroSeconds = 0;
 800880a:	683b      	ldr	r3, [r7, #0]
 800880c:	2200      	movs	r2, #0
 800880e:	601a      	str	r2, [r3, #0]

	if (Status == VL53L1_ERROR_NONE)
 8008810:	187b      	adds	r3, r7, r1
 8008812:	781b      	ldrb	r3, [r3, #0]
 8008814:	b25b      	sxtb	r3, r3
 8008816:	2b00      	cmp	r3, #0
 8008818:	d10a      	bne.n	8008830 <VL53L1_GetMeasurementTimingBudgetMicroSeconds+0x58>
		Status = VL53L1_GetSequenceStepEnable(Dev,
 800881a:	232f      	movs	r3, #47	; 0x2f
 800881c:	18fc      	adds	r4, r7, r3
 800881e:	231b      	movs	r3, #27
 8008820:	18fa      	adds	r2, r7, r3
 8008822:	687b      	ldr	r3, [r7, #4]
 8008824:	2105      	movs	r1, #5
 8008826:	0018      	movs	r0, r3
 8008828:	f000 faf6 	bl	8008e18 <VL53L1_GetSequenceStepEnable>
 800882c:	0003      	movs	r3, r0
 800882e:	7023      	strb	r3, [r4, #0]
			VL53L1_SEQUENCESTEP_MM1, &Mm1Enabled);

	if (Status == VL53L1_ERROR_NONE)
 8008830:	232f      	movs	r3, #47	; 0x2f
 8008832:	18fb      	adds	r3, r7, r3
 8008834:	781b      	ldrb	r3, [r3, #0]
 8008836:	b25b      	sxtb	r3, r3
 8008838:	2b00      	cmp	r3, #0
 800883a:	d10a      	bne.n	8008852 <VL53L1_GetMeasurementTimingBudgetMicroSeconds+0x7a>
		Status = VL53L1_GetSequenceStepEnable(Dev,
 800883c:	232f      	movs	r3, #47	; 0x2f
 800883e:	18fc      	adds	r4, r7, r3
 8008840:	231a      	movs	r3, #26
 8008842:	18fa      	adds	r2, r7, r3
 8008844:	687b      	ldr	r3, [r7, #4]
 8008846:	2106      	movs	r1, #6
 8008848:	0018      	movs	r0, r3
 800884a:	f000 fae5 	bl	8008e18 <VL53L1_GetSequenceStepEnable>
 800884e:	0003      	movs	r3, r0
 8008850:	7023      	strb	r3, [r4, #0]
			VL53L1_SEQUENCESTEP_MM2, &Mm2Enabled);

	if (Status == VL53L1_ERROR_NONE)
 8008852:	232f      	movs	r3, #47	; 0x2f
 8008854:	18fb      	adds	r3, r7, r3
 8008856:	781b      	ldrb	r3, [r3, #0]
 8008858:	b25b      	sxtb	r3, r3
 800885a:	2b00      	cmp	r3, #0
 800885c:	d10c      	bne.n	8008878 <VL53L1_GetMeasurementTimingBudgetMicroSeconds+0xa0>
		Status = VL53L1_get_timeouts_us(Dev,
 800885e:	232f      	movs	r3, #47	; 0x2f
 8008860:	18fc      	adds	r4, r7, r3
 8008862:	2310      	movs	r3, #16
 8008864:	18fb      	adds	r3, r7, r3
 8008866:	2214      	movs	r2, #20
 8008868:	18ba      	adds	r2, r7, r2
 800886a:	210c      	movs	r1, #12
 800886c:	1879      	adds	r1, r7, r1
 800886e:	6878      	ldr	r0, [r7, #4]
 8008870:	f001 f8c3 	bl	80099fa <VL53L1_get_timeouts_us>
 8008874:	0003      	movs	r3, r0
 8008876:	7023      	strb	r3, [r4, #0]
			&PhaseCalTimeoutUs,
			&MmTimeoutUs,
			&RangeTimeoutUs);

	if (Status == VL53L1_ERROR_NONE) {
 8008878:	232f      	movs	r3, #47	; 0x2f
 800887a:	18fb      	adds	r3, r7, r3
 800887c:	781b      	ldrb	r3, [r3, #0]
 800887e:	b25b      	sxtb	r3, r3
 8008880:	2b00      	cmp	r3, #0
 8008882:	d161      	bne.n	8008948 <VL53L1_GetMeasurementTimingBudgetMicroSeconds+0x170>
		PresetMode = VL53L1DevDataGet(Dev, CurrentParameters.PresetMode);
 8008884:	2023      	movs	r0, #35	; 0x23
 8008886:	183b      	adds	r3, r7, r0
 8008888:	6879      	ldr	r1, [r7, #4]
 800888a:	22df      	movs	r2, #223	; 0xdf
 800888c:	0092      	lsls	r2, r2, #2
 800888e:	5c8a      	ldrb	r2, [r1, r2]
 8008890:	701a      	strb	r2, [r3, #0]

		switch (PresetMode) {
 8008892:	183b      	adds	r3, r7, r0
 8008894:	781b      	ldrb	r3, [r3, #0]
 8008896:	2b04      	cmp	r3, #4
 8008898:	d004      	beq.n	80088a4 <VL53L1_GetMeasurementTimingBudgetMicroSeconds+0xcc>
 800889a:	2b08      	cmp	r3, #8
 800889c:	d031      	beq.n	8008902 <VL53L1_GetMeasurementTimingBudgetMicroSeconds+0x12a>
 800889e:	2b03      	cmp	r3, #3
 80088a0:	d017      	beq.n	80088d2 <VL53L1_GetMeasurementTimingBudgetMicroSeconds+0xfa>
 80088a2:	e04c      	b.n	800893e <VL53L1_GetMeasurementTimingBudgetMicroSeconds+0x166>
		case VL53L1_PRESETMODE_LITE_RANGING:
			if ((Mm1Enabled == 1) || (Mm2Enabled == 1))
 80088a4:	231b      	movs	r3, #27
 80088a6:	18fb      	adds	r3, r7, r3
 80088a8:	781b      	ldrb	r3, [r3, #0]
 80088aa:	2b01      	cmp	r3, #1
 80088ac:	d004      	beq.n	80088b8 <VL53L1_GetMeasurementTimingBudgetMicroSeconds+0xe0>
 80088ae:	231a      	movs	r3, #26
 80088b0:	18fb      	adds	r3, r7, r3
 80088b2:	781b      	ldrb	r3, [r3, #0]
 80088b4:	2b01      	cmp	r3, #1
 80088b6:	d105      	bne.n	80088c4 <VL53L1_GetMeasurementTimingBudgetMicroSeconds+0xec>
				MeasTimingBdg = RangeTimeoutUs + 5000;
 80088b8:	693b      	ldr	r3, [r7, #16]
 80088ba:	4a2c      	ldr	r2, [pc, #176]	; (800896c <VL53L1_GetMeasurementTimingBudgetMicroSeconds+0x194>)
 80088bc:	4694      	mov	ip, r2
 80088be:	4463      	add	r3, ip
 80088c0:	62bb      	str	r3, [r7, #40]	; 0x28
			else
				MeasTimingBdg = RangeTimeoutUs + 1000;

		break;
 80088c2:	e042      	b.n	800894a <VL53L1_GetMeasurementTimingBudgetMicroSeconds+0x172>
				MeasTimingBdg = RangeTimeoutUs + 1000;
 80088c4:	693b      	ldr	r3, [r7, #16]
 80088c6:	22fa      	movs	r2, #250	; 0xfa
 80088c8:	0092      	lsls	r2, r2, #2
 80088ca:	4694      	mov	ip, r2
 80088cc:	4463      	add	r3, ip
 80088ce:	62bb      	str	r3, [r7, #40]	; 0x28
		break;
 80088d0:	e03b      	b.n	800894a <VL53L1_GetMeasurementTimingBudgetMicroSeconds+0x172>

		case VL53L1_PRESETMODE_AUTONOMOUS:
			if ((Mm1Enabled == 1) || (Mm2Enabled == 1))
 80088d2:	231b      	movs	r3, #27
 80088d4:	18fb      	adds	r3, r7, r3
 80088d6:	781b      	ldrb	r3, [r3, #0]
 80088d8:	2b01      	cmp	r3, #1
 80088da:	d004      	beq.n	80088e6 <VL53L1_GetMeasurementTimingBudgetMicroSeconds+0x10e>
 80088dc:	231a      	movs	r3, #26
 80088de:	18fb      	adds	r3, r7, r3
 80088e0:	781b      	ldrb	r3, [r3, #0]
 80088e2:	2b01      	cmp	r3, #1
 80088e4:	d106      	bne.n	80088f4 <VL53L1_GetMeasurementTimingBudgetMicroSeconds+0x11c>
				MeasTimingBdg = 2 * RangeTimeoutUs + 26600;
 80088e6:	693b      	ldr	r3, [r7, #16]
 80088e8:	4a21      	ldr	r2, [pc, #132]	; (8008970 <VL53L1_GetMeasurementTimingBudgetMicroSeconds+0x198>)
 80088ea:	4694      	mov	ip, r2
 80088ec:	4463      	add	r3, ip
 80088ee:	005b      	lsls	r3, r3, #1
 80088f0:	62bb      	str	r3, [r7, #40]	; 0x28
			else
				MeasTimingBdg = 2 * RangeTimeoutUs + 21600;

		break;
 80088f2:	e02a      	b.n	800894a <VL53L1_GetMeasurementTimingBudgetMicroSeconds+0x172>
				MeasTimingBdg = 2 * RangeTimeoutUs + 21600;
 80088f4:	693b      	ldr	r3, [r7, #16]
 80088f6:	4a1f      	ldr	r2, [pc, #124]	; (8008974 <VL53L1_GetMeasurementTimingBudgetMicroSeconds+0x19c>)
 80088f8:	4694      	mov	ip, r2
 80088fa:	4463      	add	r3, ip
 80088fc:	005b      	lsls	r3, r3, #1
 80088fe:	62bb      	str	r3, [r7, #40]	; 0x28
		break;
 8008900:	e023      	b.n	800894a <VL53L1_GetMeasurementTimingBudgetMicroSeconds+0x172>

		case VL53L1_PRESETMODE_LOWPOWER_AUTONOMOUS:
			vhv = LOWPOWER_AUTO_VHV_LOOP_DURATION_US;
 8008902:	23f5      	movs	r3, #245	; 0xf5
 8008904:	627b      	str	r3, [r7, #36]	; 0x24
			VL53L1_get_tuning_parm(Dev,
 8008906:	2308      	movs	r3, #8
 8008908:	18fa      	adds	r2, r7, r3
 800890a:	491b      	ldr	r1, [pc, #108]	; (8008978 <VL53L1_GetMeasurementTimingBudgetMicroSeconds+0x1a0>)
 800890c:	687b      	ldr	r3, [r7, #4]
 800890e:	0018      	movs	r0, r3
 8008910:	f002 faa0 	bl	800ae54 <VL53L1_get_tuning_parm>
				VL53L1_TUNINGPARM_LOWPOWERAUTO_VHV_LOOP_BOUND,
				&vhv_loops);
			if (vhv_loops > 0) {
 8008914:	68bb      	ldr	r3, [r7, #8]
 8008916:	2b00      	cmp	r3, #0
 8008918:	dd06      	ble.n	8008928 <VL53L1_GetMeasurementTimingBudgetMicroSeconds+0x150>
				vhv += vhv_loops *
 800891a:	68bb      	ldr	r3, [r7, #8]
 800891c:	22f5      	movs	r2, #245	; 0xf5
 800891e:	4353      	muls	r3, r2
 8008920:	001a      	movs	r2, r3
 8008922:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008924:	189b      	adds	r3, r3, r2
 8008926:	627b      	str	r3, [r7, #36]	; 0x24
					LOWPOWER_AUTO_VHV_LOOP_DURATION_US;
			}
			TimingGuard = LOWPOWER_AUTO_OVERHEAD_BEFORE_A_RANGING +
 8008928:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800892a:	4a14      	ldr	r2, [pc, #80]	; (800897c <VL53L1_GetMeasurementTimingBudgetMicroSeconds+0x1a4>)
 800892c:	4694      	mov	ip, r2
 800892e:	4463      	add	r3, ip
 8008930:	61fb      	str	r3, [r7, #28]
				LOWPOWER_AUTO_OVERHEAD_BETWEEN_A_B_RANGING +
				vhv;
			MeasTimingBdg = 2 * RangeTimeoutUs + TimingGuard;
 8008932:	693b      	ldr	r3, [r7, #16]
 8008934:	005b      	lsls	r3, r3, #1
 8008936:	69fa      	ldr	r2, [r7, #28]
 8008938:	18d3      	adds	r3, r2, r3
 800893a:	62bb      	str	r3, [r7, #40]	; 0x28
		break;
 800893c:	e005      	b.n	800894a <VL53L1_GetMeasurementTimingBudgetMicroSeconds+0x172>

		default:
			/* Unsupported mode */
			Status = VL53L1_ERROR_MODE_NOT_SUPPORTED;
 800893e:	232f      	movs	r3, #47	; 0x2f
 8008940:	18fb      	adds	r3, r7, r3
 8008942:	22f8      	movs	r2, #248	; 0xf8
 8008944:	701a      	strb	r2, [r3, #0]
 8008946:	e000      	b.n	800894a <VL53L1_GetMeasurementTimingBudgetMicroSeconds+0x172>
		}
	}
 8008948:	46c0      	nop			; (mov r8, r8)
	if (Status == VL53L1_ERROR_NONE)
 800894a:	232f      	movs	r3, #47	; 0x2f
 800894c:	18fb      	adds	r3, r7, r3
 800894e:	781b      	ldrb	r3, [r3, #0]
 8008950:	b25b      	sxtb	r3, r3
 8008952:	2b00      	cmp	r3, #0
 8008954:	d102      	bne.n	800895c <VL53L1_GetMeasurementTimingBudgetMicroSeconds+0x184>
		*pMeasurementTimingBudgetMicroSeconds = MeasTimingBdg;
 8008956:	683b      	ldr	r3, [r7, #0]
 8008958:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800895a:	601a      	str	r2, [r3, #0]

	LOG_FUNCTION_END(Status);
	return Status;
 800895c:	232f      	movs	r3, #47	; 0x2f
 800895e:	18fb      	adds	r3, r7, r3
 8008960:	781b      	ldrb	r3, [r3, #0]
 8008962:	b25b      	sxtb	r3, r3
}
 8008964:	0018      	movs	r0, r3
 8008966:	46bd      	mov	sp, r7
 8008968:	b00d      	add	sp, #52	; 0x34
 800896a:	bd90      	pop	{r4, r7, pc}
 800896c:	00001388 	.word	0x00001388
 8008970:	000033f4 	.word	0x000033f4
 8008974:	00002a30 	.word	0x00002a30
 8008978:	00008036 	.word	0x00008036
 800897c:	00000ddc 	.word	0x00000ddc

08008980 <VL53L1_SetInterMeasurementPeriodMilliSeconds>:



VL53L1_Error VL53L1_SetInterMeasurementPeriodMilliSeconds(VL53L1_DEV Dev,
	uint32_t InterMeasurementPeriodMilliSeconds)
{
 8008980:	b5b0      	push	{r4, r5, r7, lr}
 8008982:	b084      	sub	sp, #16
 8008984:	af00      	add	r7, sp, #0
 8008986:	6078      	str	r0, [r7, #4]
 8008988:	6039      	str	r1, [r7, #0]
	VL53L1_Error Status = VL53L1_ERROR_NONE;
 800898a:	240f      	movs	r4, #15
 800898c:	193b      	adds	r3, r7, r4
 800898e:	2200      	movs	r2, #0
 8008990:	701a      	strb	r2, [r3, #0]
	uint32_t adjustedIMP;

	LOG_FUNCTION_START("");

	/* Fix for Ticket 468205 actual measurement period shorter than set */
	adjustedIMP = InterMeasurementPeriodMilliSeconds;
 8008992:	683b      	ldr	r3, [r7, #0]
 8008994:	60bb      	str	r3, [r7, #8]
	adjustedIMP += (adjustedIMP * 64) / 1000;
 8008996:	68bb      	ldr	r3, [r7, #8]
 8008998:	019a      	lsls	r2, r3, #6
 800899a:	23fa      	movs	r3, #250	; 0xfa
 800899c:	0099      	lsls	r1, r3, #2
 800899e:	0010      	movs	r0, r2
 80089a0:	f7f7 fbc4 	bl	800012c <__udivsi3>
 80089a4:	0003      	movs	r3, r0
 80089a6:	001a      	movs	r2, r3
 80089a8:	68bb      	ldr	r3, [r7, #8]
 80089aa:	189b      	adds	r3, r3, r2
 80089ac:	60bb      	str	r3, [r7, #8]
	/* End of fix for Ticket 468205 */
	Status = VL53L1_set_inter_measurement_period_ms(Dev,
 80089ae:	0025      	movs	r5, r4
 80089b0:	193c      	adds	r4, r7, r4
 80089b2:	68ba      	ldr	r2, [r7, #8]
 80089b4:	687b      	ldr	r3, [r7, #4]
 80089b6:	0011      	movs	r1, r2
 80089b8:	0018      	movs	r0, r3
 80089ba:	f000 ff75 	bl	80098a8 <VL53L1_set_inter_measurement_period_ms>
 80089be:	0003      	movs	r3, r0
 80089c0:	7023      	strb	r3, [r4, #0]
			adjustedIMP);

	LOG_FUNCTION_END(Status);
	return Status;
 80089c2:	002c      	movs	r4, r5
 80089c4:	193b      	adds	r3, r7, r4
 80089c6:	781b      	ldrb	r3, [r3, #0]
 80089c8:	b25b      	sxtb	r3, r3
}
 80089ca:	0018      	movs	r0, r3
 80089cc:	46bd      	mov	sp, r7
 80089ce:	b004      	add	sp, #16
 80089d0:	bdb0      	pop	{r4, r5, r7, pc}

080089d2 <VL53L1_GetInterMeasurementPeriodMilliSeconds>:

VL53L1_Error VL53L1_GetInterMeasurementPeriodMilliSeconds(VL53L1_DEV Dev,
	uint32_t *pInterMeasurementPeriodMilliSeconds)
{
 80089d2:	b5b0      	push	{r4, r5, r7, lr}
 80089d4:	b084      	sub	sp, #16
 80089d6:	af00      	add	r7, sp, #0
 80089d8:	6078      	str	r0, [r7, #4]
 80089da:	6039      	str	r1, [r7, #0]
	VL53L1_Error Status = VL53L1_ERROR_NONE;
 80089dc:	250f      	movs	r5, #15
 80089de:	197b      	adds	r3, r7, r5
 80089e0:	2200      	movs	r2, #0
 80089e2:	701a      	strb	r2, [r3, #0]
	uint32_t adjustedIMP;

	LOG_FUNCTION_START("");

	Status = VL53L1_get_inter_measurement_period_ms(Dev, &adjustedIMP);
 80089e4:	197c      	adds	r4, r7, r5
 80089e6:	2308      	movs	r3, #8
 80089e8:	18fa      	adds	r2, r7, r3
 80089ea:	687b      	ldr	r3, [r7, #4]
 80089ec:	0011      	movs	r1, r2
 80089ee:	0018      	movs	r0, r3
 80089f0:	f000 ff8c 	bl	800990c <VL53L1_get_inter_measurement_period_ms>
 80089f4:	0003      	movs	r3, r0
 80089f6:	7023      	strb	r3, [r4, #0]
	/* Fix for Ticket 468205 actual measurement period shorter than set */
	adjustedIMP -= (adjustedIMP * 64) / 1000;
 80089f8:	68bc      	ldr	r4, [r7, #8]
 80089fa:	68bb      	ldr	r3, [r7, #8]
 80089fc:	019a      	lsls	r2, r3, #6
 80089fe:	23fa      	movs	r3, #250	; 0xfa
 8008a00:	0099      	lsls	r1, r3, #2
 8008a02:	0010      	movs	r0, r2
 8008a04:	f7f7 fb92 	bl	800012c <__udivsi3>
 8008a08:	0003      	movs	r3, r0
 8008a0a:	1ae3      	subs	r3, r4, r3
 8008a0c:	60bb      	str	r3, [r7, #8]
	*pInterMeasurementPeriodMilliSeconds = adjustedIMP;
 8008a0e:	68ba      	ldr	r2, [r7, #8]
 8008a10:	683b      	ldr	r3, [r7, #0]
 8008a12:	601a      	str	r2, [r3, #0]
	/* End of fix for Ticket 468205 */

	LOG_FUNCTION_END(Status);
	return Status;
 8008a14:	197b      	adds	r3, r7, r5
 8008a16:	781b      	ldrb	r3, [r3, #0]
 8008a18:	b25b      	sxtb	r3, r3
}
 8008a1a:	0018      	movs	r0, r3
 8008a1c:	46bd      	mov	sp, r7
 8008a1e:	b004      	add	sp, #16
 8008a20:	bdb0      	pop	{r4, r5, r7, pc}

08008a22 <SetLimitValue>:
	return Status;
}

static VL53L1_Error SetLimitValue(VL53L1_DEV Dev, uint16_t LimitCheckId,
		FixPoint1616_t value)
{
 8008a22:	b580      	push	{r7, lr}
 8008a24:	b086      	sub	sp, #24
 8008a26:	af00      	add	r7, sp, #0
 8008a28:	60f8      	str	r0, [r7, #12]
 8008a2a:	607a      	str	r2, [r7, #4]
 8008a2c:	200a      	movs	r0, #10
 8008a2e:	183b      	adds	r3, r7, r0
 8008a30:	1c0a      	adds	r2, r1, #0
 8008a32:	801a      	strh	r2, [r3, #0]
	VL53L1_Error Status = VL53L1_ERROR_NONE;
 8008a34:	2317      	movs	r3, #23
 8008a36:	18fb      	adds	r3, r7, r3
 8008a38:	2200      	movs	r2, #0
 8008a3a:	701a      	strb	r2, [r3, #0]
	uint16_t tmpuint16; /* temporary variable */

	LOG_FUNCTION_START("");

	switch (LimitCheckId) {
 8008a3c:	183b      	adds	r3, r7, r0
 8008a3e:	881b      	ldrh	r3, [r3, #0]
 8008a40:	2b00      	cmp	r3, #0
 8008a42:	d002      	beq.n	8008a4a <SetLimitValue+0x28>
 8008a44:	2b01      	cmp	r3, #1
 8008a46:	d00d      	beq.n	8008a64 <SetLimitValue+0x42>
 8008a48:	e019      	b.n	8008a7e <SetLimitValue+0x5c>
	case VL53L1_CHECKENABLE_SIGMA_FINAL_RANGE:
		tmpuint16 = VL53L1_FIXPOINT1616TOFIXPOINT142(value);
 8008a4a:	687b      	ldr	r3, [r7, #4]
 8008a4c:	0b9a      	lsrs	r2, r3, #14
 8008a4e:	2114      	movs	r1, #20
 8008a50:	187b      	adds	r3, r7, r1
 8008a52:	801a      	strh	r2, [r3, #0]
		VL53L1_set_lite_sigma_threshold(Dev, tmpuint16);
 8008a54:	187b      	adds	r3, r7, r1
 8008a56:	881a      	ldrh	r2, [r3, #0]
 8008a58:	68fb      	ldr	r3, [r7, #12]
 8008a5a:	0011      	movs	r1, r2
 8008a5c:	0018      	movs	r0, r3
 8008a5e:	f001 fb1d 	bl	800a09c <VL53L1_set_lite_sigma_threshold>
		break;
 8008a62:	e010      	b.n	8008a86 <SetLimitValue+0x64>
	case VL53L1_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE:
		tmpuint16 = VL53L1_FIXPOINT1616TOFIXPOINT97(value);
 8008a64:	687b      	ldr	r3, [r7, #4]
 8008a66:	0a5a      	lsrs	r2, r3, #9
 8008a68:	2114      	movs	r1, #20
 8008a6a:	187b      	adds	r3, r7, r1
 8008a6c:	801a      	strh	r2, [r3, #0]
		VL53L1_set_lite_min_count_rate(Dev, tmpuint16);
 8008a6e:	187b      	adds	r3, r7, r1
 8008a70:	881a      	ldrh	r2, [r3, #0]
 8008a72:	68fb      	ldr	r3, [r7, #12]
 8008a74:	0011      	movs	r1, r2
 8008a76:	0018      	movs	r0, r3
 8008a78:	f001 fb42 	bl	800a100 <VL53L1_set_lite_min_count_rate>
		break;
 8008a7c:	e003      	b.n	8008a86 <SetLimitValue+0x64>
	default:
		Status = VL53L1_ERROR_INVALID_PARAMS;
 8008a7e:	2317      	movs	r3, #23
 8008a80:	18fb      	adds	r3, r7, r3
 8008a82:	22fc      	movs	r2, #252	; 0xfc
 8008a84:	701a      	strb	r2, [r3, #0]
	}

	LOG_FUNCTION_END(Status);
	return Status;
 8008a86:	2317      	movs	r3, #23
 8008a88:	18fb      	adds	r3, r7, r3
 8008a8a:	781b      	ldrb	r3, [r3, #0]
 8008a8c:	b25b      	sxtb	r3, r3
}
 8008a8e:	0018      	movs	r0, r3
 8008a90:	46bd      	mov	sp, r7
 8008a92:	b006      	add	sp, #24
 8008a94:	bd80      	pop	{r7, pc}

08008a96 <VL53L1_SetLimitCheckEnable>:


VL53L1_Error VL53L1_SetLimitCheckEnable(VL53L1_DEV Dev, uint16_t LimitCheckId,
	uint8_t LimitCheckEnable)
{
 8008a96:	b590      	push	{r4, r7, lr}
 8008a98:	b085      	sub	sp, #20
 8008a9a:	af00      	add	r7, sp, #0
 8008a9c:	6078      	str	r0, [r7, #4]
 8008a9e:	0008      	movs	r0, r1
 8008aa0:	0011      	movs	r1, r2
 8008aa2:	1cbb      	adds	r3, r7, #2
 8008aa4:	1c02      	adds	r2, r0, #0
 8008aa6:	801a      	strh	r2, [r3, #0]
 8008aa8:	1c7b      	adds	r3, r7, #1
 8008aaa:	1c0a      	adds	r2, r1, #0
 8008aac:	701a      	strb	r2, [r3, #0]
	VL53L1_Error Status = VL53L1_ERROR_NONE;
 8008aae:	230f      	movs	r3, #15
 8008ab0:	18fb      	adds	r3, r7, r3
 8008ab2:	2200      	movs	r2, #0
 8008ab4:	701a      	strb	r2, [r3, #0]
	FixPoint1616_t TempFix1616 = 0;
 8008ab6:	2300      	movs	r3, #0
 8008ab8:	60bb      	str	r3, [r7, #8]

	LOG_FUNCTION_START("");


	if (LimitCheckId >= VL53L1_CHECKENABLE_NUMBER_OF_CHECKS) {
 8008aba:	1cbb      	adds	r3, r7, #2
 8008abc:	881b      	ldrh	r3, [r3, #0]
 8008abe:	2b01      	cmp	r3, #1
 8008ac0:	d904      	bls.n	8008acc <VL53L1_SetLimitCheckEnable+0x36>
		Status = VL53L1_ERROR_INVALID_PARAMS;
 8008ac2:	230f      	movs	r3, #15
 8008ac4:	18fb      	adds	r3, r7, r3
 8008ac6:	22fc      	movs	r2, #252	; 0xfc
 8008ac8:	701a      	strb	r2, [r3, #0]
 8008aca:	e01a      	b.n	8008b02 <VL53L1_SetLimitCheckEnable+0x6c>
	} else {
		/* TempFix1616 contains either 0 or the limit value */
		if (LimitCheckEnable == 0)
 8008acc:	1c7b      	adds	r3, r7, #1
 8008ace:	781b      	ldrb	r3, [r3, #0]
 8008ad0:	2b00      	cmp	r3, #0
 8008ad2:	d102      	bne.n	8008ada <VL53L1_SetLimitCheckEnable+0x44>
			TempFix1616 = 0;
 8008ad4:	2300      	movs	r3, #0
 8008ad6:	60bb      	str	r3, [r7, #8]
 8008ad8:	e008      	b.n	8008aec <VL53L1_SetLimitCheckEnable+0x56>
		else
			VL53L1_GETARRAYPARAMETERFIELD(Dev, LimitChecksValue,
 8008ada:	1cbb      	adds	r3, r7, #2
 8008adc:	881b      	ldrh	r3, [r3, #0]
 8008ade:	687a      	ldr	r2, [r7, #4]
 8008ae0:	33e0      	adds	r3, #224	; 0xe0
 8008ae2:	009b      	lsls	r3, r3, #2
 8008ae4:	18d3      	adds	r3, r2, r3
 8008ae6:	3308      	adds	r3, #8
 8008ae8:	681b      	ldr	r3, [r3, #0]
 8008aea:	60bb      	str	r3, [r7, #8]
				LimitCheckId, TempFix1616);

		Status = SetLimitValue(Dev, LimitCheckId, TempFix1616);
 8008aec:	230f      	movs	r3, #15
 8008aee:	18fc      	adds	r4, r7, r3
 8008af0:	68ba      	ldr	r2, [r7, #8]
 8008af2:	1cbb      	adds	r3, r7, #2
 8008af4:	8819      	ldrh	r1, [r3, #0]
 8008af6:	687b      	ldr	r3, [r7, #4]
 8008af8:	0018      	movs	r0, r3
 8008afa:	f7ff ff92 	bl	8008a22 <SetLimitValue>
 8008afe:	0003      	movs	r3, r0
 8008b00:	7023      	strb	r3, [r4, #0]
	}

	if (Status == VL53L1_ERROR_NONE)
 8008b02:	230f      	movs	r3, #15
 8008b04:	18fb      	adds	r3, r7, r3
 8008b06:	781b      	ldrb	r3, [r3, #0]
 8008b08:	b25b      	sxtb	r3, r3
 8008b0a:	2b00      	cmp	r3, #0
 8008b0c:	d10e      	bne.n	8008b2c <VL53L1_SetLimitCheckEnable+0x96>
		VL53L1_SETARRAYPARAMETERFIELD(Dev,
 8008b0e:	1c7b      	adds	r3, r7, #1
 8008b10:	781b      	ldrb	r3, [r3, #0]
 8008b12:	1e5a      	subs	r2, r3, #1
 8008b14:	4193      	sbcs	r3, r2
 8008b16:	b2d9      	uxtb	r1, r3
 8008b18:	1cbb      	adds	r3, r7, #2
 8008b1a:	881a      	ldrh	r2, [r3, #0]
 8008b1c:	0008      	movs	r0, r1
 8008b1e:	6879      	ldr	r1, [r7, #4]
 8008b20:	23e1      	movs	r3, #225	; 0xe1
 8008b22:	009b      	lsls	r3, r3, #2
 8008b24:	188a      	adds	r2, r1, r2
 8008b26:	18d3      	adds	r3, r2, r3
 8008b28:	1c02      	adds	r2, r0, #0
 8008b2a:	701a      	strb	r2, [r3, #0]
			((LimitCheckEnable == 0) ? 0 : 1));



	LOG_FUNCTION_END(Status);
	return Status;
 8008b2c:	230f      	movs	r3, #15
 8008b2e:	18fb      	adds	r3, r7, r3
 8008b30:	781b      	ldrb	r3, [r3, #0]
 8008b32:	b25b      	sxtb	r3, r3
}
 8008b34:	0018      	movs	r0, r3
 8008b36:	46bd      	mov	sp, r7
 8008b38:	b005      	add	sp, #20
 8008b3a:	bd90      	pop	{r4, r7, pc}

08008b3c <VL53L1_GetLimitCheckEnable>:

VL53L1_Error VL53L1_GetLimitCheckEnable(VL53L1_DEV Dev, uint16_t LimitCheckId,
	uint8_t *pLimitCheckEnable)
{
 8008b3c:	b590      	push	{r4, r7, lr}
 8008b3e:	b087      	sub	sp, #28
 8008b40:	af00      	add	r7, sp, #0
 8008b42:	60f8      	str	r0, [r7, #12]
 8008b44:	607a      	str	r2, [r7, #4]
 8008b46:	200a      	movs	r0, #10
 8008b48:	183b      	adds	r3, r7, r0
 8008b4a:	1c0a      	adds	r2, r1, #0
 8008b4c:	801a      	strh	r2, [r3, #0]
	VL53L1_Error Status = VL53L1_ERROR_NONE;
 8008b4e:	2317      	movs	r3, #23
 8008b50:	18fb      	adds	r3, r7, r3
 8008b52:	2200      	movs	r2, #0
 8008b54:	701a      	strb	r2, [r3, #0]
	uint8_t Temp8;

	LOG_FUNCTION_START("");

	if (LimitCheckId >= VL53L1_CHECKENABLE_NUMBER_OF_CHECKS) {
 8008b56:	183b      	adds	r3, r7, r0
 8008b58:	881b      	ldrh	r3, [r3, #0]
 8008b5a:	2b01      	cmp	r3, #1
 8008b5c:	d907      	bls.n	8008b6e <VL53L1_GetLimitCheckEnable+0x32>
		Status = VL53L1_ERROR_INVALID_PARAMS;
 8008b5e:	2317      	movs	r3, #23
 8008b60:	18fb      	adds	r3, r7, r3
 8008b62:	22fc      	movs	r2, #252	; 0xfc
 8008b64:	701a      	strb	r2, [r3, #0]
		*pLimitCheckEnable = 0;
 8008b66:	687b      	ldr	r3, [r7, #4]
 8008b68:	2200      	movs	r2, #0
 8008b6a:	701a      	strb	r2, [r3, #0]
 8008b6c:	e00f      	b.n	8008b8e <VL53L1_GetLimitCheckEnable+0x52>
	} else {
		VL53L1_GETARRAYPARAMETERFIELD(Dev, LimitChecksEnable,
 8008b6e:	230a      	movs	r3, #10
 8008b70:	18fb      	adds	r3, r7, r3
 8008b72:	8819      	ldrh	r1, [r3, #0]
 8008b74:	2416      	movs	r4, #22
 8008b76:	193b      	adds	r3, r7, r4
 8008b78:	68f8      	ldr	r0, [r7, #12]
 8008b7a:	22e1      	movs	r2, #225	; 0xe1
 8008b7c:	0092      	lsls	r2, r2, #2
 8008b7e:	1841      	adds	r1, r0, r1
 8008b80:	188a      	adds	r2, r1, r2
 8008b82:	7812      	ldrb	r2, [r2, #0]
 8008b84:	701a      	strb	r2, [r3, #0]
			LimitCheckId, Temp8);
		*pLimitCheckEnable = Temp8;
 8008b86:	687b      	ldr	r3, [r7, #4]
 8008b88:	193a      	adds	r2, r7, r4
 8008b8a:	7812      	ldrb	r2, [r2, #0]
 8008b8c:	701a      	strb	r2, [r3, #0]
	}


	LOG_FUNCTION_END(Status);
	return Status;
 8008b8e:	2317      	movs	r3, #23
 8008b90:	18fb      	adds	r3, r7, r3
 8008b92:	781b      	ldrb	r3, [r3, #0]
 8008b94:	b25b      	sxtb	r3, r3
}
 8008b96:	0018      	movs	r0, r3
 8008b98:	46bd      	mov	sp, r7
 8008b9a:	b007      	add	sp, #28
 8008b9c:	bd90      	pop	{r4, r7, pc}

08008b9e <VL53L1_SetLimitCheckValue>:

VL53L1_Error VL53L1_SetLimitCheckValue(VL53L1_DEV Dev, uint16_t LimitCheckId,
	FixPoint1616_t LimitCheckValue)
{
 8008b9e:	b5b0      	push	{r4, r5, r7, lr}
 8008ba0:	b086      	sub	sp, #24
 8008ba2:	af00      	add	r7, sp, #0
 8008ba4:	60f8      	str	r0, [r7, #12]
 8008ba6:	607a      	str	r2, [r7, #4]
 8008ba8:	200a      	movs	r0, #10
 8008baa:	183b      	adds	r3, r7, r0
 8008bac:	1c0a      	adds	r2, r1, #0
 8008bae:	801a      	strh	r2, [r3, #0]
	VL53L1_Error Status = VL53L1_ERROR_NONE;
 8008bb0:	2317      	movs	r3, #23
 8008bb2:	18fb      	adds	r3, r7, r3
 8008bb4:	2200      	movs	r2, #0
 8008bb6:	701a      	strb	r2, [r3, #0]
	uint8_t LimitChecksEnable;

	LOG_FUNCTION_START("");

	if (LimitCheckId >= VL53L1_CHECKENABLE_NUMBER_OF_CHECKS) {
 8008bb8:	183b      	adds	r3, r7, r0
 8008bba:	881b      	ldrh	r3, [r3, #0]
 8008bbc:	2b01      	cmp	r3, #1
 8008bbe:	d904      	bls.n	8008bca <VL53L1_SetLimitCheckValue+0x2c>
		Status = VL53L1_ERROR_INVALID_PARAMS;
 8008bc0:	2317      	movs	r3, #23
 8008bc2:	18fb      	adds	r3, r7, r3
 8008bc4:	22fc      	movs	r2, #252	; 0xfc
 8008bc6:	701a      	strb	r2, [r3, #0]
 8008bc8:	e035      	b.n	8008c36 <VL53L1_SetLimitCheckValue+0x98>
	} else {

		VL53L1_GETARRAYPARAMETERFIELD(Dev, LimitChecksEnable,
 8008bca:	230a      	movs	r3, #10
 8008bcc:	18fb      	adds	r3, r7, r3
 8008bce:	8819      	ldrh	r1, [r3, #0]
 8008bd0:	2416      	movs	r4, #22
 8008bd2:	193b      	adds	r3, r7, r4
 8008bd4:	68f8      	ldr	r0, [r7, #12]
 8008bd6:	22e1      	movs	r2, #225	; 0xe1
 8008bd8:	0092      	lsls	r2, r2, #2
 8008bda:	1841      	adds	r1, r0, r1
 8008bdc:	188a      	adds	r2, r1, r2
 8008bde:	7812      	ldrb	r2, [r2, #0]
 8008be0:	701a      	strb	r2, [r3, #0]
				LimitCheckId,
				LimitChecksEnable);

		if (LimitChecksEnable == 0) {
 8008be2:	193b      	adds	r3, r7, r4
 8008be4:	781b      	ldrb	r3, [r3, #0]
 8008be6:	2b00      	cmp	r3, #0
 8008be8:	d10a      	bne.n	8008c00 <VL53L1_SetLimitCheckValue+0x62>
			/* disabled write only internal value */
			VL53L1_SETARRAYPARAMETERFIELD(Dev, LimitChecksValue,
 8008bea:	230a      	movs	r3, #10
 8008bec:	18fb      	adds	r3, r7, r3
 8008bee:	881b      	ldrh	r3, [r3, #0]
 8008bf0:	68fa      	ldr	r2, [r7, #12]
 8008bf2:	33e0      	adds	r3, #224	; 0xe0
 8008bf4:	009b      	lsls	r3, r3, #2
 8008bf6:	18d3      	adds	r3, r2, r3
 8008bf8:	3308      	adds	r3, #8
 8008bfa:	687a      	ldr	r2, [r7, #4]
 8008bfc:	601a      	str	r2, [r3, #0]
 8008bfe:	e01a      	b.n	8008c36 <VL53L1_SetLimitCheckValue+0x98>
				LimitCheckId, LimitCheckValue);
		} else {

			Status = SetLimitValue(Dev, LimitCheckId,
 8008c00:	2517      	movs	r5, #23
 8008c02:	197c      	adds	r4, r7, r5
 8008c04:	687a      	ldr	r2, [r7, #4]
 8008c06:	230a      	movs	r3, #10
 8008c08:	18fb      	adds	r3, r7, r3
 8008c0a:	8819      	ldrh	r1, [r3, #0]
 8008c0c:	68fb      	ldr	r3, [r7, #12]
 8008c0e:	0018      	movs	r0, r3
 8008c10:	f7ff ff07 	bl	8008a22 <SetLimitValue>
 8008c14:	0003      	movs	r3, r0
 8008c16:	7023      	strb	r3, [r4, #0]
					LimitCheckValue);

			if (Status == VL53L1_ERROR_NONE) {
 8008c18:	197b      	adds	r3, r7, r5
 8008c1a:	781b      	ldrb	r3, [r3, #0]
 8008c1c:	b25b      	sxtb	r3, r3
 8008c1e:	2b00      	cmp	r3, #0
 8008c20:	d109      	bne.n	8008c36 <VL53L1_SetLimitCheckValue+0x98>
				VL53L1_SETARRAYPARAMETERFIELD(Dev,
 8008c22:	230a      	movs	r3, #10
 8008c24:	18fb      	adds	r3, r7, r3
 8008c26:	881b      	ldrh	r3, [r3, #0]
 8008c28:	68fa      	ldr	r2, [r7, #12]
 8008c2a:	33e0      	adds	r3, #224	; 0xe0
 8008c2c:	009b      	lsls	r3, r3, #2
 8008c2e:	18d3      	adds	r3, r2, r3
 8008c30:	3308      	adds	r3, #8
 8008c32:	687a      	ldr	r2, [r7, #4]
 8008c34:	601a      	str	r2, [r3, #0]
			}
		}
	}

	LOG_FUNCTION_END(Status);
	return Status;
 8008c36:	2317      	movs	r3, #23
 8008c38:	18fb      	adds	r3, r7, r3
 8008c3a:	781b      	ldrb	r3, [r3, #0]
 8008c3c:	b25b      	sxtb	r3, r3
}
 8008c3e:	0018      	movs	r0, r3
 8008c40:	46bd      	mov	sp, r7
 8008c42:	b006      	add	sp, #24
 8008c44:	bdb0      	pop	{r4, r5, r7, pc}

08008c46 <VL53L1_GetLimitCheckValue>:

VL53L1_Error VL53L1_GetLimitCheckValue(VL53L1_DEV Dev, uint16_t LimitCheckId,
	FixPoint1616_t *pLimitCheckValue)
{
 8008c46:	b5b0      	push	{r4, r5, r7, lr}
 8008c48:	b088      	sub	sp, #32
 8008c4a:	af00      	add	r7, sp, #0
 8008c4c:	60f8      	str	r0, [r7, #12]
 8008c4e:	607a      	str	r2, [r7, #4]
 8008c50:	200a      	movs	r0, #10
 8008c52:	183b      	adds	r3, r7, r0
 8008c54:	1c0a      	adds	r2, r1, #0
 8008c56:	801a      	strh	r2, [r3, #0]
	VL53L1_Error Status = VL53L1_ERROR_NONE;
 8008c58:	231f      	movs	r3, #31
 8008c5a:	18fb      	adds	r3, r7, r3
 8008c5c:	2200      	movs	r2, #0
 8008c5e:	701a      	strb	r2, [r3, #0]
	FixPoint1616_t TempFix1616;
	uint16_t SigmaThresh;

	LOG_FUNCTION_START("");

	switch (LimitCheckId) {
 8008c60:	183b      	adds	r3, r7, r0
 8008c62:	881b      	ldrh	r3, [r3, #0]
 8008c64:	2b00      	cmp	r3, #0
 8008c66:	d002      	beq.n	8008c6e <VL53L1_GetLimitCheckValue+0x28>
 8008c68:	2b01      	cmp	r3, #1
 8008c6a:	d010      	beq.n	8008c8e <VL53L1_GetLimitCheckValue+0x48>
 8008c6c:	e01f      	b.n	8008cae <VL53L1_GetLimitCheckValue+0x68>
	case VL53L1_CHECKENABLE_SIGMA_FINAL_RANGE:
		Status = VL53L1_get_lite_sigma_threshold(Dev, &SigmaThresh);
 8008c6e:	231f      	movs	r3, #31
 8008c70:	18fc      	adds	r4, r7, r3
 8008c72:	2514      	movs	r5, #20
 8008c74:	197a      	adds	r2, r7, r5
 8008c76:	68fb      	ldr	r3, [r7, #12]
 8008c78:	0011      	movs	r1, r2
 8008c7a:	0018      	movs	r0, r3
 8008c7c:	f001 f9f6 	bl	800a06c <VL53L1_get_lite_sigma_threshold>
 8008c80:	0003      	movs	r3, r0
 8008c82:	7023      	strb	r3, [r4, #0]
		TempFix1616 = VL53L1_FIXPOINT142TOFIXPOINT1616(SigmaThresh);
 8008c84:	197b      	adds	r3, r7, r5
 8008c86:	881b      	ldrh	r3, [r3, #0]
 8008c88:	039b      	lsls	r3, r3, #14
 8008c8a:	61bb      	str	r3, [r7, #24]
		break;
 8008c8c:	e013      	b.n	8008cb6 <VL53L1_GetLimitCheckValue+0x70>
	case VL53L1_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE:
		Status = VL53L1_get_lite_min_count_rate(Dev, &MinCountRate);
 8008c8e:	231f      	movs	r3, #31
 8008c90:	18fc      	adds	r4, r7, r3
 8008c92:	2516      	movs	r5, #22
 8008c94:	197a      	adds	r2, r7, r5
 8008c96:	68fb      	ldr	r3, [r7, #12]
 8008c98:	0011      	movs	r1, r2
 8008c9a:	0018      	movs	r0, r3
 8008c9c:	f001 fa18 	bl	800a0d0 <VL53L1_get_lite_min_count_rate>
 8008ca0:	0003      	movs	r3, r0
 8008ca2:	7023      	strb	r3, [r4, #0]
		TempFix1616 = VL53L1_FIXPOINT97TOFIXPOINT1616(MinCountRate);
 8008ca4:	197b      	adds	r3, r7, r5
 8008ca6:	881b      	ldrh	r3, [r3, #0]
 8008ca8:	025b      	lsls	r3, r3, #9
 8008caa:	61bb      	str	r3, [r7, #24]
		break;
 8008cac:	e003      	b.n	8008cb6 <VL53L1_GetLimitCheckValue+0x70>
	default:
		Status = VL53L1_ERROR_INVALID_PARAMS;
 8008cae:	231f      	movs	r3, #31
 8008cb0:	18fb      	adds	r3, r7, r3
 8008cb2:	22fc      	movs	r2, #252	; 0xfc
 8008cb4:	701a      	strb	r2, [r3, #0]
	}

	if (Status == VL53L1_ERROR_NONE) {
 8008cb6:	231f      	movs	r3, #31
 8008cb8:	18fb      	adds	r3, r7, r3
 8008cba:	781b      	ldrb	r3, [r3, #0]
 8008cbc:	b25b      	sxtb	r3, r3
 8008cbe:	2b00      	cmp	r3, #0
 8008cc0:	d12f      	bne.n	8008d22 <VL53L1_GetLimitCheckValue+0xdc>

		if (TempFix1616 == 0) {
 8008cc2:	69bb      	ldr	r3, [r7, #24]
 8008cc4:	2b00      	cmp	r3, #0
 8008cc6:	d116      	bne.n	8008cf6 <VL53L1_GetLimitCheckValue+0xb0>
			/* disabled: return value from memory */
			VL53L1_GETARRAYPARAMETERFIELD(Dev,
 8008cc8:	210a      	movs	r1, #10
 8008cca:	187b      	adds	r3, r7, r1
 8008ccc:	881b      	ldrh	r3, [r3, #0]
 8008cce:	68fa      	ldr	r2, [r7, #12]
 8008cd0:	33e0      	adds	r3, #224	; 0xe0
 8008cd2:	009b      	lsls	r3, r3, #2
 8008cd4:	18d3      	adds	r3, r2, r3
 8008cd6:	3308      	adds	r3, #8
 8008cd8:	681b      	ldr	r3, [r3, #0]
 8008cda:	61bb      	str	r3, [r7, #24]
				LimitChecksValue, LimitCheckId,
				TempFix1616);
			*pLimitCheckValue = TempFix1616;
 8008cdc:	687b      	ldr	r3, [r7, #4]
 8008cde:	69ba      	ldr	r2, [r7, #24]
 8008ce0:	601a      	str	r2, [r3, #0]
			VL53L1_SETARRAYPARAMETERFIELD(Dev,
 8008ce2:	187b      	adds	r3, r7, r1
 8008ce4:	881a      	ldrh	r2, [r3, #0]
 8008ce6:	68f9      	ldr	r1, [r7, #12]
 8008ce8:	23e1      	movs	r3, #225	; 0xe1
 8008cea:	009b      	lsls	r3, r3, #2
 8008cec:	188a      	adds	r2, r1, r2
 8008cee:	18d3      	adds	r3, r2, r3
 8008cf0:	2200      	movs	r2, #0
 8008cf2:	701a      	strb	r2, [r3, #0]
 8008cf4:	e015      	b.n	8008d22 <VL53L1_GetLimitCheckValue+0xdc>
				LimitChecksEnable, LimitCheckId, 0);
		} else {
			*pLimitCheckValue = TempFix1616;
 8008cf6:	687b      	ldr	r3, [r7, #4]
 8008cf8:	69ba      	ldr	r2, [r7, #24]
 8008cfa:	601a      	str	r2, [r3, #0]
			VL53L1_SETARRAYPARAMETERFIELD(Dev,
 8008cfc:	210a      	movs	r1, #10
 8008cfe:	187b      	adds	r3, r7, r1
 8008d00:	881b      	ldrh	r3, [r3, #0]
 8008d02:	68fa      	ldr	r2, [r7, #12]
 8008d04:	33e0      	adds	r3, #224	; 0xe0
 8008d06:	009b      	lsls	r3, r3, #2
 8008d08:	18d3      	adds	r3, r2, r3
 8008d0a:	3308      	adds	r3, #8
 8008d0c:	69ba      	ldr	r2, [r7, #24]
 8008d0e:	601a      	str	r2, [r3, #0]
				LimitChecksValue, LimitCheckId,
				TempFix1616);
			VL53L1_SETARRAYPARAMETERFIELD(Dev,
 8008d10:	187b      	adds	r3, r7, r1
 8008d12:	881a      	ldrh	r2, [r3, #0]
 8008d14:	68f9      	ldr	r1, [r7, #12]
 8008d16:	23e1      	movs	r3, #225	; 0xe1
 8008d18:	009b      	lsls	r3, r3, #2
 8008d1a:	188a      	adds	r2, r1, r2
 8008d1c:	18d3      	adds	r3, r2, r3
 8008d1e:	2201      	movs	r2, #1
 8008d20:	701a      	strb	r2, [r3, #0]
				LimitChecksEnable, LimitCheckId, 1);
		}
	}
	LOG_FUNCTION_END(Status);
	return Status;
 8008d22:	231f      	movs	r3, #31
 8008d24:	18fb      	adds	r3, r7, r3
 8008d26:	781b      	ldrb	r3, [r3, #0]
 8008d28:	b25b      	sxtb	r3, r3

}
 8008d2a:	0018      	movs	r0, r3
 8008d2c:	46bd      	mov	sp, r7
 8008d2e:	b008      	add	sp, #32
 8008d30:	bdb0      	pop	{r4, r5, r7, pc}

08008d32 <VL53L1_SetUserROI>:

/* Group ROI Functions */

VL53L1_Error VL53L1_SetUserROI(VL53L1_DEV Dev,
		VL53L1_UserRoi_t *pRoi)
{
 8008d32:	b5b0      	push	{r4, r5, r7, lr}
 8008d34:	b084      	sub	sp, #16
 8008d36:	af00      	add	r7, sp, #0
 8008d38:	6078      	str	r0, [r7, #4]
 8008d3a:	6039      	str	r1, [r7, #0]
	VL53L1_Error Status = VL53L1_ERROR_NONE;
 8008d3c:	250f      	movs	r5, #15
 8008d3e:	197b      	adds	r3, r7, r5
 8008d40:	2200      	movs	r2, #0
 8008d42:	701a      	strb	r2, [r3, #0]
	VL53L1_user_zone_t user_zone;

	Status = CheckValidRectRoi(*pRoi);
 8008d44:	197c      	adds	r4, r7, r5
 8008d46:	683b      	ldr	r3, [r7, #0]
 8008d48:	781a      	ldrb	r2, [r3, #0]
 8008d4a:	7859      	ldrb	r1, [r3, #1]
 8008d4c:	0209      	lsls	r1, r1, #8
 8008d4e:	430a      	orrs	r2, r1
 8008d50:	7899      	ldrb	r1, [r3, #2]
 8008d52:	0409      	lsls	r1, r1, #16
 8008d54:	430a      	orrs	r2, r1
 8008d56:	78db      	ldrb	r3, [r3, #3]
 8008d58:	061b      	lsls	r3, r3, #24
 8008d5a:	4313      	orrs	r3, r2
 8008d5c:	2200      	movs	r2, #0
 8008d5e:	001a      	movs	r2, r3
 8008d60:	0010      	movs	r0, r2
 8008d62:	f7ff f8e9 	bl	8007f38 <CheckValidRectRoi>
 8008d66:	0003      	movs	r3, r0
 8008d68:	7023      	strb	r3, [r4, #0]
	if (Status != VL53L1_ERROR_NONE)
 8008d6a:	197b      	adds	r3, r7, r5
 8008d6c:	781b      	ldrb	r3, [r3, #0]
 8008d6e:	b25b      	sxtb	r3, r3
 8008d70:	2b00      	cmp	r3, #0
 8008d72:	d002      	beq.n	8008d7a <VL53L1_SetUserROI+0x48>
		return VL53L1_ERROR_INVALID_PARAMS;
 8008d74:	2304      	movs	r3, #4
 8008d76:	425b      	negs	r3, r3
 8008d78:	e04a      	b.n	8008e10 <VL53L1_SetUserROI+0xde>

	user_zone.x_centre = (pRoi->BotRightX + pRoi->TopLeftX  + 1) / 2;
 8008d7a:	683b      	ldr	r3, [r7, #0]
 8008d7c:	789b      	ldrb	r3, [r3, #2]
 8008d7e:	001a      	movs	r2, r3
 8008d80:	683b      	ldr	r3, [r7, #0]
 8008d82:	781b      	ldrb	r3, [r3, #0]
 8008d84:	18d3      	adds	r3, r2, r3
 8008d86:	3301      	adds	r3, #1
 8008d88:	2b00      	cmp	r3, #0
 8008d8a:	da00      	bge.n	8008d8e <VL53L1_SetUserROI+0x5c>
 8008d8c:	3301      	adds	r3, #1
 8008d8e:	105b      	asrs	r3, r3, #1
 8008d90:	b2da      	uxtb	r2, r3
 8008d92:	2308      	movs	r3, #8
 8008d94:	18fb      	adds	r3, r7, r3
 8008d96:	701a      	strb	r2, [r3, #0]
	user_zone.y_centre = (pRoi->TopLeftY  + pRoi->BotRightY + 1) / 2;
 8008d98:	683b      	ldr	r3, [r7, #0]
 8008d9a:	785b      	ldrb	r3, [r3, #1]
 8008d9c:	001a      	movs	r2, r3
 8008d9e:	683b      	ldr	r3, [r7, #0]
 8008da0:	78db      	ldrb	r3, [r3, #3]
 8008da2:	18d3      	adds	r3, r2, r3
 8008da4:	3301      	adds	r3, #1
 8008da6:	2b00      	cmp	r3, #0
 8008da8:	da00      	bge.n	8008dac <VL53L1_SetUserROI+0x7a>
 8008daa:	3301      	adds	r3, #1
 8008dac:	105b      	asrs	r3, r3, #1
 8008dae:	b2da      	uxtb	r2, r3
 8008db0:	2108      	movs	r1, #8
 8008db2:	187b      	adds	r3, r7, r1
 8008db4:	705a      	strb	r2, [r3, #1]
	user_zone.width =    (pRoi->BotRightX - pRoi->TopLeftX);
 8008db6:	683b      	ldr	r3, [r7, #0]
 8008db8:	789a      	ldrb	r2, [r3, #2]
 8008dba:	683b      	ldr	r3, [r7, #0]
 8008dbc:	781b      	ldrb	r3, [r3, #0]
 8008dbe:	1ad3      	subs	r3, r2, r3
 8008dc0:	b2da      	uxtb	r2, r3
 8008dc2:	187b      	adds	r3, r7, r1
 8008dc4:	709a      	strb	r2, [r3, #2]
	user_zone.height =   (pRoi->TopLeftY  - pRoi->BotRightY);
 8008dc6:	683b      	ldr	r3, [r7, #0]
 8008dc8:	785a      	ldrb	r2, [r3, #1]
 8008dca:	683b      	ldr	r3, [r7, #0]
 8008dcc:	78db      	ldrb	r3, [r3, #3]
 8008dce:	1ad3      	subs	r3, r2, r3
 8008dd0:	b2da      	uxtb	r2, r3
 8008dd2:	187b      	adds	r3, r7, r1
 8008dd4:	70da      	strb	r2, [r3, #3]
	if ((user_zone.width < 3) || (user_zone.height < 3))
 8008dd6:	187b      	adds	r3, r7, r1
 8008dd8:	789b      	ldrb	r3, [r3, #2]
 8008dda:	2b02      	cmp	r3, #2
 8008ddc:	d904      	bls.n	8008de8 <VL53L1_SetUserROI+0xb6>
 8008dde:	2308      	movs	r3, #8
 8008de0:	18fb      	adds	r3, r7, r3
 8008de2:	78db      	ldrb	r3, [r3, #3]
 8008de4:	2b02      	cmp	r3, #2
 8008de6:	d804      	bhi.n	8008df2 <VL53L1_SetUserROI+0xc0>
		Status = VL53L1_ERROR_INVALID_PARAMS;
 8008de8:	230f      	movs	r3, #15
 8008dea:	18fb      	adds	r3, r7, r3
 8008dec:	22fc      	movs	r2, #252	; 0xfc
 8008dee:	701a      	strb	r2, [r3, #0]
 8008df0:	e00a      	b.n	8008e08 <VL53L1_SetUserROI+0xd6>
	else
		Status =  VL53L1_set_user_zone(Dev, &user_zone);
 8008df2:	230f      	movs	r3, #15
 8008df4:	18fc      	adds	r4, r7, r3
 8008df6:	2308      	movs	r3, #8
 8008df8:	18fa      	adds	r2, r7, r3
 8008dfa:	687b      	ldr	r3, [r7, #4]
 8008dfc:	0011      	movs	r1, r2
 8008dfe:	0018      	movs	r0, r3
 8008e00:	f000 fed3 	bl	8009baa <VL53L1_set_user_zone>
 8008e04:	0003      	movs	r3, r0
 8008e06:	7023      	strb	r3, [r4, #0]

	LOG_FUNCTION_END(Status);
	return Status;
 8008e08:	230f      	movs	r3, #15
 8008e0a:	18fb      	adds	r3, r7, r3
 8008e0c:	781b      	ldrb	r3, [r3, #0]
 8008e0e:	b25b      	sxtb	r3, r3
}
 8008e10:	0018      	movs	r0, r3
 8008e12:	46bd      	mov	sp, r7
 8008e14:	b004      	add	sp, #16
 8008e16:	bdb0      	pop	{r4, r5, r7, pc}

08008e18 <VL53L1_GetSequenceStepEnable>:
}


VL53L1_Error VL53L1_GetSequenceStepEnable(VL53L1_DEV Dev,
	VL53L1_SequenceStepId SequenceStepId, uint8_t *pSequenceStepEnabled)
{
 8008e18:	b5b0      	push	{r4, r5, r7, lr}
 8008e1a:	b086      	sub	sp, #24
 8008e1c:	af00      	add	r7, sp, #0
 8008e1e:	60f8      	str	r0, [r7, #12]
 8008e20:	607a      	str	r2, [r7, #4]
 8008e22:	200b      	movs	r0, #11
 8008e24:	183b      	adds	r3, r7, r0
 8008e26:	1c0a      	adds	r2, r1, #0
 8008e28:	701a      	strb	r2, [r3, #0]
	VL53L1_Error Status = VL53L1_ERROR_NONE;
 8008e2a:	2517      	movs	r5, #23
 8008e2c:	197b      	adds	r3, r7, r5
 8008e2e:	2200      	movs	r2, #0
 8008e30:	701a      	strb	r2, [r3, #0]

	LOG_FUNCTION_START("");

	Status = VL53L1_get_sequence_config_bit(Dev,
 8008e32:	197c      	adds	r4, r7, r5
 8008e34:	687a      	ldr	r2, [r7, #4]
 8008e36:	183b      	adds	r3, r7, r0
 8008e38:	7819      	ldrb	r1, [r3, #0]
 8008e3a:	68fb      	ldr	r3, [r7, #12]
 8008e3c:	0018      	movs	r0, r3
 8008e3e:	f000 fe68 	bl	8009b12 <VL53L1_get_sequence_config_bit>
 8008e42:	0003      	movs	r3, r0
 8008e44:	7023      	strb	r3, [r4, #0]
		(VL53L1_DeviceSequenceConfig)SequenceStepId,
		pSequenceStepEnabled);

	LOG_FUNCTION_END(Status);
	return Status;
 8008e46:	197b      	adds	r3, r7, r5
 8008e48:	781b      	ldrb	r3, [r3, #0]
 8008e4a:	b25b      	sxtb	r3, r3
}
 8008e4c:	0018      	movs	r0, r3
 8008e4e:	46bd      	mov	sp, r7
 8008e50:	b006      	add	sp, #24
 8008e52:	bdb0      	pop	{r4, r5, r7, pc}

08008e54 <VL53L1_StartMeasurement>:
/* Group PAL Measurement Functions */



VL53L1_Error VL53L1_StartMeasurement(VL53L1_DEV Dev)
{
 8008e54:	b5b0      	push	{r4, r5, r7, lr}
 8008e56:	b086      	sub	sp, #24
 8008e58:	af00      	add	r7, sp, #0
 8008e5a:	6078      	str	r0, [r7, #4]
#define TIMED_MODE_TIMING_GUARD_MILLISECONDS 4
	VL53L1_Error Status = VL53L1_ERROR_NONE;
 8008e5c:	2317      	movs	r3, #23
 8008e5e:	18fb      	adds	r3, r7, r3
 8008e60:	2200      	movs	r2, #0
 8008e62:	701a      	strb	r2, [r3, #0]
	VL53L1_Error lStatus;
	uint32_t MTBus, IMPms;

	LOG_FUNCTION_START("");

	CurrPalState = VL53L1DevDataGet(Dev, PalState);
 8008e64:	2016      	movs	r0, #22
 8008e66:	183b      	adds	r3, r7, r0
 8008e68:	6879      	ldr	r1, [r7, #4]
 8008e6a:	22de      	movs	r2, #222	; 0xde
 8008e6c:	0092      	lsls	r2, r2, #2
 8008e6e:	5c8a      	ldrb	r2, [r1, r2]
 8008e70:	701a      	strb	r2, [r3, #0]
	switch (CurrPalState) {
 8008e72:	183b      	adds	r3, r7, r0
 8008e74:	781b      	ldrb	r3, [r3, #0]
 8008e76:	2b05      	cmp	r3, #5
 8008e78:	dc06      	bgt.n	8008e88 <VL53L1_StartMeasurement+0x34>
 8008e7a:	2b04      	cmp	r3, #4
 8008e7c:	da0d      	bge.n	8008e9a <VL53L1_StartMeasurement+0x46>
 8008e7e:	2b00      	cmp	r3, #0
 8008e80:	db10      	blt.n	8008ea4 <VL53L1_StartMeasurement+0x50>
 8008e82:	2b02      	cmp	r3, #2
 8008e84:	dd09      	ble.n	8008e9a <VL53L1_StartMeasurement+0x46>
 8008e86:	e003      	b.n	8008e90 <VL53L1_StartMeasurement+0x3c>
 8008e88:	3b62      	subs	r3, #98	; 0x62
 8008e8a:	2b01      	cmp	r3, #1
 8008e8c:	d80a      	bhi.n	8008ea4 <VL53L1_StartMeasurement+0x50>
 8008e8e:	e004      	b.n	8008e9a <VL53L1_StartMeasurement+0x46>
	case VL53L1_STATE_IDLE:
		Status = VL53L1_ERROR_NONE;
 8008e90:	2317      	movs	r3, #23
 8008e92:	18fb      	adds	r3, r7, r3
 8008e94:	2200      	movs	r2, #0
 8008e96:	701a      	strb	r2, [r3, #0]
		break;
 8008e98:	e008      	b.n	8008eac <VL53L1_StartMeasurement+0x58>
	case VL53L1_STATE_STANDBY:
	case VL53L1_STATE_RUNNING:
	case VL53L1_STATE_RESET:
	case VL53L1_STATE_UNKNOWN:
	case VL53L1_STATE_ERROR:
		Status = VL53L1_ERROR_INVALID_COMMAND;
 8008e9a:	2317      	movs	r3, #23
 8008e9c:	18fb      	adds	r3, r7, r3
 8008e9e:	22f2      	movs	r2, #242	; 0xf2
 8008ea0:	701a      	strb	r2, [r3, #0]
		break;
 8008ea2:	e003      	b.n	8008eac <VL53L1_StartMeasurement+0x58>
	default:
		Status = VL53L1_ERROR_UNDEFINED;
 8008ea4:	2317      	movs	r3, #23
 8008ea6:	18fb      	adds	r3, r7, r3
 8008ea8:	22fd      	movs	r2, #253	; 0xfd
 8008eaa:	701a      	strb	r2, [r3, #0]
	}

	DeviceMeasurementMode = VL53L1DevDataGet(Dev, LLData.measurement_mode);
 8008eac:	2315      	movs	r3, #21
 8008eae:	18fb      	adds	r3, r7, r3
 8008eb0:	687a      	ldr	r2, [r7, #4]
 8008eb2:	7892      	ldrb	r2, [r2, #2]
 8008eb4:	701a      	strb	r2, [r3, #0]

	/* Check timing configuration between timing budget and
	* inter measurement period */
	if ((Status == VL53L1_ERROR_NONE) &&
 8008eb6:	2317      	movs	r3, #23
 8008eb8:	18fb      	adds	r3, r7, r3
 8008eba:	781b      	ldrb	r3, [r3, #0]
 8008ebc:	b25b      	sxtb	r3, r3
 8008ebe:	2b00      	cmp	r3, #0
 8008ec0:	d12a      	bne.n	8008f18 <VL53L1_StartMeasurement+0xc4>
 8008ec2:	2315      	movs	r3, #21
 8008ec4:	18fb      	adds	r3, r7, r3
 8008ec6:	781b      	ldrb	r3, [r3, #0]
 8008ec8:	2b40      	cmp	r3, #64	; 0x40
 8008eca:	d125      	bne.n	8008f18 <VL53L1_StartMeasurement+0xc4>
		(DeviceMeasurementMode == VL53L1_DEVICEMEASUREMENTMODE_TIMED)) {
		lStatus = VL53L1_GetMeasurementTimingBudgetMicroSeconds(Dev,
 8008ecc:	2514      	movs	r5, #20
 8008ece:	197c      	adds	r4, r7, r5
 8008ed0:	2310      	movs	r3, #16
 8008ed2:	18fa      	adds	r2, r7, r3
 8008ed4:	687b      	ldr	r3, [r7, #4]
 8008ed6:	0011      	movs	r1, r2
 8008ed8:	0018      	movs	r0, r3
 8008eda:	f7ff fc7d 	bl	80087d8 <VL53L1_GetMeasurementTimingBudgetMicroSeconds>
 8008ede:	0003      	movs	r3, r0
 8008ee0:	7023      	strb	r3, [r4, #0]
				&MTBus);
		/* convert timing budget in ms */
		MTBus /= 1000;
 8008ee2:	693a      	ldr	r2, [r7, #16]
 8008ee4:	23fa      	movs	r3, #250	; 0xfa
 8008ee6:	0099      	lsls	r1, r3, #2
 8008ee8:	0010      	movs	r0, r2
 8008eea:	f7f7 f91f 	bl	800012c <__udivsi3>
 8008eee:	0003      	movs	r3, r0
 8008ef0:	613b      	str	r3, [r7, #16]
		lStatus = VL53L1_GetInterMeasurementPeriodMilliSeconds(Dev,
 8008ef2:	197c      	adds	r4, r7, r5
 8008ef4:	230c      	movs	r3, #12
 8008ef6:	18fa      	adds	r2, r7, r3
 8008ef8:	687b      	ldr	r3, [r7, #4]
 8008efa:	0011      	movs	r1, r2
 8008efc:	0018      	movs	r0, r3
 8008efe:	f7ff fd68 	bl	80089d2 <VL53L1_GetInterMeasurementPeriodMilliSeconds>
 8008f02:	0003      	movs	r3, r0
 8008f04:	7023      	strb	r3, [r4, #0]
				&IMPms);
		/* trick to get rid of compiler "set but not used" warning */
		SUPPRESS_UNUSED_WARNING(lStatus);
		if (IMPms < MTBus + TIMED_MODE_TIMING_GUARD_MILLISECONDS)
 8008f06:	693b      	ldr	r3, [r7, #16]
 8008f08:	1d1a      	adds	r2, r3, #4
 8008f0a:	68fb      	ldr	r3, [r7, #12]
 8008f0c:	429a      	cmp	r2, r3
 8008f0e:	d903      	bls.n	8008f18 <VL53L1_StartMeasurement+0xc4>
			Status = VL53L1_ERROR_INVALID_PARAMS;
 8008f10:	2317      	movs	r3, #23
 8008f12:	18fb      	adds	r3, r7, r3
 8008f14:	22fc      	movs	r2, #252	; 0xfc
 8008f16:	701a      	strb	r2, [r3, #0]
	}

	if (Status == VL53L1_ERROR_NONE)
 8008f18:	2317      	movs	r3, #23
 8008f1a:	18fb      	adds	r3, r7, r3
 8008f1c:	781b      	ldrb	r3, [r3, #0]
 8008f1e:	b25b      	sxtb	r3, r3
 8008f20:	2b00      	cmp	r3, #0
 8008f22:	d10b      	bne.n	8008f3c <VL53L1_StartMeasurement+0xe8>
		Status = VL53L1_init_and_start_range(
 8008f24:	2317      	movs	r3, #23
 8008f26:	18fc      	adds	r4, r7, r3
 8008f28:	2315      	movs	r3, #21
 8008f2a:	18fb      	adds	r3, r7, r3
 8008f2c:	7819      	ldrb	r1, [r3, #0]
 8008f2e:	687b      	ldr	r3, [r7, #4]
 8008f30:	2206      	movs	r2, #6
 8008f32:	0018      	movs	r0, r3
 8008f34:	f001 f924 	bl	800a180 <VL53L1_init_and_start_range>
 8008f38:	0003      	movs	r3, r0
 8008f3a:	7023      	strb	r3, [r4, #0]
				Dev,
				DeviceMeasurementMode,
				VL53L1_DEVICECONFIGLEVEL_FULL);

	/* Set PAL State to Running */
	if (Status == VL53L1_ERROR_NONE)
 8008f3c:	2317      	movs	r3, #23
 8008f3e:	18fb      	adds	r3, r7, r3
 8008f40:	781b      	ldrb	r3, [r3, #0]
 8008f42:	b25b      	sxtb	r3, r3
 8008f44:	2b00      	cmp	r3, #0
 8008f46:	d104      	bne.n	8008f52 <VL53L1_StartMeasurement+0xfe>
		VL53L1DevDataSet(Dev, PalState, VL53L1_STATE_RUNNING);
 8008f48:	687a      	ldr	r2, [r7, #4]
 8008f4a:	23de      	movs	r3, #222	; 0xde
 8008f4c:	009b      	lsls	r3, r3, #2
 8008f4e:	2104      	movs	r1, #4
 8008f50:	54d1      	strb	r1, [r2, r3]


	LOG_FUNCTION_END(Status);
	return Status;
 8008f52:	2317      	movs	r3, #23
 8008f54:	18fb      	adds	r3, r7, r3
 8008f56:	781b      	ldrb	r3, [r3, #0]
 8008f58:	b25b      	sxtb	r3, r3
}
 8008f5a:	0018      	movs	r0, r3
 8008f5c:	46bd      	mov	sp, r7
 8008f5e:	b006      	add	sp, #24
 8008f60:	bdb0      	pop	{r4, r5, r7, pc}
	...

08008f64 <ChangePresetMode>:
	LOG_FUNCTION_END(Status);
	return Status;
}

static VL53L1_Error ChangePresetMode(VL53L1_DEV Dev)
{
 8008f64:	b5b0      	push	{r4, r5, r7, lr}
 8008f66:	b08a      	sub	sp, #40	; 0x28
 8008f68:	af00      	add	r7, sp, #0
 8008f6a:	6078      	str	r0, [r7, #4]
	VL53L1_Error Status = VL53L1_ERROR_NONE;
 8008f6c:	2527      	movs	r5, #39	; 0x27
 8008f6e:	197b      	adds	r3, r7, r5
 8008f70:	2200      	movs	r2, #0
 8008f72:	701a      	strb	r2, [r3, #0]
	uint8_t DeviceMeasurementMode;
	uint32_t inter_measurement_period_ms;

	LOG_FUNCTION_START("");

	Status = VL53L1_get_user_zone(Dev, &user_zone);
 8008f74:	197c      	adds	r4, r7, r5
 8008f76:	2318      	movs	r3, #24
 8008f78:	18fa      	adds	r2, r7, r3
 8008f7a:	687b      	ldr	r3, [r7, #4]
 8008f7c:	0011      	movs	r1, r2
 8008f7e:	0018      	movs	r0, r3
 8008f80:	f000 fe39 	bl	8009bf6 <VL53L1_get_user_zone>
 8008f84:	0003      	movs	r3, r0
 8008f86:	7023      	strb	r3, [r4, #0]
	/*  Initialize variables fix ticket EwokP #475395 */
	PresetMode = VL53L1DevDataGet(Dev,
 8008f88:	2326      	movs	r3, #38	; 0x26
 8008f8a:	18fb      	adds	r3, r7, r3
 8008f8c:	6879      	ldr	r1, [r7, #4]
 8008f8e:	22df      	movs	r2, #223	; 0xdf
 8008f90:	0092      	lsls	r2, r2, #2
 8008f92:	5c8a      	ldrb	r2, [r1, r2]
 8008f94:	701a      	strb	r2, [r3, #0]
			CurrentParameters.PresetMode);
	NewDistanceMode = VL53L1DevDataGet(Dev,
 8008f96:	2325      	movs	r3, #37	; 0x25
 8008f98:	18fb      	adds	r3, r7, r3
 8008f9a:	687a      	ldr	r2, [r7, #4]
 8008f9c:	494f      	ldr	r1, [pc, #316]	; (80090dc <ChangePresetMode+0x178>)
 8008f9e:	5c52      	ldrb	r2, [r2, r1]
 8008fa0:	701a      	strb	r2, [r3, #0]
			CurrentParameters.NewDistanceMode);
	/*  End of Initialize variables fix ticket EwokP #475395 */
	if (Status == VL53L1_ERROR_NONE)
 8008fa2:	197b      	adds	r3, r7, r5
 8008fa4:	781b      	ldrb	r3, [r3, #0]
 8008fa6:	b25b      	sxtb	r3, r3
 8008fa8:	2b00      	cmp	r3, #0
 8008faa:	d10c      	bne.n	8008fc6 <ChangePresetMode+0x62>
		Status = VL53L1_get_timeouts_us(Dev, &PhaseCalTimeoutUs,
 8008fac:	2327      	movs	r3, #39	; 0x27
 8008fae:	18fc      	adds	r4, r7, r3
 8008fb0:	2314      	movs	r3, #20
 8008fb2:	18fb      	adds	r3, r7, r3
 8008fb4:	2210      	movs	r2, #16
 8008fb6:	18ba      	adds	r2, r7, r2
 8008fb8:	210c      	movs	r1, #12
 8008fba:	1879      	adds	r1, r7, r1
 8008fbc:	6878      	ldr	r0, [r7, #4]
 8008fbe:	f000 fd1c 	bl	80099fa <VL53L1_get_timeouts_us>
 8008fc2:	0003      	movs	r3, r0
 8008fc4:	7023      	strb	r3, [r4, #0]
			&MmTimeoutUs, &TimingBudget);

	if (Status == VL53L1_ERROR_NONE)
 8008fc6:	2327      	movs	r3, #39	; 0x27
 8008fc8:	18fb      	adds	r3, r7, r3
 8008fca:	781b      	ldrb	r3, [r3, #0]
 8008fcc:	b25b      	sxtb	r3, r3
 8008fce:	2b00      	cmp	r3, #0
 8008fd0:	d107      	bne.n	8008fe2 <ChangePresetMode+0x7e>
		Status = VL53L1_stop_range(Dev);
 8008fd2:	2327      	movs	r3, #39	; 0x27
 8008fd4:	18fc      	adds	r4, r7, r3
 8008fd6:	687b      	ldr	r3, [r7, #4]
 8008fd8:	0018      	movs	r0, r3
 8008fda:	f001 fc01 	bl	800a7e0 <VL53L1_stop_range>
 8008fde:	0003      	movs	r3, r0
 8008fe0:	7023      	strb	r3, [r4, #0]

	if (Status == VL53L1_ERROR_NONE)
 8008fe2:	2327      	movs	r3, #39	; 0x27
 8008fe4:	18fb      	adds	r3, r7, r3
 8008fe6:	781b      	ldrb	r3, [r3, #0]
 8008fe8:	b25b      	sxtb	r3, r3
 8008fea:	2b00      	cmp	r3, #0
 8008fec:	d10a      	bne.n	8009004 <ChangePresetMode+0xa0>
		Status = VL53L1_WaitUs(Dev, 500);
 8008fee:	2327      	movs	r3, #39	; 0x27
 8008ff0:	18fc      	adds	r4, r7, r3
 8008ff2:	23fa      	movs	r3, #250	; 0xfa
 8008ff4:	005a      	lsls	r2, r3, #1
 8008ff6:	687b      	ldr	r3, [r7, #4]
 8008ff8:	0011      	movs	r1, r2
 8008ffa:	0018      	movs	r0, r3
 8008ffc:	f005 fa28 	bl	800e450 <VL53L1_WaitUs>
 8009000:	0003      	movs	r3, r0
 8009002:	7023      	strb	r3, [r4, #0]

	if (Status == VL53L1_ERROR_NONE) {
 8009004:	2327      	movs	r3, #39	; 0x27
 8009006:	18fb      	adds	r3, r7, r3
 8009008:	781b      	ldrb	r3, [r3, #0]
 800900a:	b25b      	sxtb	r3, r3
 800900c:	2b00      	cmp	r3, #0
 800900e:	d111      	bne.n	8009034 <ChangePresetMode+0xd0>
		inter_measurement_period_ms =  VL53L1DevDataGet(Dev,
 8009010:	687b      	ldr	r3, [r7, #4]
 8009012:	695b      	ldr	r3, [r3, #20]
 8009014:	623b      	str	r3, [r7, #32]
					LLData.inter_measurement_period_ms);

		Status = SetPresetMode(Dev,
 8009016:	2327      	movs	r3, #39	; 0x27
 8009018:	18fc      	adds	r4, r7, r3
 800901a:	6a3d      	ldr	r5, [r7, #32]
 800901c:	2325      	movs	r3, #37	; 0x25
 800901e:	18fb      	adds	r3, r7, r3
 8009020:	781a      	ldrb	r2, [r3, #0]
 8009022:	2326      	movs	r3, #38	; 0x26
 8009024:	18fb      	adds	r3, r7, r3
 8009026:	7819      	ldrb	r1, [r3, #0]
 8009028:	6878      	ldr	r0, [r7, #4]
 800902a:	002b      	movs	r3, r5
 800902c:	f7ff f916 	bl	800825c <SetPresetMode>
 8009030:	0003      	movs	r3, r0
 8009032:	7023      	strb	r3, [r4, #0]
				PresetMode,
				NewDistanceMode,
				inter_measurement_period_ms);
	}

	if (Status == VL53L1_ERROR_NONE) {
 8009034:	2327      	movs	r3, #39	; 0x27
 8009036:	18fb      	adds	r3, r7, r3
 8009038:	781b      	ldrb	r3, [r3, #0]
 800903a:	b25b      	sxtb	r3, r3
 800903c:	2b00      	cmp	r3, #0
 800903e:	d111      	bne.n	8009064 <ChangePresetMode+0x100>
		Status = VL53L1_set_timeouts_us(Dev, PhaseCalTimeoutUs,
 8009040:	68f9      	ldr	r1, [r7, #12]
 8009042:	693a      	ldr	r2, [r7, #16]
 8009044:	697b      	ldr	r3, [r7, #20]
 8009046:	2527      	movs	r5, #39	; 0x27
 8009048:	197c      	adds	r4, r7, r5
 800904a:	6878      	ldr	r0, [r7, #4]
 800904c:	f000 fc90 	bl	8009970 <VL53L1_set_timeouts_us>
 8009050:	0003      	movs	r3, r0
 8009052:	7023      	strb	r3, [r4, #0]
			MmTimeoutUs, TimingBudget);

		if (Status == VL53L1_ERROR_NONE)
 8009054:	197b      	adds	r3, r7, r5
 8009056:	781b      	ldrb	r3, [r3, #0]
 8009058:	b25b      	sxtb	r3, r3
 800905a:	2b00      	cmp	r3, #0
 800905c:	d102      	bne.n	8009064 <ChangePresetMode+0x100>
			VL53L1DevDataSet(Dev, LLData.range_config_timeout_us,
 800905e:	697a      	ldr	r2, [r7, #20]
 8009060:	687b      	ldr	r3, [r7, #4]
 8009062:	611a      	str	r2, [r3, #16]
				TimingBudget);
	}

	if (Status == VL53L1_ERROR_NONE)
 8009064:	2327      	movs	r3, #39	; 0x27
 8009066:	18fb      	adds	r3, r7, r3
 8009068:	781b      	ldrb	r3, [r3, #0]
 800906a:	b25b      	sxtb	r3, r3
 800906c:	2b00      	cmp	r3, #0
 800906e:	d10a      	bne.n	8009086 <ChangePresetMode+0x122>
		Status = VL53L1_set_user_zone(Dev, &user_zone);
 8009070:	2327      	movs	r3, #39	; 0x27
 8009072:	18fc      	adds	r4, r7, r3
 8009074:	2318      	movs	r3, #24
 8009076:	18fa      	adds	r2, r7, r3
 8009078:	687b      	ldr	r3, [r7, #4]
 800907a:	0011      	movs	r1, r2
 800907c:	0018      	movs	r0, r3
 800907e:	f000 fd94 	bl	8009baa <VL53L1_set_user_zone>
 8009082:	0003      	movs	r3, r0
 8009084:	7023      	strb	r3, [r4, #0]

	if (Status == VL53L1_ERROR_NONE) {
 8009086:	2327      	movs	r3, #39	; 0x27
 8009088:	18fb      	adds	r3, r7, r3
 800908a:	781b      	ldrb	r3, [r3, #0]
 800908c:	b25b      	sxtb	r3, r3
 800908e:	2b00      	cmp	r3, #0
 8009090:	d10f      	bne.n	80090b2 <ChangePresetMode+0x14e>
		DeviceMeasurementMode = VL53L1DevDataGet(Dev,
 8009092:	211f      	movs	r1, #31
 8009094:	187b      	adds	r3, r7, r1
 8009096:	687a      	ldr	r2, [r7, #4]
 8009098:	7892      	ldrb	r2, [r2, #2]
 800909a:	701a      	strb	r2, [r3, #0]
				LLData.measurement_mode);

		Status = VL53L1_init_and_start_range(
 800909c:	2327      	movs	r3, #39	; 0x27
 800909e:	18fc      	adds	r4, r7, r3
 80090a0:	187b      	adds	r3, r7, r1
 80090a2:	7819      	ldrb	r1, [r3, #0]
 80090a4:	687b      	ldr	r3, [r7, #4]
 80090a6:	2206      	movs	r2, #6
 80090a8:	0018      	movs	r0, r3
 80090aa:	f001 f869 	bl	800a180 <VL53L1_init_and_start_range>
 80090ae:	0003      	movs	r3, r0
 80090b0:	7023      	strb	r3, [r4, #0]
				Dev,
				DeviceMeasurementMode,
				VL53L1_DEVICECONFIGLEVEL_FULL);
	}

	if (Status == VL53L1_ERROR_NONE)
 80090b2:	2327      	movs	r3, #39	; 0x27
 80090b4:	18fb      	adds	r3, r7, r3
 80090b6:	781b      	ldrb	r3, [r3, #0]
 80090b8:	b25b      	sxtb	r3, r3
 80090ba:	2b00      	cmp	r3, #0
 80090bc:	d105      	bne.n	80090ca <ChangePresetMode+0x166>
		VL53L1DevDataSet(Dev,
 80090be:	687b      	ldr	r3, [r7, #4]
 80090c0:	2225      	movs	r2, #37	; 0x25
 80090c2:	18ba      	adds	r2, r7, r2
 80090c4:	4906      	ldr	r1, [pc, #24]	; (80090e0 <ChangePresetMode+0x17c>)
 80090c6:	7812      	ldrb	r2, [r2, #0]
 80090c8:	545a      	strb	r2, [r3, r1]
			CurrentParameters.InternalDistanceMode,
			NewDistanceMode);

	LOG_FUNCTION_END(Status);
	return Status;
 80090ca:	2327      	movs	r3, #39	; 0x27
 80090cc:	18fb      	adds	r3, r7, r3
 80090ce:	781b      	ldrb	r3, [r3, #0]
 80090d0:	b25b      	sxtb	r3, r3
}
 80090d2:	0018      	movs	r0, r3
 80090d4:	46bd      	mov	sp, r7
 80090d6:	b00a      	add	sp, #40	; 0x28
 80090d8:	bdb0      	pop	{r4, r5, r7, pc}
 80090da:	46c0      	nop			; (mov r8, r8)
 80090dc:	0000037f 	.word	0x0000037f
 80090e0:	0000037e 	.word	0x0000037e

080090e4 <VL53L1_ClearInterruptAndStartMeasurement>:


VL53L1_Error VL53L1_ClearInterruptAndStartMeasurement(VL53L1_DEV Dev)
{
 80090e4:	b590      	push	{r4, r7, lr}
 80090e6:	b085      	sub	sp, #20
 80090e8:	af00      	add	r7, sp, #0
 80090ea:	6078      	str	r0, [r7, #4]
	VL53L1_Error Status = VL53L1_ERROR_NONE;
 80090ec:	230f      	movs	r3, #15
 80090ee:	18fb      	adds	r3, r7, r3
 80090f0:	2200      	movs	r2, #0
 80090f2:	701a      	strb	r2, [r3, #0]
	VL53L1_DistanceModes InternalDistanceMode;
	VL53L1_DistanceModes NewDistanceMode;

	LOG_FUNCTION_START("");

	DeviceMeasurementMode = VL53L1DevDataGet(Dev, LLData.measurement_mode);
 80090f4:	230e      	movs	r3, #14
 80090f6:	18fb      	adds	r3, r7, r3
 80090f8:	687a      	ldr	r2, [r7, #4]
 80090fa:	7892      	ldrb	r2, [r2, #2]
 80090fc:	701a      	strb	r2, [r3, #0]
	InternalDistanceMode = VL53L1DevDataGet(Dev,
 80090fe:	200d      	movs	r0, #13
 8009100:	183b      	adds	r3, r7, r0
 8009102:	687a      	ldr	r2, [r7, #4]
 8009104:	4915      	ldr	r1, [pc, #84]	; (800915c <VL53L1_ClearInterruptAndStartMeasurement+0x78>)
 8009106:	5c52      	ldrb	r2, [r2, r1]
 8009108:	701a      	strb	r2, [r3, #0]
			CurrentParameters.InternalDistanceMode);
	NewDistanceMode = VL53L1DevDataGet(Dev,
 800910a:	240c      	movs	r4, #12
 800910c:	193b      	adds	r3, r7, r4
 800910e:	687a      	ldr	r2, [r7, #4]
 8009110:	4913      	ldr	r1, [pc, #76]	; (8009160 <VL53L1_ClearInterruptAndStartMeasurement+0x7c>)
 8009112:	5c52      	ldrb	r2, [r2, r1]
 8009114:	701a      	strb	r2, [r3, #0]
			CurrentParameters.NewDistanceMode);

	if (NewDistanceMode != InternalDistanceMode)
 8009116:	193a      	adds	r2, r7, r4
 8009118:	183b      	adds	r3, r7, r0
 800911a:	7812      	ldrb	r2, [r2, #0]
 800911c:	781b      	ldrb	r3, [r3, #0]
 800911e:	429a      	cmp	r2, r3
 8009120:	d008      	beq.n	8009134 <VL53L1_ClearInterruptAndStartMeasurement+0x50>
		Status = ChangePresetMode(Dev);
 8009122:	230f      	movs	r3, #15
 8009124:	18fc      	adds	r4, r7, r3
 8009126:	687b      	ldr	r3, [r7, #4]
 8009128:	0018      	movs	r0, r3
 800912a:	f7ff ff1b 	bl	8008f64 <ChangePresetMode>
 800912e:	0003      	movs	r3, r0
 8009130:	7023      	strb	r3, [r4, #0]
 8009132:	e00b      	b.n	800914c <VL53L1_ClearInterruptAndStartMeasurement+0x68>
	else
		Status = VL53L1_clear_interrupt_and_enable_next_range(
 8009134:	230f      	movs	r3, #15
 8009136:	18fc      	adds	r4, r7, r3
 8009138:	230e      	movs	r3, #14
 800913a:	18fb      	adds	r3, r7, r3
 800913c:	781a      	ldrb	r2, [r3, #0]
 800913e:	687b      	ldr	r3, [r7, #4]
 8009140:	0011      	movs	r1, r2
 8009142:	0018      	movs	r0, r3
 8009144:	f001 fd40 	bl	800abc8 <VL53L1_clear_interrupt_and_enable_next_range>
 8009148:	0003      	movs	r3, r0
 800914a:	7023      	strb	r3, [r4, #0]
						Dev,
						DeviceMeasurementMode);

	LOG_FUNCTION_END(Status);
	return Status;
 800914c:	230f      	movs	r3, #15
 800914e:	18fb      	adds	r3, r7, r3
 8009150:	781b      	ldrb	r3, [r3, #0]
 8009152:	b25b      	sxtb	r3, r3
}
 8009154:	0018      	movs	r0, r3
 8009156:	46bd      	mov	sp, r7
 8009158:	b005      	add	sp, #20
 800915a:	bd90      	pop	{r4, r7, pc}
 800915c:	0000037e 	.word	0x0000037e
 8009160:	0000037f 	.word	0x0000037f

08009164 <VL53L1_WaitMeasurementDataReady>:
	LOG_FUNCTION_END(Status);
	return Status;
}

VL53L1_Error VL53L1_WaitMeasurementDataReady(VL53L1_DEV Dev)
{
 8009164:	b5b0      	push	{r4, r5, r7, lr}
 8009166:	b084      	sub	sp, #16
 8009168:	af00      	add	r7, sp, #0
 800916a:	6078      	str	r0, [r7, #4]
	VL53L1_Error Status = VL53L1_ERROR_NONE;
 800916c:	250f      	movs	r5, #15
 800916e:	197b      	adds	r3, r7, r5
 8009170:	2200      	movs	r2, #0
 8009172:	701a      	strb	r2, [r3, #0]

	/* Note that the timeout is given by:
	* VL53L1_RANGE_COMPLETION_POLLING_TIMEOUT_MS defined in def.h
	*/

	Status = VL53L1_poll_for_range_completion(Dev,
 8009174:	197c      	adds	r4, r7, r5
 8009176:	23fa      	movs	r3, #250	; 0xfa
 8009178:	00da      	lsls	r2, r3, #3
 800917a:	687b      	ldr	r3, [r7, #4]
 800917c:	0011      	movs	r1, r2
 800917e:	0018      	movs	r0, r3
 8009180:	f004 ff65 	bl	800e04e <VL53L1_poll_for_range_completion>
 8009184:	0003      	movs	r3, r0
 8009186:	7023      	strb	r3, [r4, #0]
			VL53L1_RANGE_COMPLETION_POLLING_TIMEOUT_MS);

	LOG_FUNCTION_END(Status);
	return Status;
 8009188:	197b      	adds	r3, r7, r5
 800918a:	781b      	ldrb	r3, [r3, #0]
 800918c:	b25b      	sxtb	r3, r3
}
 800918e:	0018      	movs	r0, r3
 8009190:	46bd      	mov	sp, r7
 8009192:	b004      	add	sp, #16
 8009194:	bdb0      	pop	{r4, r5, r7, pc}
	...

08009198 <ComputeRQL>:


static uint8_t ComputeRQL(uint8_t active_results,
		uint8_t FilteredRangeStatus,
		VL53L1_range_data_t *presults_data)
{
 8009198:	b580      	push	{r7, lr}
 800919a:	b08c      	sub	sp, #48	; 0x30
 800919c:	af00      	add	r7, sp, #0
 800919e:	603a      	str	r2, [r7, #0]
 80091a0:	1dfb      	adds	r3, r7, #7
 80091a2:	1c02      	adds	r2, r0, #0
 80091a4:	701a      	strb	r2, [r3, #0]
 80091a6:	1dbb      	adds	r3, r7, #6
 80091a8:	1c0a      	adds	r2, r1, #0
 80091aa:	701a      	strb	r2, [r3, #0]
	int16_t SRL = 300;
 80091ac:	2324      	movs	r3, #36	; 0x24
 80091ae:	18fb      	adds	r3, r7, r3
 80091b0:	2296      	movs	r2, #150	; 0x96
 80091b2:	0052      	lsls	r2, r2, #1
 80091b4:	801a      	strh	r2, [r3, #0]
	uint16_t SRAS = 30;
 80091b6:	2322      	movs	r3, #34	; 0x22
 80091b8:	18fb      	adds	r3, r7, r3
 80091ba:	221e      	movs	r2, #30
 80091bc:	801a      	strh	r2, [r3, #0]
	FixPoint1616_t RAS;
	FixPoint1616_t SRQL;
	FixPoint1616_t GI =   7713587; /* 117.7 * 65536 */
 80091be:	4b39      	ldr	r3, [pc, #228]	; (80092a4 <ComputeRQL+0x10c>)
 80091c0:	61fb      	str	r3, [r7, #28]
	FixPoint1616_t GGm =  3198157; /* 48.8 * 65536 */
 80091c2:	4b39      	ldr	r3, [pc, #228]	; (80092a8 <ComputeRQL+0x110>)
 80091c4:	61bb      	str	r3, [r7, #24]
	FixPoint1616_t LRAP = 6554;    /* 0.1 * 65536 */
 80091c6:	4b39      	ldr	r3, [pc, #228]	; (80092ac <ComputeRQL+0x114>)
 80091c8:	617b      	str	r3, [r7, #20]
	FixPoint1616_t partial;
	uint8_t finalvalue;
	uint8_t returnvalue;

	if (active_results == 0)
 80091ca:	1dfb      	adds	r3, r7, #7
 80091cc:	781b      	ldrb	r3, [r3, #0]
 80091ce:	2b00      	cmp	r3, #0
 80091d0:	d104      	bne.n	80091dc <ComputeRQL+0x44>
		returnvalue = 0;
 80091d2:	2327      	movs	r3, #39	; 0x27
 80091d4:	18fb      	adds	r3, r7, r3
 80091d6:	2200      	movs	r2, #0
 80091d8:	701a      	strb	r2, [r3, #0]
 80091da:	e05b      	b.n	8009294 <ComputeRQL+0xfc>
	else if (FilteredRangeStatus == VL53L1_DEVICEERROR_PHASECONSISTENCY)
 80091dc:	1dbb      	adds	r3, r7, #6
 80091de:	781b      	ldrb	r3, [r3, #0]
 80091e0:	2b07      	cmp	r3, #7
 80091e2:	d104      	bne.n	80091ee <ComputeRQL+0x56>
		returnvalue = 50;
 80091e4:	2327      	movs	r3, #39	; 0x27
 80091e6:	18fb      	adds	r3, r7, r3
 80091e8:	2232      	movs	r2, #50	; 0x32
 80091ea:	701a      	strb	r2, [r3, #0]
 80091ec:	e052      	b.n	8009294 <ComputeRQL+0xfc>
	else {
		if (presults_data->median_range_mm < SRL)
 80091ee:	683b      	ldr	r3, [r7, #0]
 80091f0:	223c      	movs	r2, #60	; 0x3c
 80091f2:	5e9b      	ldrsh	r3, [r3, r2]
 80091f4:	2224      	movs	r2, #36	; 0x24
 80091f6:	18ba      	adds	r2, r7, r2
 80091f8:	2100      	movs	r1, #0
 80091fa:	5e52      	ldrsh	r2, [r2, r1]
 80091fc:	429a      	cmp	r2, r3
 80091fe:	dd05      	ble.n	800920c <ComputeRQL+0x74>
			RAS = SRAS * 65536;
 8009200:	2322      	movs	r3, #34	; 0x22
 8009202:	18fb      	adds	r3, r7, r3
 8009204:	881b      	ldrh	r3, [r3, #0]
 8009206:	041b      	lsls	r3, r3, #16
 8009208:	62fb      	str	r3, [r7, #44]	; 0x2c
 800920a:	e006      	b.n	800921a <ComputeRQL+0x82>
		else
			RAS = LRAP * presults_data->median_range_mm;
 800920c:	683b      	ldr	r3, [r7, #0]
 800920e:	223c      	movs	r2, #60	; 0x3c
 8009210:	5e9b      	ldrsh	r3, [r3, r2]
 8009212:	001a      	movs	r2, r3
 8009214:	697b      	ldr	r3, [r7, #20]
 8009216:	4353      	muls	r3, r2
 8009218:	62fb      	str	r3, [r7, #44]	; 0x2c

		/* Fix1616 + (fix1616 * uint16_t / fix1616) * 65536 = fix1616 */
		if (RAS != 0) {
 800921a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800921c:	2b00      	cmp	r3, #0
 800921e:	d020      	beq.n	8009262 <ComputeRQL+0xca>
			partial = (GGm * presults_data->sigma_mm);
 8009220:	683b      	ldr	r3, [r7, #0]
 8009222:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8009224:	001a      	movs	r2, r3
 8009226:	69bb      	ldr	r3, [r7, #24]
 8009228:	4353      	muls	r3, r2
 800922a:	613b      	str	r3, [r7, #16]
			partial = partial + (RAS >> 1);
 800922c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800922e:	085b      	lsrs	r3, r3, #1
 8009230:	693a      	ldr	r2, [r7, #16]
 8009232:	18d3      	adds	r3, r2, r3
 8009234:	613b      	str	r3, [r7, #16]
			partial = partial / RAS;
 8009236:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8009238:	6938      	ldr	r0, [r7, #16]
 800923a:	f7f6 ff77 	bl	800012c <__udivsi3>
 800923e:	0003      	movs	r3, r0
 8009240:	613b      	str	r3, [r7, #16]
			partial = partial * 65536;
 8009242:	693b      	ldr	r3, [r7, #16]
 8009244:	041b      	lsls	r3, r3, #16
 8009246:	613b      	str	r3, [r7, #16]
			if (partial <= GI)
 8009248:	693a      	ldr	r2, [r7, #16]
 800924a:	69fb      	ldr	r3, [r7, #28]
 800924c:	429a      	cmp	r2, r3
 800924e:	d804      	bhi.n	800925a <ComputeRQL+0xc2>
				SRQL = GI - partial;
 8009250:	69fa      	ldr	r2, [r7, #28]
 8009252:	693b      	ldr	r3, [r7, #16]
 8009254:	1ad3      	subs	r3, r2, r3
 8009256:	62bb      	str	r3, [r7, #40]	; 0x28
 8009258:	e006      	b.n	8009268 <ComputeRQL+0xd0>
			else
				SRQL = 50 * 65536;
 800925a:	23c8      	movs	r3, #200	; 0xc8
 800925c:	039b      	lsls	r3, r3, #14
 800925e:	62bb      	str	r3, [r7, #40]	; 0x28
 8009260:	e002      	b.n	8009268 <ComputeRQL+0xd0>
		} else
			SRQL = 100 * 65536;
 8009262:	23c8      	movs	r3, #200	; 0xc8
 8009264:	03db      	lsls	r3, r3, #15
 8009266:	62bb      	str	r3, [r7, #40]	; 0x28

		finalvalue = (uint8_t)(SRQL >> 16);
 8009268:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800926a:	0c1a      	lsrs	r2, r3, #16
 800926c:	210f      	movs	r1, #15
 800926e:	187b      	adds	r3, r7, r1
 8009270:	701a      	strb	r2, [r3, #0]
		returnvalue = MAX(50, MIN(100, finalvalue));
 8009272:	187b      	adds	r3, r7, r1
 8009274:	781b      	ldrb	r3, [r3, #0]
 8009276:	2b32      	cmp	r3, #50	; 0x32
 8009278:	d908      	bls.n	800928c <ComputeRQL+0xf4>
 800927a:	230f      	movs	r3, #15
 800927c:	18fb      	adds	r3, r7, r3
 800927e:	781b      	ldrb	r3, [r3, #0]
 8009280:	b2da      	uxtb	r2, r3
 8009282:	2a64      	cmp	r2, #100	; 0x64
 8009284:	d900      	bls.n	8009288 <ComputeRQL+0xf0>
 8009286:	2364      	movs	r3, #100	; 0x64
 8009288:	b2da      	uxtb	r2, r3
 800928a:	e000      	b.n	800928e <ComputeRQL+0xf6>
 800928c:	2232      	movs	r2, #50	; 0x32
 800928e:	2327      	movs	r3, #39	; 0x27
 8009290:	18fb      	adds	r3, r7, r3
 8009292:	701a      	strb	r2, [r3, #0]
	}

	return returnvalue;
 8009294:	2327      	movs	r3, #39	; 0x27
 8009296:	18fb      	adds	r3, r7, r3
 8009298:	781b      	ldrb	r3, [r3, #0]
}
 800929a:	0018      	movs	r0, r3
 800929c:	46bd      	mov	sp, r7
 800929e:	b00c      	add	sp, #48	; 0x30
 80092a0:	bd80      	pop	{r7, pc}
 80092a2:	46c0      	nop			; (mov r8, r8)
 80092a4:	0075b333 	.word	0x0075b333
 80092a8:	0030cccd 	.word	0x0030cccd
 80092ac:	0000199a 	.word	0x0000199a

080092b0 <ConvertStatusLite>:


static uint8_t ConvertStatusLite(uint8_t FilteredRangeStatus)
{
 80092b0:	b580      	push	{r7, lr}
 80092b2:	b084      	sub	sp, #16
 80092b4:	af00      	add	r7, sp, #0
 80092b6:	0002      	movs	r2, r0
 80092b8:	1dfb      	adds	r3, r7, #7
 80092ba:	701a      	strb	r2, [r3, #0]
	uint8_t RangeStatus;

	switch (FilteredRangeStatus) {
 80092bc:	1dfb      	adds	r3, r7, #7
 80092be:	781b      	ldrb	r3, [r3, #0]
 80092c0:	3b04      	subs	r3, #4
 80092c2:	2b0f      	cmp	r3, #15
 80092c4:	d831      	bhi.n	800932a <ConvertStatusLite+0x7a>
 80092c6:	009a      	lsls	r2, r3, #2
 80092c8:	4b1d      	ldr	r3, [pc, #116]	; (8009340 <ConvertStatusLite+0x90>)
 80092ca:	18d3      	adds	r3, r2, r3
 80092cc:	681b      	ldr	r3, [r3, #0]
 80092ce:	469f      	mov	pc, r3
	case VL53L1_DEVICEERROR_GPHSTREAMCOUNT0READY:
		RangeStatus = VL53L1_RANGESTATUS_SYNCRONISATION_INT;
 80092d0:	230f      	movs	r3, #15
 80092d2:	18fb      	adds	r3, r7, r3
 80092d4:	220a      	movs	r2, #10
 80092d6:	701a      	strb	r2, [r3, #0]
		break;
 80092d8:	e02b      	b.n	8009332 <ConvertStatusLite+0x82>
	case VL53L1_DEVICEERROR_RANGECOMPLETE_NO_WRAP_CHECK:
		RangeStatus = VL53L1_RANGESTATUS_RANGE_VALID_NO_WRAP_CHECK_FAIL;
 80092da:	230f      	movs	r3, #15
 80092dc:	18fb      	adds	r3, r7, r3
 80092de:	2206      	movs	r2, #6
 80092e0:	701a      	strb	r2, [r3, #0]
		break;
 80092e2:	e026      	b.n	8009332 <ConvertStatusLite+0x82>
	case VL53L1_DEVICEERROR_RANGEPHASECHECK:
		RangeStatus = VL53L1_RANGESTATUS_OUTOFBOUNDS_FAIL;
 80092e4:	230f      	movs	r3, #15
 80092e6:	18fb      	adds	r3, r7, r3
 80092e8:	2204      	movs	r2, #4
 80092ea:	701a      	strb	r2, [r3, #0]
		break;
 80092ec:	e021      	b.n	8009332 <ConvertStatusLite+0x82>
	case VL53L1_DEVICEERROR_MSRCNOTARGET:
		RangeStatus = VL53L1_RANGESTATUS_SIGNAL_FAIL;
 80092ee:	230f      	movs	r3, #15
 80092f0:	18fb      	adds	r3, r7, r3
 80092f2:	2202      	movs	r2, #2
 80092f4:	701a      	strb	r2, [r3, #0]
		break;
 80092f6:	e01c      	b.n	8009332 <ConvertStatusLite+0x82>
	case VL53L1_DEVICEERROR_SIGMATHRESHOLDCHECK:
		RangeStatus = VL53L1_RANGESTATUS_SIGMA_FAIL;
 80092f8:	230f      	movs	r3, #15
 80092fa:	18fb      	adds	r3, r7, r3
 80092fc:	2201      	movs	r2, #1
 80092fe:	701a      	strb	r2, [r3, #0]
		break;
 8009300:	e017      	b.n	8009332 <ConvertStatusLite+0x82>
	case VL53L1_DEVICEERROR_PHASECONSISTENCY:
		RangeStatus = VL53L1_RANGESTATUS_WRAP_TARGET_FAIL;
 8009302:	230f      	movs	r3, #15
 8009304:	18fb      	adds	r3, r7, r3
 8009306:	2207      	movs	r2, #7
 8009308:	701a      	strb	r2, [r3, #0]
		break;
 800930a:	e012      	b.n	8009332 <ConvertStatusLite+0x82>
	case VL53L1_DEVICEERROR_RANGEIGNORETHRESHOLD:
		RangeStatus = VL53L1_RANGESTATUS_XTALK_SIGNAL_FAIL;
 800930c:	230f      	movs	r3, #15
 800930e:	18fb      	adds	r3, r7, r3
 8009310:	2209      	movs	r2, #9
 8009312:	701a      	strb	r2, [r3, #0]
		break;
 8009314:	e00d      	b.n	8009332 <ConvertStatusLite+0x82>
	case VL53L1_DEVICEERROR_MINCLIP:
		RangeStatus = VL53L1_RANGESTATUS_RANGE_VALID_MIN_RANGE_CLIPPED;
 8009316:	230f      	movs	r3, #15
 8009318:	18fb      	adds	r3, r7, r3
 800931a:	2203      	movs	r2, #3
 800931c:	701a      	strb	r2, [r3, #0]
		break;
 800931e:	e008      	b.n	8009332 <ConvertStatusLite+0x82>
	case VL53L1_DEVICEERROR_RANGECOMPLETE:
		RangeStatus = VL53L1_RANGESTATUS_RANGE_VALID;
 8009320:	230f      	movs	r3, #15
 8009322:	18fb      	adds	r3, r7, r3
 8009324:	2200      	movs	r2, #0
 8009326:	701a      	strb	r2, [r3, #0]
		break;
 8009328:	e003      	b.n	8009332 <ConvertStatusLite+0x82>
	default:
		RangeStatus = VL53L1_RANGESTATUS_NONE;
 800932a:	230f      	movs	r3, #15
 800932c:	18fb      	adds	r3, r7, r3
 800932e:	22ff      	movs	r2, #255	; 0xff
 8009330:	701a      	strb	r2, [r3, #0]
	}

	return RangeStatus;
 8009332:	230f      	movs	r3, #15
 8009334:	18fb      	adds	r3, r7, r3
 8009336:	781b      	ldrb	r3, [r3, #0]
}
 8009338:	0018      	movs	r0, r3
 800933a:	46bd      	mov	sp, r7
 800933c:	b004      	add	sp, #16
 800933e:	bd80      	pop	{r7, pc}
 8009340:	08014f3c 	.word	0x08014f3c

08009344 <SetSimpleData>:

static VL53L1_Error SetSimpleData(VL53L1_DEV Dev,
	uint8_t active_results, uint8_t device_status,
	VL53L1_range_data_t *presults_data,
	VL53L1_RangingMeasurementData_t *pRangeData)
{
 8009344:	b5b0      	push	{r4, r5, r7, lr}
 8009346:	b08c      	sub	sp, #48	; 0x30
 8009348:	af00      	add	r7, sp, #0
 800934a:	60f8      	str	r0, [r7, #12]
 800934c:	0008      	movs	r0, r1
 800934e:	0011      	movs	r1, r2
 8009350:	607b      	str	r3, [r7, #4]
 8009352:	240b      	movs	r4, #11
 8009354:	193b      	adds	r3, r7, r4
 8009356:	1c02      	adds	r2, r0, #0
 8009358:	701a      	strb	r2, [r3, #0]
 800935a:	250a      	movs	r5, #10
 800935c:	197b      	adds	r3, r7, r5
 800935e:	1c0a      	adds	r2, r1, #0
 8009360:	701a      	strb	r2, [r3, #0]
	VL53L1_Error Status = VL53L1_ERROR_NONE;
 8009362:	232f      	movs	r3, #47	; 0x2f
 8009364:	18fb      	adds	r3, r7, r3
 8009366:	2200      	movs	r2, #0
 8009368:	701a      	strb	r2, [r3, #0]
	FixPoint1616_t SignalRate;
	FixPoint1616_t TempFix1616;
	FixPoint1616_t LimitCheckValue;
	int16_t Range;

	pRangeData->TimeStamp = presults_data->time_stamp;
 800936a:	687b      	ldr	r3, [r7, #4]
 800936c:	685a      	ldr	r2, [r3, #4]
 800936e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009370:	601a      	str	r2, [r3, #0]

	FilteredRangeStatus = presults_data->range_status & 0x1F;
 8009372:	687b      	ldr	r3, [r7, #4]
 8009374:	223e      	movs	r2, #62	; 0x3e
 8009376:	5c9a      	ldrb	r2, [r3, r2]
 8009378:	202e      	movs	r0, #46	; 0x2e
 800937a:	183b      	adds	r3, r7, r0
 800937c:	211f      	movs	r1, #31
 800937e:	400a      	ands	r2, r1
 8009380:	701a      	strb	r2, [r3, #0]

	pRangeData->RangeQualityLevel = ComputeRQL(active_results,
 8009382:	687a      	ldr	r2, [r7, #4]
 8009384:	183b      	adds	r3, r7, r0
 8009386:	7819      	ldrb	r1, [r3, #0]
 8009388:	193b      	adds	r3, r7, r4
 800938a:	781b      	ldrb	r3, [r3, #0]
 800938c:	0018      	movs	r0, r3
 800938e:	f7ff ff03 	bl	8009198 <ComputeRQL>
 8009392:	0003      	movs	r3, r0
 8009394:	001a      	movs	r2, r3
 8009396:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009398:	715a      	strb	r2, [r3, #5]
					FilteredRangeStatus,
					presults_data);

	SignalRate = VL53L1_FIXPOINT97TOFIXPOINT1616(
 800939a:	687b      	ldr	r3, [r7, #4]
 800939c:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 800939e:	025b      	lsls	r3, r3, #9
 80093a0:	62bb      	str	r3, [r7, #40]	; 0x28
		presults_data->peak_signal_count_rate_mcps);
	pRangeData->SignalRateRtnMegaCps
		= SignalRate;
 80093a2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80093a4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80093a6:	609a      	str	r2, [r3, #8]

	AmbientRate = VL53L1_FIXPOINT97TOFIXPOINT1616(
 80093a8:	687b      	ldr	r3, [r7, #4]
 80093aa:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 80093ac:	025b      	lsls	r3, r3, #9
 80093ae:	627b      	str	r3, [r7, #36]	; 0x24
		presults_data->ambient_count_rate_mcps);
	pRangeData->AmbientRateRtnMegaCps = AmbientRate;
 80093b0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80093b2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80093b4:	60da      	str	r2, [r3, #12]

	pRangeData->EffectiveSpadRtnCount =
		presults_data->actual_effective_spads;
 80093b6:	687b      	ldr	r3, [r7, #4]
 80093b8:	8a1a      	ldrh	r2, [r3, #16]
	pRangeData->EffectiveSpadRtnCount =
 80093ba:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80093bc:	821a      	strh	r2, [r3, #16]

	TempFix1616 = VL53L1_FIXPOINT97TOFIXPOINT1616(
 80093be:	687b      	ldr	r3, [r7, #4]
 80093c0:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 80093c2:	025b      	lsls	r3, r3, #9
 80093c4:	623b      	str	r3, [r7, #32]
			presults_data->sigma_mm);

	pRangeData->SigmaMilliMeter = TempFix1616;
 80093c6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80093c8:	6a3a      	ldr	r2, [r7, #32]
 80093ca:	615a      	str	r2, [r3, #20]

	pRangeData->RangeMilliMeter = presults_data->median_range_mm;
 80093cc:	687b      	ldr	r3, [r7, #4]
 80093ce:	223c      	movs	r2, #60	; 0x3c
 80093d0:	5e9a      	ldrsh	r2, [r3, r2]
 80093d2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80093d4:	831a      	strh	r2, [r3, #24]

	pRangeData->RangeFractionalPart = 0;
 80093d6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80093d8:	2200      	movs	r2, #0
 80093da:	769a      	strb	r2, [r3, #26]

	/* Treat device error status first */
	switch (device_status) {
 80093dc:	197b      	adds	r3, r7, r5
 80093de:	781b      	ldrb	r3, [r3, #0]
 80093e0:	2b0d      	cmp	r3, #13
 80093e2:	d00a      	beq.n	80093fa <SetSimpleData+0xb6>
 80093e4:	dc03      	bgt.n	80093ee <SetSimpleData+0xaa>
 80093e6:	3b01      	subs	r3, #1
 80093e8:	2b02      	cmp	r3, #2
 80093ea:	d80a      	bhi.n	8009402 <SetSimpleData+0xbe>
 80093ec:	e001      	b.n	80093f2 <SetSimpleData+0xae>
 80093ee:	2b11      	cmp	r3, #17
 80093f0:	d107      	bne.n	8009402 <SetSimpleData+0xbe>
	case VL53L1_DEVICEERROR_MULTCLIPFAIL:
	case VL53L1_DEVICEERROR_VCSELWATCHDOGTESTFAILURE:
	case VL53L1_DEVICEERROR_VCSELCONTINUITYTESTFAILURE:
	case VL53L1_DEVICEERROR_NOVHVVALUEFOUND:
		pRangeData->RangeStatus = VL53L1_RANGESTATUS_HARDWARE_FAIL;
 80093f2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80093f4:	2205      	movs	r2, #5
 80093f6:	76da      	strb	r2, [r3, #27]
		break;
 80093f8:	e006      	b.n	8009408 <SetSimpleData+0xc4>
	case VL53L1_DEVICEERROR_USERROICLIP:
		pRangeData->RangeStatus = VL53L1_RANGESTATUS_MIN_RANGE_FAIL;
 80093fa:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80093fc:	220d      	movs	r2, #13
 80093fe:	76da      	strb	r2, [r3, #27]
		break;
 8009400:	e002      	b.n	8009408 <SetSimpleData+0xc4>
	default:
		pRangeData->RangeStatus = VL53L1_RANGESTATUS_RANGE_VALID;
 8009402:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009404:	2200      	movs	r2, #0
 8009406:	76da      	strb	r2, [r3, #27]
	}

	/* Now deal with range status according to the ranging preset */
	if (pRangeData->RangeStatus == VL53L1_RANGESTATUS_RANGE_VALID) {
 8009408:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800940a:	7edb      	ldrb	r3, [r3, #27]
 800940c:	2b00      	cmp	r3, #0
 800940e:	d109      	bne.n	8009424 <SetSimpleData+0xe0>
			pRangeData->RangeStatus =
				ConvertStatusLite(FilteredRangeStatus);
 8009410:	232e      	movs	r3, #46	; 0x2e
 8009412:	18fb      	adds	r3, r7, r3
 8009414:	781b      	ldrb	r3, [r3, #0]
 8009416:	0018      	movs	r0, r3
 8009418:	f7ff ff4a 	bl	80092b0 <ConvertStatusLite>
 800941c:	0003      	movs	r3, r0
 800941e:	001a      	movs	r2, r3
			pRangeData->RangeStatus =
 8009420:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009422:	76da      	strb	r2, [r3, #27]
	}

	/* Update current Limit Check */
	TempFix1616 = VL53L1_FIXPOINT97TOFIXPOINT1616(
 8009424:	687b      	ldr	r3, [r7, #4]
 8009426:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8009428:	025b      	lsls	r3, r3, #9
 800942a:	623b      	str	r3, [r7, #32]
			presults_data->sigma_mm);
	VL53L1_SETARRAYPARAMETERFIELD(Dev,
 800942c:	68fa      	ldr	r2, [r7, #12]
 800942e:	23e4      	movs	r3, #228	; 0xe4
 8009430:	009b      	lsls	r3, r3, #2
 8009432:	6a39      	ldr	r1, [r7, #32]
 8009434:	50d1      	str	r1, [r2, r3]
		LimitChecksCurrent, VL53L1_CHECKENABLE_SIGMA_FINAL_RANGE,
		TempFix1616);

	TempFix1616 = VL53L1_FIXPOINT97TOFIXPOINT1616(
 8009436:	687b      	ldr	r3, [r7, #4]
 8009438:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 800943a:	025b      	lsls	r3, r3, #9
 800943c:	623b      	str	r3, [r7, #32]
			presults_data->peak_signal_count_rate_mcps);
	VL53L1_SETARRAYPARAMETERFIELD(Dev,
 800943e:	68fa      	ldr	r2, [r7, #12]
 8009440:	23e5      	movs	r3, #229	; 0xe5
 8009442:	009b      	lsls	r3, r3, #2
 8009444:	6a39      	ldr	r1, [r7, #32]
 8009446:	50d1      	str	r1, [r2, r3]
		LimitChecksCurrent, VL53L1_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE,
		TempFix1616);

	/* Update Limit Check Status */
	/* Sigma */
	VL53L1_GetLimitCheckValue(Dev,
 8009448:	2314      	movs	r3, #20
 800944a:	18fa      	adds	r2, r7, r3
 800944c:	68fb      	ldr	r3, [r7, #12]
 800944e:	2100      	movs	r1, #0
 8009450:	0018      	movs	r0, r3
 8009452:	f7ff fbf8 	bl	8008c46 <VL53L1_GetLimitCheckValue>
			VL53L1_CHECKENABLE_SIGMA_FINAL_RANGE,
			&LimitCheckValue);

	SigmaLimitflag = (FilteredRangeStatus ==
			VL53L1_DEVICEERROR_SIGMATHRESHOLDCHECK)
			? 1 : 0;
 8009456:	232e      	movs	r3, #46	; 0x2e
 8009458:	18fb      	adds	r3, r7, r3
 800945a:	781b      	ldrb	r3, [r3, #0]
 800945c:	3b06      	subs	r3, #6
 800945e:	425a      	negs	r2, r3
 8009460:	4153      	adcs	r3, r2
 8009462:	b2da      	uxtb	r2, r3
	SigmaLimitflag = (FilteredRangeStatus ==
 8009464:	231f      	movs	r3, #31
 8009466:	18fb      	adds	r3, r7, r3
 8009468:	701a      	strb	r2, [r3, #0]

	VL53L1_GetLimitCheckEnable(Dev,
 800946a:	2419      	movs	r4, #25
 800946c:	193a      	adds	r2, r7, r4
 800946e:	68fb      	ldr	r3, [r7, #12]
 8009470:	2100      	movs	r1, #0
 8009472:	0018      	movs	r0, r3
 8009474:	f7ff fb62 	bl	8008b3c <VL53L1_GetLimitCheckEnable>
			VL53L1_CHECKENABLE_SIGMA_FINAL_RANGE,
			&Temp8Enable);

	Temp8 = ((Temp8Enable == 1) && (SigmaLimitflag == 1)) ? 1 : 0;
 8009478:	193b      	adds	r3, r7, r4
 800947a:	781b      	ldrb	r3, [r3, #0]
 800947c:	2b01      	cmp	r3, #1
 800947e:	d106      	bne.n	800948e <SetSimpleData+0x14a>
 8009480:	231f      	movs	r3, #31
 8009482:	18fb      	adds	r3, r7, r3
 8009484:	781b      	ldrb	r3, [r3, #0]
 8009486:	2b01      	cmp	r3, #1
 8009488:	d101      	bne.n	800948e <SetSimpleData+0x14a>
 800948a:	2201      	movs	r2, #1
 800948c:	e000      	b.n	8009490 <SetSimpleData+0x14c>
 800948e:	2200      	movs	r2, #0
 8009490:	211e      	movs	r1, #30
 8009492:	187b      	adds	r3, r7, r1
 8009494:	701a      	strb	r2, [r3, #0]
	VL53L1_SETARRAYPARAMETERFIELD(Dev, LimitChecksStatus,
 8009496:	68fb      	ldr	r3, [r7, #12]
 8009498:	187a      	adds	r2, r7, r1
 800949a:	492a      	ldr	r1, [pc, #168]	; (8009544 <SetSimpleData+0x200>)
 800949c:	7812      	ldrb	r2, [r2, #0]
 800949e:	545a      	strb	r2, [r3, r1]
			VL53L1_CHECKENABLE_SIGMA_FINAL_RANGE, Temp8);

	/* Signal Rate */
	VL53L1_GetLimitCheckValue(Dev,
 80094a0:	2314      	movs	r3, #20
 80094a2:	18fa      	adds	r2, r7, r3
 80094a4:	68fb      	ldr	r3, [r7, #12]
 80094a6:	2101      	movs	r1, #1
 80094a8:	0018      	movs	r0, r3
 80094aa:	f7ff fbcc 	bl	8008c46 <VL53L1_GetLimitCheckValue>
			VL53L1_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE,
			&LimitCheckValue);

	SignalLimitflag = (FilteredRangeStatus ==
			VL53L1_DEVICEERROR_MSRCNOTARGET)
			? 1 : 0;
 80094ae:	232e      	movs	r3, #46	; 0x2e
 80094b0:	18fb      	adds	r3, r7, r3
 80094b2:	781b      	ldrb	r3, [r3, #0]
 80094b4:	3b04      	subs	r3, #4
 80094b6:	425a      	negs	r2, r3
 80094b8:	4153      	adcs	r3, r2
 80094ba:	b2da      	uxtb	r2, r3
	SignalLimitflag = (FilteredRangeStatus ==
 80094bc:	231d      	movs	r3, #29
 80094be:	18fb      	adds	r3, r7, r3
 80094c0:	701a      	strb	r2, [r3, #0]

	VL53L1_GetLimitCheckEnable(Dev,
 80094c2:	2419      	movs	r4, #25
 80094c4:	193a      	adds	r2, r7, r4
 80094c6:	68fb      	ldr	r3, [r7, #12]
 80094c8:	2101      	movs	r1, #1
 80094ca:	0018      	movs	r0, r3
 80094cc:	f7ff fb36 	bl	8008b3c <VL53L1_GetLimitCheckEnable>
			VL53L1_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE,
			&Temp8Enable);

	Temp8 = ((Temp8Enable == 1) && (SignalLimitflag == 1)) ? 1 : 0;
 80094d0:	193b      	adds	r3, r7, r4
 80094d2:	781b      	ldrb	r3, [r3, #0]
 80094d4:	2b01      	cmp	r3, #1
 80094d6:	d106      	bne.n	80094e6 <SetSimpleData+0x1a2>
 80094d8:	231d      	movs	r3, #29
 80094da:	18fb      	adds	r3, r7, r3
 80094dc:	781b      	ldrb	r3, [r3, #0]
 80094de:	2b01      	cmp	r3, #1
 80094e0:	d101      	bne.n	80094e6 <SetSimpleData+0x1a2>
 80094e2:	2201      	movs	r2, #1
 80094e4:	e000      	b.n	80094e8 <SetSimpleData+0x1a4>
 80094e6:	2200      	movs	r2, #0
 80094e8:	211e      	movs	r1, #30
 80094ea:	187b      	adds	r3, r7, r1
 80094ec:	701a      	strb	r2, [r3, #0]
	VL53L1_SETARRAYPARAMETERFIELD(Dev, LimitChecksStatus,
 80094ee:	68fb      	ldr	r3, [r7, #12]
 80094f0:	187a      	adds	r2, r7, r1
 80094f2:	4915      	ldr	r1, [pc, #84]	; (8009548 <SetSimpleData+0x204>)
 80094f4:	7812      	ldrb	r2, [r2, #0]
 80094f6:	545a      	strb	r2, [r3, r1]
			VL53L1_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE, Temp8);

	Range = pRangeData->RangeMilliMeter;
 80094f8:	231a      	movs	r3, #26
 80094fa:	18fb      	adds	r3, r7, r3
 80094fc:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80094fe:	8b12      	ldrh	r2, [r2, #24]
 8009500:	801a      	strh	r2, [r3, #0]
	if ((pRangeData->RangeStatus == VL53L1_RANGESTATUS_RANGE_VALID) &&
 8009502:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009504:	7edb      	ldrb	r3, [r3, #27]
 8009506:	2b00      	cmp	r3, #0
 8009508:	d114      	bne.n	8009534 <SetSimpleData+0x1f0>
 800950a:	231a      	movs	r3, #26
 800950c:	18fb      	adds	r3, r7, r3
 800950e:	2200      	movs	r2, #0
 8009510:	5e9b      	ldrsh	r3, [r3, r2]
 8009512:	2b00      	cmp	r3, #0
 8009514:	da0e      	bge.n	8009534 <SetSimpleData+0x1f0>
		(Range < 0)) {
		if (Range < BDTable[VL53L1_TUNING_PROXY_MIN])
 8009516:	231a      	movs	r3, #26
 8009518:	18fb      	adds	r3, r7, r3
 800951a:	2200      	movs	r2, #0
 800951c:	5e9a      	ldrsh	r2, [r3, r2]
 800951e:	4b0b      	ldr	r3, [pc, #44]	; (800954c <SetSimpleData+0x208>)
 8009520:	685b      	ldr	r3, [r3, #4]
 8009522:	429a      	cmp	r2, r3
 8009524:	da03      	bge.n	800952e <SetSimpleData+0x1ea>
			pRangeData->RangeStatus =
 8009526:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009528:	220e      	movs	r2, #14
 800952a:	76da      	strb	r2, [r3, #27]
 800952c:	e002      	b.n	8009534 <SetSimpleData+0x1f0>
					VL53L1_RANGESTATUS_RANGE_INVALID;
		else
			pRangeData->RangeMilliMeter = 0;
 800952e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009530:	2200      	movs	r2, #0
 8009532:	831a      	strh	r2, [r3, #24]
	}

	return Status;
 8009534:	232f      	movs	r3, #47	; 0x2f
 8009536:	18fb      	adds	r3, r7, r3
 8009538:	781b      	ldrb	r3, [r3, #0]
 800953a:	b25b      	sxtb	r3, r3
}
 800953c:	0018      	movs	r0, r3
 800953e:	46bd      	mov	sp, r7
 8009540:	b00c      	add	sp, #48	; 0x30
 8009542:	bdb0      	pop	{r4, r5, r7, pc}
 8009544:	00000386 	.word	0x00000386
 8009548:	00000387 	.word	0x00000387
 800954c:	20000240 	.word	0x20000240

08009550 <VL53L1_GetRangingMeasurementData>:



VL53L1_Error VL53L1_GetRangingMeasurementData(VL53L1_DEV Dev,
	VL53L1_RangingMeasurementData_t *pRangingMeasurementData)
{
 8009550:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009552:	b0a9      	sub	sp, #164	; 0xa4
 8009554:	af02      	add	r7, sp, #8
 8009556:	6078      	str	r0, [r7, #4]
 8009558:	6039      	str	r1, [r7, #0]
	VL53L1_Error Status = VL53L1_ERROR_NONE;
 800955a:	2597      	movs	r5, #151	; 0x97
 800955c:	197b      	adds	r3, r7, r5
 800955e:	2200      	movs	r2, #0
 8009560:	701a      	strb	r2, [r3, #0]
	VL53L1_range_results_t       results;
	VL53L1_range_results_t       *presults = &results;
 8009562:	2308      	movs	r3, #8
 8009564:	18fb      	adds	r3, r7, r3
 8009566:	2690      	movs	r6, #144	; 0x90
 8009568:	19ba      	adds	r2, r7, r6
 800956a:	6013      	str	r3, [r2, #0]

	LOG_FUNCTION_START("");


	/* Clear Ranging Data */
	memset(pRangingMeasurementData, 0xFF,
 800956c:	683b      	ldr	r3, [r7, #0]
 800956e:	221c      	movs	r2, #28
 8009570:	21ff      	movs	r1, #255	; 0xff
 8009572:	0018      	movs	r0, r3
 8009574:	f009 fe2f 	bl	80131d6 <memset>
		sizeof(VL53L1_RangingMeasurementData_t));

	/* Get Ranging Data */
	Status = VL53L1_get_device_results(
 8009578:	197c      	adds	r4, r7, r5
 800957a:	19bb      	adds	r3, r7, r6
 800957c:	681a      	ldr	r2, [r3, #0]
 800957e:	687b      	ldr	r3, [r7, #4]
 8009580:	2102      	movs	r1, #2
 8009582:	0018      	movs	r0, r3
 8009584:	f001 fa7a 	bl	800aa7c <VL53L1_get_device_results>
 8009588:	0003      	movs	r3, r0
 800958a:	7023      	strb	r3, [r4, #0]
			Dev,
			VL53L1_DEVICERESULTSLEVEL_FULL,
			presults);

	if (Status == VL53L1_ERROR_NONE) {
 800958c:	197b      	adds	r3, r7, r5
 800958e:	781b      	ldrb	r3, [r3, #0]
 8009590:	b25b      	sxtb	r3, r3
 8009592:	2b00      	cmp	r3, #0
 8009594:	d11d      	bne.n	80095d2 <VL53L1_GetRangingMeasurementData+0x82>
		pRangingMeasurementData->StreamCount = presults->stream_count;
 8009596:	2290      	movs	r2, #144	; 0x90
 8009598:	0011      	movs	r1, r2
 800959a:	18bb      	adds	r3, r7, r2
 800959c:	681b      	ldr	r3, [r3, #0]
 800959e:	789a      	ldrb	r2, [r3, #2]
 80095a0:	683b      	ldr	r3, [r7, #0]
 80095a2:	711a      	strb	r2, [r3, #4]

		/* in case of lite ranging or autonomous the following function
		 * returns index = 0
		 */
		presults_data = &(presults->data[0]);
 80095a4:	000a      	movs	r2, r1
 80095a6:	18bb      	adds	r3, r7, r2
 80095a8:	681b      	ldr	r3, [r3, #0]
 80095aa:	3304      	adds	r3, #4
 80095ac:	218c      	movs	r1, #140	; 0x8c
 80095ae:	1878      	adds	r0, r7, r1
 80095b0:	6003      	str	r3, [r0, #0]
		Status = SetSimpleData(Dev, 1,
 80095b2:	18bb      	adds	r3, r7, r2
 80095b4:	681b      	ldr	r3, [r3, #0]
 80095b6:	78da      	ldrb	r2, [r3, #3]
 80095b8:	2397      	movs	r3, #151	; 0x97
 80095ba:	18fc      	adds	r4, r7, r3
 80095bc:	187b      	adds	r3, r7, r1
 80095be:	6819      	ldr	r1, [r3, #0]
 80095c0:	6878      	ldr	r0, [r7, #4]
 80095c2:	683b      	ldr	r3, [r7, #0]
 80095c4:	9300      	str	r3, [sp, #0]
 80095c6:	000b      	movs	r3, r1
 80095c8:	2101      	movs	r1, #1
 80095ca:	f7ff febb 	bl	8009344 <SetSimpleData>
 80095ce:	0003      	movs	r3, r0
 80095d0:	7023      	strb	r3, [r4, #0]
				presults_data,
				pRangingMeasurementData);
	}

	LOG_FUNCTION_END(Status);
	return Status;
 80095d2:	2397      	movs	r3, #151	; 0x97
 80095d4:	18fb      	adds	r3, r7, r3
 80095d6:	781b      	ldrb	r3, [r3, #0]
 80095d8:	b25b      	sxtb	r3, r3
}
 80095da:	0018      	movs	r0, r3
 80095dc:	46bd      	mov	sp, r7
 80095de:	b027      	add	sp, #156	; 0x9c
 80095e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

080095e4 <VL53L1_data_init>:


VL53L1_Error VL53L1_data_init(
	VL53L1_DEV        Dev,
	uint8_t           read_p2p_data)
{
 80095e4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80095e6:	b089      	sub	sp, #36	; 0x24
 80095e8:	af04      	add	r7, sp, #16
 80095ea:	6078      	str	r0, [r7, #4]
 80095ec:	000a      	movs	r2, r1
 80095ee:	1cfb      	adds	r3, r7, #3
 80095f0:	701a      	strb	r2, [r3, #0]
	/*
	 * Initialise pdev data structure
	 */

	VL53L1_Error status       = VL53L1_ERROR_NONE;
 80095f2:	230f      	movs	r3, #15
 80095f4:	18fb      	adds	r3, r7, r3
 80095f6:	2200      	movs	r2, #0
 80095f8:	701a      	strb	r2, [r3, #0]
	VL53L1_LLDriverData_t    *pdev =
 80095fa:	687b      	ldr	r3, [r7, #4]
 80095fc:	60bb      	str	r3, [r7, #8]
			VL53L1DevStructGetLLDriverHandle(Dev);

	VL53L1_init_ll_driver_state(
 80095fe:	687b      	ldr	r3, [r7, #4]
 8009600:	2162      	movs	r1, #98	; 0x62
 8009602:	0018      	movs	r0, r3
 8009604:	f002 fb47 	bl	800bc96 <VL53L1_init_ll_driver_state>
			Dev,
			VL53L1_DEVICESTATE_UNKNOWN);

	pdev->wait_method             = VL53L1_WAIT_METHOD_BLOCKING;
 8009608:	68bb      	ldr	r3, [r7, #8]
 800960a:	2200      	movs	r2, #0
 800960c:	701a      	strb	r2, [r3, #0]
	pdev->preset_mode             = VL53L1_DEVICEPRESETMODE_STANDARD_RANGING;
 800960e:	68bb      	ldr	r3, [r7, #8]
 8009610:	2201      	movs	r2, #1
 8009612:	705a      	strb	r2, [r3, #1]
	pdev->measurement_mode        = VL53L1_DEVICEMEASUREMENTMODE_STOP;
 8009614:	68bb      	ldr	r3, [r7, #8]
 8009616:	2200      	movs	r2, #0
 8009618:	709a      	strb	r2, [r3, #2]

	pdev->offset_calibration_mode =
 800961a:	68bb      	ldr	r3, [r7, #8]
 800961c:	2201      	movs	r2, #1
 800961e:	70da      	strb	r2, [r3, #3]
		VL53L1_OFFSETCALIBRATIONMODE__MM1_MM2__STANDARD;
	pdev->offset_correction_mode  =
 8009620:	68bb      	ldr	r3, [r7, #8]
 8009622:	2201      	movs	r2, #1
 8009624:	711a      	strb	r2, [r3, #4]
		VL53L1_OFFSETCORRECTIONMODE__MM1_MM2_OFFSETS;

	pdev->phasecal_config_timeout_us  =  1000;
 8009626:	68bb      	ldr	r3, [r7, #8]
 8009628:	22fa      	movs	r2, #250	; 0xfa
 800962a:	0092      	lsls	r2, r2, #2
 800962c:	609a      	str	r2, [r3, #8]
	pdev->mm_config_timeout_us        =  2000;
 800962e:	68bb      	ldr	r3, [r7, #8]
 8009630:	22fa      	movs	r2, #250	; 0xfa
 8009632:	00d2      	lsls	r2, r2, #3
 8009634:	60da      	str	r2, [r3, #12]
	pdev->range_config_timeout_us     = 13000;
 8009636:	68bb      	ldr	r3, [r7, #8]
 8009638:	4a45      	ldr	r2, [pc, #276]	; (8009750 <VL53L1_data_init+0x16c>)
 800963a:	611a      	str	r2, [r3, #16]
	pdev->inter_measurement_period_ms =   100;
 800963c:	68bb      	ldr	r3, [r7, #8]
 800963e:	2264      	movs	r2, #100	; 0x64
 8009640:	615a      	str	r2, [r3, #20]
	pdev->dss_config__target_total_rate_mcps = 0x0A00;
 8009642:	68bb      	ldr	r3, [r7, #8]
 8009644:	22a0      	movs	r2, #160	; 0xa0
 8009646:	0112      	lsls	r2, r2, #4
 8009648:	831a      	strh	r2, [r3, #24]
	pdev->debug_mode                  =  0x00;
 800964a:	68bb      	ldr	r3, [r7, #8]
 800964c:	2221      	movs	r2, #33	; 0x21
 800964e:	2100      	movs	r1, #0
 8009650:	5499      	strb	r1, [r3, r2]

	/* initialise gain calibration values to tuning parameter values */

	pdev->gain_cal.standard_ranging_gain_factor =
 8009652:	68bb      	ldr	r3, [r7, #8]
 8009654:	229c      	movs	r2, #156	; 0x9c
 8009656:	493f      	ldr	r1, [pc, #252]	; (8009754 <VL53L1_data_init+0x170>)
 8009658:	5299      	strh	r1, [r3, r2]
			VL53L1_TUNINGPARM_LITE_RANGING_GAIN_FACTOR_DEFAULT;

	/*
	 * Initialise version structure
	 */
	VL53L1_init_version(Dev);
 800965a:	687b      	ldr	r3, [r7, #4]
 800965c:	0018      	movs	r0, r3
 800965e:	f002 fb00 	bl	800bc62 <VL53L1_init_version>
	 *
	 *  Contains the key NVM data e.g identification info fast oscillator
	 *  freq, max trim and laser safety info
	 */

	if (read_p2p_data > 0 && status == VL53L1_ERROR_NONE) /*lint !e774 always true*/
 8009662:	1cfb      	adds	r3, r7, #3
 8009664:	781b      	ldrb	r3, [r3, #0]
 8009666:	2b00      	cmp	r3, #0
 8009668:	d00d      	beq.n	8009686 <VL53L1_data_init+0xa2>
 800966a:	230f      	movs	r3, #15
 800966c:	18fb      	adds	r3, r7, r3
 800966e:	781b      	ldrb	r3, [r3, #0]
 8009670:	b25b      	sxtb	r3, r3
 8009672:	2b00      	cmp	r3, #0
 8009674:	d107      	bne.n	8009686 <VL53L1_data_init+0xa2>
			status = VL53L1_read_p2p_data(Dev);
 8009676:	230f      	movs	r3, #15
 8009678:	18fc      	adds	r4, r7, r3
 800967a:	687b      	ldr	r3, [r7, #4]
 800967c:	0018      	movs	r0, r3
 800967e:	f000 f86b 	bl	8009758 <VL53L1_read_p2p_data>
 8009682:	0003      	movs	r3, r0
 8009684:	7023      	strb	r3, [r4, #0]

	/* Initialise Ref SPAD Char configuration structure */
#ifndef VL53L1_NOCALIB
	status =
		VL53L1_init_refspadchar_config_struct(
 8009686:	68bb      	ldr	r3, [r7, #8]
 8009688:	3311      	adds	r3, #17
 800968a:	33ff      	adds	r3, #255	; 0xff
	status =
 800968c:	250f      	movs	r5, #15
 800968e:	197c      	adds	r4, r7, r5
 8009690:	0018      	movs	r0, r3
 8009692:	f001 fdb5 	bl	800b200 <VL53L1_init_refspadchar_config_struct>
 8009696:	0003      	movs	r3, r0
 8009698:	7023      	strb	r3, [r4, #0]
#endif

	/* Initialise SPAD Self Check (SSC) configuration structure */
#ifndef VL53L1_NOCALIB
	status =
		VL53L1_init_ssc_config_struct(
 800969a:	68bb      	ldr	r3, [r7, #8]
 800969c:	3321      	adds	r3, #33	; 0x21
 800969e:	33ff      	adds	r3, #255	; 0xff
	status =
 80096a0:	197c      	adds	r4, r7, r5
 80096a2:	0018      	movs	r0, r3
 80096a4:	f001 fdd2 	bl	800b24c <VL53L1_init_ssc_config_struct>
 80096a8:	0003      	movs	r3, r0
 80096aa:	7023      	strb	r3, [r4, #0]

	/* Initialise Private Xtalk configuration structure
	 * - Fill with customer NVM data to begin
	 */
	status =
		VL53L1_init_xtalk_config_struct(
 80096ac:	68bb      	ldr	r3, [r7, #8]
 80096ae:	3342      	adds	r3, #66	; 0x42
 80096b0:	001a      	movs	r2, r3
 80096b2:	68bb      	ldr	r3, [r7, #8]
 80096b4:	332d      	adds	r3, #45	; 0x2d
 80096b6:	33ff      	adds	r3, #255	; 0xff
	status =
 80096b8:	197c      	adds	r4, r7, r5
 80096ba:	0019      	movs	r1, r3
 80096bc:	0010      	movs	r0, r2
 80096be:	f001 fde9 	bl	800b294 <VL53L1_init_xtalk_config_struct>
 80096c2:	0003      	movs	r3, r0
 80096c4:	7023      	strb	r3, [r4, #0]

	/* Initialise Offset Calibration configuration structure
	 */
#ifndef VL53L1_NOCALIB
	status =
		VL53L1_init_offset_cal_config_struct(
 80096c6:	68bb      	ldr	r3, [r7, #8]
 80096c8:	3345      	adds	r3, #69	; 0x45
 80096ca:	33ff      	adds	r3, #255	; 0xff
	status =
 80096cc:	197c      	adds	r4, r7, r5
 80096ce:	0018      	movs	r0, r3
 80096d0:	f001 fe48 	bl	800b364 <VL53L1_init_offset_cal_config_struct>
 80096d4:	0003      	movs	r3, r0
 80096d6:	7023      	strb	r3, [r4, #0]

	/* Initialise Tuning Parameter structure
	 * - Added as part of Patch_AddingTuningParmStorage_11821
	 */
	status =
		VL53L1_init_tuning_parm_storage_struct(
 80096d8:	68bb      	ldr	r3, [r7, #8]
 80096da:	33a4      	adds	r3, #164	; 0xa4
	status =
 80096dc:	197c      	adds	r4, r7, r5
 80096de:	0018      	movs	r0, r3
 80096e0:	f001 fe68 	bl	800b3b4 <VL53L1_init_tuning_parm_storage_struct>
 80096e4:	0003      	movs	r3, r0
 80096e6:	7023      	strb	r3, [r4, #0]
			&(pdev->tuning_parms));

	status = VL53L1_set_vhv_loopbound(Dev,
 80096e8:	197c      	adds	r4, r7, r5
 80096ea:	687b      	ldr	r3, [r7, #4]
 80096ec:	2120      	movs	r1, #32
 80096ee:	0018      	movs	r0, r3
 80096f0:	f000 fd20 	bl	800a134 <VL53L1_set_vhv_loopbound>
 80096f4:	0003      	movs	r3, r0
 80096f6:	7023      	strb	r3, [r4, #0]
	/*
	 * Initialise default settings - much happen *after*
	 * reading /setting  of static_nvm_managed
	 */

	if (status == VL53L1_ERROR_NONE)
 80096f8:	197b      	adds	r3, r7, r5
 80096fa:	781b      	ldrb	r3, [r3, #0]
 80096fc:	b25b      	sxtb	r3, r3
 80096fe:	2b00      	cmp	r3, #0
 8009700:	d119      	bne.n	8009736 <VL53L1_data_init+0x152>
		status = VL53L1_set_preset_mode(
 8009702:	68bb      	ldr	r3, [r7, #8]
 8009704:	785d      	ldrb	r5, [r3, #1]
 8009706:	68bb      	ldr	r3, [r7, #8]
 8009708:	8b1e      	ldrh	r6, [r3, #24]
 800970a:	68bb      	ldr	r3, [r7, #8]
 800970c:	689b      	ldr	r3, [r3, #8]
 800970e:	469c      	mov	ip, r3
 8009710:	68bb      	ldr	r3, [r7, #8]
 8009712:	68da      	ldr	r2, [r3, #12]
 8009714:	68bb      	ldr	r3, [r7, #8]
 8009716:	6919      	ldr	r1, [r3, #16]
 8009718:	68bb      	ldr	r3, [r7, #8]
 800971a:	695b      	ldr	r3, [r3, #20]
 800971c:	200f      	movs	r0, #15
 800971e:	183c      	adds	r4, r7, r0
 8009720:	6878      	ldr	r0, [r7, #4]
 8009722:	9302      	str	r3, [sp, #8]
 8009724:	9101      	str	r1, [sp, #4]
 8009726:	9200      	str	r2, [sp, #0]
 8009728:	4663      	mov	r3, ip
 800972a:	0032      	movs	r2, r6
 800972c:	0029      	movs	r1, r5
 800972e:	f000 fb3b 	bl	8009da8 <VL53L1_set_preset_mode>
 8009732:	0003      	movs	r3, r0
 8009734:	7023      	strb	r3, [r4, #0]
						pdev->range_config_timeout_us,
						pdev->inter_measurement_period_ms);

	/* Initial Low Power Auto Mode data structures */
	/* Added for Patch_LowPowerAutoMode */
	VL53L1_low_power_auto_data_init(
 8009736:	687b      	ldr	r3, [r7, #4]
 8009738:	0018      	movs	r0, r3
 800973a:	f003 f8c9 	bl	800c8d0 <VL53L1_low_power_auto_data_init>

#endif

	LOG_FUNCTION_END(status);

	return status;
 800973e:	230f      	movs	r3, #15
 8009740:	18fb      	adds	r3, r7, r3
 8009742:	781b      	ldrb	r3, [r3, #0]
 8009744:	b25b      	sxtb	r3, r3
}
 8009746:	0018      	movs	r0, r3
 8009748:	46bd      	mov	sp, r7
 800974a:	b005      	add	sp, #20
 800974c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800974e:	46c0      	nop			; (mov r8, r8)
 8009750:	000032c8 	.word	0x000032c8
 8009754:	000007db 	.word	0x000007db

08009758 <VL53L1_read_p2p_data>:


VL53L1_Error VL53L1_read_p2p_data(
	VL53L1_DEV        Dev)
{
 8009758:	b5b0      	push	{r4, r5, r7, lr}
 800975a:	b084      	sub	sp, #16
 800975c:	af00      	add	r7, sp, #0
 800975e:	6078      	str	r0, [r7, #4]
	 *
	 *  Contains the key NVM data e.g identification info
	 *  fast oscillator freq, max trim and laser safety info
	 */

	VL53L1_Error status       = VL53L1_ERROR_NONE;
 8009760:	210f      	movs	r1, #15
 8009762:	187b      	adds	r3, r7, r1
 8009764:	2200      	movs	r2, #0
 8009766:	701a      	strb	r2, [r3, #0]
	VL53L1_LLDriverData_t *pdev = VL53L1DevStructGetLLDriverHandle(Dev);
 8009768:	687b      	ldr	r3, [r7, #4]
 800976a:	60bb      	str	r3, [r7, #8]

	LOG_FUNCTION_START("");

	if (status == VL53L1_ERROR_NONE)
 800976c:	187b      	adds	r3, r7, r1
 800976e:	781b      	ldrb	r3, [r3, #0]
 8009770:	b25b      	sxtb	r3, r3
 8009772:	2b00      	cmp	r3, #0
 8009774:	d10c      	bne.n	8009790 <VL53L1_read_p2p_data+0x38>
		status = VL53L1_get_static_nvm_managed(
 8009776:	68bb      	ldr	r3, [r7, #8]
 8009778:	3359      	adds	r3, #89	; 0x59
 800977a:	33ff      	adds	r3, #255	; 0xff
 800977c:	001a      	movs	r2, r3
 800977e:	230f      	movs	r3, #15
 8009780:	18fc      	adds	r4, r7, r3
 8009782:	687b      	ldr	r3, [r7, #4]
 8009784:	0011      	movs	r1, r2
 8009786:	0018      	movs	r0, r3
 8009788:	f003 fb62 	bl	800ce50 <VL53L1_get_static_nvm_managed>
 800978c:	0003      	movs	r3, r0
 800978e:	7023      	strb	r3, [r4, #0]
						Dev,
						&(pdev->stat_nvm));

	if (status == VL53L1_ERROR_NONE)
 8009790:	230f      	movs	r3, #15
 8009792:	18fb      	adds	r3, r7, r3
 8009794:	781b      	ldrb	r3, [r3, #0]
 8009796:	b25b      	sxtb	r3, r3
 8009798:	2b00      	cmp	r3, #0
 800979a:	d10b      	bne.n	80097b4 <VL53L1_read_p2p_data+0x5c>
		status = VL53L1_get_customer_nvm_managed(
 800979c:	68bb      	ldr	r3, [r7, #8]
 800979e:	3342      	adds	r3, #66	; 0x42
 80097a0:	001a      	movs	r2, r3
 80097a2:	230f      	movs	r3, #15
 80097a4:	18fc      	adds	r4, r7, r3
 80097a6:	687b      	ldr	r3, [r7, #4]
 80097a8:	0011      	movs	r1, r2
 80097aa:	0018      	movs	r0, r3
 80097ac:	f003 fca7 	bl	800d0fe <VL53L1_get_customer_nvm_managed>
 80097b0:	0003      	movs	r3, r0
 80097b2:	7023      	strb	r3, [r4, #0]
						Dev,
						&(pdev->customer));

	if (status == VL53L1_ERROR_NONE) {
 80097b4:	230f      	movs	r3, #15
 80097b6:	18fb      	adds	r3, r7, r3
 80097b8:	781b      	ldrb	r3, [r3, #0]
 80097ba:	b25b      	sxtb	r3, r3
 80097bc:	2b00      	cmp	r3, #0
 80097be:	d11b      	bne.n	80097f8 <VL53L1_read_p2p_data+0xa0>

		status = VL53L1_get_nvm_copy_data(
 80097c0:	68bb      	ldr	r3, [r7, #8]
 80097c2:	33fb      	adds	r3, #251	; 0xfb
 80097c4:	33ff      	adds	r3, #255	; 0xff
 80097c6:	001a      	movs	r2, r3
 80097c8:	250f      	movs	r5, #15
 80097ca:	197c      	adds	r4, r7, r5
 80097cc:	687b      	ldr	r3, [r7, #4]
 80097ce:	0011      	movs	r1, r2
 80097d0:	0018      	movs	r0, r3
 80097d2:	f004 fbcf 	bl	800df74 <VL53L1_get_nvm_copy_data>
 80097d6:	0003      	movs	r3, r0
 80097d8:	7023      	strb	r3, [r4, #0]
						Dev,
						&(pdev->nvm_copy_data));

		/* copy Return Good SPADs to buffer */
		if (status == VL53L1_ERROR_NONE)
 80097da:	197b      	adds	r3, r7, r5
 80097dc:	781b      	ldrb	r3, [r3, #0]
 80097de:	b25b      	sxtb	r3, r3
 80097e0:	2b00      	cmp	r3, #0
 80097e2:	d109      	bne.n	80097f8 <VL53L1_read_p2p_data+0xa0>
			VL53L1_copy_rtn_good_spads_to_buffer(
 80097e4:	68bb      	ldr	r3, [r7, #8]
 80097e6:	33fb      	adds	r3, #251	; 0xfb
 80097e8:	33ff      	adds	r3, #255	; 0xff
 80097ea:	001a      	movs	r2, r3
 80097ec:	68bb      	ldr	r3, [r7, #8]
 80097ee:	33f0      	adds	r3, #240	; 0xf0
 80097f0:	0019      	movs	r1, r3
 80097f2:	0010      	movs	r0, r2
 80097f4:	f002 fbcb 	bl	800bf8e <VL53L1_copy_rtn_good_spads_to_buffer>

	/*
	 * read slow osc calibration value
	 * counts per ms
	 */
	if (status == VL53L1_ERROR_NONE)
 80097f8:	230f      	movs	r3, #15
 80097fa:	18fb      	adds	r3, r7, r3
 80097fc:	781b      	ldrb	r3, [r3, #0]
 80097fe:	b25b      	sxtb	r3, r3
 8009800:	2b00      	cmp	r3, #0
 8009802:	d10c      	bne.n	800981e <VL53L1_read_p2p_data+0xc6>
		status =
			VL53L1_RdWord(
 8009804:	68bb      	ldr	r3, [r7, #8]
 8009806:	22ad      	movs	r2, #173	; 0xad
 8009808:	0092      	lsls	r2, r2, #2
 800980a:	189a      	adds	r2, r3, r2
		status =
 800980c:	230f      	movs	r3, #15
 800980e:	18fc      	adds	r4, r7, r3
 8009810:	687b      	ldr	r3, [r7, #4]
 8009812:	21de      	movs	r1, #222	; 0xde
 8009814:	0018      	movs	r0, r3
 8009816:	f004 fdab 	bl	800e370 <VL53L1_RdWord>
 800981a:	0003      	movs	r3, r0
 800981c:	7023      	strb	r3, [r4, #0]

	/*
	 * Check if there a sensible value for osc_measured__fast_osc__frequency
	 */

	if (pdev->stat_nvm.osc_measured__fast_osc__frequency < 0x1000) {
 800981e:	68ba      	ldr	r2, [r7, #8]
 8009820:	23af      	movs	r3, #175	; 0xaf
 8009822:	005b      	lsls	r3, r3, #1
 8009824:	5ad3      	ldrh	r3, [r2, r3]
 8009826:	4a1e      	ldr	r2, [pc, #120]	; (80098a0 <VL53L1_read_p2p_data+0x148>)
 8009828:	4293      	cmp	r3, r2
 800982a:	d804      	bhi.n	8009836 <VL53L1_read_p2p_data+0xde>
			VL53L1_TRACE_LEVEL_WARNING,
			"\nInvalid %s value (0x%04X) - forcing to 0x%04X\n\n",
			"pdev->stat_nvm.osc_measured__fast_osc__frequency",
			pdev->stat_nvm.osc_measured__fast_osc__frequency,
			0xBCCC);
		pdev->stat_nvm.osc_measured__fast_osc__frequency = 0xBCCC;
 800982c:	68ba      	ldr	r2, [r7, #8]
 800982e:	23af      	movs	r3, #175	; 0xaf
 8009830:	005b      	lsls	r3, r3, #1
 8009832:	491c      	ldr	r1, [pc, #112]	; (80098a4 <VL53L1_read_p2p_data+0x14c>)
 8009834:	52d1      	strh	r1, [r2, r3]

	/*
	 * Get MM ROI - contains optical centre as SPAD number
	 */

	if (status == VL53L1_ERROR_NONE)
 8009836:	230f      	movs	r3, #15
 8009838:	18fb      	adds	r3, r7, r3
 800983a:	781b      	ldrb	r3, [r3, #0]
 800983c:	b25b      	sxtb	r3, r3
 800983e:	2b00      	cmp	r3, #0
 8009840:	d10b      	bne.n	800985a <VL53L1_read_p2p_data+0x102>
		status =
			VL53L1_get_mode_mitigation_roi(
 8009842:	68bb      	ldr	r3, [r7, #8]
 8009844:	339e      	adds	r3, #158	; 0x9e
 8009846:	001a      	movs	r2, r3
		status =
 8009848:	230f      	movs	r3, #15
 800984a:	18fc      	adds	r4, r7, r3
 800984c:	687b      	ldr	r3, [r7, #4]
 800984e:	0011      	movs	r1, r2
 8009850:	0018      	movs	r0, r3
 8009852:	f000 f9f7 	bl	8009c44 <VL53L1_get_mode_mitigation_roi>
 8009856:	0003      	movs	r3, r0
 8009858:	7023      	strb	r3, [r4, #0]

	/* catch parts where the optical centre is
	 * no programmed in to the NVM
	 */

	if (pdev->optical_centre.x_centre == 0 &&
 800985a:	68bb      	ldr	r3, [r7, #8]
 800985c:	22a2      	movs	r2, #162	; 0xa2
 800985e:	5c9b      	ldrb	r3, [r3, r2]
 8009860:	2b00      	cmp	r3, #0
 8009862:	d114      	bne.n	800988e <VL53L1_read_p2p_data+0x136>
		pdev->optical_centre.y_centre == 0) {
 8009864:	68bb      	ldr	r3, [r7, #8]
 8009866:	22a3      	movs	r2, #163	; 0xa3
 8009868:	5c9b      	ldrb	r3, [r3, r2]
	if (pdev->optical_centre.x_centre == 0 &&
 800986a:	2b00      	cmp	r3, #0
 800986c:	d10f      	bne.n	800988e <VL53L1_read_p2p_data+0x136>
		pdev->optical_centre.x_centre =
				pdev->mm_roi.x_centre << 4;
 800986e:	68bb      	ldr	r3, [r7, #8]
 8009870:	229e      	movs	r2, #158	; 0x9e
 8009872:	5c9b      	ldrb	r3, [r3, r2]
 8009874:	011b      	lsls	r3, r3, #4
 8009876:	b2d9      	uxtb	r1, r3
		pdev->optical_centre.x_centre =
 8009878:	68bb      	ldr	r3, [r7, #8]
 800987a:	22a2      	movs	r2, #162	; 0xa2
 800987c:	5499      	strb	r1, [r3, r2]
		pdev->optical_centre.y_centre =
				pdev->mm_roi.y_centre << 4;
 800987e:	68bb      	ldr	r3, [r7, #8]
 8009880:	229f      	movs	r2, #159	; 0x9f
 8009882:	5c9b      	ldrb	r3, [r3, r2]
 8009884:	011b      	lsls	r3, r3, #4
 8009886:	b2d9      	uxtb	r1, r3
		pdev->optical_centre.y_centre =
 8009888:	68bb      	ldr	r3, [r7, #8]
 800988a:	22a3      	movs	r2, #163	; 0xa3
 800988c:	5499      	strb	r1, [r3, r2]
	}

	LOG_FUNCTION_END(status);

	return status;
 800988e:	230f      	movs	r3, #15
 8009890:	18fb      	adds	r3, r7, r3
 8009892:	781b      	ldrb	r3, [r3, #0]
 8009894:	b25b      	sxtb	r3, r3
}
 8009896:	0018      	movs	r0, r3
 8009898:	46bd      	mov	sp, r7
 800989a:	b004      	add	sp, #16
 800989c:	bdb0      	pop	{r4, r5, r7, pc}
 800989e:	46c0      	nop			; (mov r8, r8)
 80098a0:	00000fff 	.word	0x00000fff
 80098a4:	ffffbccc 	.word	0xffffbccc

080098a8 <VL53L1_set_inter_measurement_period_ms>:


VL53L1_Error VL53L1_set_inter_measurement_period_ms(
	VL53L1_DEV              Dev,
	uint32_t                inter_measurement_period_ms)
{
 80098a8:	b580      	push	{r7, lr}
 80098aa:	b084      	sub	sp, #16
 80098ac:	af00      	add	r7, sp, #0
 80098ae:	6078      	str	r0, [r7, #4]
 80098b0:	6039      	str	r1, [r7, #0]
	/**
	 * Convenience function for setting the inter measurement period
	 */

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 80098b2:	230f      	movs	r3, #15
 80098b4:	18fb      	adds	r3, r7, r3
 80098b6:	2200      	movs	r2, #0
 80098b8:	701a      	strb	r2, [r3, #0]
	VL53L1_LLDriverData_t *pdev = VL53L1DevStructGetLLDriverHandle(Dev);
 80098ba:	687b      	ldr	r3, [r7, #4]
 80098bc:	60bb      	str	r3, [r7, #8]

	LOG_FUNCTION_START("");

	if (pdev->dbg_results.result__osc_calibrate_val == 0)
 80098be:	68ba      	ldr	r2, [r7, #8]
 80098c0:	23ad      	movs	r3, #173	; 0xad
 80098c2:	009b      	lsls	r3, r3, #2
 80098c4:	5ad3      	ldrh	r3, [r2, r3]
 80098c6:	2b00      	cmp	r3, #0
 80098c8:	d103      	bne.n	80098d2 <VL53L1_set_inter_measurement_period_ms+0x2a>
		status = VL53L1_ERROR_DIVISION_BY_ZERO;
 80098ca:	230f      	movs	r3, #15
 80098cc:	18fb      	adds	r3, r7, r3
 80098ce:	22f1      	movs	r2, #241	; 0xf1
 80098d0:	701a      	strb	r2, [r3, #0]

	if (status == VL53L1_ERROR_NONE) {
 80098d2:	230f      	movs	r3, #15
 80098d4:	18fb      	adds	r3, r7, r3
 80098d6:	781b      	ldrb	r3, [r3, #0]
 80098d8:	b25b      	sxtb	r3, r3
 80098da:	2b00      	cmp	r3, #0
 80098dc:	d10e      	bne.n	80098fc <VL53L1_set_inter_measurement_period_ms+0x54>
		pdev->inter_measurement_period_ms = inter_measurement_period_ms;
 80098de:	68bb      	ldr	r3, [r7, #8]
 80098e0:	683a      	ldr	r2, [r7, #0]
 80098e2:	615a      	str	r2, [r3, #20]
		pdev->tim_cfg.system__intermeasurement_period = \
			inter_measurement_period_ms *
			(uint32_t)pdev->dbg_results.result__osc_calibrate_val;
 80098e4:	68ba      	ldr	r2, [r7, #8]
 80098e6:	23ad      	movs	r3, #173	; 0xad
 80098e8:	009b      	lsls	r3, r3, #2
 80098ea:	5ad3      	ldrh	r3, [r2, r3]
 80098ec:	001a      	movs	r2, r3
			inter_measurement_period_ms *
 80098ee:	683b      	ldr	r3, [r7, #0]
 80098f0:	4353      	muls	r3, r2
 80098f2:	0019      	movs	r1, r3
		pdev->tim_cfg.system__intermeasurement_period = \
 80098f4:	68ba      	ldr	r2, [r7, #8]
 80098f6:	23d6      	movs	r3, #214	; 0xd6
 80098f8:	005b      	lsls	r3, r3, #1
 80098fa:	50d1      	str	r1, [r2, r3]
	}

	LOG_FUNCTION_END(status);

	return status;
 80098fc:	230f      	movs	r3, #15
 80098fe:	18fb      	adds	r3, r7, r3
 8009900:	781b      	ldrb	r3, [r3, #0]
 8009902:	b25b      	sxtb	r3, r3
}
 8009904:	0018      	movs	r0, r3
 8009906:	46bd      	mov	sp, r7
 8009908:	b004      	add	sp, #16
 800990a:	bd80      	pop	{r7, pc}

0800990c <VL53L1_get_inter_measurement_period_ms>:


VL53L1_Error VL53L1_get_inter_measurement_period_ms(
	VL53L1_DEV              Dev,
	uint32_t               *pinter_measurement_period_ms)
{
 800990c:	b580      	push	{r7, lr}
 800990e:	b084      	sub	sp, #16
 8009910:	af00      	add	r7, sp, #0
 8009912:	6078      	str	r0, [r7, #4]
 8009914:	6039      	str	r1, [r7, #0]
	/**
	 * Convenience function for getting the inter measurement period
	 */

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 8009916:	230f      	movs	r3, #15
 8009918:	18fb      	adds	r3, r7, r3
 800991a:	2200      	movs	r2, #0
 800991c:	701a      	strb	r2, [r3, #0]
	VL53L1_LLDriverData_t *pdev = VL53L1DevStructGetLLDriverHandle(Dev);
 800991e:	687b      	ldr	r3, [r7, #4]
 8009920:	60bb      	str	r3, [r7, #8]

	LOG_FUNCTION_START("");

	if (pdev->dbg_results.result__osc_calibrate_val == 0)
 8009922:	68ba      	ldr	r2, [r7, #8]
 8009924:	23ad      	movs	r3, #173	; 0xad
 8009926:	009b      	lsls	r3, r3, #2
 8009928:	5ad3      	ldrh	r3, [r2, r3]
 800992a:	2b00      	cmp	r3, #0
 800992c:	d103      	bne.n	8009936 <VL53L1_get_inter_measurement_period_ms+0x2a>
		status = VL53L1_ERROR_DIVISION_BY_ZERO;
 800992e:	230f      	movs	r3, #15
 8009930:	18fb      	adds	r3, r7, r3
 8009932:	22f1      	movs	r2, #241	; 0xf1
 8009934:	701a      	strb	r2, [r3, #0]

	if (status == VL53L1_ERROR_NONE)
 8009936:	230f      	movs	r3, #15
 8009938:	18fb      	adds	r3, r7, r3
 800993a:	781b      	ldrb	r3, [r3, #0]
 800993c:	b25b      	sxtb	r3, r3
 800993e:	2b00      	cmp	r3, #0
 8009940:	d10e      	bne.n	8009960 <VL53L1_get_inter_measurement_period_ms+0x54>
		*pinter_measurement_period_ms = \
			pdev->tim_cfg.system__intermeasurement_period /
 8009942:	68ba      	ldr	r2, [r7, #8]
 8009944:	23d6      	movs	r3, #214	; 0xd6
 8009946:	005b      	lsls	r3, r3, #1
 8009948:	58d0      	ldr	r0, [r2, r3]
			(uint32_t)pdev->dbg_results.result__osc_calibrate_val;
 800994a:	68ba      	ldr	r2, [r7, #8]
 800994c:	23ad      	movs	r3, #173	; 0xad
 800994e:	009b      	lsls	r3, r3, #2
 8009950:	5ad3      	ldrh	r3, [r2, r3]
			pdev->tim_cfg.system__intermeasurement_period /
 8009952:	0019      	movs	r1, r3
 8009954:	f7f6 fbea 	bl	800012c <__udivsi3>
 8009958:	0003      	movs	r3, r0
 800995a:	001a      	movs	r2, r3
		*pinter_measurement_period_ms = \
 800995c:	683b      	ldr	r3, [r7, #0]
 800995e:	601a      	str	r2, [r3, #0]


	LOG_FUNCTION_END(status);

	return status;
 8009960:	230f      	movs	r3, #15
 8009962:	18fb      	adds	r3, r7, r3
 8009964:	781b      	ldrb	r3, [r3, #0]
 8009966:	b25b      	sxtb	r3, r3
}
 8009968:	0018      	movs	r0, r3
 800996a:	46bd      	mov	sp, r7
 800996c:	b004      	add	sp, #16
 800996e:	bd80      	pop	{r7, pc}

08009970 <VL53L1_set_timeouts_us>:
VL53L1_Error VL53L1_set_timeouts_us(
	VL53L1_DEV          Dev,
	uint32_t            phasecal_config_timeout_us,
	uint32_t            mm_config_timeout_us,
	uint32_t            range_config_timeout_us)
{
 8009970:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009972:	b089      	sub	sp, #36	; 0x24
 8009974:	af02      	add	r7, sp, #8
 8009976:	60f8      	str	r0, [r7, #12]
 8009978:	60b9      	str	r1, [r7, #8]
 800997a:	607a      	str	r2, [r7, #4]
 800997c:	603b      	str	r3, [r7, #0]
	/**
	 * Convenience function for setting the MM and range
	 * timeouts
	 */

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 800997e:	2317      	movs	r3, #23
 8009980:	18fb      	adds	r3, r7, r3
 8009982:	2200      	movs	r2, #0
 8009984:	701a      	strb	r2, [r3, #0]
	VL53L1_LLDriverData_t *pdev =
 8009986:	68fb      	ldr	r3, [r7, #12]
 8009988:	613b      	str	r3, [r7, #16]
			VL53L1DevStructGetLLDriverHandle(Dev);

	LOG_FUNCTION_START("");

	if (pdev->stat_nvm.osc_measured__fast_osc__frequency == 0)
 800998a:	693a      	ldr	r2, [r7, #16]
 800998c:	23af      	movs	r3, #175	; 0xaf
 800998e:	005b      	lsls	r3, r3, #1
 8009990:	5ad3      	ldrh	r3, [r2, r3]
 8009992:	2b00      	cmp	r3, #0
 8009994:	d103      	bne.n	800999e <VL53L1_set_timeouts_us+0x2e>
		status = VL53L1_ERROR_DIVISION_BY_ZERO;
 8009996:	2317      	movs	r3, #23
 8009998:	18fb      	adds	r3, r7, r3
 800999a:	22f1      	movs	r2, #241	; 0xf1
 800999c:	701a      	strb	r2, [r3, #0]

	if (status == VL53L1_ERROR_NONE) {
 800999e:	2317      	movs	r3, #23
 80099a0:	18fb      	adds	r3, r7, r3
 80099a2:	781b      	ldrb	r3, [r3, #0]
 80099a4:	b25b      	sxtb	r3, r3
 80099a6:	2b00      	cmp	r3, #0
 80099a8:	d11f      	bne.n	80099ea <VL53L1_set_timeouts_us+0x7a>

		pdev->phasecal_config_timeout_us = phasecal_config_timeout_us;
 80099aa:	693b      	ldr	r3, [r7, #16]
 80099ac:	68ba      	ldr	r2, [r7, #8]
 80099ae:	609a      	str	r2, [r3, #8]
		pdev->mm_config_timeout_us       = mm_config_timeout_us;
 80099b0:	693b      	ldr	r3, [r7, #16]
 80099b2:	687a      	ldr	r2, [r7, #4]
 80099b4:	60da      	str	r2, [r3, #12]
		pdev->range_config_timeout_us    = range_config_timeout_us;
 80099b6:	693b      	ldr	r3, [r7, #16]
 80099b8:	683a      	ldr	r2, [r7, #0]
 80099ba:	611a      	str	r2, [r3, #16]

		status =
			VL53L1_calc_timeout_register_values(
 80099bc:	693a      	ldr	r2, [r7, #16]
 80099be:	23af      	movs	r3, #175	; 0xaf
 80099c0:	005b      	lsls	r3, r3, #1
 80099c2:	5ad6      	ldrh	r6, [r2, r3]
 80099c4:	693b      	ldr	r3, [r7, #16]
 80099c6:	3385      	adds	r3, #133	; 0x85
 80099c8:	33ff      	adds	r3, #255	; 0xff
 80099ca:	693a      	ldr	r2, [r7, #16]
 80099cc:	329d      	adds	r2, #157	; 0x9d
 80099ce:	32ff      	adds	r2, #255	; 0xff
		status =
 80099d0:	2117      	movs	r1, #23
 80099d2:	187c      	adds	r4, r7, r1
 80099d4:	683d      	ldr	r5, [r7, #0]
 80099d6:	6879      	ldr	r1, [r7, #4]
 80099d8:	68b8      	ldr	r0, [r7, #8]
 80099da:	9201      	str	r2, [sp, #4]
 80099dc:	9300      	str	r3, [sp, #0]
 80099de:	0033      	movs	r3, r6
 80099e0:	002a      	movs	r2, r5
 80099e2:	f002 fe6e 	bl	800c6c2 <VL53L1_calc_timeout_register_values>
 80099e6:	0003      	movs	r3, r0
 80099e8:	7023      	strb	r3, [r4, #0]
				&(pdev->tim_cfg));
	}

	LOG_FUNCTION_END(status);

	return status;
 80099ea:	2317      	movs	r3, #23
 80099ec:	18fb      	adds	r3, r7, r3
 80099ee:	781b      	ldrb	r3, [r3, #0]
 80099f0:	b25b      	sxtb	r3, r3
}
 80099f2:	0018      	movs	r0, r3
 80099f4:	46bd      	mov	sp, r7
 80099f6:	b007      	add	sp, #28
 80099f8:	bdf0      	pop	{r4, r5, r6, r7, pc}

080099fa <VL53L1_get_timeouts_us>:
VL53L1_Error VL53L1_get_timeouts_us(
	VL53L1_DEV           Dev,
	uint32_t            *pphasecal_config_timeout_us,
	uint32_t            *pmm_config_timeout_us,
	uint32_t			*prange_config_timeout_us)
{
 80099fa:	b590      	push	{r4, r7, lr}
 80099fc:	b089      	sub	sp, #36	; 0x24
 80099fe:	af00      	add	r7, sp, #0
 8009a00:	60f8      	str	r0, [r7, #12]
 8009a02:	60b9      	str	r1, [r7, #8]
 8009a04:	607a      	str	r2, [r7, #4]
 8009a06:	603b      	str	r3, [r7, #0]
	/**
	 * Convenience function for getting the MM and range
	 * timeouts
	 */

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 8009a08:	231f      	movs	r3, #31
 8009a0a:	18fb      	adds	r3, r7, r3
 8009a0c:	2200      	movs	r2, #0
 8009a0e:	701a      	strb	r2, [r3, #0]
	VL53L1_LLDriverData_t *pdev =
 8009a10:	68fb      	ldr	r3, [r7, #12]
 8009a12:	61bb      	str	r3, [r7, #24]
			VL53L1DevStructGetLLDriverHandle(Dev);

	uint32_t  macro_period_us = 0;
 8009a14:	2300      	movs	r3, #0
 8009a16:	617b      	str	r3, [r7, #20]
	uint16_t  timeout_encoded = 0;
 8009a18:	2312      	movs	r3, #18
 8009a1a:	18fb      	adds	r3, r7, r3
 8009a1c:	2200      	movs	r2, #0
 8009a1e:	801a      	strh	r2, [r3, #0]

	LOG_FUNCTION_START("");

	if (pdev->stat_nvm.osc_measured__fast_osc__frequency == 0)
 8009a20:	69ba      	ldr	r2, [r7, #24]
 8009a22:	23af      	movs	r3, #175	; 0xaf
 8009a24:	005b      	lsls	r3, r3, #1
 8009a26:	5ad3      	ldrh	r3, [r2, r3]
 8009a28:	2b00      	cmp	r3, #0
 8009a2a:	d103      	bne.n	8009a34 <VL53L1_get_timeouts_us+0x3a>
		status = VL53L1_ERROR_DIVISION_BY_ZERO;
 8009a2c:	231f      	movs	r3, #31
 8009a2e:	18fb      	adds	r3, r7, r3
 8009a30:	22f1      	movs	r2, #241	; 0xf1
 8009a32:	701a      	strb	r2, [r3, #0]

	if (status == VL53L1_ERROR_NONE) {
 8009a34:	231f      	movs	r3, #31
 8009a36:	18fb      	adds	r3, r7, r3
 8009a38:	781b      	ldrb	r3, [r3, #0]
 8009a3a:	b25b      	sxtb	r3, r3
 8009a3c:	2b00      	cmp	r3, #0
 8009a3e:	d160      	bne.n	8009b02 <VL53L1_get_timeouts_us+0x108>

		/* Update Macro Period for Range A VCSEL Period */
		macro_period_us =
			VL53L1_calc_macro_period_us(
 8009a40:	69ba      	ldr	r2, [r7, #24]
 8009a42:	23af      	movs	r3, #175	; 0xaf
 8009a44:	005b      	lsls	r3, r3, #1
 8009a46:	5ad0      	ldrh	r0, [r2, r3]
 8009a48:	69ba      	ldr	r2, [r7, #24]
 8009a4a:	23d1      	movs	r3, #209	; 0xd1
 8009a4c:	005b      	lsls	r3, r3, #1
 8009a4e:	5cd3      	ldrb	r3, [r2, r3]
		macro_period_us =
 8009a50:	0019      	movs	r1, r3
 8009a52:	f002 fca4 	bl	800c39e <VL53L1_calc_macro_period_us>
 8009a56:	0003      	movs	r3, r0
 8009a58:	617b      	str	r3, [r7, #20]

		/*  Get Phase Cal Timing A timeout */

		*pphasecal_config_timeout_us =
			VL53L1_calc_timeout_us(
				(uint32_t)pdev->gen_cfg.phasecal_config__timeout_macrop,
 8009a5a:	69ba      	ldr	r2, [r7, #24]
 8009a5c:	238c      	movs	r3, #140	; 0x8c
 8009a5e:	33ff      	adds	r3, #255	; 0xff
 8009a60:	5cd3      	ldrb	r3, [r2, r3]
			VL53L1_calc_timeout_us(
 8009a62:	001a      	movs	r2, r3
 8009a64:	697b      	ldr	r3, [r7, #20]
 8009a66:	0019      	movs	r1, r3
 8009a68:	0010      	movs	r0, r2
 8009a6a:	f002 fd86 	bl	800c57a <VL53L1_calc_timeout_us>
 8009a6e:	0002      	movs	r2, r0
		*pphasecal_config_timeout_us =
 8009a70:	68bb      	ldr	r3, [r7, #8]
 8009a72:	601a      	str	r2, [r3, #0]
				macro_period_us);

		/*  Get MM Timing A timeout */

		timeout_encoded =
			(uint16_t)pdev->tim_cfg.mm_config__timeout_macrop_a_hi;
 8009a74:	69ba      	ldr	r2, [r7, #24]
 8009a76:	23ce      	movs	r3, #206	; 0xce
 8009a78:	005b      	lsls	r3, r3, #1
 8009a7a:	5cd2      	ldrb	r2, [r2, r3]
		timeout_encoded =
 8009a7c:	2012      	movs	r0, #18
 8009a7e:	183b      	adds	r3, r7, r0
 8009a80:	801a      	strh	r2, [r3, #0]
		timeout_encoded = (timeout_encoded << 8) +
 8009a82:	183b      	adds	r3, r7, r0
 8009a84:	881b      	ldrh	r3, [r3, #0]
 8009a86:	021b      	lsls	r3, r3, #8
 8009a88:	b299      	uxth	r1, r3
			(uint16_t)pdev->tim_cfg.mm_config__timeout_macrop_a_lo;
 8009a8a:	69ba      	ldr	r2, [r7, #24]
 8009a8c:	239e      	movs	r3, #158	; 0x9e
 8009a8e:	33ff      	adds	r3, #255	; 0xff
 8009a90:	5cd3      	ldrb	r3, [r2, r3]
 8009a92:	b29a      	uxth	r2, r3
		timeout_encoded = (timeout_encoded << 8) +
 8009a94:	183b      	adds	r3, r7, r0
 8009a96:	188a      	adds	r2, r1, r2
 8009a98:	801a      	strh	r2, [r3, #0]

		*pmm_config_timeout_us =
			VL53L1_calc_decoded_timeout_us(
 8009a9a:	697a      	ldr	r2, [r7, #20]
 8009a9c:	0004      	movs	r4, r0
 8009a9e:	183b      	adds	r3, r7, r0
 8009aa0:	881b      	ldrh	r3, [r3, #0]
 8009aa2:	0011      	movs	r1, r2
 8009aa4:	0018      	movs	r0, r3
 8009aa6:	f002 fd9e 	bl	800c5e6 <VL53L1_calc_decoded_timeout_us>
 8009aaa:	0002      	movs	r2, r0
		*pmm_config_timeout_us =
 8009aac:	687b      	ldr	r3, [r7, #4]
 8009aae:	601a      	str	r2, [r3, #0]
				macro_period_us);

		/* Get Range Timing A timeout */

		timeout_encoded =
			(uint16_t)pdev->tim_cfg.range_config__timeout_macrop_a_hi;
 8009ab0:	69ba      	ldr	r2, [r7, #24]
 8009ab2:	23d0      	movs	r3, #208	; 0xd0
 8009ab4:	005b      	lsls	r3, r3, #1
 8009ab6:	5cd2      	ldrb	r2, [r2, r3]
		timeout_encoded =
 8009ab8:	0020      	movs	r0, r4
 8009aba:	183b      	adds	r3, r7, r0
 8009abc:	801a      	strh	r2, [r3, #0]
		timeout_encoded = (timeout_encoded << 8) +
 8009abe:	183b      	adds	r3, r7, r0
 8009ac0:	881b      	ldrh	r3, [r3, #0]
 8009ac2:	021b      	lsls	r3, r3, #8
 8009ac4:	b299      	uxth	r1, r3
			(uint16_t)pdev->tim_cfg.range_config__timeout_macrop_a_lo;
 8009ac6:	69ba      	ldr	r2, [r7, #24]
 8009ac8:	23a2      	movs	r3, #162	; 0xa2
 8009aca:	33ff      	adds	r3, #255	; 0xff
 8009acc:	5cd3      	ldrb	r3, [r2, r3]
 8009ace:	b29a      	uxth	r2, r3
		timeout_encoded = (timeout_encoded << 8) +
 8009ad0:	183b      	adds	r3, r7, r0
 8009ad2:	188a      	adds	r2, r1, r2
 8009ad4:	801a      	strh	r2, [r3, #0]

		*prange_config_timeout_us =
			VL53L1_calc_decoded_timeout_us(
 8009ad6:	697a      	ldr	r2, [r7, #20]
 8009ad8:	183b      	adds	r3, r7, r0
 8009ada:	881b      	ldrh	r3, [r3, #0]
 8009adc:	0011      	movs	r1, r2
 8009ade:	0018      	movs	r0, r3
 8009ae0:	f002 fd81 	bl	800c5e6 <VL53L1_calc_decoded_timeout_us>
 8009ae4:	0002      	movs	r2, r0
		*prange_config_timeout_us =
 8009ae6:	683b      	ldr	r3, [r7, #0]
 8009ae8:	601a      	str	r2, [r3, #0]
				timeout_encoded,
				macro_period_us);

		pdev->phasecal_config_timeout_us = *pphasecal_config_timeout_us;
 8009aea:	68bb      	ldr	r3, [r7, #8]
 8009aec:	681a      	ldr	r2, [r3, #0]
 8009aee:	69bb      	ldr	r3, [r7, #24]
 8009af0:	609a      	str	r2, [r3, #8]
		pdev->mm_config_timeout_us       = *pmm_config_timeout_us;
 8009af2:	687b      	ldr	r3, [r7, #4]
 8009af4:	681a      	ldr	r2, [r3, #0]
 8009af6:	69bb      	ldr	r3, [r7, #24]
 8009af8:	60da      	str	r2, [r3, #12]
		pdev->range_config_timeout_us    = *prange_config_timeout_us;
 8009afa:	683b      	ldr	r3, [r7, #0]
 8009afc:	681a      	ldr	r2, [r3, #0]
 8009afe:	69bb      	ldr	r3, [r7, #24]
 8009b00:	611a      	str	r2, [r3, #16]

	}

	LOG_FUNCTION_END(status);

	return status;
 8009b02:	231f      	movs	r3, #31
 8009b04:	18fb      	adds	r3, r7, r3
 8009b06:	781b      	ldrb	r3, [r3, #0]
 8009b08:	b25b      	sxtb	r3, r3
}
 8009b0a:	0018      	movs	r0, r3
 8009b0c:	46bd      	mov	sp, r7
 8009b0e:	b009      	add	sp, #36	; 0x24
 8009b10:	bd90      	pop	{r4, r7, pc}

08009b12 <VL53L1_get_sequence_config_bit>:

VL53L1_Error VL53L1_get_sequence_config_bit(
	VL53L1_DEV                    Dev,
	VL53L1_DeviceSequenceConfig   bit_id,
	uint8_t                      *pvalue)
{
 8009b12:	b580      	push	{r7, lr}
 8009b14:	b086      	sub	sp, #24
 8009b16:	af00      	add	r7, sp, #0
 8009b18:	60f8      	str	r0, [r7, #12]
 8009b1a:	607a      	str	r2, [r7, #4]
 8009b1c:	200b      	movs	r0, #11
 8009b1e:	183b      	adds	r3, r7, r0
 8009b20:	1c0a      	adds	r2, r1, #0
 8009b22:	701a      	strb	r2, [r3, #0]
	/**
	 * Convenience function for getting sequence
	 * config enable bits
	 */

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 8009b24:	2317      	movs	r3, #23
 8009b26:	18fb      	adds	r3, r7, r3
 8009b28:	2200      	movs	r2, #0
 8009b2a:	701a      	strb	r2, [r3, #0]
	VL53L1_LLDriverData_t *pdev =
 8009b2c:	68fb      	ldr	r3, [r7, #12]
 8009b2e:	613b      	str	r3, [r7, #16]
		VL53L1DevStructGetLLDriverHandle(Dev);

	uint8_t  bit_mask        = 0x01;
 8009b30:	2316      	movs	r3, #22
 8009b32:	18fb      	adds	r3, r7, r3
 8009b34:	2201      	movs	r2, #1
 8009b36:	701a      	strb	r2, [r3, #0]

	if (bit_id <= VL53L1_DEVICESEQUENCECONFIG_RANGE) {
 8009b38:	183b      	adds	r3, r7, r0
 8009b3a:	781b      	ldrb	r3, [r3, #0]
 8009b3c:	2b07      	cmp	r3, #7
 8009b3e:	d828      	bhi.n	8009b92 <VL53L1_get_sequence_config_bit+0x80>

		if (bit_id > 0) {
 8009b40:	230b      	movs	r3, #11
 8009b42:	18fb      	adds	r3, r7, r3
 8009b44:	781b      	ldrb	r3, [r3, #0]
 8009b46:	2b00      	cmp	r3, #0
 8009b48:	d007      	beq.n	8009b5a <VL53L1_get_sequence_config_bit+0x48>
			bit_mask  = 0x01 << bit_id;
 8009b4a:	230b      	movs	r3, #11
 8009b4c:	18fb      	adds	r3, r7, r3
 8009b4e:	781b      	ldrb	r3, [r3, #0]
 8009b50:	2201      	movs	r2, #1
 8009b52:	409a      	lsls	r2, r3
 8009b54:	2316      	movs	r3, #22
 8009b56:	18fb      	adds	r3, r7, r3
 8009b58:	701a      	strb	r2, [r3, #0]
		}

		*pvalue =
			pdev->dyn_cfg.system__sequence_config & bit_mask;
 8009b5a:	693a      	ldr	r2, [r7, #16]
 8009b5c:	23c6      	movs	r3, #198	; 0xc6
 8009b5e:	33ff      	adds	r3, #255	; 0xff
 8009b60:	5cd3      	ldrb	r3, [r2, r3]
		*pvalue =
 8009b62:	2216      	movs	r2, #22
 8009b64:	18ba      	adds	r2, r7, r2
 8009b66:	7812      	ldrb	r2, [r2, #0]
 8009b68:	4013      	ands	r3, r2
 8009b6a:	b2da      	uxtb	r2, r3
 8009b6c:	687b      	ldr	r3, [r7, #4]
 8009b6e:	701a      	strb	r2, [r3, #0]

		if (bit_id > 0) {
 8009b70:	230b      	movs	r3, #11
 8009b72:	18fb      	adds	r3, r7, r3
 8009b74:	781b      	ldrb	r3, [r3, #0]
 8009b76:	2b00      	cmp	r3, #0
 8009b78:	d00f      	beq.n	8009b9a <VL53L1_get_sequence_config_bit+0x88>
			*pvalue  = *pvalue >> bit_id;
 8009b7a:	687b      	ldr	r3, [r7, #4]
 8009b7c:	781b      	ldrb	r3, [r3, #0]
 8009b7e:	001a      	movs	r2, r3
 8009b80:	230b      	movs	r3, #11
 8009b82:	18fb      	adds	r3, r7, r3
 8009b84:	781b      	ldrb	r3, [r3, #0]
 8009b86:	411a      	asrs	r2, r3
 8009b88:	0013      	movs	r3, r2
 8009b8a:	b2da      	uxtb	r2, r3
 8009b8c:	687b      	ldr	r3, [r7, #4]
 8009b8e:	701a      	strb	r2, [r3, #0]
 8009b90:	e003      	b.n	8009b9a <VL53L1_get_sequence_config_bit+0x88>
		}

	} else {
		status = VL53L1_ERROR_INVALID_PARAMS;
 8009b92:	2317      	movs	r3, #23
 8009b94:	18fb      	adds	r3, r7, r3
 8009b96:	22fc      	movs	r2, #252	; 0xfc
 8009b98:	701a      	strb	r2, [r3, #0]
	}

	return status;
 8009b9a:	2317      	movs	r3, #23
 8009b9c:	18fb      	adds	r3, r7, r3
 8009b9e:	781b      	ldrb	r3, [r3, #0]
 8009ba0:	b25b      	sxtb	r3, r3
}
 8009ba2:	0018      	movs	r0, r3
 8009ba4:	46bd      	mov	sp, r7
 8009ba6:	b006      	add	sp, #24
 8009ba8:	bd80      	pop	{r7, pc}

08009baa <VL53L1_set_user_zone>:


VL53L1_Error VL53L1_set_user_zone(
	VL53L1_DEV              Dev,
	VL53L1_user_zone_t     *puser_zone)
{
 8009baa:	b590      	push	{r4, r7, lr}
 8009bac:	b085      	sub	sp, #20
 8009bae:	af00      	add	r7, sp, #0
 8009bb0:	6078      	str	r0, [r7, #4]
 8009bb2:	6039      	str	r1, [r7, #0]
	/**
	 * Convenience function for setting the user ROI
	 */

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 8009bb4:	240f      	movs	r4, #15
 8009bb6:	193b      	adds	r3, r7, r4
 8009bb8:	2200      	movs	r2, #0
 8009bba:	701a      	strb	r2, [r3, #0]
	VL53L1_LLDriverData_t *pdev = VL53L1DevStructGetLLDriverHandle(Dev);
 8009bbc:	687b      	ldr	r3, [r7, #4]
 8009bbe:	60bb      	str	r3, [r7, #8]

	LOG_FUNCTION_START("");

	/* convert (row,col) location into a SPAD number */
	VL53L1_encode_row_col(
 8009bc0:	683b      	ldr	r3, [r7, #0]
 8009bc2:	7858      	ldrb	r0, [r3, #1]
 8009bc4:	683b      	ldr	r3, [r7, #0]
 8009bc6:	7819      	ldrb	r1, [r3, #0]
 8009bc8:	68bb      	ldr	r3, [r7, #8]
 8009bca:	33c4      	adds	r3, #196	; 0xc4
 8009bcc:	33ff      	adds	r3, #255	; 0xff
 8009bce:	001a      	movs	r2, r3
 8009bd0:	f002 fe20 	bl	800c814 <VL53L1_encode_row_col>
		puser_zone->y_centre,
		puser_zone->x_centre,
		&(pdev->dyn_cfg.roi_config__user_roi_centre_spad));

	/* merge x and y sizes */
	VL53L1_encode_zone_size(
 8009bd4:	683b      	ldr	r3, [r7, #0]
 8009bd6:	7898      	ldrb	r0, [r3, #2]
 8009bd8:	683b      	ldr	r3, [r7, #0]
 8009bda:	78d9      	ldrb	r1, [r3, #3]
 8009bdc:	68bb      	ldr	r3, [r7, #8]
 8009bde:	33c5      	adds	r3, #197	; 0xc5
 8009be0:	33ff      	adds	r3, #255	; 0xff
 8009be2:	001a      	movs	r2, r3
 8009be4:	f002 fe5c 	bl	800c8a0 <VL53L1_encode_zone_size>

	/* need to add checks to ensure ROI is within array */

	LOG_FUNCTION_END(status);

	return status;
 8009be8:	193b      	adds	r3, r7, r4
 8009bea:	781b      	ldrb	r3, [r3, #0]
 8009bec:	b25b      	sxtb	r3, r3
}
 8009bee:	0018      	movs	r0, r3
 8009bf0:	46bd      	mov	sp, r7
 8009bf2:	b005      	add	sp, #20
 8009bf4:	bd90      	pop	{r4, r7, pc}

08009bf6 <VL53L1_get_user_zone>:


VL53L1_Error VL53L1_get_user_zone(
	VL53L1_DEV              Dev,
	VL53L1_user_zone_t     *puser_zone)
{
 8009bf6:	b590      	push	{r4, r7, lr}
 8009bf8:	b085      	sub	sp, #20
 8009bfa:	af00      	add	r7, sp, #0
 8009bfc:	6078      	str	r0, [r7, #4]
 8009bfe:	6039      	str	r1, [r7, #0]
	/**
	 * Convenience function for getting the user ROI
	 */

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 8009c00:	240f      	movs	r4, #15
 8009c02:	193b      	adds	r3, r7, r4
 8009c04:	2200      	movs	r2, #0
 8009c06:	701a      	strb	r2, [r3, #0]
	VL53L1_LLDriverData_t *pdev = VL53L1DevStructGetLLDriverHandle(Dev);
 8009c08:	687b      	ldr	r3, [r7, #4]
 8009c0a:	60bb      	str	r3, [r7, #8]

	LOG_FUNCTION_START("");

	/* convert SPAD number into (row,col) location*/
	VL53L1_decode_row_col(
 8009c0c:	68ba      	ldr	r2, [r7, #8]
 8009c0e:	23c4      	movs	r3, #196	; 0xc4
 8009c10:	33ff      	adds	r3, #255	; 0xff
 8009c12:	5cd0      	ldrb	r0, [r2, r3]
 8009c14:	683b      	ldr	r3, [r7, #0]
 8009c16:	3301      	adds	r3, #1
 8009c18:	683a      	ldr	r2, [r7, #0]
 8009c1a:	0019      	movs	r1, r3
 8009c1c:	f003 f81f 	bl	800cc5e <VL53L1_decode_row_col>
			pdev->dyn_cfg.roi_config__user_roi_centre_spad,
			&(puser_zone->y_centre),
			&(puser_zone->x_centre));

	/* extract x and y sizes */
	VL53L1_decode_zone_size(
 8009c20:	68ba      	ldr	r2, [r7, #8]
 8009c22:	23e2      	movs	r3, #226	; 0xe2
 8009c24:	005b      	lsls	r3, r3, #1
 8009c26:	5cd0      	ldrb	r0, [r2, r3]
 8009c28:	683b      	ldr	r3, [r7, #0]
 8009c2a:	1c99      	adds	r1, r3, #2
 8009c2c:	683b      	ldr	r3, [r7, #0]
 8009c2e:	3303      	adds	r3, #3
 8009c30:	001a      	movs	r2, r3
 8009c32:	f002 fe1b 	bl	800c86c <VL53L1_decode_zone_size>
		&(puser_zone->width),
		&(puser_zone->height));

	LOG_FUNCTION_END(status);

	return status;
 8009c36:	193b      	adds	r3, r7, r4
 8009c38:	781b      	ldrb	r3, [r3, #0]
 8009c3a:	b25b      	sxtb	r3, r3
}
 8009c3c:	0018      	movs	r0, r3
 8009c3e:	46bd      	mov	sp, r7
 8009c40:	b005      	add	sp, #20
 8009c42:	bd90      	pop	{r4, r7, pc}

08009c44 <VL53L1_get_mode_mitigation_roi>:


VL53L1_Error VL53L1_get_mode_mitigation_roi(
	VL53L1_DEV              Dev,
	VL53L1_user_zone_t     *pmm_roi)
{
 8009c44:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009c46:	b087      	sub	sp, #28
 8009c48:	af00      	add	r7, sp, #0
 8009c4a:	6078      	str	r0, [r7, #4]
 8009c4c:	6039      	str	r1, [r7, #0]
	/**
	 * Convenience function for getting the mode mitigation ROI
	 */

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 8009c4e:	2317      	movs	r3, #23
 8009c50:	18fb      	adds	r3, r7, r3
 8009c52:	2200      	movs	r2, #0
 8009c54:	701a      	strb	r2, [r3, #0]
	VL53L1_LLDriverData_t *pdev = VL53L1DevStructGetLLDriverHandle(Dev);
 8009c56:	687b      	ldr	r3, [r7, #4]
 8009c58:	613b      	str	r3, [r7, #16]

	uint8_t  x       = 0;
 8009c5a:	210e      	movs	r1, #14
 8009c5c:	187b      	adds	r3, r7, r1
 8009c5e:	2200      	movs	r2, #0
 8009c60:	701a      	strb	r2, [r3, #0]
	uint8_t  y       = 0;
 8009c62:	200d      	movs	r0, #13
 8009c64:	183b      	adds	r3, r7, r0
 8009c66:	2200      	movs	r2, #0
 8009c68:	701a      	strb	r2, [r3, #0]
	uint8_t  xy_size = 0;
 8009c6a:	240f      	movs	r4, #15
 8009c6c:	193b      	adds	r3, r7, r4
 8009c6e:	2200      	movs	r2, #0
 8009c70:	701a      	strb	r2, [r3, #0]

	LOG_FUNCTION_START("");

	/* convert SPAD number into (row,col) location */
	VL53L1_decode_row_col(
 8009c72:	693b      	ldr	r3, [r7, #16]
 8009c74:	4a16      	ldr	r2, [pc, #88]	; (8009cd0 <VL53L1_get_mode_mitigation_roi+0x8c>)
 8009c76:	5c9b      	ldrb	r3, [r3, r2]
 8009c78:	000d      	movs	r5, r1
 8009c7a:	187a      	adds	r2, r7, r1
 8009c7c:	0006      	movs	r6, r0
 8009c7e:	1839      	adds	r1, r7, r0
 8009c80:	0018      	movs	r0, r3
 8009c82:	f002 ffec 	bl	800cc5e <VL53L1_decode_row_col>
			pdev->nvm_copy_data.roi_config__mode_roi_centre_spad,
			&y,
			&x);

	pmm_roi->x_centre = x;
 8009c86:	0029      	movs	r1, r5
 8009c88:	187b      	adds	r3, r7, r1
 8009c8a:	781a      	ldrb	r2, [r3, #0]
 8009c8c:	683b      	ldr	r3, [r7, #0]
 8009c8e:	701a      	strb	r2, [r3, #0]
	pmm_roi->y_centre = y;
 8009c90:	0030      	movs	r0, r6
 8009c92:	183b      	adds	r3, r7, r0
 8009c94:	781a      	ldrb	r2, [r3, #0]
 8009c96:	683b      	ldr	r3, [r7, #0]
 8009c98:	705a      	strb	r2, [r3, #1]
	 * versus the API sense
	 *
	 * MS Nibble = height
	 * LS Nibble = width
	 */
	xy_size = pdev->nvm_copy_data.roi_config__mode_roi_xy_size;
 8009c9a:	193b      	adds	r3, r7, r4
 8009c9c:	693a      	ldr	r2, [r7, #16]
 8009c9e:	490d      	ldr	r1, [pc, #52]	; (8009cd4 <VL53L1_get_mode_mitigation_roi+0x90>)
 8009ca0:	5c52      	ldrb	r2, [r2, r1]
 8009ca2:	701a      	strb	r2, [r3, #0]

	pmm_roi->height = xy_size >> 4;
 8009ca4:	193b      	adds	r3, r7, r4
 8009ca6:	781b      	ldrb	r3, [r3, #0]
 8009ca8:	091b      	lsrs	r3, r3, #4
 8009caa:	b2da      	uxtb	r2, r3
 8009cac:	683b      	ldr	r3, [r7, #0]
 8009cae:	70da      	strb	r2, [r3, #3]
	pmm_roi->width  = xy_size & 0x0F;
 8009cb0:	193b      	adds	r3, r7, r4
 8009cb2:	781b      	ldrb	r3, [r3, #0]
 8009cb4:	220f      	movs	r2, #15
 8009cb6:	4013      	ands	r3, r2
 8009cb8:	b2da      	uxtb	r2, r3
 8009cba:	683b      	ldr	r3, [r7, #0]
 8009cbc:	709a      	strb	r2, [r3, #2]

	LOG_FUNCTION_END(status);

	return status;
 8009cbe:	2317      	movs	r3, #23
 8009cc0:	18fb      	adds	r3, r7, r3
 8009cc2:	781b      	ldrb	r3, [r3, #0]
 8009cc4:	b25b      	sxtb	r3, r3
}
 8009cc6:	0018      	movs	r0, r3
 8009cc8:	46bd      	mov	sp, r7
 8009cca:	b007      	add	sp, #28
 8009ccc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8009cce:	46c0      	nop			; (mov r8, r8)
 8009cd0:	0000022a 	.word	0x0000022a
 8009cd4:	0000022b 	.word	0x0000022b

08009cd8 <VL53L1_get_preset_mode_timing_cfg>:
	VL53L1_DevicePresetModes     device_preset_mode,
	uint16_t                    *pdss_config__target_total_rate_mcps,
	uint32_t                    *pphasecal_config_timeout_us,
	uint32_t                    *pmm_config_timeout_us,
	uint32_t                    *prange_config_timeout_us)
{
 8009cd8:	b580      	push	{r7, lr}
 8009cda:	b086      	sub	sp, #24
 8009cdc:	af00      	add	r7, sp, #0
 8009cde:	60f8      	str	r0, [r7, #12]
 8009ce0:	607a      	str	r2, [r7, #4]
 8009ce2:	603b      	str	r3, [r7, #0]
 8009ce4:	200b      	movs	r0, #11
 8009ce6:	183b      	adds	r3, r7, r0
 8009ce8:	1c0a      	adds	r2, r1, #0
 8009cea:	701a      	strb	r2, [r3, #0]
	VL53L1_Error  status = VL53L1_ERROR_NONE;
 8009cec:	2317      	movs	r3, #23
 8009cee:	18fb      	adds	r3, r7, r3
 8009cf0:	2200      	movs	r2, #0
 8009cf2:	701a      	strb	r2, [r3, #0]
	VL53L1_LLDriverData_t *pdev = VL53L1DevStructGetLLDriverHandle(Dev);
 8009cf4:	68fb      	ldr	r3, [r7, #12]
 8009cf6:	613b      	str	r3, [r7, #16]

	LOG_FUNCTION_START("");


	switch (device_preset_mode) {
 8009cf8:	183b      	adds	r3, r7, r0
 8009cfa:	781b      	ldrb	r3, [r3, #0]
 8009cfc:	2b26      	cmp	r3, #38	; 0x26
 8009cfe:	d843      	bhi.n	8009d88 <VL53L1_get_preset_mode_timing_cfg+0xb0>
 8009d00:	009a      	lsls	r2, r3, #2
 8009d02:	4b28      	ldr	r3, [pc, #160]	; (8009da4 <VL53L1_get_preset_mode_timing_cfg+0xcc>)
 8009d04:	18d3      	adds	r3, r2, r3
 8009d06:	681b      	ldr	r3, [r3, #0]
 8009d08:	469f      	mov	pc, r3
	case VL53L1_DEVICEPRESETMODE_STANDARD_RANGING_LONG_RANGE:
	case VL53L1_DEVICEPRESETMODE_STANDARD_RANGING_MM1_CAL:
	case VL53L1_DEVICEPRESETMODE_STANDARD_RANGING_MM2_CAL:
	case VL53L1_DEVICEPRESETMODE_OLT:
		*pdss_config__target_total_rate_mcps =
				pdev->tuning_parms.tp_dss_target_lite_mcps;
 8009d0a:	693b      	ldr	r3, [r7, #16]
 8009d0c:	22ca      	movs	r2, #202	; 0xca
 8009d0e:	5a9a      	ldrh	r2, [r3, r2]
		*pdss_config__target_total_rate_mcps =
 8009d10:	687b      	ldr	r3, [r7, #4]
 8009d12:	801a      	strh	r2, [r3, #0]
		*pphasecal_config_timeout_us =
				pdev->tuning_parms.tp_phasecal_timeout_lite_us;
 8009d14:	693b      	ldr	r3, [r7, #16]
 8009d16:	22d0      	movs	r2, #208	; 0xd0
 8009d18:	589a      	ldr	r2, [r3, r2]
		*pphasecal_config_timeout_us =
 8009d1a:	683b      	ldr	r3, [r7, #0]
 8009d1c:	601a      	str	r2, [r3, #0]
		*pmm_config_timeout_us =
				pdev->tuning_parms.tp_mm_timeout_lite_us;
 8009d1e:	693b      	ldr	r3, [r7, #16]
 8009d20:	22d8      	movs	r2, #216	; 0xd8
 8009d22:	589a      	ldr	r2, [r3, r2]
		*pmm_config_timeout_us =
 8009d24:	6a3b      	ldr	r3, [r7, #32]
 8009d26:	601a      	str	r2, [r3, #0]
		*prange_config_timeout_us =
				pdev->tuning_parms.tp_range_timeout_lite_us;
 8009d28:	693b      	ldr	r3, [r7, #16]
 8009d2a:	22e4      	movs	r2, #228	; 0xe4
 8009d2c:	589a      	ldr	r2, [r3, r2]
		*prange_config_timeout_us =
 8009d2e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009d30:	601a      	str	r2, [r3, #0]
	break;
 8009d32:	e02e      	b.n	8009d92 <VL53L1_get_preset_mode_timing_cfg+0xba>
	case VL53L1_DEVICEPRESETMODE_TIMED_RANGING:
	case VL53L1_DEVICEPRESETMODE_TIMED_RANGING_SHORT_RANGE:
	case VL53L1_DEVICEPRESETMODE_TIMED_RANGING_LONG_RANGE:
	case VL53L1_DEVICEPRESETMODE_SINGLESHOT_RANGING:
		*pdss_config__target_total_rate_mcps =
				pdev->tuning_parms.tp_dss_target_timed_mcps;
 8009d34:	693b      	ldr	r3, [r7, #16]
 8009d36:	22cc      	movs	r2, #204	; 0xcc
 8009d38:	5a9a      	ldrh	r2, [r3, r2]
		*pdss_config__target_total_rate_mcps =
 8009d3a:	687b      	ldr	r3, [r7, #4]
 8009d3c:	801a      	strh	r2, [r3, #0]
		*pphasecal_config_timeout_us =
				pdev->tuning_parms.tp_phasecal_timeout_timed_us;
 8009d3e:	693b      	ldr	r3, [r7, #16]
 8009d40:	22d4      	movs	r2, #212	; 0xd4
 8009d42:	589a      	ldr	r2, [r3, r2]
		*pphasecal_config_timeout_us =
 8009d44:	683b      	ldr	r3, [r7, #0]
 8009d46:	601a      	str	r2, [r3, #0]
		*pmm_config_timeout_us =
				pdev->tuning_parms.tp_mm_timeout_timed_us;
 8009d48:	693b      	ldr	r3, [r7, #16]
 8009d4a:	22dc      	movs	r2, #220	; 0xdc
 8009d4c:	589a      	ldr	r2, [r3, r2]
		*pmm_config_timeout_us =
 8009d4e:	6a3b      	ldr	r3, [r7, #32]
 8009d50:	601a      	str	r2, [r3, #0]
		*prange_config_timeout_us =
				pdev->tuning_parms.tp_range_timeout_timed_us;
 8009d52:	693b      	ldr	r3, [r7, #16]
 8009d54:	22e8      	movs	r2, #232	; 0xe8
 8009d56:	589a      	ldr	r2, [r3, r2]
		*prange_config_timeout_us =
 8009d58:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009d5a:	601a      	str	r2, [r3, #0]
	break;
 8009d5c:	e019      	b.n	8009d92 <VL53L1_get_preset_mode_timing_cfg+0xba>

	case VL53L1_DEVICEPRESETMODE_LOWPOWERAUTO_SHORT_RANGE:
	case VL53L1_DEVICEPRESETMODE_LOWPOWERAUTO_MEDIUM_RANGE:
	case VL53L1_DEVICEPRESETMODE_LOWPOWERAUTO_LONG_RANGE:
		*pdss_config__target_total_rate_mcps =
				pdev->tuning_parms.tp_dss_target_timed_mcps;
 8009d5e:	693b      	ldr	r3, [r7, #16]
 8009d60:	22cc      	movs	r2, #204	; 0xcc
 8009d62:	5a9a      	ldrh	r2, [r3, r2]
		*pdss_config__target_total_rate_mcps =
 8009d64:	687b      	ldr	r3, [r7, #4]
 8009d66:	801a      	strh	r2, [r3, #0]
		*pphasecal_config_timeout_us =
				pdev->tuning_parms.tp_phasecal_timeout_timed_us;
 8009d68:	693b      	ldr	r3, [r7, #16]
 8009d6a:	22d4      	movs	r2, #212	; 0xd4
 8009d6c:	589a      	ldr	r2, [r3, r2]
		*pphasecal_config_timeout_us =
 8009d6e:	683b      	ldr	r3, [r7, #0]
 8009d70:	601a      	str	r2, [r3, #0]
		*pmm_config_timeout_us =
				pdev->tuning_parms.tp_mm_timeout_lpa_us;
 8009d72:	693b      	ldr	r3, [r7, #16]
 8009d74:	22e0      	movs	r2, #224	; 0xe0
 8009d76:	589a      	ldr	r2, [r3, r2]
		*pmm_config_timeout_us =
 8009d78:	6a3b      	ldr	r3, [r7, #32]
 8009d7a:	601a      	str	r2, [r3, #0]
		*prange_config_timeout_us =
				pdev->tuning_parms.tp_range_timeout_lpa_us;
 8009d7c:	693b      	ldr	r3, [r7, #16]
 8009d7e:	22ec      	movs	r2, #236	; 0xec
 8009d80:	589a      	ldr	r2, [r3, r2]
		*prange_config_timeout_us =
 8009d82:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009d84:	601a      	str	r2, [r3, #0]
	break;
 8009d86:	e004      	b.n	8009d92 <VL53L1_get_preset_mode_timing_cfg+0xba>

	default:
		status = VL53L1_ERROR_INVALID_PARAMS;
 8009d88:	2317      	movs	r3, #23
 8009d8a:	18fb      	adds	r3, r7, r3
 8009d8c:	22fc      	movs	r2, #252	; 0xfc
 8009d8e:	701a      	strb	r2, [r3, #0]
		break;
 8009d90:	46c0      	nop			; (mov r8, r8)

	}

	LOG_FUNCTION_END(status);

	return status;
 8009d92:	2317      	movs	r3, #23
 8009d94:	18fb      	adds	r3, r7, r3
 8009d96:	781b      	ldrb	r3, [r3, #0]
 8009d98:	b25b      	sxtb	r3, r3
}
 8009d9a:	0018      	movs	r0, r3
 8009d9c:	46bd      	mov	sp, r7
 8009d9e:	b006      	add	sp, #24
 8009da0:	bd80      	pop	{r7, pc}
 8009da2:	46c0      	nop			; (mov r8, r8)
 8009da4:	08014f7c 	.word	0x08014f7c

08009da8 <VL53L1_set_preset_mode>:
	uint16_t                     dss_config__target_total_rate_mcps,
	uint32_t                     phasecal_config_timeout_us,
	uint32_t                     mm_config_timeout_us,
	uint32_t                     range_config_timeout_us,
	uint32_t                     inter_measurement_period_ms)
{
 8009da8:	b5b0      	push	{r4, r5, r7, lr}
 8009daa:	b092      	sub	sp, #72	; 0x48
 8009dac:	af04      	add	r7, sp, #16
 8009dae:	60f8      	str	r0, [r7, #12]
 8009db0:	0008      	movs	r0, r1
 8009db2:	0011      	movs	r1, r2
 8009db4:	607b      	str	r3, [r7, #4]
 8009db6:	240b      	movs	r4, #11
 8009db8:	193b      	adds	r3, r7, r4
 8009dba:	1c02      	adds	r2, r0, #0
 8009dbc:	701a      	strb	r2, [r3, #0]
 8009dbe:	2308      	movs	r3, #8
 8009dc0:	18fb      	adds	r3, r7, r3
 8009dc2:	1c0a      	adds	r2, r1, #0
 8009dc4:	801a      	strh	r2, [r3, #0]
	/**
	 * Initializes static and dynamic data structures for
	 * the provided preset mode
	 */

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 8009dc6:	2337      	movs	r3, #55	; 0x37
 8009dc8:	18fb      	adds	r3, r7, r3
 8009dca:	2200      	movs	r2, #0
 8009dcc:	701a      	strb	r2, [r3, #0]
	VL53L1_LLDriverData_t *pdev =
 8009dce:	68fb      	ldr	r3, [r7, #12]
 8009dd0:	633b      	str	r3, [r7, #48]	; 0x30
			VL53L1DevStructGetLLDriverHandle(Dev);

	VL53L1_static_config_t        *pstatic       = &(pdev->stat_cfg);
 8009dd2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009dd4:	3365      	adds	r3, #101	; 0x65
 8009dd6:	33ff      	adds	r3, #255	; 0xff
 8009dd8:	62fb      	str	r3, [r7, #44]	; 0x2c
	VL53L1_general_config_t       *pgeneral      = &(pdev->gen_cfg);
 8009dda:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009ddc:	3385      	adds	r3, #133	; 0x85
 8009dde:	33ff      	adds	r3, #255	; 0xff
 8009de0:	62bb      	str	r3, [r7, #40]	; 0x28
	VL53L1_timing_config_t        *ptiming       = &(pdev->tim_cfg);
 8009de2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009de4:	339d      	adds	r3, #157	; 0x9d
 8009de6:	33ff      	adds	r3, #255	; 0xff
 8009de8:	627b      	str	r3, [r7, #36]	; 0x24
	VL53L1_dynamic_config_t       *pdynamic      = &(pdev->dyn_cfg);
 8009dea:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009dec:	33b5      	adds	r3, #181	; 0xb5
 8009dee:	33ff      	adds	r3, #255	; 0xff
 8009df0:	623b      	str	r3, [r7, #32]
	VL53L1_system_control_t       *psystem       = &(pdev->sys_ctrl);
 8009df2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009df4:	33c9      	adds	r3, #201	; 0xc9
 8009df6:	33ff      	adds	r3, #255	; 0xff
 8009df8:	61fb      	str	r3, [r7, #28]
	VL53L1_tuning_parm_storage_t  *ptuning_parms = &(pdev->tuning_parms);
 8009dfa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009dfc:	33a4      	adds	r3, #164	; 0xa4
 8009dfe:	61bb      	str	r3, [r7, #24]
	VL53L1_low_power_auto_data_t  *plpadata      =
 8009e00:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009e02:	22b9      	movs	r2, #185	; 0xb9
 8009e04:	0092      	lsls	r2, r2, #2
 8009e06:	4694      	mov	ip, r2
 8009e08:	4463      	add	r3, ip
 8009e0a:	617b      	str	r3, [r7, #20]
					&(pdev->low_power_auto_data);

	LOG_FUNCTION_START("");

	/* save input settings */
	pdev->preset_mode                 = device_preset_mode;
 8009e0c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009e0e:	193a      	adds	r2, r7, r4
 8009e10:	7812      	ldrb	r2, [r2, #0]
 8009e12:	705a      	strb	r2, [r3, #1]
	pdev->mm_config_timeout_us        = mm_config_timeout_us;
 8009e14:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009e16:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8009e18:	60da      	str	r2, [r3, #12]
	pdev->range_config_timeout_us     = range_config_timeout_us;
 8009e1a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009e1c:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8009e1e:	611a      	str	r2, [r3, #16]
	pdev->inter_measurement_period_ms = inter_measurement_period_ms;
 8009e20:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009e22:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8009e24:	615a      	str	r2, [r3, #20]

	/* Reset LL Driver state variables */

	VL53L1_init_ll_driver_state(
 8009e26:	68fb      	ldr	r3, [r7, #12]
 8009e28:	2103      	movs	r1, #3
 8009e2a:	0018      	movs	r0, r3
 8009e2c:	f001 ff33 	bl	800bc96 <VL53L1_init_ll_driver_state>
			Dev,
			VL53L1_DEVICESTATE_SW_STANDBY);

	/* apply selected preset */

	switch (device_preset_mode) {
 8009e30:	193b      	adds	r3, r7, r4
 8009e32:	781b      	ldrb	r3, [r3, #0]
 8009e34:	2b26      	cmp	r3, #38	; 0x26
 8009e36:	d900      	bls.n	8009e3a <VL53L1_set_preset_mode+0x92>
 8009e38:	e0da      	b.n	8009ff0 <VL53L1_set_preset_mode+0x248>
 8009e3a:	009a      	lsls	r2, r3, #2
 8009e3c:	4b8a      	ldr	r3, [pc, #552]	; (800a068 <VL53L1_set_preset_mode+0x2c0>)
 8009e3e:	18d3      	adds	r3, r2, r3
 8009e40:	681b      	ldr	r3, [r3, #0]
 8009e42:	469f      	mov	pc, r3

	case VL53L1_DEVICEPRESETMODE_STANDARD_RANGING:
		status = VL53L1_preset_mode_standard_ranging(
 8009e44:	2337      	movs	r3, #55	; 0x37
 8009e46:	18fc      	adds	r4, r7, r3
 8009e48:	6a3d      	ldr	r5, [r7, #32]
 8009e4a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8009e4c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8009e4e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8009e50:	69bb      	ldr	r3, [r7, #24]
 8009e52:	9301      	str	r3, [sp, #4]
 8009e54:	69fb      	ldr	r3, [r7, #28]
 8009e56:	9300      	str	r3, [sp, #0]
 8009e58:	002b      	movs	r3, r5
 8009e5a:	f001 fb41 	bl	800b4e0 <VL53L1_preset_mode_standard_ranging>
 8009e5e:	0003      	movs	r3, r0
 8009e60:	7023      	strb	r3, [r4, #0]
					pgeneral,
					ptiming,
					pdynamic,
					psystem,
					ptuning_parms);
		break;
 8009e62:	e0ca      	b.n	8009ffa <VL53L1_set_preset_mode+0x252>

	case VL53L1_DEVICEPRESETMODE_STANDARD_RANGING_SHORT_RANGE:
		status = VL53L1_preset_mode_standard_ranging_short_range(
 8009e64:	2337      	movs	r3, #55	; 0x37
 8009e66:	18fc      	adds	r4, r7, r3
 8009e68:	6a3d      	ldr	r5, [r7, #32]
 8009e6a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8009e6c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8009e6e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8009e70:	69bb      	ldr	r3, [r7, #24]
 8009e72:	9301      	str	r3, [sp, #4]
 8009e74:	69fb      	ldr	r3, [r7, #28]
 8009e76:	9300      	str	r3, [sp, #0]
 8009e78:	002b      	movs	r3, r5
 8009e7a:	f001 fc51 	bl	800b720 <VL53L1_preset_mode_standard_ranging_short_range>
 8009e7e:	0003      	movs	r3, r0
 8009e80:	7023      	strb	r3, [r4, #0]
					pgeneral,
					ptiming,
					pdynamic,
					psystem,
					ptuning_parms);
		break;
 8009e82:	e0ba      	b.n	8009ffa <VL53L1_set_preset_mode+0x252>

	case VL53L1_DEVICEPRESETMODE_STANDARD_RANGING_LONG_RANGE:
		status = VL53L1_preset_mode_standard_ranging_long_range(
 8009e84:	2337      	movs	r3, #55	; 0x37
 8009e86:	18fc      	adds	r4, r7, r3
 8009e88:	6a3d      	ldr	r5, [r7, #32]
 8009e8a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8009e8c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8009e8e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8009e90:	69bb      	ldr	r3, [r7, #24]
 8009e92:	9301      	str	r3, [sp, #4]
 8009e94:	69fb      	ldr	r3, [r7, #28]
 8009e96:	9300      	str	r3, [sp, #0]
 8009e98:	002b      	movs	r3, r5
 8009e9a:	f001 fc89 	bl	800b7b0 <VL53L1_preset_mode_standard_ranging_long_range>
 8009e9e:	0003      	movs	r3, r0
 8009ea0:	7023      	strb	r3, [r4, #0]
					pgeneral,
					ptiming,
					pdynamic,
					psystem,
					ptuning_parms);
		break;
 8009ea2:	e0aa      	b.n	8009ffa <VL53L1_set_preset_mode+0x252>

#ifndef VL53L1_NOCALIB
	case VL53L1_DEVICEPRESETMODE_STANDARD_RANGING_MM1_CAL:
		status = VL53L1_preset_mode_standard_ranging_mm1_cal(
 8009ea4:	2337      	movs	r3, #55	; 0x37
 8009ea6:	18fc      	adds	r4, r7, r3
 8009ea8:	6a3d      	ldr	r5, [r7, #32]
 8009eaa:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8009eac:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8009eae:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8009eb0:	69bb      	ldr	r3, [r7, #24]
 8009eb2:	9301      	str	r3, [sp, #4]
 8009eb4:	69fb      	ldr	r3, [r7, #28]
 8009eb6:	9300      	str	r3, [sp, #0]
 8009eb8:	002b      	movs	r3, r5
 8009eba:	f001 fcc1 	bl	800b840 <VL53L1_preset_mode_standard_ranging_mm1_cal>
 8009ebe:	0003      	movs	r3, r0
 8009ec0:	7023      	strb	r3, [r4, #0]
					pgeneral,
					ptiming,
					pdynamic,
					psystem,
					ptuning_parms);
		break;
 8009ec2:	e09a      	b.n	8009ffa <VL53L1_set_preset_mode+0x252>

	case VL53L1_DEVICEPRESETMODE_STANDARD_RANGING_MM2_CAL:
		status = VL53L1_preset_mode_standard_ranging_mm2_cal(
 8009ec4:	2337      	movs	r3, #55	; 0x37
 8009ec6:	18fc      	adds	r4, r7, r3
 8009ec8:	6a3d      	ldr	r5, [r7, #32]
 8009eca:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8009ecc:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8009ece:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8009ed0:	69bb      	ldr	r3, [r7, #24]
 8009ed2:	9301      	str	r3, [sp, #4]
 8009ed4:	69fb      	ldr	r3, [r7, #28]
 8009ed6:	9300      	str	r3, [sp, #0]
 8009ed8:	002b      	movs	r3, r5
 8009eda:	f001 fcdd 	bl	800b898 <VL53L1_preset_mode_standard_ranging_mm2_cal>
 8009ede:	0003      	movs	r3, r0
 8009ee0:	7023      	strb	r3, [r4, #0]
					pgeneral,
					ptiming,
					pdynamic,
					psystem,
					ptuning_parms);
		break;
 8009ee2:	e08a      	b.n	8009ffa <VL53L1_set_preset_mode+0x252>
#endif

	case VL53L1_DEVICEPRESETMODE_TIMED_RANGING:
		status = VL53L1_preset_mode_timed_ranging(
 8009ee4:	2337      	movs	r3, #55	; 0x37
 8009ee6:	18fc      	adds	r4, r7, r3
 8009ee8:	6a3d      	ldr	r5, [r7, #32]
 8009eea:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8009eec:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8009eee:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8009ef0:	69bb      	ldr	r3, [r7, #24]
 8009ef2:	9301      	str	r3, [sp, #4]
 8009ef4:	69fb      	ldr	r3, [r7, #28]
 8009ef6:	9300      	str	r3, [sp, #0]
 8009ef8:	002b      	movs	r3, r5
 8009efa:	f001 fcf9 	bl	800b8f0 <VL53L1_preset_mode_timed_ranging>
 8009efe:	0003      	movs	r3, r0
 8009f00:	7023      	strb	r3, [r4, #0]
					pgeneral,
					ptiming,
					pdynamic,
					psystem,
					ptuning_parms);
		break;
 8009f02:	e07a      	b.n	8009ffa <VL53L1_set_preset_mode+0x252>

	case VL53L1_DEVICEPRESETMODE_TIMED_RANGING_SHORT_RANGE:
		status = VL53L1_preset_mode_timed_ranging_short_range(
 8009f04:	2337      	movs	r3, #55	; 0x37
 8009f06:	18fc      	adds	r4, r7, r3
 8009f08:	6a3d      	ldr	r5, [r7, #32]
 8009f0a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8009f0c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8009f0e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8009f10:	69bb      	ldr	r3, [r7, #24]
 8009f12:	9301      	str	r3, [sp, #4]
 8009f14:	69fb      	ldr	r3, [r7, #28]
 8009f16:	9300      	str	r3, [sp, #0]
 8009f18:	002b      	movs	r3, r5
 8009f1a:	f001 fd2a 	bl	800b972 <VL53L1_preset_mode_timed_ranging_short_range>
 8009f1e:	0003      	movs	r3, r0
 8009f20:	7023      	strb	r3, [r4, #0]
					pgeneral,
					ptiming,
					pdynamic,
					psystem,
					ptuning_parms);
		break;
 8009f22:	e06a      	b.n	8009ffa <VL53L1_set_preset_mode+0x252>

	case VL53L1_DEVICEPRESETMODE_TIMED_RANGING_LONG_RANGE:
		status = VL53L1_preset_mode_timed_ranging_long_range(
 8009f24:	2337      	movs	r3, #55	; 0x37
 8009f26:	18fc      	adds	r4, r7, r3
 8009f28:	6a3d      	ldr	r5, [r7, #32]
 8009f2a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8009f2c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8009f2e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8009f30:	69bb      	ldr	r3, [r7, #24]
 8009f32:	9301      	str	r3, [sp, #4]
 8009f34:	69fb      	ldr	r3, [r7, #28]
 8009f36:	9300      	str	r3, [sp, #0]
 8009f38:	002b      	movs	r3, r5
 8009f3a:	f001 fd5b 	bl	800b9f4 <VL53L1_preset_mode_timed_ranging_long_range>
 8009f3e:	0003      	movs	r3, r0
 8009f40:	7023      	strb	r3, [r4, #0]
					pgeneral,
					ptiming,
					pdynamic,
					psystem,
					ptuning_parms);
		break;
 8009f42:	e05a      	b.n	8009ffa <VL53L1_set_preset_mode+0x252>

	case VL53L1_DEVICEPRESETMODE_OLT:
		status = VL53L1_preset_mode_olt(
 8009f44:	2337      	movs	r3, #55	; 0x37
 8009f46:	18fc      	adds	r4, r7, r3
 8009f48:	6a3d      	ldr	r5, [r7, #32]
 8009f4a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8009f4c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8009f4e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8009f50:	69bb      	ldr	r3, [r7, #24]
 8009f52:	9301      	str	r3, [sp, #4]
 8009f54:	69fb      	ldr	r3, [r7, #28]
 8009f56:	9300      	str	r3, [sp, #0]
 8009f58:	002b      	movs	r3, r5
 8009f5a:	f001 fe59 	bl	800bc10 <VL53L1_preset_mode_olt>
 8009f5e:	0003      	movs	r3, r0
 8009f60:	7023      	strb	r3, [r4, #0]
					pgeneral,
					ptiming,
					pdynamic,
					psystem,
					ptuning_parms);
		break;
 8009f62:	e04a      	b.n	8009ffa <VL53L1_set_preset_mode+0x252>

	case VL53L1_DEVICEPRESETMODE_SINGLESHOT_RANGING:
		status = VL53L1_preset_mode_singleshot_ranging(
 8009f64:	2337      	movs	r3, #55	; 0x37
 8009f66:	18fc      	adds	r4, r7, r3
 8009f68:	6a3d      	ldr	r5, [r7, #32]
 8009f6a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8009f6c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8009f6e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8009f70:	69bb      	ldr	r3, [r7, #24]
 8009f72:	9301      	str	r3, [sp, #4]
 8009f74:	69fb      	ldr	r3, [r7, #28]
 8009f76:	9300      	str	r3, [sp, #0]
 8009f78:	002b      	movs	r3, r5
 8009f7a:	f001 fe0c 	bl	800bb96 <VL53L1_preset_mode_singleshot_ranging>
 8009f7e:	0003      	movs	r3, r0
 8009f80:	7023      	strb	r3, [r4, #0]
					pgeneral,
					ptiming,
					pdynamic,
					psystem,
					ptuning_parms);
		break;
 8009f82:	e03a      	b.n	8009ffa <VL53L1_set_preset_mode+0x252>

	case VL53L1_DEVICEPRESETMODE_LOWPOWERAUTO_SHORT_RANGE:
		status = VL53L1_preset_mode_low_power_auto_short_ranging(
 8009f84:	2337      	movs	r3, #55	; 0x37
 8009f86:	18fc      	adds	r4, r7, r3
 8009f88:	6a3d      	ldr	r5, [r7, #32]
 8009f8a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8009f8c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8009f8e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8009f90:	697b      	ldr	r3, [r7, #20]
 8009f92:	9302      	str	r3, [sp, #8]
 8009f94:	69bb      	ldr	r3, [r7, #24]
 8009f96:	9301      	str	r3, [sp, #4]
 8009f98:	69fb      	ldr	r3, [r7, #28]
 8009f9a:	9300      	str	r3, [sp, #0]
 8009f9c:	002b      	movs	r3, r5
 8009f9e:	f001 fd9a 	bl	800bad6 <VL53L1_preset_mode_low_power_auto_short_ranging>
 8009fa2:	0003      	movs	r3, r0
 8009fa4:	7023      	strb	r3, [r4, #0]
					ptiming,
					pdynamic,
					psystem,
					ptuning_parms,
					plpadata);
		break;
 8009fa6:	e028      	b.n	8009ffa <VL53L1_set_preset_mode+0x252>

	case VL53L1_DEVICEPRESETMODE_LOWPOWERAUTO_MEDIUM_RANGE:
		status = VL53L1_preset_mode_low_power_auto_ranging(
 8009fa8:	2337      	movs	r3, #55	; 0x37
 8009faa:	18fc      	adds	r4, r7, r3
 8009fac:	6a3d      	ldr	r5, [r7, #32]
 8009fae:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8009fb0:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8009fb2:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8009fb4:	697b      	ldr	r3, [r7, #20]
 8009fb6:	9302      	str	r3, [sp, #8]
 8009fb8:	69bb      	ldr	r3, [r7, #24]
 8009fba:	9301      	str	r3, [sp, #4]
 8009fbc:	69fb      	ldr	r3, [r7, #28]
 8009fbe:	9300      	str	r3, [sp, #0]
 8009fc0:	002b      	movs	r3, r5
 8009fc2:	f001 fd58 	bl	800ba76 <VL53L1_preset_mode_low_power_auto_ranging>
 8009fc6:	0003      	movs	r3, r0
 8009fc8:	7023      	strb	r3, [r4, #0]
					ptiming,
					pdynamic,
					psystem,
					ptuning_parms,
					plpadata);
		break;
 8009fca:	e016      	b.n	8009ffa <VL53L1_set_preset_mode+0x252>

	case VL53L1_DEVICEPRESETMODE_LOWPOWERAUTO_LONG_RANGE:
		status = VL53L1_preset_mode_low_power_auto_long_ranging(
 8009fcc:	2337      	movs	r3, #55	; 0x37
 8009fce:	18fc      	adds	r4, r7, r3
 8009fd0:	6a3d      	ldr	r5, [r7, #32]
 8009fd2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8009fd4:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8009fd6:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8009fd8:	697b      	ldr	r3, [r7, #20]
 8009fda:	9302      	str	r3, [sp, #8]
 8009fdc:	69bb      	ldr	r3, [r7, #24]
 8009fde:	9301      	str	r3, [sp, #4]
 8009fe0:	69fb      	ldr	r3, [r7, #28]
 8009fe2:	9300      	str	r3, [sp, #0]
 8009fe4:	002b      	movs	r3, r5
 8009fe6:	f001 fda6 	bl	800bb36 <VL53L1_preset_mode_low_power_auto_long_ranging>
 8009fea:	0003      	movs	r3, r0
 8009fec:	7023      	strb	r3, [r4, #0]
					ptiming,
					pdynamic,
					psystem,
					ptuning_parms,
					plpadata);
		break;
 8009fee:	e004      	b.n	8009ffa <VL53L1_set_preset_mode+0x252>

	default:
		status = VL53L1_ERROR_INVALID_PARAMS;
 8009ff0:	2337      	movs	r3, #55	; 0x37
 8009ff2:	18fb      	adds	r3, r7, r3
 8009ff4:	22fc      	movs	r2, #252	; 0xfc
 8009ff6:	701a      	strb	r2, [r3, #0]
		break;
 8009ff8:	46c0      	nop			; (mov r8, r8)

	}

	/* update DSS target */

	if (status == VL53L1_ERROR_NONE) {
 8009ffa:	2337      	movs	r3, #55	; 0x37
 8009ffc:	18fb      	adds	r3, r7, r3
 8009ffe:	781b      	ldrb	r3, [r3, #0]
 800a000:	b25b      	sxtb	r3, r3
 800a002:	2b00      	cmp	r3, #0
 800a004:	d108      	bne.n	800a018 <VL53L1_set_preset_mode+0x270>

		pstatic->dss_config__target_total_rate_mcps =
 800a006:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800a008:	2108      	movs	r1, #8
 800a00a:	187a      	adds	r2, r7, r1
 800a00c:	8812      	ldrh	r2, [r2, #0]
 800a00e:	801a      	strh	r2, [r3, #0]
				dss_config__target_total_rate_mcps;
		pdev->dss_config__target_total_rate_mcps    =
 800a010:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a012:	187a      	adds	r2, r7, r1
 800a014:	8812      	ldrh	r2, [r2, #0]
 800a016:	831a      	strh	r2, [r3, #24]
	/*
	 * Update the register timeout values based on input
	 * real time values and preset mode VCSEL periods
	 */

	if (status == VL53L1_ERROR_NONE)
 800a018:	2337      	movs	r3, #55	; 0x37
 800a01a:	18fb      	adds	r3, r7, r3
 800a01c:	781b      	ldrb	r3, [r3, #0]
 800a01e:	b25b      	sxtb	r3, r3
 800a020:	2b00      	cmp	r3, #0
 800a022:	d109      	bne.n	800a038 <VL53L1_set_preset_mode+0x290>
		status =
 800a024:	2337      	movs	r3, #55	; 0x37
 800a026:	18fc      	adds	r4, r7, r3
 800a028:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a02a:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800a02c:	6879      	ldr	r1, [r7, #4]
 800a02e:	68f8      	ldr	r0, [r7, #12]
 800a030:	f7ff fc9e 	bl	8009970 <VL53L1_set_timeouts_us>
 800a034:	0003      	movs	r3, r0
 800a036:	7023      	strb	r3, [r4, #0]
				Dev,
				phasecal_config_timeout_us,
				mm_config_timeout_us,
				range_config_timeout_us);

	if (status == VL53L1_ERROR_NONE)
 800a038:	2337      	movs	r3, #55	; 0x37
 800a03a:	18fb      	adds	r3, r7, r3
 800a03c:	781b      	ldrb	r3, [r3, #0]
 800a03e:	b25b      	sxtb	r3, r3
 800a040:	2b00      	cmp	r3, #0
 800a042:	d109      	bne.n	800a058 <VL53L1_set_preset_mode+0x2b0>
		status =
 800a044:	2337      	movs	r3, #55	; 0x37
 800a046:	18fc      	adds	r4, r7, r3
 800a048:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800a04a:	68fb      	ldr	r3, [r7, #12]
 800a04c:	0011      	movs	r1, r2
 800a04e:	0018      	movs	r0, r3
 800a050:	f7ff fc2a 	bl	80098a8 <VL53L1_set_inter_measurement_period_ms>
 800a054:	0003      	movs	r3, r0
 800a056:	7023      	strb	r3, [r4, #0]
				Dev,
				inter_measurement_period_ms);

	LOG_FUNCTION_END(status);

	return status;
 800a058:	2337      	movs	r3, #55	; 0x37
 800a05a:	18fb      	adds	r3, r7, r3
 800a05c:	781b      	ldrb	r3, [r3, #0]
 800a05e:	b25b      	sxtb	r3, r3
}
 800a060:	0018      	movs	r0, r3
 800a062:	46bd      	mov	sp, r7
 800a064:	b00e      	add	sp, #56	; 0x38
 800a066:	bdb0      	pop	{r4, r5, r7, pc}
 800a068:	08015018 	.word	0x08015018

0800a06c <VL53L1_get_lite_sigma_threshold>:
}

VL53L1_Error VL53L1_get_lite_sigma_threshold(
	VL53L1_DEV                          Dev,
	uint16_t                           *plite_sigma)
{
 800a06c:	b580      	push	{r7, lr}
 800a06e:	b084      	sub	sp, #16
 800a070:	af00      	add	r7, sp, #0
 800a072:	6078      	str	r0, [r7, #4]
 800a074:	6039      	str	r1, [r7, #0]
	 * Gets the Sigma Threshold value for Lite Mode
	 *
	 * (fixed point 14.2)
	 */

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 800a076:	210f      	movs	r1, #15
 800a078:	187b      	adds	r3, r7, r1
 800a07a:	2200      	movs	r2, #0
 800a07c:	701a      	strb	r2, [r3, #0]

	VL53L1_LLDriverData_t *pdev = VL53L1DevStructGetLLDriverHandle(Dev);
 800a07e:	687b      	ldr	r3, [r7, #4]
 800a080:	60bb      	str	r3, [r7, #8]

	LOG_FUNCTION_START("");

	*plite_sigma =
			pdev->tim_cfg.range_config__sigma_thresh;
 800a082:	68ba      	ldr	r2, [r7, #8]
 800a084:	23d3      	movs	r3, #211	; 0xd3
 800a086:	005b      	lsls	r3, r3, #1
 800a088:	5ad2      	ldrh	r2, [r2, r3]
	*plite_sigma =
 800a08a:	683b      	ldr	r3, [r7, #0]
 800a08c:	801a      	strh	r2, [r3, #0]

	LOG_FUNCTION_END(status);

	return status;
 800a08e:	187b      	adds	r3, r7, r1
 800a090:	781b      	ldrb	r3, [r3, #0]
 800a092:	b25b      	sxtb	r3, r3

}
 800a094:	0018      	movs	r0, r3
 800a096:	46bd      	mov	sp, r7
 800a098:	b004      	add	sp, #16
 800a09a:	bd80      	pop	{r7, pc}

0800a09c <VL53L1_set_lite_sigma_threshold>:

VL53L1_Error VL53L1_set_lite_sigma_threshold(
	VL53L1_DEV                          Dev,
	uint16_t                           lite_sigma)
{
 800a09c:	b580      	push	{r7, lr}
 800a09e:	b084      	sub	sp, #16
 800a0a0:	af00      	add	r7, sp, #0
 800a0a2:	6078      	str	r0, [r7, #4]
 800a0a4:	000a      	movs	r2, r1
 800a0a6:	1cbb      	adds	r3, r7, #2
 800a0a8:	801a      	strh	r2, [r3, #0]
	 * Sets the Sigma threshold value for Lite mode
	 *
	 * (fixed point 14.2)
	 */

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 800a0aa:	200f      	movs	r0, #15
 800a0ac:	183b      	adds	r3, r7, r0
 800a0ae:	2200      	movs	r2, #0
 800a0b0:	701a      	strb	r2, [r3, #0]

	VL53L1_LLDriverData_t *pdev = VL53L1DevStructGetLLDriverHandle(Dev);
 800a0b2:	687b      	ldr	r3, [r7, #4]
 800a0b4:	60bb      	str	r3, [r7, #8]

	LOG_FUNCTION_START("");

	pdev->tim_cfg.range_config__sigma_thresh = lite_sigma;
 800a0b6:	68ba      	ldr	r2, [r7, #8]
 800a0b8:	1cb9      	adds	r1, r7, #2
 800a0ba:	23d3      	movs	r3, #211	; 0xd3
 800a0bc:	005b      	lsls	r3, r3, #1
 800a0be:	8809      	ldrh	r1, [r1, #0]
 800a0c0:	52d1      	strh	r1, [r2, r3]

	LOG_FUNCTION_END(status);

	return status;
 800a0c2:	183b      	adds	r3, r7, r0
 800a0c4:	781b      	ldrb	r3, [r3, #0]
 800a0c6:	b25b      	sxtb	r3, r3

}
 800a0c8:	0018      	movs	r0, r3
 800a0ca:	46bd      	mov	sp, r7
 800a0cc:	b004      	add	sp, #16
 800a0ce:	bd80      	pop	{r7, pc}

0800a0d0 <VL53L1_get_lite_min_count_rate>:

VL53L1_Error VL53L1_get_lite_min_count_rate(
	VL53L1_DEV                          Dev,
	uint16_t                           *plite_mincountrate)
{
 800a0d0:	b580      	push	{r7, lr}
 800a0d2:	b084      	sub	sp, #16
 800a0d4:	af00      	add	r7, sp, #0
 800a0d6:	6078      	str	r0, [r7, #4]
 800a0d8:	6039      	str	r1, [r7, #0]
	 * Gets the Min Count Rate value for Lite Mode
	 *
	 * (fixed point 9.7 Mcps)
	 */

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 800a0da:	210f      	movs	r1, #15
 800a0dc:	187b      	adds	r3, r7, r1
 800a0de:	2200      	movs	r2, #0
 800a0e0:	701a      	strb	r2, [r3, #0]

	VL53L1_LLDriverData_t *pdev = VL53L1DevStructGetLLDriverHandle(Dev);
 800a0e2:	687b      	ldr	r3, [r7, #4]
 800a0e4:	60bb      	str	r3, [r7, #8]

	LOG_FUNCTION_START("");

	*plite_mincountrate =
			pdev->tim_cfg.range_config__min_count_rate_rtn_limit_mcps;
 800a0e6:	68ba      	ldr	r2, [r7, #8]
 800a0e8:	23d4      	movs	r3, #212	; 0xd4
 800a0ea:	005b      	lsls	r3, r3, #1
 800a0ec:	5ad2      	ldrh	r2, [r2, r3]
	*plite_mincountrate =
 800a0ee:	683b      	ldr	r3, [r7, #0]
 800a0f0:	801a      	strh	r2, [r3, #0]

	LOG_FUNCTION_END(status);

	return status;
 800a0f2:	187b      	adds	r3, r7, r1
 800a0f4:	781b      	ldrb	r3, [r3, #0]
 800a0f6:	b25b      	sxtb	r3, r3

}
 800a0f8:	0018      	movs	r0, r3
 800a0fa:	46bd      	mov	sp, r7
 800a0fc:	b004      	add	sp, #16
 800a0fe:	bd80      	pop	{r7, pc}

0800a100 <VL53L1_set_lite_min_count_rate>:

VL53L1_Error VL53L1_set_lite_min_count_rate(
	VL53L1_DEV                          Dev,
	uint16_t                            lite_mincountrate)
{
 800a100:	b580      	push	{r7, lr}
 800a102:	b084      	sub	sp, #16
 800a104:	af00      	add	r7, sp, #0
 800a106:	6078      	str	r0, [r7, #4]
 800a108:	000a      	movs	r2, r1
 800a10a:	1cbb      	adds	r3, r7, #2
 800a10c:	801a      	strh	r2, [r3, #0]
	 * Sets the Min COunt Rate value for Lite mode
	 *
	 * (fixed point 19.7Mcps)
	 */

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 800a10e:	200f      	movs	r0, #15
 800a110:	183b      	adds	r3, r7, r0
 800a112:	2200      	movs	r2, #0
 800a114:	701a      	strb	r2, [r3, #0]

	VL53L1_LLDriverData_t *pdev = VL53L1DevStructGetLLDriverHandle(Dev);
 800a116:	687b      	ldr	r3, [r7, #4]
 800a118:	60bb      	str	r3, [r7, #8]

	LOG_FUNCTION_START("");

	pdev->tim_cfg.range_config__min_count_rate_rtn_limit_mcps =
 800a11a:	68ba      	ldr	r2, [r7, #8]
 800a11c:	1cb9      	adds	r1, r7, #2
 800a11e:	23d4      	movs	r3, #212	; 0xd4
 800a120:	005b      	lsls	r3, r3, #1
 800a122:	8809      	ldrh	r1, [r1, #0]
 800a124:	52d1      	strh	r1, [r2, r3]
		lite_mincountrate;

	LOG_FUNCTION_END(status);

	return status;
 800a126:	183b      	adds	r3, r7, r0
 800a128:	781b      	ldrb	r3, [r3, #0]
 800a12a:	b25b      	sxtb	r3, r3

}
 800a12c:	0018      	movs	r0, r3
 800a12e:	46bd      	mov	sp, r7
 800a130:	b004      	add	sp, #16
 800a132:	bd80      	pop	{r7, pc}

0800a134 <VL53L1_set_vhv_loopbound>:


VL53L1_Error VL53L1_set_vhv_loopbound(
	VL53L1_DEV                   Dev,
	uint8_t                      vhv_loopbound)
{
 800a134:	b580      	push	{r7, lr}
 800a136:	b084      	sub	sp, #16
 800a138:	af00      	add	r7, sp, #0
 800a13a:	6078      	str	r0, [r7, #4]
 800a13c:	000a      	movs	r2, r1
 800a13e:	1cfb      	adds	r3, r7, #3
 800a140:	701a      	strb	r2, [r3, #0]
	 * - ensure that any change here is followed by a
	 * init_and_start_range with full i2c packet
	 * configuration.
	 */

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 800a142:	200f      	movs	r0, #15
 800a144:	183b      	adds	r3, r7, r0
 800a146:	2200      	movs	r2, #0
 800a148:	701a      	strb	r2, [r3, #0]

	VL53L1_LLDriverData_t *pdev = VL53L1DevStructGetLLDriverHandle(Dev);
 800a14a:	687b      	ldr	r3, [r7, #4]
 800a14c:	60bb      	str	r3, [r7, #8]

	LOG_FUNCTION_START("");

	pdev->stat_nvm.vhv_config__timeout_macrop_loop_bound =
			(pdev->stat_nvm.vhv_config__timeout_macrop_loop_bound & 0x03) +
 800a14e:	68ba      	ldr	r2, [r7, #8]
 800a150:	23b0      	movs	r3, #176	; 0xb0
 800a152:	005b      	lsls	r3, r3, #1
 800a154:	5cd3      	ldrb	r3, [r2, r3]
 800a156:	2203      	movs	r2, #3
 800a158:	4013      	ands	r3, r2
 800a15a:	b2da      	uxtb	r2, r3
 800a15c:	1cfb      	adds	r3, r7, #3
 800a15e:	781b      	ldrb	r3, [r3, #0]
 800a160:	009b      	lsls	r3, r3, #2
 800a162:	b2db      	uxtb	r3, r3
 800a164:	18d3      	adds	r3, r2, r3
 800a166:	b2d9      	uxtb	r1, r3
	pdev->stat_nvm.vhv_config__timeout_macrop_loop_bound =
 800a168:	68ba      	ldr	r2, [r7, #8]
 800a16a:	23b0      	movs	r3, #176	; 0xb0
 800a16c:	005b      	lsls	r3, r3, #1
 800a16e:	54d1      	strb	r1, [r2, r3]
			(vhv_loopbound * 4);

	LOG_FUNCTION_END(status);

	return status;
 800a170:	183b      	adds	r3, r7, r0
 800a172:	781b      	ldrb	r3, [r3, #0]
 800a174:	b25b      	sxtb	r3, r3

}
 800a176:	0018      	movs	r0, r3
 800a178:	46bd      	mov	sp, r7
 800a17a:	b004      	add	sp, #16
 800a17c:	bd80      	pop	{r7, pc}
	...

0800a180 <VL53L1_init_and_start_range>:

VL53L1_Error VL53L1_init_and_start_range(
	VL53L1_DEV                     Dev,
	uint8_t                        measurement_mode,
	VL53L1_DeviceConfigLevel       device_config_level)
{
 800a180:	b5b0      	push	{r4, r5, r7, lr}
 800a182:	b0d0      	sub	sp, #320	; 0x140
 800a184:	af00      	add	r7, sp, #0
 800a186:	6078      	str	r0, [r7, #4]
 800a188:	0008      	movs	r0, r1
 800a18a:	0011      	movs	r1, r2
 800a18c:	4bb5      	ldr	r3, [pc, #724]	; (800a464 <VL53L1_init_and_start_range+0x2e4>)
 800a18e:	22a0      	movs	r2, #160	; 0xa0
 800a190:	0052      	lsls	r2, r2, #1
 800a192:	4694      	mov	ip, r2
 800a194:	44bc      	add	ip, r7
 800a196:	4463      	add	r3, ip
 800a198:	1c02      	adds	r2, r0, #0
 800a19a:	701a      	strb	r2, [r3, #0]
 800a19c:	4bb2      	ldr	r3, [pc, #712]	; (800a468 <VL53L1_init_and_start_range+0x2e8>)
 800a19e:	22a0      	movs	r2, #160	; 0xa0
 800a1a0:	0052      	lsls	r2, r2, #1
 800a1a2:	4694      	mov	ip, r2
 800a1a4:	44bc      	add	ip, r7
 800a1a6:	4463      	add	r3, ip
 800a1a8:	1c0a      	adds	r2, r1, #0
 800a1aa:	701a      	strb	r2, [r3, #0]
	 * system_control is always sent as the last byte of this
	 * register group (mode_start) either triggers the range
	 * or enables the next range
	 */

	VL53L1_Error status = VL53L1_ERROR_NONE;
 800a1ac:	2340      	movs	r3, #64	; 0x40
 800a1ae:	33ff      	adds	r3, #255	; 0xff
 800a1b0:	18fb      	adds	r3, r7, r3
 800a1b2:	2200      	movs	r2, #0
 800a1b4:	701a      	strb	r2, [r3, #0]
	VL53L1_LLDriverData_t *pdev = VL53L1DevStructGetLLDriverHandle(Dev);
 800a1b6:	687b      	ldr	r3, [r7, #4]
 800a1b8:	2198      	movs	r1, #152	; 0x98
 800a1ba:	0049      	lsls	r1, r1, #1
 800a1bc:	187a      	adds	r2, r7, r1
 800a1be:	6013      	str	r3, [r2, #0]

	uint8_t buffer[VL53L1_MAX_I2C_XFER_SIZE];

	VL53L1_static_nvm_managed_t   *pstatic_nvm   = &(pdev->stat_nvm);
 800a1c0:	187b      	adds	r3, r7, r1
 800a1c2:	681b      	ldr	r3, [r3, #0]
 800a1c4:	3359      	adds	r3, #89	; 0x59
 800a1c6:	33ff      	adds	r3, #255	; 0xff
 800a1c8:	2296      	movs	r2, #150	; 0x96
 800a1ca:	0052      	lsls	r2, r2, #1
 800a1cc:	18ba      	adds	r2, r7, r2
 800a1ce:	6013      	str	r3, [r2, #0]
	VL53L1_customer_nvm_managed_t *pcustomer_nvm = &(pdev->customer);
 800a1d0:	187b      	adds	r3, r7, r1
 800a1d2:	681b      	ldr	r3, [r3, #0]
 800a1d4:	3342      	adds	r3, #66	; 0x42
 800a1d6:	2294      	movs	r2, #148	; 0x94
 800a1d8:	0052      	lsls	r2, r2, #1
 800a1da:	18ba      	adds	r2, r7, r2
 800a1dc:	6013      	str	r3, [r2, #0]
	VL53L1_static_config_t        *pstatic       = &(pdev->stat_cfg);
 800a1de:	187b      	adds	r3, r7, r1
 800a1e0:	681b      	ldr	r3, [r3, #0]
 800a1e2:	3365      	adds	r3, #101	; 0x65
 800a1e4:	33ff      	adds	r3, #255	; 0xff
 800a1e6:	2292      	movs	r2, #146	; 0x92
 800a1e8:	0052      	lsls	r2, r2, #1
 800a1ea:	18ba      	adds	r2, r7, r2
 800a1ec:	6013      	str	r3, [r2, #0]
	VL53L1_general_config_t       *pgeneral      = &(pdev->gen_cfg);
 800a1ee:	187b      	adds	r3, r7, r1
 800a1f0:	681b      	ldr	r3, [r3, #0]
 800a1f2:	3385      	adds	r3, #133	; 0x85
 800a1f4:	33ff      	adds	r3, #255	; 0xff
 800a1f6:	2290      	movs	r2, #144	; 0x90
 800a1f8:	0052      	lsls	r2, r2, #1
 800a1fa:	18ba      	adds	r2, r7, r2
 800a1fc:	6013      	str	r3, [r2, #0]
	VL53L1_timing_config_t        *ptiming       = &(pdev->tim_cfg);
 800a1fe:	187b      	adds	r3, r7, r1
 800a200:	681b      	ldr	r3, [r3, #0]
 800a202:	339d      	adds	r3, #157	; 0x9d
 800a204:	33ff      	adds	r3, #255	; 0xff
 800a206:	228e      	movs	r2, #142	; 0x8e
 800a208:	0052      	lsls	r2, r2, #1
 800a20a:	18ba      	adds	r2, r7, r2
 800a20c:	6013      	str	r3, [r2, #0]
	VL53L1_dynamic_config_t       *pdynamic      = &(pdev->dyn_cfg);
 800a20e:	187b      	adds	r3, r7, r1
 800a210:	681b      	ldr	r3, [r3, #0]
 800a212:	33b5      	adds	r3, #181	; 0xb5
 800a214:	33ff      	adds	r3, #255	; 0xff
 800a216:	228c      	movs	r2, #140	; 0x8c
 800a218:	0052      	lsls	r2, r2, #1
 800a21a:	18ba      	adds	r2, r7, r2
 800a21c:	6013      	str	r3, [r2, #0]
	VL53L1_system_control_t       *psystem       = &(pdev->sys_ctrl);
 800a21e:	187b      	adds	r3, r7, r1
 800a220:	681b      	ldr	r3, [r3, #0]
 800a222:	33c9      	adds	r3, #201	; 0xc9
 800a224:	33ff      	adds	r3, #255	; 0xff
 800a226:	208a      	movs	r0, #138	; 0x8a
 800a228:	0040      	lsls	r0, r0, #1
 800a22a:	183a      	adds	r2, r7, r0
 800a22c:	6013      	str	r3, [r2, #0]

	VL53L1_ll_driver_state_t  *pstate   = &(pdev->ll_state);
 800a22e:	187b      	adds	r3, r7, r1
 800a230:	681b      	ldr	r3, [r3, #0]
 800a232:	332c      	adds	r3, #44	; 0x2c
 800a234:	2288      	movs	r2, #136	; 0x88
 800a236:	0052      	lsls	r2, r2, #1
 800a238:	18ba      	adds	r2, r7, r2
 800a23a:	6013      	str	r3, [r2, #0]

	uint8_t  *pbuffer                   = &buffer[0];
 800a23c:	230c      	movs	r3, #12
 800a23e:	18fb      	adds	r3, r7, r3
 800a240:	229c      	movs	r2, #156	; 0x9c
 800a242:	0052      	lsls	r2, r2, #1
 800a244:	18ba      	adds	r2, r7, r2
 800a246:	6013      	str	r3, [r2, #0]
	uint16_t i                          = 0;
 800a248:	239b      	movs	r3, #155	; 0x9b
 800a24a:	005b      	lsls	r3, r3, #1
 800a24c:	18fb      	adds	r3, r7, r3
 800a24e:	2200      	movs	r2, #0
 800a250:	801a      	strh	r2, [r3, #0]
	uint16_t i2c_index                  = 0;
 800a252:	239a      	movs	r3, #154	; 0x9a
 800a254:	005b      	lsls	r3, r3, #1
 800a256:	18fb      	adds	r3, r7, r3
 800a258:	2200      	movs	r2, #0
 800a25a:	801a      	strh	r2, [r3, #0]
	uint16_t i2c_buffer_offset_bytes    = 0;
 800a25c:	2387      	movs	r3, #135	; 0x87
 800a25e:	005b      	lsls	r3, r3, #1
 800a260:	18fb      	adds	r3, r7, r3
 800a262:	2200      	movs	r2, #0
 800a264:	801a      	strh	r2, [r3, #0]
	uint16_t i2c_buffer_size_bytes      = 0;
 800a266:	2386      	movs	r3, #134	; 0x86
 800a268:	005b      	lsls	r3, r3, #1
 800a26a:	18fb      	adds	r3, r7, r3
 800a26c:	2200      	movs	r2, #0
 800a26e:	801a      	strh	r2, [r3, #0]

	LOG_FUNCTION_START("");

	/* save measurement mode */
	pdev->measurement_mode = measurement_mode;
 800a270:	187b      	adds	r3, r7, r1
 800a272:	681b      	ldr	r3, [r3, #0]
 800a274:	4a7b      	ldr	r2, [pc, #492]	; (800a464 <VL53L1_init_and_start_range+0x2e4>)
 800a276:	24a0      	movs	r4, #160	; 0xa0
 800a278:	0064      	lsls	r4, r4, #1
 800a27a:	46a4      	mov	ip, r4
 800a27c:	44bc      	add	ip, r7
 800a27e:	4462      	add	r2, ip
 800a280:	7812      	ldrb	r2, [r2, #0]
 800a282:	709a      	strb	r2, [r3, #2]

	/* Merge measurement mode with mode_start */

	psystem->system__mode_start =
		(psystem->system__mode_start &
 800a284:	183b      	adds	r3, r7, r0
 800a286:	681b      	ldr	r3, [r3, #0]
 800a288:	791b      	ldrb	r3, [r3, #4]
 800a28a:	b25b      	sxtb	r3, r3
 800a28c:	220f      	movs	r2, #15
 800a28e:	4013      	ands	r3, r2
 800a290:	b25a      	sxtb	r2, r3
		VL53L1_DEVICEMEASUREMENTMODE_STOP_MASK) |
 800a292:	4b74      	ldr	r3, [pc, #464]	; (800a464 <VL53L1_init_and_start_range+0x2e4>)
 800a294:	24a0      	movs	r4, #160	; 0xa0
 800a296:	0064      	lsls	r4, r4, #1
 800a298:	46a4      	mov	ip, r4
 800a29a:	44bc      	add	ip, r7
 800a29c:	4463      	add	r3, ip
 800a29e:	781b      	ldrb	r3, [r3, #0]
 800a2a0:	b25b      	sxtb	r3, r3
 800a2a2:	4313      	orrs	r3, r2
 800a2a4:	b25b      	sxtb	r3, r3
 800a2a6:	b2da      	uxtb	r2, r3
	psystem->system__mode_start =
 800a2a8:	183b      	adds	r3, r7, r0
 800a2aa:	681b      	ldr	r3, [r3, #0]
 800a2ac:	711a      	strb	r2, [r3, #4]
		measurement_mode;

	/* copy in rit from xtalk config */

	pdev->stat_cfg.algo__range_ignore_threshold_mcps =
		pdev->xtalk_cfg.crosstalk_range_ignore_threshold_rate_mcps;
 800a2ae:	0008      	movs	r0, r1
 800a2b0:	183b      	adds	r3, r7, r0
 800a2b2:	681a      	ldr	r2, [r3, #0]
 800a2b4:	23a1      	movs	r3, #161	; 0xa1
 800a2b6:	005b      	lsls	r3, r3, #1
 800a2b8:	5ad1      	ldrh	r1, [r2, r3]
	pdev->stat_cfg.algo__range_ignore_threshold_mcps =
 800a2ba:	183b      	adds	r3, r7, r0
 800a2bc:	681a      	ldr	r2, [r3, #0]
 800a2be:	23be      	movs	r3, #190	; 0xbe
 800a2c0:	005b      	lsls	r3, r3, #1
 800a2c2:	52d1      	strh	r1, [r2, r3]
	/* Start Patch_LowPowerAutoMode */

	/* doing this ensures stop_range followed by a get_device_results does
	 * not mess up the counters */

	if (pdev->low_power_auto_data.low_power_auto_range_count == 0xFF) {
 800a2c4:	0001      	movs	r1, r0
 800a2c6:	187b      	adds	r3, r7, r1
 800a2c8:	681b      	ldr	r3, [r3, #0]
 800a2ca:	4a68      	ldr	r2, [pc, #416]	; (800a46c <VL53L1_init_and_start_range+0x2ec>)
 800a2cc:	5c9b      	ldrb	r3, [r3, r2]
 800a2ce:	2bff      	cmp	r3, #255	; 0xff
 800a2d0:	d106      	bne.n	800a2e0 <VL53L1_init_and_start_range+0x160>
		pdev->low_power_auto_data.low_power_auto_range_count = 0x0;
 800a2d2:	2398      	movs	r3, #152	; 0x98
 800a2d4:	005b      	lsls	r3, r3, #1
 800a2d6:	18fb      	adds	r3, r7, r3
 800a2d8:	681b      	ldr	r3, [r3, #0]
 800a2da:	4a64      	ldr	r2, [pc, #400]	; (800a46c <VL53L1_init_and_start_range+0x2ec>)
 800a2dc:	2100      	movs	r1, #0
 800a2de:	5499      	strb	r1, [r3, r2]
	}

	/* For Presence. Override threshold config */
	if ((pdev->low_power_auto_data.is_low_power_auto_mode == 1) &&
 800a2e0:	2398      	movs	r3, #152	; 0x98
 800a2e2:	005b      	lsls	r3, r3, #1
 800a2e4:	18fb      	adds	r3, r7, r3
 800a2e6:	681b      	ldr	r3, [r3, #0]
 800a2e8:	4a61      	ldr	r2, [pc, #388]	; (800a470 <VL53L1_init_and_start_range+0x2f0>)
 800a2ea:	5c9b      	ldrb	r3, [r3, r2]
 800a2ec:	2b01      	cmp	r3, #1
 800a2ee:	d148      	bne.n	800a382 <VL53L1_init_and_start_range+0x202>
		(pdev->low_power_auto_data.low_power_auto_range_count == 0)) {
 800a2f0:	2398      	movs	r3, #152	; 0x98
 800a2f2:	005b      	lsls	r3, r3, #1
 800a2f4:	18fb      	adds	r3, r7, r3
 800a2f6:	681b      	ldr	r3, [r3, #0]
 800a2f8:	4a5c      	ldr	r2, [pc, #368]	; (800a46c <VL53L1_init_and_start_range+0x2ec>)
 800a2fa:	5c9b      	ldrb	r3, [r3, r2]
	if ((pdev->low_power_auto_data.is_low_power_auto_mode == 1) &&
 800a2fc:	2b00      	cmp	r3, #0
 800a2fe:	d140      	bne.n	800a382 <VL53L1_init_and_start_range+0x202>
		/* save interrupt config */
		pdev->low_power_auto_data.saved_interrupt_config =
			pdev->gen_cfg.system__interrupt_config_gpio;
 800a300:	2098      	movs	r0, #152	; 0x98
 800a302:	0040      	lsls	r0, r0, #1
 800a304:	183b      	adds	r3, r7, r0
 800a306:	681a      	ldr	r2, [r3, #0]
 800a308:	23c3      	movs	r3, #195	; 0xc3
 800a30a:	005b      	lsls	r3, r3, #1
 800a30c:	5cd1      	ldrb	r1, [r2, r3]
		pdev->low_power_auto_data.saved_interrupt_config =
 800a30e:	183b      	adds	r3, r7, r0
 800a310:	681b      	ldr	r3, [r3, #0]
 800a312:	4a58      	ldr	r2, [pc, #352]	; (800a474 <VL53L1_init_and_start_range+0x2f4>)
 800a314:	5499      	strb	r1, [r3, r2]
		/* set intr_new_measure_ready */
		pdev->gen_cfg.system__interrupt_config_gpio = 1 << 5;
 800a316:	183b      	adds	r3, r7, r0
 800a318:	681a      	ldr	r2, [r3, #0]
 800a31a:	23c3      	movs	r3, #195	; 0xc3
 800a31c:	005b      	lsls	r3, r3, #1
 800a31e:	2120      	movs	r1, #32
 800a320:	54d1      	strb	r1, [r2, r3]
		/* check MM1/MM2 disabled? */
		if ((pdev->dyn_cfg.system__sequence_config & (
 800a322:	183b      	adds	r3, r7, r0
 800a324:	681a      	ldr	r2, [r3, #0]
 800a326:	23c6      	movs	r3, #198	; 0xc6
 800a328:	33ff      	adds	r3, #255	; 0xff
 800a32a:	5cd3      	ldrb	r3, [r2, r3]
 800a32c:	001a      	movs	r2, r3
 800a32e:	2360      	movs	r3, #96	; 0x60
 800a330:	4013      	ands	r3, r2
 800a332:	d10e      	bne.n	800a352 <VL53L1_init_and_start_range+0x1d2>
			VL53L1_SEQUENCE_MM1_EN | VL53L1_SEQUENCE_MM2_EN)) ==
				0x0) {
			pdev->customer.algo__part_to_part_range_offset_mm =
				pdev->customer.mm_config__outer_offset_mm * 4;
 800a334:	2098      	movs	r0, #152	; 0x98
 800a336:	0040      	lsls	r0, r0, #1
 800a338:	183b      	adds	r3, r7, r0
 800a33a:	681b      	ldr	r3, [r3, #0]
 800a33c:	2258      	movs	r2, #88	; 0x58
 800a33e:	5e9b      	ldrsh	r3, [r3, r2]
 800a340:	b29b      	uxth	r3, r3
 800a342:	009b      	lsls	r3, r3, #2
 800a344:	b29b      	uxth	r3, r3
 800a346:	b219      	sxth	r1, r3
			pdev->customer.algo__part_to_part_range_offset_mm =
 800a348:	183b      	adds	r3, r7, r0
 800a34a:	681b      	ldr	r3, [r3, #0]
 800a34c:	2254      	movs	r2, #84	; 0x54
 800a34e:	5299      	strh	r1, [r3, r2]
 800a350:	e006      	b.n	800a360 <VL53L1_init_and_start_range+0x1e0>
		} else {
			pdev->customer.algo__part_to_part_range_offset_mm = 0x0;
 800a352:	2398      	movs	r3, #152	; 0x98
 800a354:	005b      	lsls	r3, r3, #1
 800a356:	18fb      	adds	r3, r7, r3
 800a358:	681b      	ldr	r3, [r3, #0]
 800a35a:	2254      	movs	r2, #84	; 0x54
 800a35c:	2100      	movs	r1, #0
 800a35e:	5299      	strh	r1, [r3, r2]
		}

		/* make sure config gets written out */
		if (device_config_level <
 800a360:	4b41      	ldr	r3, [pc, #260]	; (800a468 <VL53L1_init_and_start_range+0x2e8>)
 800a362:	22a0      	movs	r2, #160	; 0xa0
 800a364:	0052      	lsls	r2, r2, #1
 800a366:	4694      	mov	ip, r2
 800a368:	44bc      	add	ip, r7
 800a36a:	4463      	add	r3, ip
 800a36c:	781b      	ldrb	r3, [r3, #0]
 800a36e:	2b04      	cmp	r3, #4
 800a370:	d807      	bhi.n	800a382 <VL53L1_init_and_start_range+0x202>
				VL53L1_DEVICECONFIGLEVEL_CUSTOMER_ONWARDS) {
			device_config_level =
 800a372:	4b3d      	ldr	r3, [pc, #244]	; (800a468 <VL53L1_init_and_start_range+0x2e8>)
 800a374:	22a0      	movs	r2, #160	; 0xa0
 800a376:	0052      	lsls	r2, r2, #1
 800a378:	4694      	mov	ip, r2
 800a37a:	44bc      	add	ip, r7
 800a37c:	4463      	add	r3, ip
 800a37e:	2205      	movs	r2, #5
 800a380:	701a      	strb	r2, [r3, #0]
				VL53L1_DEVICECONFIGLEVEL_CUSTOMER_ONWARDS;
		}
	}

	if ((pdev->low_power_auto_data.is_low_power_auto_mode == 1) &&
 800a382:	2398      	movs	r3, #152	; 0x98
 800a384:	005b      	lsls	r3, r3, #1
 800a386:	18fb      	adds	r3, r7, r3
 800a388:	681b      	ldr	r3, [r3, #0]
 800a38a:	4a39      	ldr	r2, [pc, #228]	; (800a470 <VL53L1_init_and_start_range+0x2f0>)
 800a38c:	5c9b      	ldrb	r3, [r3, r2]
 800a38e:	2b01      	cmp	r3, #1
 800a390:	d11a      	bne.n	800a3c8 <VL53L1_init_and_start_range+0x248>
		(pdev->low_power_auto_data.low_power_auto_range_count == 1)) {
 800a392:	2398      	movs	r3, #152	; 0x98
 800a394:	005b      	lsls	r3, r3, #1
 800a396:	18fb      	adds	r3, r7, r3
 800a398:	681b      	ldr	r3, [r3, #0]
 800a39a:	4a34      	ldr	r2, [pc, #208]	; (800a46c <VL53L1_init_and_start_range+0x2ec>)
 800a39c:	5c9b      	ldrb	r3, [r3, r2]
	if ((pdev->low_power_auto_data.is_low_power_auto_mode == 1) &&
 800a39e:	2b01      	cmp	r3, #1
 800a3a0:	d112      	bne.n	800a3c8 <VL53L1_init_and_start_range+0x248>
		/* restore interrupt config */
		pdev->gen_cfg.system__interrupt_config_gpio =
			pdev->low_power_auto_data.saved_interrupt_config;
 800a3a2:	2098      	movs	r0, #152	; 0x98
 800a3a4:	0040      	lsls	r0, r0, #1
 800a3a6:	183b      	adds	r3, r7, r0
 800a3a8:	681b      	ldr	r3, [r3, #0]
 800a3aa:	4a32      	ldr	r2, [pc, #200]	; (800a474 <VL53L1_init_and_start_range+0x2f4>)
 800a3ac:	5c99      	ldrb	r1, [r3, r2]
		pdev->gen_cfg.system__interrupt_config_gpio =
 800a3ae:	183b      	adds	r3, r7, r0
 800a3b0:	681a      	ldr	r2, [r3, #0]
 800a3b2:	23c3      	movs	r3, #195	; 0xc3
 800a3b4:	005b      	lsls	r3, r3, #1
 800a3b6:	54d1      	strb	r1, [r2, r3]

		/* make sure config gets written out including VHV config */
		device_config_level = VL53L1_DEVICECONFIGLEVEL_FULL;
 800a3b8:	4b2b      	ldr	r3, [pc, #172]	; (800a468 <VL53L1_init_and_start_range+0x2e8>)
 800a3ba:	22a0      	movs	r2, #160	; 0xa0
 800a3bc:	0052      	lsls	r2, r2, #1
 800a3be:	4694      	mov	ip, r2
 800a3c0:	44bc      	add	ip, r7
 800a3c2:	4463      	add	r3, ip
 800a3c4:	2206      	movs	r2, #6
 800a3c6:	701a      	strb	r2, [r3, #0]

	/*
	 * Determine Initial I2C index
	 */

	switch (device_config_level) {
 800a3c8:	4b27      	ldr	r3, [pc, #156]	; (800a468 <VL53L1_init_and_start_range+0x2e8>)
 800a3ca:	22a0      	movs	r2, #160	; 0xa0
 800a3cc:	0052      	lsls	r2, r2, #1
 800a3ce:	4694      	mov	ip, r2
 800a3d0:	44bc      	add	ip, r7
 800a3d2:	4463      	add	r3, ip
 800a3d4:	781b      	ldrb	r3, [r3, #0]
 800a3d6:	2b06      	cmp	r3, #6
 800a3d8:	d828      	bhi.n	800a42c <VL53L1_init_and_start_range+0x2ac>
 800a3da:	009a      	lsls	r2, r3, #2
 800a3dc:	4b26      	ldr	r3, [pc, #152]	; (800a478 <VL53L1_init_and_start_range+0x2f8>)
 800a3de:	18d3      	adds	r3, r2, r3
 800a3e0:	681b      	ldr	r3, [r3, #0]
 800a3e2:	469f      	mov	pc, r3
	case VL53L1_DEVICECONFIGLEVEL_FULL:
		i2c_index = VL53L1_STATIC_NVM_MANAGED_I2C_INDEX;
 800a3e4:	239a      	movs	r3, #154	; 0x9a
 800a3e6:	005b      	lsls	r3, r3, #1
 800a3e8:	18fb      	adds	r3, r7, r3
 800a3ea:	2201      	movs	r2, #1
 800a3ec:	801a      	strh	r2, [r3, #0]
		break;
 800a3ee:	e023      	b.n	800a438 <VL53L1_init_and_start_range+0x2b8>
	case VL53L1_DEVICECONFIGLEVEL_CUSTOMER_ONWARDS:
		i2c_index = VL53L1_CUSTOMER_NVM_MANAGED_I2C_INDEX;
 800a3f0:	239a      	movs	r3, #154	; 0x9a
 800a3f2:	005b      	lsls	r3, r3, #1
 800a3f4:	18fb      	adds	r3, r7, r3
 800a3f6:	220d      	movs	r2, #13
 800a3f8:	801a      	strh	r2, [r3, #0]
		break;
 800a3fa:	e01d      	b.n	800a438 <VL53L1_init_and_start_range+0x2b8>
	case VL53L1_DEVICECONFIGLEVEL_STATIC_ONWARDS:
		i2c_index = VL53L1_STATIC_CONFIG_I2C_INDEX;
 800a3fc:	239a      	movs	r3, #154	; 0x9a
 800a3fe:	005b      	lsls	r3, r3, #1
 800a400:	18fb      	adds	r3, r7, r3
 800a402:	2224      	movs	r2, #36	; 0x24
 800a404:	801a      	strh	r2, [r3, #0]
		break;
 800a406:	e017      	b.n	800a438 <VL53L1_init_and_start_range+0x2b8>
	case VL53L1_DEVICECONFIGLEVEL_GENERAL_ONWARDS:
		i2c_index = VL53L1_GENERAL_CONFIG_I2C_INDEX;
 800a408:	239a      	movs	r3, #154	; 0x9a
 800a40a:	005b      	lsls	r3, r3, #1
 800a40c:	18fb      	adds	r3, r7, r3
 800a40e:	2244      	movs	r2, #68	; 0x44
 800a410:	801a      	strh	r2, [r3, #0]
		break;
 800a412:	e011      	b.n	800a438 <VL53L1_init_and_start_range+0x2b8>
	case VL53L1_DEVICECONFIGLEVEL_TIMING_ONWARDS:
		i2c_index = VL53L1_TIMING_CONFIG_I2C_INDEX;
 800a414:	239a      	movs	r3, #154	; 0x9a
 800a416:	005b      	lsls	r3, r3, #1
 800a418:	18fb      	adds	r3, r7, r3
 800a41a:	225a      	movs	r2, #90	; 0x5a
 800a41c:	801a      	strh	r2, [r3, #0]
		break;
 800a41e:	e00b      	b.n	800a438 <VL53L1_init_and_start_range+0x2b8>
	case VL53L1_DEVICECONFIGLEVEL_DYNAMIC_ONWARDS:
		i2c_index = VL53L1_DYNAMIC_CONFIG_I2C_INDEX;
 800a420:	239a      	movs	r3, #154	; 0x9a
 800a422:	005b      	lsls	r3, r3, #1
 800a424:	18fb      	adds	r3, r7, r3
 800a426:	2271      	movs	r2, #113	; 0x71
 800a428:	801a      	strh	r2, [r3, #0]
		break;
 800a42a:	e005      	b.n	800a438 <VL53L1_init_and_start_range+0x2b8>
	default:
		i2c_index = VL53L1_SYSTEM_CONTROL_I2C_INDEX;
 800a42c:	239a      	movs	r3, #154	; 0x9a
 800a42e:	005b      	lsls	r3, r3, #1
 800a430:	18fb      	adds	r3, r7, r3
 800a432:	2283      	movs	r2, #131	; 0x83
 800a434:	801a      	strh	r2, [r3, #0]
		break;
 800a436:	46c0      	nop			; (mov r8, r8)
	}

	/* I2C Buffer size */

	i2c_buffer_size_bytes = \
 800a438:	2386      	movs	r3, #134	; 0x86
 800a43a:	005b      	lsls	r3, r3, #1
 800a43c:	18fb      	adds	r3, r7, r3
 800a43e:	229a      	movs	r2, #154	; 0x9a
 800a440:	0052      	lsls	r2, r2, #1
 800a442:	18ba      	adds	r2, r7, r2
 800a444:	8812      	ldrh	r2, [r2, #0]
 800a446:	2188      	movs	r1, #136	; 0x88
 800a448:	1a8a      	subs	r2, r1, r2
 800a44a:	801a      	strh	r2, [r3, #0]
			 VL53L1_SYSTEM_CONTROL_I2C_SIZE_BYTES) -
			 i2c_index;

	/* Initialize buffer */

	pbuffer = &buffer[0];
 800a44c:	230c      	movs	r3, #12
 800a44e:	18fb      	adds	r3, r7, r3
 800a450:	229c      	movs	r2, #156	; 0x9c
 800a452:	0052      	lsls	r2, r2, #1
 800a454:	18ba      	adds	r2, r7, r2
 800a456:	6013      	str	r3, [r2, #0]
	for (i = 0 ; i < i2c_buffer_size_bytes ; i++) {
 800a458:	239b      	movs	r3, #155	; 0x9b
 800a45a:	005b      	lsls	r3, r3, #1
 800a45c:	18fb      	adds	r3, r7, r3
 800a45e:	2200      	movs	r2, #0
 800a460:	801a      	strh	r2, [r3, #0]
 800a462:	e01b      	b.n	800a49c <VL53L1_init_and_start_range+0x31c>
 800a464:	fffffec3 	.word	0xfffffec3
 800a468:	fffffec2 	.word	0xfffffec2
 800a46c:	000002e6 	.word	0x000002e6
 800a470:	000002e5 	.word	0x000002e5
 800a474:	000002e7 	.word	0x000002e7
 800a478:	080150b4 	.word	0x080150b4
		*pbuffer++ = 0;
 800a47c:	219c      	movs	r1, #156	; 0x9c
 800a47e:	0049      	lsls	r1, r1, #1
 800a480:	187b      	adds	r3, r7, r1
 800a482:	681b      	ldr	r3, [r3, #0]
 800a484:	1c5a      	adds	r2, r3, #1
 800a486:	1879      	adds	r1, r7, r1
 800a488:	600a      	str	r2, [r1, #0]
 800a48a:	2200      	movs	r2, #0
 800a48c:	701a      	strb	r2, [r3, #0]
	for (i = 0 ; i < i2c_buffer_size_bytes ; i++) {
 800a48e:	219b      	movs	r1, #155	; 0x9b
 800a490:	0049      	lsls	r1, r1, #1
 800a492:	187b      	adds	r3, r7, r1
 800a494:	881a      	ldrh	r2, [r3, #0]
 800a496:	187b      	adds	r3, r7, r1
 800a498:	3201      	adds	r2, #1
 800a49a:	801a      	strh	r2, [r3, #0]
 800a49c:	239b      	movs	r3, #155	; 0x9b
 800a49e:	005b      	lsls	r3, r3, #1
 800a4a0:	18fa      	adds	r2, r7, r3
 800a4a2:	2386      	movs	r3, #134	; 0x86
 800a4a4:	005b      	lsls	r3, r3, #1
 800a4a6:	18fb      	adds	r3, r7, r3
 800a4a8:	8812      	ldrh	r2, [r2, #0]
 800a4aa:	881b      	ldrh	r3, [r3, #0]
 800a4ac:	429a      	cmp	r2, r3
 800a4ae:	d3e5      	bcc.n	800a47c <VL53L1_init_and_start_range+0x2fc>
	}

	/* Build I2C buffer */

	if (device_config_level >= VL53L1_DEVICECONFIGLEVEL_FULL &&
 800a4b0:	4bca      	ldr	r3, [pc, #808]	; (800a7dc <VL53L1_init_and_start_range+0x65c>)
 800a4b2:	22a0      	movs	r2, #160	; 0xa0
 800a4b4:	0052      	lsls	r2, r2, #1
 800a4b6:	4694      	mov	ip, r2
 800a4b8:	44bc      	add	ip, r7
 800a4ba:	4463      	add	r3, ip
 800a4bc:	781b      	ldrb	r3, [r3, #0]
 800a4be:	2b05      	cmp	r3, #5
 800a4c0:	d922      	bls.n	800a508 <VL53L1_init_and_start_range+0x388>
 800a4c2:	2340      	movs	r3, #64	; 0x40
 800a4c4:	33ff      	adds	r3, #255	; 0xff
 800a4c6:	18fb      	adds	r3, r7, r3
 800a4c8:	781b      	ldrb	r3, [r3, #0]
 800a4ca:	b25b      	sxtb	r3, r3
 800a4cc:	2b00      	cmp	r3, #0
 800a4ce:	d11b      	bne.n	800a508 <VL53L1_init_and_start_range+0x388>
		status == VL53L1_ERROR_NONE) {

		i2c_buffer_offset_bytes = \
 800a4d0:	2087      	movs	r0, #135	; 0x87
 800a4d2:	0040      	lsls	r0, r0, #1
 800a4d4:	183b      	adds	r3, r7, r0
 800a4d6:	229a      	movs	r2, #154	; 0x9a
 800a4d8:	0052      	lsls	r2, r2, #1
 800a4da:	18ba      	adds	r2, r7, r2
 800a4dc:	8812      	ldrh	r2, [r2, #0]
 800a4de:	2101      	movs	r1, #1
 800a4e0:	1a8a      	subs	r2, r1, r2
 800a4e2:	801a      	strh	r2, [r3, #0]

		status =
			VL53L1_i2c_encode_static_nvm_managed(
				pstatic_nvm,
				VL53L1_STATIC_NVM_MANAGED_I2C_SIZE_BYTES,
				&buffer[i2c_buffer_offset_bytes]);
 800a4e4:	183b      	adds	r3, r7, r0
 800a4e6:	881b      	ldrh	r3, [r3, #0]
			VL53L1_i2c_encode_static_nvm_managed(
 800a4e8:	220c      	movs	r2, #12
 800a4ea:	18ba      	adds	r2, r7, r2
 800a4ec:	18d2      	adds	r2, r2, r3
		status =
 800a4ee:	2340      	movs	r3, #64	; 0x40
 800a4f0:	33ff      	adds	r3, #255	; 0xff
 800a4f2:	18fc      	adds	r4, r7, r3
 800a4f4:	2396      	movs	r3, #150	; 0x96
 800a4f6:	005b      	lsls	r3, r3, #1
 800a4f8:	18fb      	adds	r3, r7, r3
 800a4fa:	681b      	ldr	r3, [r3, #0]
 800a4fc:	210b      	movs	r1, #11
 800a4fe:	0018      	movs	r0, r3
 800a500:	f002 fbe3 	bl	800ccca <VL53L1_i2c_encode_static_nvm_managed>
 800a504:	0003      	movs	r3, r0
 800a506:	7023      	strb	r3, [r4, #0]
	}

	if (device_config_level >= VL53L1_DEVICECONFIGLEVEL_CUSTOMER_ONWARDS &&
 800a508:	4bb4      	ldr	r3, [pc, #720]	; (800a7dc <VL53L1_init_and_start_range+0x65c>)
 800a50a:	22a0      	movs	r2, #160	; 0xa0
 800a50c:	0052      	lsls	r2, r2, #1
 800a50e:	4694      	mov	ip, r2
 800a510:	44bc      	add	ip, r7
 800a512:	4463      	add	r3, ip
 800a514:	781b      	ldrb	r3, [r3, #0]
 800a516:	2b04      	cmp	r3, #4
 800a518:	d922      	bls.n	800a560 <VL53L1_init_and_start_range+0x3e0>
 800a51a:	2340      	movs	r3, #64	; 0x40
 800a51c:	33ff      	adds	r3, #255	; 0xff
 800a51e:	18fb      	adds	r3, r7, r3
 800a520:	781b      	ldrb	r3, [r3, #0]
 800a522:	b25b      	sxtb	r3, r3
 800a524:	2b00      	cmp	r3, #0
 800a526:	d11b      	bne.n	800a560 <VL53L1_init_and_start_range+0x3e0>
		status == VL53L1_ERROR_NONE) {

		i2c_buffer_offset_bytes = \
 800a528:	2087      	movs	r0, #135	; 0x87
 800a52a:	0040      	lsls	r0, r0, #1
 800a52c:	183b      	adds	r3, r7, r0
 800a52e:	229a      	movs	r2, #154	; 0x9a
 800a530:	0052      	lsls	r2, r2, #1
 800a532:	18ba      	adds	r2, r7, r2
 800a534:	8812      	ldrh	r2, [r2, #0]
 800a536:	210d      	movs	r1, #13
 800a538:	1a8a      	subs	r2, r1, r2
 800a53a:	801a      	strh	r2, [r3, #0]

		status =
			VL53L1_i2c_encode_customer_nvm_managed(
				pcustomer_nvm,
				VL53L1_CUSTOMER_NVM_MANAGED_I2C_SIZE_BYTES,
				&buffer[i2c_buffer_offset_bytes]);
 800a53c:	183b      	adds	r3, r7, r0
 800a53e:	881b      	ldrh	r3, [r3, #0]
			VL53L1_i2c_encode_customer_nvm_managed(
 800a540:	220c      	movs	r2, #12
 800a542:	18ba      	adds	r2, r7, r2
 800a544:	18d2      	adds	r2, r2, r3
		status =
 800a546:	2340      	movs	r3, #64	; 0x40
 800a548:	33ff      	adds	r3, #255	; 0xff
 800a54a:	18fc      	adds	r4, r7, r3
 800a54c:	2394      	movs	r3, #148	; 0x94
 800a54e:	005b      	lsls	r3, r3, #1
 800a550:	18fb      	adds	r3, r7, r3
 800a552:	681b      	ldr	r3, [r3, #0]
 800a554:	2117      	movs	r1, #23
 800a556:	0018      	movs	r0, r3
 800a558:	f002 fcac 	bl	800ceb4 <VL53L1_i2c_encode_customer_nvm_managed>
 800a55c:	0003      	movs	r3, r0
 800a55e:	7023      	strb	r3, [r4, #0]
	}

	if (device_config_level >= VL53L1_DEVICECONFIGLEVEL_STATIC_ONWARDS &&
 800a560:	4b9e      	ldr	r3, [pc, #632]	; (800a7dc <VL53L1_init_and_start_range+0x65c>)
 800a562:	22a0      	movs	r2, #160	; 0xa0
 800a564:	0052      	lsls	r2, r2, #1
 800a566:	4694      	mov	ip, r2
 800a568:	44bc      	add	ip, r7
 800a56a:	4463      	add	r3, ip
 800a56c:	781b      	ldrb	r3, [r3, #0]
 800a56e:	2b03      	cmp	r3, #3
 800a570:	d922      	bls.n	800a5b8 <VL53L1_init_and_start_range+0x438>
 800a572:	2340      	movs	r3, #64	; 0x40
 800a574:	33ff      	adds	r3, #255	; 0xff
 800a576:	18fb      	adds	r3, r7, r3
 800a578:	781b      	ldrb	r3, [r3, #0]
 800a57a:	b25b      	sxtb	r3, r3
 800a57c:	2b00      	cmp	r3, #0
 800a57e:	d11b      	bne.n	800a5b8 <VL53L1_init_and_start_range+0x438>
		status == VL53L1_ERROR_NONE) {

		i2c_buffer_offset_bytes = \
 800a580:	2087      	movs	r0, #135	; 0x87
 800a582:	0040      	lsls	r0, r0, #1
 800a584:	183b      	adds	r3, r7, r0
 800a586:	229a      	movs	r2, #154	; 0x9a
 800a588:	0052      	lsls	r2, r2, #1
 800a58a:	18ba      	adds	r2, r7, r2
 800a58c:	8812      	ldrh	r2, [r2, #0]
 800a58e:	2124      	movs	r1, #36	; 0x24
 800a590:	1a8a      	subs	r2, r1, r2
 800a592:	801a      	strh	r2, [r3, #0]

		status =
			VL53L1_i2c_encode_static_config(
				pstatic,
				VL53L1_STATIC_CONFIG_I2C_SIZE_BYTES,
				&buffer[i2c_buffer_offset_bytes]);
 800a594:	183b      	adds	r3, r7, r0
 800a596:	881b      	ldrh	r3, [r3, #0]
			VL53L1_i2c_encode_static_config(
 800a598:	220c      	movs	r2, #12
 800a59a:	18ba      	adds	r2, r7, r2
 800a59c:	18d2      	adds	r2, r2, r3
		status =
 800a59e:	2340      	movs	r3, #64	; 0x40
 800a5a0:	33ff      	adds	r3, #255	; 0xff
 800a5a2:	18fc      	adds	r4, r7, r3
 800a5a4:	2392      	movs	r3, #146	; 0x92
 800a5a6:	005b      	lsls	r3, r3, #1
 800a5a8:	18fb      	adds	r3, r7, r3
 800a5aa:	681b      	ldr	r3, [r3, #0]
 800a5ac:	2120      	movs	r1, #32
 800a5ae:	0018      	movs	r0, r3
 800a5b0:	f002 fdd7 	bl	800d162 <VL53L1_i2c_encode_static_config>
 800a5b4:	0003      	movs	r3, r0
 800a5b6:	7023      	strb	r3, [r4, #0]
	}

	if (device_config_level >= VL53L1_DEVICECONFIGLEVEL_GENERAL_ONWARDS &&
 800a5b8:	4b88      	ldr	r3, [pc, #544]	; (800a7dc <VL53L1_init_and_start_range+0x65c>)
 800a5ba:	22a0      	movs	r2, #160	; 0xa0
 800a5bc:	0052      	lsls	r2, r2, #1
 800a5be:	4694      	mov	ip, r2
 800a5c0:	44bc      	add	ip, r7
 800a5c2:	4463      	add	r3, ip
 800a5c4:	781b      	ldrb	r3, [r3, #0]
 800a5c6:	2b02      	cmp	r3, #2
 800a5c8:	d922      	bls.n	800a610 <VL53L1_init_and_start_range+0x490>
 800a5ca:	2340      	movs	r3, #64	; 0x40
 800a5cc:	33ff      	adds	r3, #255	; 0xff
 800a5ce:	18fb      	adds	r3, r7, r3
 800a5d0:	781b      	ldrb	r3, [r3, #0]
 800a5d2:	b25b      	sxtb	r3, r3
 800a5d4:	2b00      	cmp	r3, #0
 800a5d6:	d11b      	bne.n	800a610 <VL53L1_init_and_start_range+0x490>
		status == VL53L1_ERROR_NONE) {

		i2c_buffer_offset_bytes =
 800a5d8:	2087      	movs	r0, #135	; 0x87
 800a5da:	0040      	lsls	r0, r0, #1
 800a5dc:	183b      	adds	r3, r7, r0
 800a5de:	229a      	movs	r2, #154	; 0x9a
 800a5e0:	0052      	lsls	r2, r2, #1
 800a5e2:	18ba      	adds	r2, r7, r2
 800a5e4:	8812      	ldrh	r2, [r2, #0]
 800a5e6:	2144      	movs	r1, #68	; 0x44
 800a5e8:	1a8a      	subs	r2, r1, r2
 800a5ea:	801a      	strh	r2, [r3, #0]

		status =
			VL53L1_i2c_encode_general_config(
				pgeneral,
				VL53L1_GENERAL_CONFIG_I2C_SIZE_BYTES,
				&buffer[i2c_buffer_offset_bytes]);
 800a5ec:	183b      	adds	r3, r7, r0
 800a5ee:	881b      	ldrh	r3, [r3, #0]
			VL53L1_i2c_encode_general_config(
 800a5f0:	220c      	movs	r2, #12
 800a5f2:	18ba      	adds	r2, r7, r2
 800a5f4:	18d2      	adds	r2, r2, r3
		status =
 800a5f6:	2340      	movs	r3, #64	; 0x40
 800a5f8:	33ff      	adds	r3, #255	; 0xff
 800a5fa:	18fc      	adds	r4, r7, r3
 800a5fc:	2390      	movs	r3, #144	; 0x90
 800a5fe:	005b      	lsls	r3, r3, #1
 800a600:	18fb      	adds	r3, r7, r3
 800a602:	681b      	ldr	r3, [r3, #0]
 800a604:	2116      	movs	r1, #22
 800a606:	0018      	movs	r0, r3
 800a608:	f002 fe95 	bl	800d336 <VL53L1_i2c_encode_general_config>
 800a60c:	0003      	movs	r3, r0
 800a60e:	7023      	strb	r3, [r4, #0]
	}

	if (device_config_level >= VL53L1_DEVICECONFIGLEVEL_TIMING_ONWARDS &&
 800a610:	4b72      	ldr	r3, [pc, #456]	; (800a7dc <VL53L1_init_and_start_range+0x65c>)
 800a612:	22a0      	movs	r2, #160	; 0xa0
 800a614:	0052      	lsls	r2, r2, #1
 800a616:	4694      	mov	ip, r2
 800a618:	44bc      	add	ip, r7
 800a61a:	4463      	add	r3, ip
 800a61c:	781b      	ldrb	r3, [r3, #0]
 800a61e:	2b01      	cmp	r3, #1
 800a620:	d922      	bls.n	800a668 <VL53L1_init_and_start_range+0x4e8>
 800a622:	2340      	movs	r3, #64	; 0x40
 800a624:	33ff      	adds	r3, #255	; 0xff
 800a626:	18fb      	adds	r3, r7, r3
 800a628:	781b      	ldrb	r3, [r3, #0]
 800a62a:	b25b      	sxtb	r3, r3
 800a62c:	2b00      	cmp	r3, #0
 800a62e:	d11b      	bne.n	800a668 <VL53L1_init_and_start_range+0x4e8>
		status == VL53L1_ERROR_NONE) {

		i2c_buffer_offset_bytes = \
 800a630:	2087      	movs	r0, #135	; 0x87
 800a632:	0040      	lsls	r0, r0, #1
 800a634:	183b      	adds	r3, r7, r0
 800a636:	229a      	movs	r2, #154	; 0x9a
 800a638:	0052      	lsls	r2, r2, #1
 800a63a:	18ba      	adds	r2, r7, r2
 800a63c:	8812      	ldrh	r2, [r2, #0]
 800a63e:	215a      	movs	r1, #90	; 0x5a
 800a640:	1a8a      	subs	r2, r1, r2
 800a642:	801a      	strh	r2, [r3, #0]

		status =
			VL53L1_i2c_encode_timing_config(
				ptiming,
				VL53L1_TIMING_CONFIG_I2C_SIZE_BYTES,
				&buffer[i2c_buffer_offset_bytes]);
 800a644:	183b      	adds	r3, r7, r0
 800a646:	881b      	ldrh	r3, [r3, #0]
			VL53L1_i2c_encode_timing_config(
 800a648:	220c      	movs	r2, #12
 800a64a:	18ba      	adds	r2, r7, r2
 800a64c:	18d2      	adds	r2, r2, r3
		status =
 800a64e:	2340      	movs	r3, #64	; 0x40
 800a650:	33ff      	adds	r3, #255	; 0xff
 800a652:	18fc      	adds	r4, r7, r3
 800a654:	238e      	movs	r3, #142	; 0x8e
 800a656:	005b      	lsls	r3, r3, #1
 800a658:	18fb      	adds	r3, r7, r3
 800a65a:	681b      	ldr	r3, [r3, #0]
 800a65c:	2117      	movs	r1, #23
 800a65e:	0018      	movs	r0, r3
 800a660:	f002 fef4 	bl	800d44c <VL53L1_i2c_encode_timing_config>
 800a664:	0003      	movs	r3, r0
 800a666:	7023      	strb	r3, [r4, #0]
	}

	if (device_config_level >= VL53L1_DEVICECONFIGLEVEL_DYNAMIC_ONWARDS &&
 800a668:	4b5c      	ldr	r3, [pc, #368]	; (800a7dc <VL53L1_init_and_start_range+0x65c>)
 800a66a:	22a0      	movs	r2, #160	; 0xa0
 800a66c:	0052      	lsls	r2, r2, #1
 800a66e:	4694      	mov	ip, r2
 800a670:	44bc      	add	ip, r7
 800a672:	4463      	add	r3, ip
 800a674:	781b      	ldrb	r3, [r3, #0]
 800a676:	2b00      	cmp	r3, #0
 800a678:	d049      	beq.n	800a70e <VL53L1_init_and_start_range+0x58e>
 800a67a:	2340      	movs	r3, #64	; 0x40
 800a67c:	33ff      	adds	r3, #255	; 0xff
 800a67e:	18fb      	adds	r3, r7, r3
 800a680:	781b      	ldrb	r3, [r3, #0]
 800a682:	b25b      	sxtb	r3, r3
 800a684:	2b00      	cmp	r3, #0
 800a686:	d142      	bne.n	800a70e <VL53L1_init_and_start_range+0x58e>
		status == VL53L1_ERROR_NONE) {

		i2c_buffer_offset_bytes = \
 800a688:	2387      	movs	r3, #135	; 0x87
 800a68a:	005b      	lsls	r3, r3, #1
 800a68c:	18fb      	adds	r3, r7, r3
 800a68e:	229a      	movs	r2, #154	; 0x9a
 800a690:	0052      	lsls	r2, r2, #1
 800a692:	18ba      	adds	r2, r7, r2
 800a694:	8812      	ldrh	r2, [r2, #0]
 800a696:	2171      	movs	r1, #113	; 0x71
 800a698:	1a8a      	subs	r2, r1, r2
 800a69a:	801a      	strh	r2, [r3, #0]
			VL53L1_DYNAMIC_CONFIG_I2C_INDEX - i2c_index;

		/* If in back to back mode, use GPH ID from cfg_state */
		if ((psystem->system__mode_start &
 800a69c:	238a      	movs	r3, #138	; 0x8a
 800a69e:	005b      	lsls	r3, r3, #1
 800a6a0:	18fb      	adds	r3, r7, r3
 800a6a2:	681b      	ldr	r3, [r3, #0]
 800a6a4:	791b      	ldrb	r3, [r3, #4]
 800a6a6:	001a      	movs	r2, r3
 800a6a8:	2320      	movs	r3, #32
 800a6aa:	4013      	ands	r3, r2
 800a6ac:	d01b      	beq.n	800a6e6 <VL53L1_init_and_start_range+0x566>
			VL53L1_DEVICEMEASUREMENTMODE_BACKTOBACK) ==
			VL53L1_DEVICEMEASUREMENTMODE_BACKTOBACK) {
			pdynamic->system__grouped_parameter_hold_0 = pstate->cfg_gph_id | 0x01;
 800a6ae:	2188      	movs	r1, #136	; 0x88
 800a6b0:	0049      	lsls	r1, r1, #1
 800a6b2:	187b      	adds	r3, r7, r1
 800a6b4:	681b      	ldr	r3, [r3, #0]
 800a6b6:	789b      	ldrb	r3, [r3, #2]
 800a6b8:	2201      	movs	r2, #1
 800a6ba:	4313      	orrs	r3, r2
 800a6bc:	b2da      	uxtb	r2, r3
 800a6be:	208c      	movs	r0, #140	; 0x8c
 800a6c0:	0040      	lsls	r0, r0, #1
 800a6c2:	183b      	adds	r3, r7, r0
 800a6c4:	681b      	ldr	r3, [r3, #0]
 800a6c6:	701a      	strb	r2, [r3, #0]
			pdynamic->system__grouped_parameter_hold_1 = pstate->cfg_gph_id | 0x01;
 800a6c8:	187b      	adds	r3, r7, r1
 800a6ca:	681b      	ldr	r3, [r3, #0]
 800a6cc:	789b      	ldrb	r3, [r3, #2]
 800a6ce:	2201      	movs	r2, #1
 800a6d0:	4313      	orrs	r3, r2
 800a6d2:	b2da      	uxtb	r2, r3
 800a6d4:	183b      	adds	r3, r7, r0
 800a6d6:	681b      	ldr	r3, [r3, #0]
 800a6d8:	731a      	strb	r2, [r3, #12]
			pdynamic->system__grouped_parameter_hold   = pstate->cfg_gph_id;
 800a6da:	187b      	adds	r3, r7, r1
 800a6dc:	681b      	ldr	r3, [r3, #0]
 800a6de:	789a      	ldrb	r2, [r3, #2]
 800a6e0:	183b      	adds	r3, r7, r0
 800a6e2:	681b      	ldr	r3, [r3, #0]
 800a6e4:	749a      	strb	r2, [r3, #18]
		}
		status =
			VL53L1_i2c_encode_dynamic_config(
				pdynamic,
				VL53L1_DYNAMIC_CONFIG_I2C_SIZE_BYTES,
				&buffer[i2c_buffer_offset_bytes]);
 800a6e6:	2387      	movs	r3, #135	; 0x87
 800a6e8:	005b      	lsls	r3, r3, #1
 800a6ea:	18fb      	adds	r3, r7, r3
 800a6ec:	881b      	ldrh	r3, [r3, #0]
			VL53L1_i2c_encode_dynamic_config(
 800a6ee:	220c      	movs	r2, #12
 800a6f0:	18ba      	adds	r2, r7, r2
 800a6f2:	18d2      	adds	r2, r2, r3
		status =
 800a6f4:	2340      	movs	r3, #64	; 0x40
 800a6f6:	33ff      	adds	r3, #255	; 0xff
 800a6f8:	18fc      	adds	r4, r7, r3
 800a6fa:	238c      	movs	r3, #140	; 0x8c
 800a6fc:	005b      	lsls	r3, r3, #1
 800a6fe:	18fb      	adds	r3, r7, r3
 800a700:	681b      	ldr	r3, [r3, #0]
 800a702:	2112      	movs	r1, #18
 800a704:	0018      	movs	r0, r3
 800a706:	f002 ff2a 	bl	800d55e <VL53L1_i2c_encode_dynamic_config>
 800a70a:	0003      	movs	r3, r0
 800a70c:	7023      	strb	r3, [r4, #0]
	}

	if (status == VL53L1_ERROR_NONE) {
 800a70e:	2340      	movs	r3, #64	; 0x40
 800a710:	33ff      	adds	r3, #255	; 0xff
 800a712:	18fb      	adds	r3, r7, r3
 800a714:	781b      	ldrb	r3, [r3, #0]
 800a716:	b25b      	sxtb	r3, r3
 800a718:	2b00      	cmp	r3, #0
 800a71a:	d11b      	bne.n	800a754 <VL53L1_init_and_start_range+0x5d4>

		i2c_buffer_offset_bytes = \
 800a71c:	2087      	movs	r0, #135	; 0x87
 800a71e:	0040      	lsls	r0, r0, #1
 800a720:	183b      	adds	r3, r7, r0
 800a722:	229a      	movs	r2, #154	; 0x9a
 800a724:	0052      	lsls	r2, r2, #1
 800a726:	18ba      	adds	r2, r7, r2
 800a728:	8812      	ldrh	r2, [r2, #0]
 800a72a:	2183      	movs	r1, #131	; 0x83
 800a72c:	1a8a      	subs	r2, r1, r2
 800a72e:	801a      	strh	r2, [r3, #0]

		status =
			VL53L1_i2c_encode_system_control(
				psystem,
				VL53L1_SYSTEM_CONTROL_I2C_SIZE_BYTES,
				&buffer[i2c_buffer_offset_bytes]);
 800a730:	183b      	adds	r3, r7, r0
 800a732:	881b      	ldrh	r3, [r3, #0]
			VL53L1_i2c_encode_system_control(
 800a734:	220c      	movs	r2, #12
 800a736:	18ba      	adds	r2, r7, r2
 800a738:	18d2      	adds	r2, r2, r3
		status =
 800a73a:	2340      	movs	r3, #64	; 0x40
 800a73c:	33ff      	adds	r3, #255	; 0xff
 800a73e:	18fc      	adds	r4, r7, r3
 800a740:	238a      	movs	r3, #138	; 0x8a
 800a742:	005b      	lsls	r3, r3, #1
 800a744:	18fb      	adds	r3, r7, r3
 800a746:	681b      	ldr	r3, [r3, #0]
 800a748:	2105      	movs	r1, #5
 800a74a:	0018      	movs	r0, r3
 800a74c:	f002 ff93 	bl	800d676 <VL53L1_i2c_encode_system_control>
 800a750:	0003      	movs	r3, r0
 800a752:	7023      	strb	r3, [r4, #0]
	}

	/* Send I2C Buffer */

	if (status == VL53L1_ERROR_NONE) {
 800a754:	2340      	movs	r3, #64	; 0x40
 800a756:	33ff      	adds	r3, #255	; 0xff
 800a758:	18fb      	adds	r3, r7, r3
 800a75a:	781b      	ldrb	r3, [r3, #0]
 800a75c:	b25b      	sxtb	r3, r3
 800a75e:	2b00      	cmp	r3, #0
 800a760:	d112      	bne.n	800a788 <VL53L1_init_and_start_range+0x608>
		status =
			VL53L1_WriteMulti(
 800a762:	2386      	movs	r3, #134	; 0x86
 800a764:	005b      	lsls	r3, r3, #1
 800a766:	18fb      	adds	r3, r7, r3
 800a768:	881d      	ldrh	r5, [r3, #0]
		status =
 800a76a:	2340      	movs	r3, #64	; 0x40
 800a76c:	33ff      	adds	r3, #255	; 0xff
 800a76e:	18fc      	adds	r4, r7, r3
 800a770:	230c      	movs	r3, #12
 800a772:	18fa      	adds	r2, r7, r3
 800a774:	239a      	movs	r3, #154	; 0x9a
 800a776:	005b      	lsls	r3, r3, #1
 800a778:	18fb      	adds	r3, r7, r3
 800a77a:	8819      	ldrh	r1, [r3, #0]
 800a77c:	6878      	ldr	r0, [r7, #4]
 800a77e:	002b      	movs	r3, r5
 800a780:	f003 fcec 	bl	800e15c <VL53L1_WriteMulti>
 800a784:	0003      	movs	r3, r0
 800a786:	7023      	strb	r3, [r4, #0]
	}

	/*
	 * Update LL Driver State
	 */
	if (status == VL53L1_ERROR_NONE)
 800a788:	2340      	movs	r3, #64	; 0x40
 800a78a:	33ff      	adds	r3, #255	; 0xff
 800a78c:	18fb      	adds	r3, r7, r3
 800a78e:	781b      	ldrb	r3, [r3, #0]
 800a790:	b25b      	sxtb	r3, r3
 800a792:	2b00      	cmp	r3, #0
 800a794:	d108      	bne.n	800a7a8 <VL53L1_init_and_start_range+0x628>
		status = VL53L1_update_ll_driver_rd_state(Dev);
 800a796:	2340      	movs	r3, #64	; 0x40
 800a798:	33ff      	adds	r3, #255	; 0xff
 800a79a:	18fc      	adds	r4, r7, r3
 800a79c:	687b      	ldr	r3, [r7, #4]
 800a79e:	0018      	movs	r0, r3
 800a7a0:	f001 faa3 	bl	800bcea <VL53L1_update_ll_driver_rd_state>
 800a7a4:	0003      	movs	r3, r0
 800a7a6:	7023      	strb	r3, [r4, #0]

	if (status == VL53L1_ERROR_NONE)
 800a7a8:	2340      	movs	r3, #64	; 0x40
 800a7aa:	33ff      	adds	r3, #255	; 0xff
 800a7ac:	18fb      	adds	r3, r7, r3
 800a7ae:	781b      	ldrb	r3, [r3, #0]
 800a7b0:	b25b      	sxtb	r3, r3
 800a7b2:	2b00      	cmp	r3, #0
 800a7b4:	d108      	bne.n	800a7c8 <VL53L1_init_and_start_range+0x648>
		status = VL53L1_update_ll_driver_cfg_state(Dev);
 800a7b6:	2340      	movs	r3, #64	; 0x40
 800a7b8:	33ff      	adds	r3, #255	; 0xff
 800a7ba:	18fc      	adds	r4, r7, r3
 800a7bc:	687b      	ldr	r3, [r7, #4]
 800a7be:	0018      	movs	r0, r3
 800a7c0:	f001 fb7c 	bl	800bebc <VL53L1_update_ll_driver_cfg_state>
 800a7c4:	0003      	movs	r3, r0
 800a7c6:	7023      	strb	r3, [r4, #0]

	LOG_FUNCTION_END(status);

	return status;
 800a7c8:	2340      	movs	r3, #64	; 0x40
 800a7ca:	33ff      	adds	r3, #255	; 0xff
 800a7cc:	18fb      	adds	r3, r7, r3
 800a7ce:	781b      	ldrb	r3, [r3, #0]
 800a7d0:	b25b      	sxtb	r3, r3
}
 800a7d2:	0018      	movs	r0, r3
 800a7d4:	46bd      	mov	sp, r7
 800a7d6:	b050      	add	sp, #320	; 0x140
 800a7d8:	bdb0      	pop	{r4, r5, r7, pc}
 800a7da:	46c0      	nop			; (mov r8, r8)
 800a7dc:	fffffec2 	.word	0xfffffec2

0800a7e0 <VL53L1_stop_range>:


VL53L1_Error VL53L1_stop_range(
	VL53L1_DEV     Dev)
{
 800a7e0:	b590      	push	{r4, r7, lr}
 800a7e2:	b085      	sub	sp, #20
 800a7e4:	af00      	add	r7, sp, #0
 800a7e6:	6078      	str	r0, [r7, #4]
	/*
	 * Stops any in process range using the ABORT command
	 * Also clears all of the measurement mode bits
	 */

	VL53L1_Error status = VL53L1_ERROR_NONE;
 800a7e8:	200f      	movs	r0, #15
 800a7ea:	183b      	adds	r3, r7, r0
 800a7ec:	2200      	movs	r2, #0
 800a7ee:	701a      	strb	r2, [r3, #0]

	VL53L1_LLDriverData_t *pdev =
 800a7f0:	687b      	ldr	r3, [r7, #4]
 800a7f2:	60bb      	str	r3, [r7, #8]
			VL53L1DevStructGetLLDriverHandle(Dev);

	/* Merge ABORT mode with mode_start */

	pdev->sys_ctrl.system__mode_start =
			(pdev->sys_ctrl.system__mode_start & VL53L1_DEVICEMEASUREMENTMODE_STOP_MASK) |
 800a7f4:	68ba      	ldr	r2, [r7, #8]
 800a7f6:	23e6      	movs	r3, #230	; 0xe6
 800a7f8:	005b      	lsls	r3, r3, #1
 800a7fa:	5cd3      	ldrb	r3, [r2, r3]
 800a7fc:	b25b      	sxtb	r3, r3
 800a7fe:	220f      	movs	r2, #15
 800a800:	4013      	ands	r3, r2
 800a802:	b25b      	sxtb	r3, r3
 800a804:	2280      	movs	r2, #128	; 0x80
 800a806:	4252      	negs	r2, r2
 800a808:	4313      	orrs	r3, r2
 800a80a:	b25b      	sxtb	r3, r3
 800a80c:	b2d9      	uxtb	r1, r3
	pdev->sys_ctrl.system__mode_start =
 800a80e:	68ba      	ldr	r2, [r7, #8]
 800a810:	23e6      	movs	r3, #230	; 0xe6
 800a812:	005b      	lsls	r3, r3, #1
 800a814:	54d1      	strb	r1, [r2, r3]
			 VL53L1_DEVICEMEASUREMENTMODE_ABORT;

	status = VL53L1_set_system_control(
 800a816:	68bb      	ldr	r3, [r7, #8]
 800a818:	33c9      	adds	r3, #201	; 0xc9
 800a81a:	33ff      	adds	r3, #255	; 0xff
 800a81c:	001a      	movs	r2, r3
 800a81e:	183c      	adds	r4, r7, r0
 800a820:	687b      	ldr	r3, [r7, #4]
 800a822:	0011      	movs	r1, r2
 800a824:	0018      	movs	r0, r3
 800a826:	f002 ff66 	bl	800d6f6 <VL53L1_set_system_control>
 800a82a:	0003      	movs	r3, r0
 800a82c:	7023      	strb	r3, [r4, #0]
				Dev,
				&pdev->sys_ctrl);

	/* Abort bit is auto clear so clear register group structure to match */
	pdev->sys_ctrl.system__mode_start =
			(pdev->sys_ctrl.system__mode_start & VL53L1_DEVICEMEASUREMENTMODE_STOP_MASK);
 800a82e:	68ba      	ldr	r2, [r7, #8]
 800a830:	23e6      	movs	r3, #230	; 0xe6
 800a832:	005b      	lsls	r3, r3, #1
 800a834:	5cd3      	ldrb	r3, [r2, r3]
 800a836:	220f      	movs	r2, #15
 800a838:	4013      	ands	r3, r2
 800a83a:	b2d9      	uxtb	r1, r3
	pdev->sys_ctrl.system__mode_start =
 800a83c:	68ba      	ldr	r2, [r7, #8]
 800a83e:	23e6      	movs	r3, #230	; 0xe6
 800a840:	005b      	lsls	r3, r3, #1
 800a842:	54d1      	strb	r1, [r2, r3]

	/* reset zone dynamic info */
	VL53L1_init_ll_driver_state(
 800a844:	687b      	ldr	r3, [r7, #4]
 800a846:	2103      	movs	r1, #3
 800a848:	0018      	movs	r0, r3
 800a84a:	f001 fa24 	bl	800bc96 <VL53L1_init_ll_driver_state>
			Dev,
			VL53L1_DEVICESTATE_SW_STANDBY);

	/* reset low power auto */
	if (pdev->low_power_auto_data.is_low_power_auto_mode == 1)
 800a84e:	68bb      	ldr	r3, [r7, #8]
 800a850:	4a07      	ldr	r2, [pc, #28]	; (800a870 <VL53L1_stop_range+0x90>)
 800a852:	5c9b      	ldrb	r3, [r3, r2]
 800a854:	2b01      	cmp	r3, #1
 800a856:	d103      	bne.n	800a860 <VL53L1_stop_range+0x80>
		VL53L1_low_power_auto_data_stop_range(Dev);
 800a858:	687b      	ldr	r3, [r7, #4]
 800a85a:	0018      	movs	r0, r3
 800a85c:	f002 f87c 	bl	800c958 <VL53L1_low_power_auto_data_stop_range>

	return status;
 800a860:	230f      	movs	r3, #15
 800a862:	18fb      	adds	r3, r7, r3
 800a864:	781b      	ldrb	r3, [r3, #0]
 800a866:	b25b      	sxtb	r3, r3
}
 800a868:	0018      	movs	r0, r3
 800a86a:	46bd      	mov	sp, r7
 800a86c:	b005      	add	sp, #20
 800a86e:	bd90      	pop	{r4, r7, pc}
 800a870:	000002e5 	.word	0x000002e5

0800a874 <VL53L1_get_measurement_results>:


VL53L1_Error VL53L1_get_measurement_results(
	VL53L1_DEV                     Dev,
	VL53L1_DeviceResultsLevel      device_results_level)
{
 800a874:	b5b0      	push	{r4, r5, r7, lr}
 800a876:	b0c8      	sub	sp, #288	; 0x120
 800a878:	af00      	add	r7, sp, #0
 800a87a:	6078      	str	r0, [r7, #4]
 800a87c:	000a      	movs	r2, r1
 800a87e:	4b7e      	ldr	r3, [pc, #504]	; (800aa78 <VL53L1_get_measurement_results+0x204>)
 800a880:	2190      	movs	r1, #144	; 0x90
 800a882:	0049      	lsls	r1, r1, #1
 800a884:	468c      	mov	ip, r1
 800a886:	44bc      	add	ip, r7
 800a888:	4463      	add	r3, ip
 800a88a:	701a      	strb	r2, [r3, #0]
	/*
	 * Read via a single I2C multiple byte transaction all
	 * of the requested device measurement data results
	 */

	VL53L1_Error status = VL53L1_ERROR_NONE;
 800a88c:	2320      	movs	r3, #32
 800a88e:	33ff      	adds	r3, #255	; 0xff
 800a890:	18fb      	adds	r3, r7, r3
 800a892:	2200      	movs	r2, #0
 800a894:	701a      	strb	r2, [r3, #0]
	VL53L1_LLDriverData_t *pdev = VL53L1DevStructGetLLDriverHandle(Dev);
 800a896:	687b      	ldr	r3, [r7, #4]
 800a898:	228c      	movs	r2, #140	; 0x8c
 800a89a:	0052      	lsls	r2, r2, #1
 800a89c:	18b9      	adds	r1, r7, r2
 800a89e:	600b      	str	r3, [r1, #0]

	uint8_t buffer[VL53L1_MAX_I2C_XFER_SIZE];

	VL53L1_system_results_t   *psystem_results = &(pdev->sys_results);
 800a8a0:	18bb      	adds	r3, r7, r2
 800a8a2:	681b      	ldr	r3, [r3, #0]
 800a8a4:	33cf      	adds	r3, #207	; 0xcf
 800a8a6:	33ff      	adds	r3, #255	; 0xff
 800a8a8:	218a      	movs	r1, #138	; 0x8a
 800a8aa:	0049      	lsls	r1, r1, #1
 800a8ac:	1879      	adds	r1, r7, r1
 800a8ae:	600b      	str	r3, [r1, #0]
	VL53L1_core_results_t     *pcore_results   = &(pdev->core_results);
 800a8b0:	18bb      	adds	r3, r7, r2
 800a8b2:	681b      	ldr	r3, [r3, #0]
 800a8b4:	21a2      	movs	r1, #162	; 0xa2
 800a8b6:	0089      	lsls	r1, r1, #2
 800a8b8:	468c      	mov	ip, r1
 800a8ba:	4463      	add	r3, ip
 800a8bc:	2188      	movs	r1, #136	; 0x88
 800a8be:	0049      	lsls	r1, r1, #1
 800a8c0:	1879      	adds	r1, r7, r1
 800a8c2:	600b      	str	r3, [r1, #0]
	VL53L1_debug_results_t    *pdebug_results  = &(pdev->dbg_results);
 800a8c4:	18bb      	adds	r3, r7, r2
 800a8c6:	681b      	ldr	r3, [r3, #0]
 800a8c8:	22ab      	movs	r2, #171	; 0xab
 800a8ca:	0092      	lsls	r2, r2, #2
 800a8cc:	4694      	mov	ip, r2
 800a8ce:	4463      	add	r3, ip
 800a8d0:	2286      	movs	r2, #134	; 0x86
 800a8d2:	0052      	lsls	r2, r2, #1
 800a8d4:	18ba      	adds	r2, r7, r2
 800a8d6:	6013      	str	r3, [r2, #0]

	uint16_t i2c_index               = VL53L1_SYSTEM_RESULTS_I2C_INDEX;
 800a8d8:	2385      	movs	r3, #133	; 0x85
 800a8da:	005b      	lsls	r3, r3, #1
 800a8dc:	18fb      	adds	r3, r7, r3
 800a8de:	2288      	movs	r2, #136	; 0x88
 800a8e0:	801a      	strh	r2, [r3, #0]
	uint16_t i2c_buffer_offset_bytes = 0;
 800a8e2:	2384      	movs	r3, #132	; 0x84
 800a8e4:	005b      	lsls	r3, r3, #1
 800a8e6:	18fb      	adds	r3, r7, r3
 800a8e8:	2200      	movs	r2, #0
 800a8ea:	801a      	strh	r2, [r3, #0]
	uint16_t i2c_buffer_size_bytes   = 0;
 800a8ec:	238e      	movs	r3, #142	; 0x8e
 800a8ee:	005b      	lsls	r3, r3, #1
 800a8f0:	18fb      	adds	r3, r7, r3
 800a8f2:	2200      	movs	r2, #0
 800a8f4:	801a      	strh	r2, [r3, #0]

	LOG_FUNCTION_START("");

	/* Determine multi byte read transaction size */

	switch (device_results_level) {
 800a8f6:	4b60      	ldr	r3, [pc, #384]	; (800aa78 <VL53L1_get_measurement_results+0x204>)
 800a8f8:	2290      	movs	r2, #144	; 0x90
 800a8fa:	0052      	lsls	r2, r2, #1
 800a8fc:	4694      	mov	ip, r2
 800a8fe:	44bc      	add	ip, r7
 800a900:	4463      	add	r3, ip
 800a902:	781b      	ldrb	r3, [r3, #0]
 800a904:	2b01      	cmp	r3, #1
 800a906:	d00d      	beq.n	800a924 <VL53L1_get_measurement_results+0xb0>
 800a908:	2b02      	cmp	r3, #2
 800a90a:	d116      	bne.n	800a93a <VL53L1_get_measurement_results+0xc6>
	case VL53L1_DEVICERESULTSLEVEL_FULL:
		i2c_buffer_size_bytes =
 800a90c:	238e      	movs	r3, #142	; 0x8e
 800a90e:	005b      	lsls	r3, r3, #1
 800a910:	18fb      	adds	r3, r7, r3
 800a912:	2285      	movs	r2, #133	; 0x85
 800a914:	0052      	lsls	r2, r2, #1
 800a916:	18ba      	adds	r2, r7, r2
 800a918:	8812      	ldrh	r2, [r2, #0]
 800a91a:	2187      	movs	r1, #135	; 0x87
 800a91c:	0049      	lsls	r1, r1, #1
 800a91e:	1a8a      	subs	r2, r1, r2
 800a920:	801a      	strh	r2, [r3, #0]
				(VL53L1_DEBUG_RESULTS_I2C_INDEX +
				VL53L1_DEBUG_RESULTS_I2C_SIZE_BYTES) -
				i2c_index;
		break;
 800a922:	e010      	b.n	800a946 <VL53L1_get_measurement_results+0xd2>
	case VL53L1_DEVICERESULTSLEVEL_UPTO_CORE:
		i2c_buffer_size_bytes =
 800a924:	238e      	movs	r3, #142	; 0x8e
 800a926:	005b      	lsls	r3, r3, #1
 800a928:	18fb      	adds	r3, r7, r3
 800a92a:	2285      	movs	r2, #133	; 0x85
 800a92c:	0052      	lsls	r2, r2, #1
 800a92e:	18ba      	adds	r2, r7, r2
 800a930:	8812      	ldrh	r2, [r2, #0]
 800a932:	21d5      	movs	r1, #213	; 0xd5
 800a934:	1a8a      	subs	r2, r1, r2
 800a936:	801a      	strh	r2, [r3, #0]
				(VL53L1_CORE_RESULTS_I2C_INDEX +
				VL53L1_CORE_RESULTS_I2C_SIZE_BYTES) -
				i2c_index;
		break;
 800a938:	e005      	b.n	800a946 <VL53L1_get_measurement_results+0xd2>
	default:
		i2c_buffer_size_bytes =
 800a93a:	238e      	movs	r3, #142	; 0x8e
 800a93c:	005b      	lsls	r3, r3, #1
 800a93e:	18fb      	adds	r3, r7, r3
 800a940:	222c      	movs	r2, #44	; 0x2c
 800a942:	801a      	strh	r2, [r3, #0]
				VL53L1_SYSTEM_RESULTS_I2C_SIZE_BYTES;
		break;
 800a944:	46c0      	nop			; (mov r8, r8)
	}

	/* Read  Result Data */

	if (status == VL53L1_ERROR_NONE) /*lint !e774 always true*/
 800a946:	2320      	movs	r3, #32
 800a948:	33ff      	adds	r3, #255	; 0xff
 800a94a:	18fb      	adds	r3, r7, r3
 800a94c:	781b      	ldrb	r3, [r3, #0]
 800a94e:	b25b      	sxtb	r3, r3
 800a950:	2b00      	cmp	r3, #0
 800a952:	d112      	bne.n	800a97a <VL53L1_get_measurement_results+0x106>
		status =
			VL53L1_ReadMulti(
 800a954:	238e      	movs	r3, #142	; 0x8e
 800a956:	005b      	lsls	r3, r3, #1
 800a958:	18fb      	adds	r3, r7, r3
 800a95a:	881d      	ldrh	r5, [r3, #0]
		status =
 800a95c:	2320      	movs	r3, #32
 800a95e:	33ff      	adds	r3, #255	; 0xff
 800a960:	18fc      	adds	r4, r7, r3
 800a962:	2308      	movs	r3, #8
 800a964:	18fa      	adds	r2, r7, r3
 800a966:	2385      	movs	r3, #133	; 0x85
 800a968:	005b      	lsls	r3, r3, #1
 800a96a:	18fb      	adds	r3, r7, r3
 800a96c:	8819      	ldrh	r1, [r3, #0]
 800a96e:	6878      	ldr	r0, [r7, #4]
 800a970:	002b      	movs	r3, r5
 800a972:	f003 fc37 	bl	800e1e4 <VL53L1_ReadMulti>
 800a976:	0003      	movs	r3, r0
 800a978:	7023      	strb	r3, [r4, #0]
				buffer,
				(uint32_t)i2c_buffer_size_bytes);

	/* Decode  I2C buffer */

	if (device_results_level >= VL53L1_DEVICERESULTSLEVEL_FULL &&
 800a97a:	4b3f      	ldr	r3, [pc, #252]	; (800aa78 <VL53L1_get_measurement_results+0x204>)
 800a97c:	2290      	movs	r2, #144	; 0x90
 800a97e:	0052      	lsls	r2, r2, #1
 800a980:	4694      	mov	ip, r2
 800a982:	44bc      	add	ip, r7
 800a984:	4463      	add	r3, ip
 800a986:	781b      	ldrb	r3, [r3, #0]
 800a988:	2b01      	cmp	r3, #1
 800a98a:	d922      	bls.n	800a9d2 <VL53L1_get_measurement_results+0x15e>
 800a98c:	2320      	movs	r3, #32
 800a98e:	33ff      	adds	r3, #255	; 0xff
 800a990:	18fb      	adds	r3, r7, r3
 800a992:	781b      	ldrb	r3, [r3, #0]
 800a994:	b25b      	sxtb	r3, r3
 800a996:	2b00      	cmp	r3, #0
 800a998:	d11b      	bne.n	800a9d2 <VL53L1_get_measurement_results+0x15e>
		status == VL53L1_ERROR_NONE) {

		i2c_buffer_offset_bytes =
 800a99a:	2084      	movs	r0, #132	; 0x84
 800a99c:	0040      	lsls	r0, r0, #1
 800a99e:	183b      	adds	r3, r7, r0
 800a9a0:	2285      	movs	r2, #133	; 0x85
 800a9a2:	0052      	lsls	r2, r2, #1
 800a9a4:	18ba      	adds	r2, r7, r2
 800a9a6:	8812      	ldrh	r2, [r2, #0]
 800a9a8:	21d6      	movs	r1, #214	; 0xd6
 800a9aa:	1a8a      	subs	r2, r1, r2
 800a9ac:	801a      	strh	r2, [r3, #0]
				VL53L1_DEBUG_RESULTS_I2C_INDEX - i2c_index;

		status =
			VL53L1_i2c_decode_debug_results(
				VL53L1_DEBUG_RESULTS_I2C_SIZE_BYTES,
				&buffer[i2c_buffer_offset_bytes],
 800a9ae:	183b      	adds	r3, r7, r0
 800a9b0:	881b      	ldrh	r3, [r3, #0]
			VL53L1_i2c_decode_debug_results(
 800a9b2:	2208      	movs	r2, #8
 800a9b4:	18ba      	adds	r2, r7, r2
 800a9b6:	18d3      	adds	r3, r2, r3
		status =
 800a9b8:	2220      	movs	r2, #32
 800a9ba:	32ff      	adds	r2, #255	; 0xff
 800a9bc:	18bc      	adds	r4, r7, r2
 800a9be:	2286      	movs	r2, #134	; 0x86
 800a9c0:	0052      	lsls	r2, r2, #1
 800a9c2:	18ba      	adds	r2, r7, r2
 800a9c4:	6812      	ldr	r2, [r2, #0]
 800a9c6:	0019      	movs	r1, r3
 800a9c8:	2038      	movs	r0, #56	; 0x38
 800a9ca:	f003 f82c 	bl	800da26 <VL53L1_i2c_decode_debug_results>
 800a9ce:	0003      	movs	r3, r0
 800a9d0:	7023      	strb	r3, [r4, #0]
				pdebug_results);
	}

	if (device_results_level >= VL53L1_DEVICERESULTSLEVEL_UPTO_CORE &&
 800a9d2:	4b29      	ldr	r3, [pc, #164]	; (800aa78 <VL53L1_get_measurement_results+0x204>)
 800a9d4:	2290      	movs	r2, #144	; 0x90
 800a9d6:	0052      	lsls	r2, r2, #1
 800a9d8:	4694      	mov	ip, r2
 800a9da:	44bc      	add	ip, r7
 800a9dc:	4463      	add	r3, ip
 800a9de:	781b      	ldrb	r3, [r3, #0]
 800a9e0:	2b00      	cmp	r3, #0
 800a9e2:	d022      	beq.n	800aa2a <VL53L1_get_measurement_results+0x1b6>
 800a9e4:	2320      	movs	r3, #32
 800a9e6:	33ff      	adds	r3, #255	; 0xff
 800a9e8:	18fb      	adds	r3, r7, r3
 800a9ea:	781b      	ldrb	r3, [r3, #0]
 800a9ec:	b25b      	sxtb	r3, r3
 800a9ee:	2b00      	cmp	r3, #0
 800a9f0:	d11b      	bne.n	800aa2a <VL53L1_get_measurement_results+0x1b6>
		status == VL53L1_ERROR_NONE) {

		i2c_buffer_offset_bytes =
 800a9f2:	2084      	movs	r0, #132	; 0x84
 800a9f4:	0040      	lsls	r0, r0, #1
 800a9f6:	183b      	adds	r3, r7, r0
 800a9f8:	2285      	movs	r2, #133	; 0x85
 800a9fa:	0052      	lsls	r2, r2, #1
 800a9fc:	18ba      	adds	r2, r7, r2
 800a9fe:	8812      	ldrh	r2, [r2, #0]
 800aa00:	21b4      	movs	r1, #180	; 0xb4
 800aa02:	1a8a      	subs	r2, r1, r2
 800aa04:	801a      	strh	r2, [r3, #0]
				VL53L1_CORE_RESULTS_I2C_INDEX - i2c_index;

		status =
			VL53L1_i2c_decode_core_results(
				VL53L1_CORE_RESULTS_I2C_SIZE_BYTES,
				&buffer[i2c_buffer_offset_bytes],
 800aa06:	183b      	adds	r3, r7, r0
 800aa08:	881b      	ldrh	r3, [r3, #0]
			VL53L1_i2c_decode_core_results(
 800aa0a:	2208      	movs	r2, #8
 800aa0c:	18ba      	adds	r2, r7, r2
 800aa0e:	18d3      	adds	r3, r2, r3
		status =
 800aa10:	2220      	movs	r2, #32
 800aa12:	32ff      	adds	r2, #255	; 0xff
 800aa14:	18bc      	adds	r4, r7, r2
 800aa16:	2288      	movs	r2, #136	; 0x88
 800aa18:	0052      	lsls	r2, r2, #1
 800aa1a:	18ba      	adds	r2, r7, r2
 800aa1c:	6812      	ldr	r2, [r2, #0]
 800aa1e:	0019      	movs	r1, r3
 800aa20:	2021      	movs	r0, #33	; 0x21
 800aa22:	f002 ff97 	bl	800d954 <VL53L1_i2c_decode_core_results>
 800aa26:	0003      	movs	r3, r0
 800aa28:	7023      	strb	r3, [r4, #0]
				pcore_results);
	}

	if (status == VL53L1_ERROR_NONE) {
 800aa2a:	2320      	movs	r3, #32
 800aa2c:	33ff      	adds	r3, #255	; 0xff
 800aa2e:	18fb      	adds	r3, r7, r3
 800aa30:	781b      	ldrb	r3, [r3, #0]
 800aa32:	b25b      	sxtb	r3, r3
 800aa34:	2b00      	cmp	r3, #0
 800aa36:	d116      	bne.n	800aa66 <VL53L1_get_measurement_results+0x1f2>

		i2c_buffer_offset_bytes = 0;
 800aa38:	2184      	movs	r1, #132	; 0x84
 800aa3a:	0049      	lsls	r1, r1, #1
 800aa3c:	187b      	adds	r3, r7, r1
 800aa3e:	2200      	movs	r2, #0
 800aa40:	801a      	strh	r2, [r3, #0]
		status =
			VL53L1_i2c_decode_system_results(
				VL53L1_SYSTEM_RESULTS_I2C_SIZE_BYTES,
				&buffer[i2c_buffer_offset_bytes],
 800aa42:	187b      	adds	r3, r7, r1
 800aa44:	881b      	ldrh	r3, [r3, #0]
			VL53L1_i2c_decode_system_results(
 800aa46:	2208      	movs	r2, #8
 800aa48:	18ba      	adds	r2, r7, r2
 800aa4a:	18d3      	adds	r3, r2, r3
		status =
 800aa4c:	2220      	movs	r2, #32
 800aa4e:	32ff      	adds	r2, #255	; 0xff
 800aa50:	18bc      	adds	r4, r7, r2
 800aa52:	228a      	movs	r2, #138	; 0x8a
 800aa54:	0052      	lsls	r2, r2, #1
 800aa56:	18ba      	adds	r2, r7, r2
 800aa58:	6812      	ldr	r2, [r2, #0]
 800aa5a:	0019      	movs	r1, r3
 800aa5c:	202c      	movs	r0, #44	; 0x2c
 800aa5e:	f002 fe7c 	bl	800d75a <VL53L1_i2c_decode_system_results>
 800aa62:	0003      	movs	r3, r0
 800aa64:	7023      	strb	r3, [r4, #0]
				psystem_results);
	}

	LOG_FUNCTION_END(status);

	return status;
 800aa66:	2320      	movs	r3, #32
 800aa68:	33ff      	adds	r3, #255	; 0xff
 800aa6a:	18fb      	adds	r3, r7, r3
 800aa6c:	781b      	ldrb	r3, [r3, #0]
 800aa6e:	b25b      	sxtb	r3, r3
}
 800aa70:	0018      	movs	r0, r3
 800aa72:	46bd      	mov	sp, r7
 800aa74:	b048      	add	sp, #288	; 0x120
 800aa76:	bdb0      	pop	{r4, r5, r7, pc}
 800aa78:	fffffee3 	.word	0xfffffee3

0800aa7c <VL53L1_get_device_results>:

VL53L1_Error VL53L1_get_device_results(
	VL53L1_DEV                    Dev,
	VL53L1_DeviceResultsLevel     device_results_level,
	VL53L1_range_results_t       *prange_results)
{
 800aa7c:	b590      	push	{r4, r7, lr}
 800aa7e:	b089      	sub	sp, #36	; 0x24
 800aa80:	af00      	add	r7, sp, #0
 800aa82:	60f8      	str	r0, [r7, #12]
 800aa84:	607a      	str	r2, [r7, #4]
 800aa86:	230b      	movs	r3, #11
 800aa88:	18fb      	adds	r3, r7, r3
 800aa8a:	1c0a      	adds	r2, r1, #0
 800aa8c:	701a      	strb	r2, [r3, #0]
	 *  VL53L1_copy_sys_and_core_results_to_range_results()
	 *
	 *  The input measurement mode controls what happens next ...
	 */

	VL53L1_Error status = VL53L1_ERROR_NONE;
 800aa8e:	211f      	movs	r1, #31
 800aa90:	187b      	adds	r3, r7, r1
 800aa92:	2200      	movs	r2, #0
 800aa94:	701a      	strb	r2, [r3, #0]

	VL53L1_LLDriverData_t *pdev =
 800aa96:	68fb      	ldr	r3, [r7, #12]
 800aa98:	61bb      	str	r3, [r7, #24]
			VL53L1DevStructGetLLDriverHandle(Dev);
	VL53L1_LLDriverResults_t *pres =
 800aa9a:	68fb      	ldr	r3, [r7, #12]
 800aa9c:	22bd      	movs	r2, #189	; 0xbd
 800aa9e:	0092      	lsls	r2, r2, #2
 800aaa0:	4694      	mov	ip, r2
 800aaa2:	4463      	add	r3, ip
 800aaa4:	617b      	str	r3, [r7, #20]
			VL53L1DevStructGetLLResultsHandle(Dev);

	VL53L1_range_results_t   *presults = &(pres->range_results);
 800aaa6:	697b      	ldr	r3, [r7, #20]
 800aaa8:	613b      	str	r3, [r7, #16]

	LOG_FUNCTION_START("");

	/* Get device results */

	if (status == VL53L1_ERROR_NONE) /*lint !e774 always true*/
 800aaaa:	187b      	adds	r3, r7, r1
 800aaac:	781b      	ldrb	r3, [r3, #0]
 800aaae:	b25b      	sxtb	r3, r3
 800aab0:	2b00      	cmp	r3, #0
 800aab2:	d10b      	bne.n	800aacc <VL53L1_get_device_results+0x50>
		status = VL53L1_get_measurement_results(
 800aab4:	231f      	movs	r3, #31
 800aab6:	18fc      	adds	r4, r7, r3
 800aab8:	230b      	movs	r3, #11
 800aaba:	18fb      	adds	r3, r7, r3
 800aabc:	781a      	ldrb	r2, [r3, #0]
 800aabe:	68fb      	ldr	r3, [r7, #12]
 800aac0:	0011      	movs	r1, r2
 800aac2:	0018      	movs	r0, r3
 800aac4:	f7ff fed6 	bl	800a874 <VL53L1_get_measurement_results>
 800aac8:	0003      	movs	r3, r0
 800aaca:	7023      	strb	r3, [r4, #0]
						Dev,
						device_results_level);

	if (status == VL53L1_ERROR_NONE)
 800aacc:	231f      	movs	r3, #31
 800aace:	18fb      	adds	r3, r7, r3
 800aad0:	781b      	ldrb	r3, [r3, #0]
 800aad2:	b25b      	sxtb	r3, r3
 800aad4:	2b00      	cmp	r3, #0
 800aad6:	d10e      	bne.n	800aaf6 <VL53L1_get_device_results+0x7a>
		VL53L1_copy_sys_and_core_results_to_range_results(
				(int32_t)pdev->gain_cal.standard_ranging_gain_factor,
 800aad8:	69bb      	ldr	r3, [r7, #24]
 800aada:	229c      	movs	r2, #156	; 0x9c
 800aadc:	5a9b      	ldrh	r3, [r3, r2]
		VL53L1_copy_sys_and_core_results_to_range_results(
 800aade:	0018      	movs	r0, r3
 800aae0:	69bb      	ldr	r3, [r7, #24]
 800aae2:	33cf      	adds	r3, #207	; 0xcf
 800aae4:	33ff      	adds	r3, #255	; 0xff
 800aae6:	0019      	movs	r1, r3
 800aae8:	69bb      	ldr	r3, [r7, #24]
 800aaea:	22a2      	movs	r2, #162	; 0xa2
 800aaec:	0092      	lsls	r2, r2, #2
 800aaee:	189a      	adds	r2, r3, r2
 800aaf0:	693b      	ldr	r3, [r7, #16]
 800aaf2:	f000 f88d 	bl	800ac10 <VL53L1_copy_sys_and_core_results_to_range_results>
				&(pdev->core_results),
				presults);

	/* Start Patch_LowPowerAutoMode */
	/* process results from first range of low power auto */
	if (pdev->low_power_auto_data.is_low_power_auto_mode == 1) {
 800aaf6:	69bb      	ldr	r3, [r7, #24]
 800aaf8:	4a31      	ldr	r2, [pc, #196]	; (800abc0 <VL53L1_get_device_results+0x144>)
 800aafa:	5c9b      	ldrb	r3, [r3, r2]
 800aafc:	2b01      	cmp	r3, #1
 800aafe:	d139      	bne.n	800ab74 <VL53L1_get_device_results+0xf8>
		/* change to manual calibrations. Only needed on the
		 * first range out  */
		if ((status == VL53L1_ERROR_NONE) &&
 800ab00:	231f      	movs	r3, #31
 800ab02:	18fb      	adds	r3, r7, r3
 800ab04:	781b      	ldrb	r3, [r3, #0]
 800ab06:	b25b      	sxtb	r3, r3
 800ab08:	2b00      	cmp	r3, #0
 800ab0a:	d111      	bne.n	800ab30 <VL53L1_get_device_results+0xb4>
			(pdev->low_power_auto_data.low_power_auto_range_count == 0)) {
 800ab0c:	69bb      	ldr	r3, [r7, #24]
 800ab0e:	4a2d      	ldr	r2, [pc, #180]	; (800abc4 <VL53L1_get_device_results+0x148>)
 800ab10:	5c9b      	ldrb	r3, [r3, r2]
		if ((status == VL53L1_ERROR_NONE) &&
 800ab12:	2b00      	cmp	r3, #0
 800ab14:	d10c      	bne.n	800ab30 <VL53L1_get_device_results+0xb4>
			status = VL53L1_low_power_auto_setup_manual_calibration(
 800ab16:	231f      	movs	r3, #31
 800ab18:	18fc      	adds	r4, r7, r3
 800ab1a:	68fb      	ldr	r3, [r7, #12]
 800ab1c:	0018      	movs	r0, r3
 800ab1e:	f001 ff87 	bl	800ca30 <VL53L1_low_power_auto_setup_manual_calibration>
 800ab22:	0003      	movs	r3, r0
 800ab24:	7023      	strb	r3, [r4, #0]
					Dev);
			pdev->low_power_auto_data.low_power_auto_range_count = 1;
 800ab26:	69bb      	ldr	r3, [r7, #24]
 800ab28:	4a26      	ldr	r2, [pc, #152]	; (800abc4 <VL53L1_get_device_results+0x148>)
 800ab2a:	2101      	movs	r1, #1
 800ab2c:	5499      	strb	r1, [r3, r2]
 800ab2e:	e00e      	b.n	800ab4e <VL53L1_get_device_results+0xd2>
		} else if ((status == VL53L1_ERROR_NONE) &&
 800ab30:	231f      	movs	r3, #31
 800ab32:	18fb      	adds	r3, r7, r3
 800ab34:	781b      	ldrb	r3, [r3, #0]
 800ab36:	b25b      	sxtb	r3, r3
 800ab38:	2b00      	cmp	r3, #0
 800ab3a:	d108      	bne.n	800ab4e <VL53L1_get_device_results+0xd2>
			(pdev->low_power_auto_data.low_power_auto_range_count == 1)) {
 800ab3c:	69bb      	ldr	r3, [r7, #24]
 800ab3e:	4a21      	ldr	r2, [pc, #132]	; (800abc4 <VL53L1_get_device_results+0x148>)
 800ab40:	5c9b      	ldrb	r3, [r3, r2]
		} else if ((status == VL53L1_ERROR_NONE) &&
 800ab42:	2b01      	cmp	r3, #1
 800ab44:	d103      	bne.n	800ab4e <VL53L1_get_device_results+0xd2>
			pdev->low_power_auto_data.low_power_auto_range_count = 2;
 800ab46:	69bb      	ldr	r3, [r7, #24]
 800ab48:	4a1e      	ldr	r2, [pc, #120]	; (800abc4 <VL53L1_get_device_results+0x148>)
 800ab4a:	2102      	movs	r1, #2
 800ab4c:	5499      	strb	r1, [r3, r2]
		}

		/* perform DSS calculation. This can be performed every range */
		if ((pdev->low_power_auto_data.low_power_auto_range_count != 0xFF) &&
 800ab4e:	69bb      	ldr	r3, [r7, #24]
 800ab50:	4a1c      	ldr	r2, [pc, #112]	; (800abc4 <VL53L1_get_device_results+0x148>)
 800ab52:	5c9b      	ldrb	r3, [r3, r2]
 800ab54:	2bff      	cmp	r3, #255	; 0xff
 800ab56:	d00d      	beq.n	800ab74 <VL53L1_get_device_results+0xf8>
 800ab58:	231f      	movs	r3, #31
 800ab5a:	18fb      	adds	r3, r7, r3
 800ab5c:	781b      	ldrb	r3, [r3, #0]
 800ab5e:	b25b      	sxtb	r3, r3
 800ab60:	2b00      	cmp	r3, #0
 800ab62:	d107      	bne.n	800ab74 <VL53L1_get_device_results+0xf8>
			(status == VL53L1_ERROR_NONE)) {
			status = VL53L1_low_power_auto_update_DSS(
 800ab64:	231f      	movs	r3, #31
 800ab66:	18fc      	adds	r4, r7, r3
 800ab68:	68fb      	ldr	r3, [r7, #12]
 800ab6a:	0018      	movs	r0, r3
 800ab6c:	f001 ffb6 	bl	800cadc <VL53L1_low_power_auto_update_DSS>
 800ab70:	0003      	movs	r3, r0
 800ab72:	7023      	strb	r3, [r4, #0]
	}
	/* End Patch_LowPowerAutoMode */

	/* copy current state into results */

	presults->cfg_device_state = pdev->ll_state.cfg_device_state;
 800ab74:	69bb      	ldr	r3, [r7, #24]
 800ab76:	222c      	movs	r2, #44	; 0x2c
 800ab78:	5c9a      	ldrb	r2, [r3, r2]
 800ab7a:	693b      	ldr	r3, [r7, #16]
 800ab7c:	701a      	strb	r2, [r3, #0]
	presults->rd_device_state  = pdev->ll_state.rd_device_state;
 800ab7e:	69bb      	ldr	r3, [r7, #24]
 800ab80:	2230      	movs	r2, #48	; 0x30
 800ab82:	5c9a      	ldrb	r2, [r3, r2]
 800ab84:	693b      	ldr	r3, [r7, #16]
 800ab86:	705a      	strb	r2, [r3, #1]

	/* copy internal structure to supplied output pointer */

	memcpy(
 800ab88:	6939      	ldr	r1, [r7, #16]
 800ab8a:	687b      	ldr	r3, [r7, #4]
 800ab8c:	2284      	movs	r2, #132	; 0x84
 800ab8e:	0018      	movs	r0, r3
 800ab90:	f008 fb18 	bl	80131c4 <memcpy>
	/*
	 * Check LL driver and Device are in Sync
	 * If not an error is raised
	 */

	if (status == VL53L1_ERROR_NONE)
 800ab94:	231f      	movs	r3, #31
 800ab96:	18fb      	adds	r3, r7, r3
 800ab98:	781b      	ldrb	r3, [r3, #0]
 800ab9a:	b25b      	sxtb	r3, r3
 800ab9c:	2b00      	cmp	r3, #0
 800ab9e:	d107      	bne.n	800abb0 <VL53L1_get_device_results+0x134>
		status = VL53L1_check_ll_driver_rd_state(Dev);
 800aba0:	231f      	movs	r3, #31
 800aba2:	18fc      	adds	r4, r7, r3
 800aba4:	68fb      	ldr	r3, [r7, #12]
 800aba6:	0018      	movs	r0, r3
 800aba8:	f001 f925 	bl	800bdf6 <VL53L1_check_ll_driver_rd_state>
 800abac:	0003      	movs	r3, r0
 800abae:	7023      	strb	r3, [r4, #0]
			VL53L1_TRACE_MODULE_RANGE_RESULTS_DATA);
#endif

	LOG_FUNCTION_END(status);

	return status;
 800abb0:	231f      	movs	r3, #31
 800abb2:	18fb      	adds	r3, r7, r3
 800abb4:	781b      	ldrb	r3, [r3, #0]
 800abb6:	b25b      	sxtb	r3, r3
}
 800abb8:	0018      	movs	r0, r3
 800abba:	46bd      	mov	sp, r7
 800abbc:	b009      	add	sp, #36	; 0x24
 800abbe:	bd90      	pop	{r4, r7, pc}
 800abc0:	000002e5 	.word	0x000002e5
 800abc4:	000002e6 	.word	0x000002e6

0800abc8 <VL53L1_clear_interrupt_and_enable_next_range>:


VL53L1_Error VL53L1_clear_interrupt_and_enable_next_range(
	VL53L1_DEV        Dev,
	uint8_t           measurement_mode)
{
 800abc8:	b590      	push	{r4, r7, lr}
 800abca:	b085      	sub	sp, #20
 800abcc:	af00      	add	r7, sp, #0
 800abce:	6078      	str	r0, [r7, #4]
 800abd0:	000a      	movs	r2, r1
 800abd2:	1cfb      	adds	r3, r7, #3
 800abd4:	701a      	strb	r2, [r3, #0]
	/*
	 * Enable next range by sending handshake which
	 * clears the interrupt
	 */

	VL53L1_Error status = VL53L1_ERROR_NONE;
 800abd6:	210f      	movs	r1, #15
 800abd8:	187b      	adds	r3, r7, r1
 800abda:	2200      	movs	r2, #0
 800abdc:	701a      	strb	r2, [r3, #0]
	/* Dynamic GPH Management     */
	/* Setup GPH absorption point and config values for next measurement */

	/* Update GPH registers, clear interrupt and set measurement mode */

	if (status == VL53L1_ERROR_NONE) /*lint !e774 always true*/
 800abde:	187b      	adds	r3, r7, r1
 800abe0:	781b      	ldrb	r3, [r3, #0]
 800abe2:	b25b      	sxtb	r3, r3
 800abe4:	2b00      	cmp	r3, #0
 800abe6:	d10a      	bne.n	800abfe <VL53L1_clear_interrupt_and_enable_next_range+0x36>
		status = VL53L1_init_and_start_range(
 800abe8:	230f      	movs	r3, #15
 800abea:	18fc      	adds	r4, r7, r3
 800abec:	1cfb      	adds	r3, r7, #3
 800abee:	7819      	ldrb	r1, [r3, #0]
 800abf0:	687b      	ldr	r3, [r7, #4]
 800abf2:	2203      	movs	r2, #3
 800abf4:	0018      	movs	r0, r3
 800abf6:	f7ff fac3 	bl	800a180 <VL53L1_init_and_start_range>
 800abfa:	0003      	movs	r3, r0
 800abfc:	7023      	strb	r3, [r4, #0]
					measurement_mode,
					VL53L1_DEVICECONFIGLEVEL_GENERAL_ONWARDS);

	LOG_FUNCTION_END(status);

	return status;
 800abfe:	230f      	movs	r3, #15
 800ac00:	18fb      	adds	r3, r7, r3
 800ac02:	781b      	ldrb	r3, [r3, #0]
 800ac04:	b25b      	sxtb	r3, r3
}
 800ac06:	0018      	movs	r0, r3
 800ac08:	46bd      	mov	sp, r7
 800ac0a:	b005      	add	sp, #20
 800ac0c:	bd90      	pop	{r4, r7, pc}
	...

0800ac10 <VL53L1_copy_sys_and_core_results_to_range_results>:
void VL53L1_copy_sys_and_core_results_to_range_results(
	int32_t                           gain_factor,
	VL53L1_system_results_t          *psys,
	VL53L1_core_results_t            *pcore,
	VL53L1_range_results_t           *presults)
{
 800ac10:	b580      	push	{r7, lr}
 800ac12:	b088      	sub	sp, #32
 800ac14:	af00      	add	r7, sp, #0
 800ac16:	60f8      	str	r0, [r7, #12]
 800ac18:	60b9      	str	r1, [r7, #8]
 800ac1a:	607a      	str	r2, [r7, #4]
 800ac1c:	603b      	str	r3, [r7, #0]
	uint8_t  i = 0;
 800ac1e:	211f      	movs	r1, #31
 800ac20:	187b      	adds	r3, r7, r1
 800ac22:	2200      	movs	r2, #0
 800ac24:	701a      	strb	r2, [r3, #0]

	VL53L1_range_data_t *pdata;
	int32_t range_mm = 0;
 800ac26:	2300      	movs	r3, #0
 800ac28:	613b      	str	r3, [r7, #16]
	uint32_t tmpu32 = 0;
 800ac2a:	2300      	movs	r3, #0
 800ac2c:	617b      	str	r3, [r7, #20]

	LOG_FUNCTION_START("");

	/* copy results */

	presults->stream_count    = psys->result__stream_count;
 800ac2e:	68bb      	ldr	r3, [r7, #8]
 800ac30:	78da      	ldrb	r2, [r3, #3]
 800ac32:	683b      	ldr	r3, [r7, #0]
 800ac34:	709a      	strb	r2, [r3, #2]

	pdata = &(presults->data[0]);
 800ac36:	683b      	ldr	r3, [r7, #0]
 800ac38:	3304      	adds	r3, #4
 800ac3a:	61bb      	str	r3, [r7, #24]

	for (i = 0 ; i < 2 ; i++) {
 800ac3c:	187b      	adds	r3, r7, r1
 800ac3e:	2200      	movs	r2, #0
 800ac40:	701a      	strb	r2, [r3, #0]
 800ac42:	e0da      	b.n	800adfa <VL53L1_copy_sys_and_core_results_to_range_results+0x1ea>

		pdata->range_id     = i;
 800ac44:	69bb      	ldr	r3, [r7, #24]
 800ac46:	221f      	movs	r2, #31
 800ac48:	18ba      	adds	r2, r7, r2
 800ac4a:	7812      	ldrb	r2, [r2, #0]
 800ac4c:	701a      	strb	r2, [r3, #0]
		pdata->time_stamp   = 0;
 800ac4e:	69bb      	ldr	r3, [r7, #24]
 800ac50:	2200      	movs	r2, #0
 800ac52:	605a      	str	r2, [r3, #4]

		if ((psys->result__stream_count == 0) &&
 800ac54:	68bb      	ldr	r3, [r7, #8]
 800ac56:	78db      	ldrb	r3, [r3, #3]
 800ac58:	2b00      	cmp	r3, #0
 800ac5a:	d10b      	bne.n	800ac74 <VL53L1_copy_sys_and_core_results_to_range_results+0x64>
			((psys->result__range_status & VL53L1_RANGE_STATUS__RANGE_STATUS_MASK) ==
 800ac5c:	68bb      	ldr	r3, [r7, #8]
 800ac5e:	785b      	ldrb	r3, [r3, #1]
 800ac60:	001a      	movs	r2, r3
 800ac62:	231f      	movs	r3, #31
 800ac64:	4013      	ands	r3, r2
		if ((psys->result__stream_count == 0) &&
 800ac66:	2b09      	cmp	r3, #9
 800ac68:	d104      	bne.n	800ac74 <VL53L1_copy_sys_and_core_results_to_range_results+0x64>
			VL53L1_DEVICEERROR_RANGECOMPLETE)) {
			pdata->range_status = VL53L1_DEVICEERROR_RANGECOMPLETE_NO_WRAP_CHECK;
 800ac6a:	69bb      	ldr	r3, [r7, #24]
 800ac6c:	223e      	movs	r2, #62	; 0x3e
 800ac6e:	2113      	movs	r1, #19
 800ac70:	5499      	strb	r1, [r3, r2]
 800ac72:	e007      	b.n	800ac84 <VL53L1_copy_sys_and_core_results_to_range_results+0x74>
		} else {
			pdata->range_status =
					psys->result__range_status & VL53L1_RANGE_STATUS__RANGE_STATUS_MASK;
 800ac74:	68bb      	ldr	r3, [r7, #8]
 800ac76:	785b      	ldrb	r3, [r3, #1]
 800ac78:	221f      	movs	r2, #31
 800ac7a:	4013      	ands	r3, r2
 800ac7c:	b2d9      	uxtb	r1, r3
			pdata->range_status =
 800ac7e:	69bb      	ldr	r3, [r7, #24]
 800ac80:	223e      	movs	r2, #62	; 0x3e
 800ac82:	5499      	strb	r1, [r3, r2]
		}

		switch (i) {
 800ac84:	231f      	movs	r3, #31
 800ac86:	18fb      	adds	r3, r7, r3
 800ac88:	781b      	ldrb	r3, [r3, #0]
 800ac8a:	2b00      	cmp	r3, #0
 800ac8c:	d002      	beq.n	800ac94 <VL53L1_copy_sys_and_core_results_to_range_results+0x84>
 800ac8e:	2b01      	cmp	r3, #1
 800ac90:	d05e      	beq.n	800ad50 <VL53L1_copy_sys_and_core_results_to_range_results+0x140>
 800ac92:	e0a9      	b.n	800ade8 <VL53L1_copy_sys_and_core_results_to_range_results+0x1d8>

		case 0:

			if (psys->result__report_status == VL53L1_DEVICEREPORTSTATUS_MM1)
 800ac94:	68bb      	ldr	r3, [r7, #8]
 800ac96:	789b      	ldrb	r3, [r3, #2]
 800ac98:	2b07      	cmp	r3, #7
 800ac9a:	d104      	bne.n	800aca6 <VL53L1_copy_sys_and_core_results_to_range_results+0x96>
				pdata->actual_effective_spads =
					psys->result__mm_inner_actual_effective_spads_sd0;
 800ac9c:	68bb      	ldr	r3, [r7, #8]
 800ac9e:	8a5a      	ldrh	r2, [r3, #18]
				pdata->actual_effective_spads =
 800aca0:	69bb      	ldr	r3, [r7, #24]
 800aca2:	821a      	strh	r2, [r3, #16]
 800aca4:	e00c      	b.n	800acc0 <VL53L1_copy_sys_and_core_results_to_range_results+0xb0>
			else if (psys->result__report_status == VL53L1_DEVICEREPORTSTATUS_MM2)
 800aca6:	68bb      	ldr	r3, [r7, #8]
 800aca8:	789b      	ldrb	r3, [r3, #2]
 800acaa:	2b08      	cmp	r3, #8
 800acac:	d104      	bne.n	800acb8 <VL53L1_copy_sys_and_core_results_to_range_results+0xa8>
				pdata->actual_effective_spads =
						psys->result__mm_outer_actual_effective_spads_sd0;
 800acae:	68bb      	ldr	r3, [r7, #8]
 800acb0:	8a9a      	ldrh	r2, [r3, #20]
				pdata->actual_effective_spads =
 800acb2:	69bb      	ldr	r3, [r7, #24]
 800acb4:	821a      	strh	r2, [r3, #16]
 800acb6:	e003      	b.n	800acc0 <VL53L1_copy_sys_and_core_results_to_range_results+0xb0>
			else
				pdata->actual_effective_spads =
					psys->result__dss_actual_effective_spads_sd0;
 800acb8:	68bb      	ldr	r3, [r7, #8]
 800acba:	889a      	ldrh	r2, [r3, #4]
				pdata->actual_effective_spads =
 800acbc:	69bb      	ldr	r3, [r7, #24]
 800acbe:	821a      	strh	r2, [r3, #16]

			pdata->peak_signal_count_rate_mcps =
				psys->result__peak_signal_count_rate_crosstalk_corrected_mcps_sd0;
 800acc0:	68bb      	ldr	r3, [r7, #8]
 800acc2:	8a1a      	ldrh	r2, [r3, #16]
			pdata->peak_signal_count_rate_mcps =
 800acc4:	69bb      	ldr	r3, [r7, #24]
 800acc6:	859a      	strh	r2, [r3, #44]	; 0x2c
			pdata->avg_signal_count_rate_mcps =
				psys->result__avg_signal_count_rate_mcps_sd0;
 800acc8:	68bb      	ldr	r3, [r7, #8]
 800acca:	8ada      	ldrh	r2, [r3, #22]
			pdata->avg_signal_count_rate_mcps =
 800accc:	69bb      	ldr	r3, [r7, #24]
 800acce:	85da      	strh	r2, [r3, #46]	; 0x2e
			pdata->ambient_count_rate_mcps =
				psys->result__ambient_count_rate_mcps_sd0;
 800acd0:	68bb      	ldr	r3, [r7, #8]
 800acd2:	891a      	ldrh	r2, [r3, #8]
			pdata->ambient_count_rate_mcps =
 800acd4:	69bb      	ldr	r3, [r7, #24]
 800acd6:	861a      	strh	r2, [r3, #48]	; 0x30

			/* Start Patch_SigmaEstimateAccuracyImprovement */

			/* shift up sigma estimate to 7 bit fractional and clip to 9 bit int */
			tmpu32 = ((uint32_t)psys->result__sigma_sd0 << 5);
 800acd8:	68bb      	ldr	r3, [r7, #8]
 800acda:	895b      	ldrh	r3, [r3, #10]
 800acdc:	015b      	lsls	r3, r3, #5
 800acde:	617b      	str	r3, [r7, #20]
			if (tmpu32 > 0xFFFF) {
 800ace0:	697b      	ldr	r3, [r7, #20]
 800ace2:	4a5a      	ldr	r2, [pc, #360]	; (800ae4c <VL53L1_copy_sys_and_core_results_to_range_results+0x23c>)
 800ace4:	4293      	cmp	r3, r2
 800ace6:	d901      	bls.n	800acec <VL53L1_copy_sys_and_core_results_to_range_results+0xdc>
				tmpu32 = 0xFFFF;
 800ace8:	4b58      	ldr	r3, [pc, #352]	; (800ae4c <VL53L1_copy_sys_and_core_results_to_range_results+0x23c>)
 800acea:	617b      	str	r3, [r7, #20]
			}
			pdata->sigma_mm = (uint16_t)tmpu32;
 800acec:	697b      	ldr	r3, [r7, #20]
 800acee:	b29a      	uxth	r2, r3
 800acf0:	69bb      	ldr	r3, [r7, #24]
 800acf2:	871a      	strh	r2, [r3, #56]	; 0x38

			/* End Patch_SigmaEstimateAccuracyImprovement */

			pdata->median_phase =
				psys->result__phase_sd0;
 800acf4:	68bb      	ldr	r3, [r7, #8]
 800acf6:	899a      	ldrh	r2, [r3, #12]
			pdata->median_phase =
 800acf8:	69bb      	ldr	r3, [r7, #24]
 800acfa:	875a      	strh	r2, [r3, #58]	; 0x3a

			range_mm =
				(int32_t)psys->result__final_crosstalk_corrected_range_mm_sd0;
 800acfc:	68bb      	ldr	r3, [r7, #8]
 800acfe:	89db      	ldrh	r3, [r3, #14]
			range_mm =
 800ad00:	613b      	str	r3, [r7, #16]

			/* apply correction gain */
			range_mm *= gain_factor;
 800ad02:	693b      	ldr	r3, [r7, #16]
 800ad04:	68fa      	ldr	r2, [r7, #12]
 800ad06:	4353      	muls	r3, r2
 800ad08:	613b      	str	r3, [r7, #16]
			range_mm += 0x0400;
 800ad0a:	693b      	ldr	r3, [r7, #16]
 800ad0c:	2280      	movs	r2, #128	; 0x80
 800ad0e:	00d2      	lsls	r2, r2, #3
 800ad10:	4694      	mov	ip, r2
 800ad12:	4463      	add	r3, ip
 800ad14:	613b      	str	r3, [r7, #16]
			range_mm /= 0x0800;
 800ad16:	693b      	ldr	r3, [r7, #16]
 800ad18:	2b00      	cmp	r3, #0
 800ad1a:	da02      	bge.n	800ad22 <VL53L1_copy_sys_and_core_results_to_range_results+0x112>
 800ad1c:	4a4c      	ldr	r2, [pc, #304]	; (800ae50 <VL53L1_copy_sys_and_core_results_to_range_results+0x240>)
 800ad1e:	4694      	mov	ip, r2
 800ad20:	4463      	add	r3, ip
 800ad22:	12db      	asrs	r3, r3, #11
 800ad24:	613b      	str	r3, [r7, #16]

			pdata->median_range_mm = (int16_t)range_mm;
 800ad26:	693b      	ldr	r3, [r7, #16]
 800ad28:	b21a      	sxth	r2, r3
 800ad2a:	69bb      	ldr	r3, [r7, #24]
 800ad2c:	879a      	strh	r2, [r3, #60]	; 0x3c

			pdata->ranging_total_events =
				pcore->result_core__ranging_total_events_sd0;
 800ad2e:	687b      	ldr	r3, [r7, #4]
 800ad30:	685a      	ldr	r2, [r3, #4]
			pdata->ranging_total_events =
 800ad32:	69bb      	ldr	r3, [r7, #24]
 800ad34:	625a      	str	r2, [r3, #36]	; 0x24
			pdata->signal_total_events =
				pcore->result_core__signal_total_events_sd0;
 800ad36:	687b      	ldr	r3, [r7, #4]
 800ad38:	689a      	ldr	r2, [r3, #8]
			pdata->signal_total_events =
 800ad3a:	69bb      	ldr	r3, [r7, #24]
 800ad3c:	629a      	str	r2, [r3, #40]	; 0x28
			pdata->total_periods_elapsed =
				pcore->result_core__total_periods_elapsed_sd0;
 800ad3e:	687b      	ldr	r3, [r7, #4]
 800ad40:	68da      	ldr	r2, [r3, #12]
			pdata->total_periods_elapsed =
 800ad42:	69bb      	ldr	r3, [r7, #24]
 800ad44:	615a      	str	r2, [r3, #20]
			pdata->ambient_window_events =
				pcore->result_core__ambient_window_events_sd0;
 800ad46:	687b      	ldr	r3, [r7, #4]
 800ad48:	681a      	ldr	r2, [r3, #0]
			pdata->ambient_window_events =
 800ad4a:	69bb      	ldr	r3, [r7, #24]
 800ad4c:	621a      	str	r2, [r3, #32]

			break;
 800ad4e:	e04b      	b.n	800ade8 <VL53L1_copy_sys_and_core_results_to_range_results+0x1d8>
		case 1:

			pdata->actual_effective_spads =
				psys->result__dss_actual_effective_spads_sd1;
 800ad50:	68bb      	ldr	r3, [r7, #8]
 800ad52:	8b1a      	ldrh	r2, [r3, #24]
			pdata->actual_effective_spads =
 800ad54:	69bb      	ldr	r3, [r7, #24]
 800ad56:	821a      	strh	r2, [r3, #16]
			pdata->peak_signal_count_rate_mcps =
				psys->result__peak_signal_count_rate_mcps_sd1;
 800ad58:	68bb      	ldr	r3, [r7, #8]
 800ad5a:	8b5a      	ldrh	r2, [r3, #26]
			pdata->peak_signal_count_rate_mcps =
 800ad5c:	69bb      	ldr	r3, [r7, #24]
 800ad5e:	859a      	strh	r2, [r3, #44]	; 0x2c
			pdata->avg_signal_count_rate_mcps =
 800ad60:	69bb      	ldr	r3, [r7, #24]
 800ad62:	2201      	movs	r2, #1
 800ad64:	4252      	negs	r2, r2
 800ad66:	85da      	strh	r2, [r3, #46]	; 0x2e
				0xFFFF;
			pdata->ambient_count_rate_mcps =
				psys->result__ambient_count_rate_mcps_sd1;
 800ad68:	68bb      	ldr	r3, [r7, #8]
 800ad6a:	8b9a      	ldrh	r2, [r3, #28]
			pdata->ambient_count_rate_mcps =
 800ad6c:	69bb      	ldr	r3, [r7, #24]
 800ad6e:	861a      	strh	r2, [r3, #48]	; 0x30

			/* Start Patch_SigmaEstimateAccuracyImprovement */

			/* shift up sigma estimate to 7 bit fractional and clip to 9 bit int */
			tmpu32 = ((uint32_t)psys->result__sigma_sd1 << 5);
 800ad70:	68bb      	ldr	r3, [r7, #8]
 800ad72:	8bdb      	ldrh	r3, [r3, #30]
 800ad74:	015b      	lsls	r3, r3, #5
 800ad76:	617b      	str	r3, [r7, #20]
			if (tmpu32 > 0xFFFF) {
 800ad78:	697b      	ldr	r3, [r7, #20]
 800ad7a:	4a34      	ldr	r2, [pc, #208]	; (800ae4c <VL53L1_copy_sys_and_core_results_to_range_results+0x23c>)
 800ad7c:	4293      	cmp	r3, r2
 800ad7e:	d901      	bls.n	800ad84 <VL53L1_copy_sys_and_core_results_to_range_results+0x174>
				tmpu32 = 0xFFFF;
 800ad80:	4b32      	ldr	r3, [pc, #200]	; (800ae4c <VL53L1_copy_sys_and_core_results_to_range_results+0x23c>)
 800ad82:	617b      	str	r3, [r7, #20]
			}
			pdata->sigma_mm = (uint16_t)tmpu32;
 800ad84:	697b      	ldr	r3, [r7, #20]
 800ad86:	b29a      	uxth	r2, r3
 800ad88:	69bb      	ldr	r3, [r7, #24]
 800ad8a:	871a      	strh	r2, [r3, #56]	; 0x38

			/* End Patch_SigmaEstimateAccuracyImprovement */

			pdata->median_phase =
				psys->result__phase_sd1;
 800ad8c:	68bb      	ldr	r3, [r7, #8]
 800ad8e:	8c1a      	ldrh	r2, [r3, #32]
			pdata->median_phase =
 800ad90:	69bb      	ldr	r3, [r7, #24]
 800ad92:	875a      	strh	r2, [r3, #58]	; 0x3a

			range_mm =
				(int32_t)psys->result__final_crosstalk_corrected_range_mm_sd1;
 800ad94:	68bb      	ldr	r3, [r7, #8]
 800ad96:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
			range_mm =
 800ad98:	613b      	str	r3, [r7, #16]

			/* apply correction gain */
			range_mm *= gain_factor;
 800ad9a:	693b      	ldr	r3, [r7, #16]
 800ad9c:	68fa      	ldr	r2, [r7, #12]
 800ad9e:	4353      	muls	r3, r2
 800ada0:	613b      	str	r3, [r7, #16]
			range_mm += 0x0400;
 800ada2:	693b      	ldr	r3, [r7, #16]
 800ada4:	2280      	movs	r2, #128	; 0x80
 800ada6:	00d2      	lsls	r2, r2, #3
 800ada8:	4694      	mov	ip, r2
 800adaa:	4463      	add	r3, ip
 800adac:	613b      	str	r3, [r7, #16]
			range_mm /= 0x0800;
 800adae:	693b      	ldr	r3, [r7, #16]
 800adb0:	2b00      	cmp	r3, #0
 800adb2:	da02      	bge.n	800adba <VL53L1_copy_sys_and_core_results_to_range_results+0x1aa>
 800adb4:	4a26      	ldr	r2, [pc, #152]	; (800ae50 <VL53L1_copy_sys_and_core_results_to_range_results+0x240>)
 800adb6:	4694      	mov	ip, r2
 800adb8:	4463      	add	r3, ip
 800adba:	12db      	asrs	r3, r3, #11
 800adbc:	613b      	str	r3, [r7, #16]

			pdata->median_range_mm = (int16_t)range_mm;
 800adbe:	693b      	ldr	r3, [r7, #16]
 800adc0:	b21a      	sxth	r2, r3
 800adc2:	69bb      	ldr	r3, [r7, #24]
 800adc4:	879a      	strh	r2, [r3, #60]	; 0x3c

			pdata->ranging_total_events =
				pcore->result_core__ranging_total_events_sd1;
 800adc6:	687b      	ldr	r3, [r7, #4]
 800adc8:	695a      	ldr	r2, [r3, #20]
			pdata->ranging_total_events =
 800adca:	69bb      	ldr	r3, [r7, #24]
 800adcc:	625a      	str	r2, [r3, #36]	; 0x24
			pdata->signal_total_events =
				pcore->result_core__signal_total_events_sd1;
 800adce:	687b      	ldr	r3, [r7, #4]
 800add0:	699a      	ldr	r2, [r3, #24]
			pdata->signal_total_events =
 800add2:	69bb      	ldr	r3, [r7, #24]
 800add4:	629a      	str	r2, [r3, #40]	; 0x28
			pdata->total_periods_elapsed  =
				pcore->result_core__total_periods_elapsed_sd1;
 800add6:	687b      	ldr	r3, [r7, #4]
 800add8:	69da      	ldr	r2, [r3, #28]
			pdata->total_periods_elapsed  =
 800adda:	69bb      	ldr	r3, [r7, #24]
 800addc:	615a      	str	r2, [r3, #20]
			pdata->ambient_window_events =
				pcore->result_core__ambient_window_events_sd1;
 800adde:	687b      	ldr	r3, [r7, #4]
 800ade0:	691a      	ldr	r2, [r3, #16]
			pdata->ambient_window_events =
 800ade2:	69bb      	ldr	r3, [r7, #24]
 800ade4:	621a      	str	r2, [r3, #32]

			break;
 800ade6:	46c0      	nop			; (mov r8, r8)
		}

		pdata++;
 800ade8:	69bb      	ldr	r3, [r7, #24]
 800adea:	3340      	adds	r3, #64	; 0x40
 800adec:	61bb      	str	r3, [r7, #24]
	for (i = 0 ; i < 2 ; i++) {
 800adee:	211f      	movs	r1, #31
 800adf0:	187b      	adds	r3, r7, r1
 800adf2:	781a      	ldrb	r2, [r3, #0]
 800adf4:	187b      	adds	r3, r7, r1
 800adf6:	3201      	adds	r2, #1
 800adf8:	701a      	strb	r2, [r3, #0]
 800adfa:	231f      	movs	r3, #31
 800adfc:	18fb      	adds	r3, r7, r3
 800adfe:	781b      	ldrb	r3, [r3, #0]
 800ae00:	2b01      	cmp	r3, #1
 800ae02:	d800      	bhi.n	800ae06 <VL53L1_copy_sys_and_core_results_to_range_results+0x1f6>
 800ae04:	e71e      	b.n	800ac44 <VL53L1_copy_sys_and_core_results_to_range_results+0x34>

	/* Update Global Device Status for results
	 * - Default to no update
	 */

	presults->device_status = VL53L1_DEVICEERROR_NOUPDATE;
 800ae06:	683b      	ldr	r3, [r7, #0]
 800ae08:	2200      	movs	r2, #0
 800ae0a:	70da      	strb	r2, [r3, #3]
	 * - If device error condition, update device status
	 * - Remove device status from range status output this should
	 * only contain information relating to range data
	 */

	switch (psys->result__range_status &
 800ae0c:	68bb      	ldr	r3, [r7, #8]
 800ae0e:	785b      	ldrb	r3, [r3, #1]
 800ae10:	001a      	movs	r2, r3
 800ae12:	231f      	movs	r3, #31
 800ae14:	4013      	ands	r3, r2
 800ae16:	2b0d      	cmp	r3, #13
 800ae18:	d007      	beq.n	800ae2a <VL53L1_copy_sys_and_core_results_to_range_results+0x21a>
 800ae1a:	dc03      	bgt.n	800ae24 <VL53L1_copy_sys_and_core_results_to_range_results+0x214>
 800ae1c:	3b01      	subs	r3, #1
 800ae1e:	2b02      	cmp	r3, #2
 800ae20:	d80f      	bhi.n	800ae42 <VL53L1_copy_sys_and_core_results_to_range_results+0x232>
 800ae22:	e002      	b.n	800ae2a <VL53L1_copy_sys_and_core_results_to_range_results+0x21a>
 800ae24:	2b11      	cmp	r3, #17
 800ae26:	d000      	beq.n	800ae2a <VL53L1_copy_sys_and_core_results_to_range_results+0x21a>
	break;

	}

	LOG_FUNCTION_END(0);
}
 800ae28:	e00b      	b.n	800ae42 <VL53L1_copy_sys_and_core_results_to_range_results+0x232>
		presults->device_status = (psys->result__range_status &
 800ae2a:	68bb      	ldr	r3, [r7, #8]
 800ae2c:	785b      	ldrb	r3, [r3, #1]
 800ae2e:	221f      	movs	r2, #31
 800ae30:	4013      	ands	r3, r2
 800ae32:	b2da      	uxtb	r2, r3
 800ae34:	683b      	ldr	r3, [r7, #0]
 800ae36:	70da      	strb	r2, [r3, #3]
		presults->data[0].range_status = VL53L1_DEVICEERROR_NOUPDATE;
 800ae38:	683b      	ldr	r3, [r7, #0]
 800ae3a:	2242      	movs	r2, #66	; 0x42
 800ae3c:	2100      	movs	r1, #0
 800ae3e:	5499      	strb	r1, [r3, r2]
	break;
 800ae40:	46c0      	nop			; (mov r8, r8)
}
 800ae42:	46c0      	nop			; (mov r8, r8)
 800ae44:	46bd      	mov	sp, r7
 800ae46:	b008      	add	sp, #32
 800ae48:	bd80      	pop	{r7, pc}
 800ae4a:	46c0      	nop			; (mov r8, r8)
 800ae4c:	0000ffff 	.word	0x0000ffff
 800ae50:	000007ff 	.word	0x000007ff

0800ae54 <VL53L1_get_tuning_parm>:

VL53L1_Error VL53L1_get_tuning_parm(
	VL53L1_DEV                     Dev,
	VL53L1_TuningParms             tuning_parm_key,
	int32_t                       *ptuning_parm_value)
{
 800ae54:	b580      	push	{r7, lr}
 800ae56:	b086      	sub	sp, #24
 800ae58:	af00      	add	r7, sp, #0
 800ae5a:	60f8      	str	r0, [r7, #12]
 800ae5c:	607a      	str	r2, [r7, #4]
 800ae5e:	200a      	movs	r0, #10
 800ae60:	183b      	adds	r3, r7, r0
 800ae62:	1c0a      	adds	r2, r1, #0
 800ae64:	801a      	strh	r2, [r3, #0]
	 * Gets the requested tuning parm value
	 * - Large case statement for returns
	 * - if key does not match, INVALID parm error returned
	 */

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 800ae66:	2317      	movs	r3, #23
 800ae68:	18fb      	adds	r3, r7, r3
 800ae6a:	2200      	movs	r2, #0
 800ae6c:	701a      	strb	r2, [r3, #0]

	VL53L1_LLDriverData_t *pdev = VL53L1DevStructGetLLDriverHandle(Dev);
 800ae6e:	68fb      	ldr	r3, [r7, #12]
 800ae70:	613b      	str	r3, [r7, #16]

	LOG_FUNCTION_START("");

	switch (tuning_parm_key) {
 800ae72:	183b      	adds	r3, r7, r0
 800ae74:	881b      	ldrh	r3, [r3, #0]
 800ae76:	4ad7      	ldr	r2, [pc, #860]	; (800b1d4 <VL53L1_get_tuning_parm+0x380>)
 800ae78:	4694      	mov	ip, r2
 800ae7a:	4463      	add	r3, ip
 800ae7c:	2b38      	cmp	r3, #56	; 0x38
 800ae7e:	d900      	bls.n	800ae82 <VL53L1_get_tuning_parm+0x2e>
 800ae80:	e1ac      	b.n	800b1dc <VL53L1_get_tuning_parm+0x388>
 800ae82:	009a      	lsls	r2, r3, #2
 800ae84:	4bd4      	ldr	r3, [pc, #848]	; (800b1d8 <VL53L1_get_tuning_parm+0x384>)
 800ae86:	18d3      	adds	r3, r2, r3
 800ae88:	681b      	ldr	r3, [r3, #0]
 800ae8a:	469f      	mov	pc, r3

	case VL53L1_TUNINGPARM_VERSION:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_tuning_parm_version;
 800ae8c:	693b      	ldr	r3, [r7, #16]
 800ae8e:	22a4      	movs	r2, #164	; 0xa4
 800ae90:	5a9b      	ldrh	r3, [r3, r2]
 800ae92:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800ae94:	687b      	ldr	r3, [r7, #4]
 800ae96:	601a      	str	r2, [r3, #0]
	break;
 800ae98:	e1a8      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_KEY_TABLE_VERSION:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_tuning_parm_key_table_version;
 800ae9a:	693b      	ldr	r3, [r7, #16]
 800ae9c:	22a6      	movs	r2, #166	; 0xa6
 800ae9e:	5a9b      	ldrh	r3, [r3, r2]
 800aea0:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800aea2:	687b      	ldr	r3, [r7, #4]
 800aea4:	601a      	str	r2, [r3, #0]
	break;
 800aea6:	e1a1      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_LLD_VERSION:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_tuning_parm_lld_version;
 800aea8:	693b      	ldr	r3, [r7, #16]
 800aeaa:	22a8      	movs	r2, #168	; 0xa8
 800aeac:	5a9b      	ldrh	r3, [r3, r2]
 800aeae:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800aeb0:	687b      	ldr	r3, [r7, #4]
 800aeb2:	601a      	str	r2, [r3, #0]
	break;
 800aeb4:	e19a      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_CONSISTENCY_LITE_PHASE_TOLERANCE:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_consistency_lite_phase_tolerance;
 800aeb6:	693b      	ldr	r3, [r7, #16]
 800aeb8:	22b0      	movs	r2, #176	; 0xb0
 800aeba:	5c9b      	ldrb	r3, [r3, r2]
 800aebc:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800aebe:	687b      	ldr	r3, [r7, #4]
 800aec0:	601a      	str	r2, [r3, #0]
	break;
 800aec2:	e193      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_PHASECAL_TARGET:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_phasecal_target;
 800aec4:	693b      	ldr	r3, [r7, #16]
 800aec6:	22b1      	movs	r2, #177	; 0xb1
 800aec8:	5c9b      	ldrb	r3, [r3, r2]
 800aeca:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800aecc:	687b      	ldr	r3, [r7, #4]
 800aece:	601a      	str	r2, [r3, #0]
	break;
 800aed0:	e18c      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_LITE_CAL_REPEAT_RATE:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_cal_repeat_rate;
 800aed2:	693b      	ldr	r3, [r7, #16]
 800aed4:	22b2      	movs	r2, #178	; 0xb2
 800aed6:	5a9b      	ldrh	r3, [r3, r2]
 800aed8:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800aeda:	687b      	ldr	r3, [r7, #4]
 800aedc:	601a      	str	r2, [r3, #0]
	break;
 800aede:	e185      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_LITE_RANGING_GAIN_FACTOR:
		*ptuning_parm_value =
				(int32_t)pdev->gain_cal.standard_ranging_gain_factor;
 800aee0:	693b      	ldr	r3, [r7, #16]
 800aee2:	229c      	movs	r2, #156	; 0x9c
 800aee4:	5a9b      	ldrh	r3, [r3, r2]
 800aee6:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800aee8:	687b      	ldr	r3, [r7, #4]
 800aeea:	601a      	str	r2, [r3, #0]
	break;
 800aeec:	e17e      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_LITE_MIN_CLIP_MM:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_lite_min_clip;
 800aeee:	693b      	ldr	r3, [r7, #16]
 800aef0:	22b4      	movs	r2, #180	; 0xb4
 800aef2:	5c9b      	ldrb	r3, [r3, r2]
 800aef4:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800aef6:	687b      	ldr	r3, [r7, #4]
 800aef8:	601a      	str	r2, [r3, #0]
	break;
 800aefa:	e177      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_LITE_LONG_SIGMA_THRESH_MM:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_lite_long_sigma_thresh_mm;
 800aefc:	693b      	ldr	r3, [r7, #16]
 800aefe:	22b6      	movs	r2, #182	; 0xb6
 800af00:	5a9b      	ldrh	r3, [r3, r2]
 800af02:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800af04:	687b      	ldr	r3, [r7, #4]
 800af06:	601a      	str	r2, [r3, #0]
	break;
 800af08:	e170      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_LITE_MED_SIGMA_THRESH_MM:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_lite_med_sigma_thresh_mm;
 800af0a:	693b      	ldr	r3, [r7, #16]
 800af0c:	22b8      	movs	r2, #184	; 0xb8
 800af0e:	5a9b      	ldrh	r3, [r3, r2]
 800af10:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800af12:	687b      	ldr	r3, [r7, #4]
 800af14:	601a      	str	r2, [r3, #0]
	break;
 800af16:	e169      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_LITE_SHORT_SIGMA_THRESH_MM:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_lite_short_sigma_thresh_mm;
 800af18:	693b      	ldr	r3, [r7, #16]
 800af1a:	22ba      	movs	r2, #186	; 0xba
 800af1c:	5a9b      	ldrh	r3, [r3, r2]
 800af1e:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800af20:	687b      	ldr	r3, [r7, #4]
 800af22:	601a      	str	r2, [r3, #0]
	break;
 800af24:	e162      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_LITE_LONG_MIN_COUNT_RATE_RTN_MCPS:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_lite_long_min_count_rate_rtn_mcps;
 800af26:	693b      	ldr	r3, [r7, #16]
 800af28:	22bc      	movs	r2, #188	; 0xbc
 800af2a:	5a9b      	ldrh	r3, [r3, r2]
 800af2c:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800af2e:	687b      	ldr	r3, [r7, #4]
 800af30:	601a      	str	r2, [r3, #0]
	break;
 800af32:	e15b      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_LITE_MED_MIN_COUNT_RATE_RTN_MCPS:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_lite_med_min_count_rate_rtn_mcps;
 800af34:	693b      	ldr	r3, [r7, #16]
 800af36:	22be      	movs	r2, #190	; 0xbe
 800af38:	5a9b      	ldrh	r3, [r3, r2]
 800af3a:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800af3c:	687b      	ldr	r3, [r7, #4]
 800af3e:	601a      	str	r2, [r3, #0]
	break;
 800af40:	e154      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_LITE_SHORT_MIN_COUNT_RATE_RTN_MCPS:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_lite_short_min_count_rate_rtn_mcps;
 800af42:	693b      	ldr	r3, [r7, #16]
 800af44:	22c0      	movs	r2, #192	; 0xc0
 800af46:	5a9b      	ldrh	r3, [r3, r2]
 800af48:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800af4a:	687b      	ldr	r3, [r7, #4]
 800af4c:	601a      	str	r2, [r3, #0]
	break;
 800af4e:	e14d      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_LITE_SIGMA_EST_PULSE_WIDTH:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_lite_sigma_est_pulse_width_ns;
 800af50:	693b      	ldr	r3, [r7, #16]
 800af52:	22c2      	movs	r2, #194	; 0xc2
 800af54:	5c9b      	ldrb	r3, [r3, r2]
 800af56:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800af58:	687b      	ldr	r3, [r7, #4]
 800af5a:	601a      	str	r2, [r3, #0]
	break;
 800af5c:	e146      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_LITE_SIGMA_EST_AMB_WIDTH_NS:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_lite_sigma_est_amb_width_ns;
 800af5e:	693b      	ldr	r3, [r7, #16]
 800af60:	22c3      	movs	r2, #195	; 0xc3
 800af62:	5c9b      	ldrb	r3, [r3, r2]
 800af64:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800af66:	687b      	ldr	r3, [r7, #4]
 800af68:	601a      	str	r2, [r3, #0]
	break;
 800af6a:	e13f      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_LITE_SIGMA_REF_MM:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_lite_sigma_ref_mm;
 800af6c:	693b      	ldr	r3, [r7, #16]
 800af6e:	22c4      	movs	r2, #196	; 0xc4
 800af70:	5c9b      	ldrb	r3, [r3, r2]
 800af72:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800af74:	687b      	ldr	r3, [r7, #4]
 800af76:	601a      	str	r2, [r3, #0]
	break;
 800af78:	e138      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_LITE_RIT_MULT:
		*ptuning_parm_value =
				(int32_t)pdev->xtalk_cfg.crosstalk_range_ignore_threshold_mult;
 800af7a:	693a      	ldr	r2, [r7, #16]
 800af7c:	23a0      	movs	r3, #160	; 0xa0
 800af7e:	005b      	lsls	r3, r3, #1
 800af80:	5cd3      	ldrb	r3, [r2, r3]
 800af82:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800af84:	687b      	ldr	r3, [r7, #4]
 800af86:	601a      	str	r2, [r3, #0]
	break;
 800af88:	e130      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_LITE_SEED_CONFIG:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_lite_seed_cfg ;
 800af8a:	693b      	ldr	r3, [r7, #16]
 800af8c:	22c5      	movs	r2, #197	; 0xc5
 800af8e:	5c9b      	ldrb	r3, [r3, r2]
 800af90:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800af92:	687b      	ldr	r3, [r7, #4]
 800af94:	601a      	str	r2, [r3, #0]
	break;
 800af96:	e129      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_LITE_QUANTIFIER:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_lite_quantifier;
 800af98:	693b      	ldr	r3, [r7, #16]
 800af9a:	22c7      	movs	r2, #199	; 0xc7
 800af9c:	5c9b      	ldrb	r3, [r3, r2]
 800af9e:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800afa0:	687b      	ldr	r3, [r7, #4]
 800afa2:	601a      	str	r2, [r3, #0]
	break;
 800afa4:	e122      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_LITE_FIRST_ORDER_SELECT:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_lite_first_order_select;
 800afa6:	693b      	ldr	r3, [r7, #16]
 800afa8:	22c8      	movs	r2, #200	; 0xc8
 800afaa:	5c9b      	ldrb	r3, [r3, r2]
 800afac:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800afae:	687b      	ldr	r3, [r7, #4]
 800afb0:	601a      	str	r2, [r3, #0]
	break;
 800afb2:	e11b      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_LITE_XTALK_MARGIN_KCPS:
		*ptuning_parm_value =
				(int32_t)pdev->xtalk_cfg.lite_mode_crosstalk_margin_kcps;
 800afb4:	693a      	ldr	r2, [r7, #16]
 800afb6:	239f      	movs	r3, #159	; 0x9f
 800afb8:	005b      	lsls	r3, r3, #1
 800afba:	5ed3      	ldrsh	r3, [r2, r3]
 800afbc:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800afbe:	687b      	ldr	r3, [r7, #4]
 800afc0:	601a      	str	r2, [r3, #0]
	break;
 800afc2:	e113      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_INITIAL_PHASE_RTN_LITE_LONG_RANGE:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_init_phase_rtn_lite_long;
 800afc4:	693b      	ldr	r3, [r7, #16]
 800afc6:	22aa      	movs	r2, #170	; 0xaa
 800afc8:	5c9b      	ldrb	r3, [r3, r2]
 800afca:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800afcc:	687b      	ldr	r3, [r7, #4]
 800afce:	601a      	str	r2, [r3, #0]
	break;
 800afd0:	e10c      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_INITIAL_PHASE_RTN_LITE_MED_RANGE:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_init_phase_rtn_lite_med;
 800afd2:	693b      	ldr	r3, [r7, #16]
 800afd4:	22ab      	movs	r2, #171	; 0xab
 800afd6:	5c9b      	ldrb	r3, [r3, r2]
 800afd8:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800afda:	687b      	ldr	r3, [r7, #4]
 800afdc:	601a      	str	r2, [r3, #0]
	break;
 800afde:	e105      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_INITIAL_PHASE_RTN_LITE_SHORT_RANGE:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_init_phase_rtn_lite_short;
 800afe0:	693b      	ldr	r3, [r7, #16]
 800afe2:	22ac      	movs	r2, #172	; 0xac
 800afe4:	5c9b      	ldrb	r3, [r3, r2]
 800afe6:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800afe8:	687b      	ldr	r3, [r7, #4]
 800afea:	601a      	str	r2, [r3, #0]
	break;
 800afec:	e0fe      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_INITIAL_PHASE_REF_LITE_LONG_RANGE:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_init_phase_ref_lite_long;
 800afee:	693b      	ldr	r3, [r7, #16]
 800aff0:	22ad      	movs	r2, #173	; 0xad
 800aff2:	5c9b      	ldrb	r3, [r3, r2]
 800aff4:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800aff6:	687b      	ldr	r3, [r7, #4]
 800aff8:	601a      	str	r2, [r3, #0]
	break;
 800affa:	e0f7      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_INITIAL_PHASE_REF_LITE_MED_RANGE:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_init_phase_ref_lite_med;
 800affc:	693b      	ldr	r3, [r7, #16]
 800affe:	22ae      	movs	r2, #174	; 0xae
 800b000:	5c9b      	ldrb	r3, [r3, r2]
 800b002:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800b004:	687b      	ldr	r3, [r7, #4]
 800b006:	601a      	str	r2, [r3, #0]
	break;
 800b008:	e0f0      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_INITIAL_PHASE_REF_LITE_SHORT_RANGE:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_init_phase_ref_lite_short;
 800b00a:	693b      	ldr	r3, [r7, #16]
 800b00c:	22af      	movs	r2, #175	; 0xaf
 800b00e:	5c9b      	ldrb	r3, [r3, r2]
 800b010:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800b012:	687b      	ldr	r3, [r7, #4]
 800b014:	601a      	str	r2, [r3, #0]
	break;
 800b016:	e0e9      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_TIMED_SEED_CONFIG:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_timed_seed_cfg;
 800b018:	693b      	ldr	r3, [r7, #16]
 800b01a:	22c6      	movs	r2, #198	; 0xc6
 800b01c:	5c9b      	ldrb	r3, [r3, r2]
 800b01e:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800b020:	687b      	ldr	r3, [r7, #4]
 800b022:	601a      	str	r2, [r3, #0]
	break;
 800b024:	e0e2      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_VHV_LOOPBOUND:
		*ptuning_parm_value =
				(int32_t)pdev->stat_nvm.vhv_config__timeout_macrop_loop_bound;
 800b026:	693a      	ldr	r2, [r7, #16]
 800b028:	23b0      	movs	r3, #176	; 0xb0
 800b02a:	005b      	lsls	r3, r3, #1
 800b02c:	5cd3      	ldrb	r3, [r2, r3]
 800b02e:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800b030:	687b      	ldr	r3, [r7, #4]
 800b032:	601a      	str	r2, [r3, #0]
	break;
 800b034:	e0da      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_REFSPADCHAR_DEVICE_TEST_MODE:
		*ptuning_parm_value =
				(int32_t)pdev->refspadchar.device_test_mode;
 800b036:	693a      	ldr	r2, [r7, #16]
 800b038:	2388      	movs	r3, #136	; 0x88
 800b03a:	005b      	lsls	r3, r3, #1
 800b03c:	5cd3      	ldrb	r3, [r2, r3]
 800b03e:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800b040:	687b      	ldr	r3, [r7, #4]
 800b042:	601a      	str	r2, [r3, #0]
	break;
 800b044:	e0d2      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_REFSPADCHAR_VCSEL_PERIOD:
		*ptuning_parm_value =
				(int32_t)pdev->refspadchar.vcsel_period;
 800b046:	693a      	ldr	r2, [r7, #16]
 800b048:	2312      	movs	r3, #18
 800b04a:	33ff      	adds	r3, #255	; 0xff
 800b04c:	5cd3      	ldrb	r3, [r2, r3]
 800b04e:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800b050:	687b      	ldr	r3, [r7, #4]
 800b052:	601a      	str	r2, [r3, #0]
	break;
 800b054:	e0ca      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_REFSPADCHAR_PHASECAL_TIMEOUT_US:
		*ptuning_parm_value =
				(int32_t)pdev->refspadchar.timeout_us;
 800b056:	693a      	ldr	r2, [r7, #16]
 800b058:	238a      	movs	r3, #138	; 0x8a
 800b05a:	005b      	lsls	r3, r3, #1
 800b05c:	58d3      	ldr	r3, [r2, r3]
 800b05e:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800b060:	687b      	ldr	r3, [r7, #4]
 800b062:	601a      	str	r2, [r3, #0]
	break;
 800b064:	e0c2      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_REFSPADCHAR_TARGET_COUNT_RATE_MCPS:
		*ptuning_parm_value =
				(int32_t)pdev->refspadchar.target_count_rate_mcps;
 800b066:	693a      	ldr	r2, [r7, #16]
 800b068:	238c      	movs	r3, #140	; 0x8c
 800b06a:	005b      	lsls	r3, r3, #1
 800b06c:	5ad3      	ldrh	r3, [r2, r3]
 800b06e:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800b070:	687b      	ldr	r3, [r7, #4]
 800b072:	601a      	str	r2, [r3, #0]
	break;
 800b074:	e0ba      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_REFSPADCHAR_MIN_COUNTRATE_LIMIT_MCPS:
		*ptuning_parm_value =
				(int32_t)pdev->refspadchar.min_count_rate_limit_mcps;
 800b076:	693a      	ldr	r2, [r7, #16]
 800b078:	238d      	movs	r3, #141	; 0x8d
 800b07a:	005b      	lsls	r3, r3, #1
 800b07c:	5ad3      	ldrh	r3, [r2, r3]
 800b07e:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800b080:	687b      	ldr	r3, [r7, #4]
 800b082:	601a      	str	r2, [r3, #0]
	break;
 800b084:	e0b2      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_REFSPADCHAR_MAX_COUNTRATE_LIMIT_MCPS:
		*ptuning_parm_value =
				(int32_t)pdev->refspadchar.max_count_rate_limit_mcps;
 800b086:	693a      	ldr	r2, [r7, #16]
 800b088:	238e      	movs	r3, #142	; 0x8e
 800b08a:	005b      	lsls	r3, r3, #1
 800b08c:	5ad3      	ldrh	r3, [r2, r3]
 800b08e:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800b090:	687b      	ldr	r3, [r7, #4]
 800b092:	601a      	str	r2, [r3, #0]
	break;
 800b094:	e0aa      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_OFFSET_CAL_DSS_RATE_MCPS:
		*ptuning_parm_value =
				(int32_t)pdev->offsetcal_cfg.dss_config__target_total_rate_mcps;;
 800b096:	693a      	ldr	r2, [r7, #16]
 800b098:	23a2      	movs	r3, #162	; 0xa2
 800b09a:	005b      	lsls	r3, r3, #1
 800b09c:	5ad3      	ldrh	r3, [r2, r3]
 800b09e:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800b0a0:	687b      	ldr	r3, [r7, #4]
 800b0a2:	601a      	str	r2, [r3, #0]
	break;
 800b0a4:	e0a2      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_OFFSET_CAL_PHASECAL_TIMEOUT_US:
		*ptuning_parm_value =
				(int32_t)pdev->offsetcal_cfg.phasecal_config_timeout_us;
 800b0a6:	693a      	ldr	r2, [r7, #16]
 800b0a8:	23a4      	movs	r3, #164	; 0xa4
 800b0aa:	005b      	lsls	r3, r3, #1
 800b0ac:	58d3      	ldr	r3, [r2, r3]
 800b0ae:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800b0b0:	687b      	ldr	r3, [r7, #4]
 800b0b2:	601a      	str	r2, [r3, #0]
	break;
 800b0b4:	e09a      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_OFFSET_CAL_MM_TIMEOUT_US:
		*ptuning_parm_value =
				(int32_t)pdev->offsetcal_cfg.mm_config_timeout_us;
 800b0b6:	693a      	ldr	r2, [r7, #16]
 800b0b8:	23a8      	movs	r3, #168	; 0xa8
 800b0ba:	005b      	lsls	r3, r3, #1
 800b0bc:	58d3      	ldr	r3, [r2, r3]
 800b0be:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800b0c0:	687b      	ldr	r3, [r7, #4]
 800b0c2:	601a      	str	r2, [r3, #0]
	break;
 800b0c4:	e092      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_OFFSET_CAL_RANGE_TIMEOUT_US:
		*ptuning_parm_value =
				(int32_t)pdev->offsetcal_cfg.range_config_timeout_us;
 800b0c6:	693a      	ldr	r2, [r7, #16]
 800b0c8:	23a6      	movs	r3, #166	; 0xa6
 800b0ca:	005b      	lsls	r3, r3, #1
 800b0cc:	58d3      	ldr	r3, [r2, r3]
 800b0ce:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800b0d0:	687b      	ldr	r3, [r7, #4]
 800b0d2:	601a      	str	r2, [r3, #0]
	break;
 800b0d4:	e08a      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_OFFSET_CAL_PRE_SAMPLES:
		*ptuning_parm_value =
				(int32_t)pdev->offsetcal_cfg.pre_num_of_samples;
 800b0d6:	693a      	ldr	r2, [r7, #16]
 800b0d8:	23aa      	movs	r3, #170	; 0xaa
 800b0da:	005b      	lsls	r3, r3, #1
 800b0dc:	5cd3      	ldrb	r3, [r2, r3]
 800b0de:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800b0e0:	687b      	ldr	r3, [r7, #4]
 800b0e2:	601a      	str	r2, [r3, #0]
	break;
 800b0e4:	e082      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_OFFSET_CAL_MM1_SAMPLES:
		*ptuning_parm_value =
			(int32_t)pdev->offsetcal_cfg.mm1_num_of_samples;
 800b0e6:	693a      	ldr	r2, [r7, #16]
 800b0e8:	2356      	movs	r3, #86	; 0x56
 800b0ea:	33ff      	adds	r3, #255	; 0xff
 800b0ec:	5cd3      	ldrb	r3, [r2, r3]
 800b0ee:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800b0f0:	687b      	ldr	r3, [r7, #4]
 800b0f2:	601a      	str	r2, [r3, #0]
	break;
 800b0f4:	e07a      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_OFFSET_CAL_MM2_SAMPLES:
		*ptuning_parm_value =
				(int32_t)pdev->offsetcal_cfg.mm2_num_of_samples;
 800b0f6:	693a      	ldr	r2, [r7, #16]
 800b0f8:	23ab      	movs	r3, #171	; 0xab
 800b0fa:	005b      	lsls	r3, r3, #1
 800b0fc:	5cd3      	ldrb	r3, [r2, r3]
 800b0fe:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800b100:	687b      	ldr	r3, [r7, #4]
 800b102:	601a      	str	r2, [r3, #0]
	break;
 800b104:	e072      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_SPADMAP_VCSEL_PERIOD:
		*ptuning_parm_value =
				(int32_t)pdev->ssc_cfg.vcsel_period;
 800b106:	693a      	ldr	r2, [r7, #16]
 800b108:	2322      	movs	r3, #34	; 0x22
 800b10a:	33ff      	adds	r3, #255	; 0xff
 800b10c:	5cd3      	ldrb	r3, [r2, r3]
 800b10e:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800b110:	687b      	ldr	r3, [r7, #4]
 800b112:	601a      	str	r2, [r3, #0]
	break;
 800b114:	e06a      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_SPADMAP_VCSEL_START:
		*ptuning_parm_value =
				(int32_t)pdev->ssc_cfg.vcsel_start;
 800b116:	693a      	ldr	r2, [r7, #16]
 800b118:	2391      	movs	r3, #145	; 0x91
 800b11a:	005b      	lsls	r3, r3, #1
 800b11c:	5cd3      	ldrb	r3, [r2, r3]
 800b11e:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800b120:	687b      	ldr	r3, [r7, #4]
 800b122:	601a      	str	r2, [r3, #0]
	break;
 800b124:	e062      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_SPADMAP_RATE_LIMIT_MCPS:
		*ptuning_parm_value =
				(int32_t)pdev->ssc_cfg.rate_limit_mcps;
 800b126:	693a      	ldr	r2, [r7, #16]
 800b128:	2394      	movs	r3, #148	; 0x94
 800b12a:	005b      	lsls	r3, r3, #1
 800b12c:	5ad3      	ldrh	r3, [r2, r3]
 800b12e:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800b130:	687b      	ldr	r3, [r7, #4]
 800b132:	601a      	str	r2, [r3, #0]
	break;
 800b134:	e05a      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_LITE_DSS_CONFIG_TARGET_TOTAL_RATE_MCPS:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_dss_target_lite_mcps;
 800b136:	693b      	ldr	r3, [r7, #16]
 800b138:	22ca      	movs	r2, #202	; 0xca
 800b13a:	5a9b      	ldrh	r3, [r3, r2]
 800b13c:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800b13e:	687b      	ldr	r3, [r7, #4]
 800b140:	601a      	str	r2, [r3, #0]
	break;
 800b142:	e053      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_TIMED_DSS_CONFIG_TARGET_TOTAL_RATE_MCPS:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_dss_target_timed_mcps;
 800b144:	693b      	ldr	r3, [r7, #16]
 800b146:	22cc      	movs	r2, #204	; 0xcc
 800b148:	5a9b      	ldrh	r3, [r3, r2]
 800b14a:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800b14c:	687b      	ldr	r3, [r7, #4]
 800b14e:	601a      	str	r2, [r3, #0]
	break;
 800b150:	e04c      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_LITE_PHASECAL_CONFIG_TIMEOUT_US:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_phasecal_timeout_lite_us;
 800b152:	693b      	ldr	r3, [r7, #16]
 800b154:	22d0      	movs	r2, #208	; 0xd0
 800b156:	589b      	ldr	r3, [r3, r2]
 800b158:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800b15a:	687b      	ldr	r3, [r7, #4]
 800b15c:	601a      	str	r2, [r3, #0]
	break;
 800b15e:	e045      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_TIMED_PHASECAL_CONFIG_TIMEOUT_US:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_phasecal_timeout_timed_us;
 800b160:	693b      	ldr	r3, [r7, #16]
 800b162:	22d4      	movs	r2, #212	; 0xd4
 800b164:	589b      	ldr	r3, [r3, r2]
 800b166:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800b168:	687b      	ldr	r3, [r7, #4]
 800b16a:	601a      	str	r2, [r3, #0]
	break;
 800b16c:	e03e      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_LITE_MM_CONFIG_TIMEOUT_US:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_mm_timeout_lite_us;
 800b16e:	693b      	ldr	r3, [r7, #16]
 800b170:	22d8      	movs	r2, #216	; 0xd8
 800b172:	589b      	ldr	r3, [r3, r2]
 800b174:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800b176:	687b      	ldr	r3, [r7, #4]
 800b178:	601a      	str	r2, [r3, #0]
	break;
 800b17a:	e037      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_TIMED_MM_CONFIG_TIMEOUT_US:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_mm_timeout_timed_us;
 800b17c:	693b      	ldr	r3, [r7, #16]
 800b17e:	22dc      	movs	r2, #220	; 0xdc
 800b180:	589b      	ldr	r3, [r3, r2]
 800b182:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800b184:	687b      	ldr	r3, [r7, #4]
 800b186:	601a      	str	r2, [r3, #0]
	break;
 800b188:	e030      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_LITE_RANGE_CONFIG_TIMEOUT_US:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_range_timeout_lite_us;
 800b18a:	693b      	ldr	r3, [r7, #16]
 800b18c:	22e4      	movs	r2, #228	; 0xe4
 800b18e:	589b      	ldr	r3, [r3, r2]
 800b190:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800b192:	687b      	ldr	r3, [r7, #4]
 800b194:	601a      	str	r2, [r3, #0]
	break;
 800b196:	e029      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_TIMED_RANGE_CONFIG_TIMEOUT_US:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_range_timeout_timed_us;
 800b198:	693b      	ldr	r3, [r7, #16]
 800b19a:	22e8      	movs	r2, #232	; 0xe8
 800b19c:	589b      	ldr	r3, [r3, r2]
 800b19e:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800b1a0:	687b      	ldr	r3, [r7, #4]
 800b1a2:	601a      	str	r2, [r3, #0]
	break;
 800b1a4:	e022      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_LOWPOWERAUTO_VHV_LOOP_BOUND:
		*ptuning_parm_value =
				(int32_t)pdev->low_power_auto_data.vhv_loop_bound;
 800b1a6:	693a      	ldr	r2, [r7, #16]
 800b1a8:	23b9      	movs	r3, #185	; 0xb9
 800b1aa:	009b      	lsls	r3, r3, #2
 800b1ac:	5cd3      	ldrb	r3, [r2, r3]
 800b1ae:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800b1b0:	687b      	ldr	r3, [r7, #4]
 800b1b2:	601a      	str	r2, [r3, #0]
	break;
 800b1b4:	e01a      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_LOWPOWERAUTO_MM_CONFIG_TIMEOUT_US:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_mm_timeout_lpa_us;
 800b1b6:	693b      	ldr	r3, [r7, #16]
 800b1b8:	22e0      	movs	r2, #224	; 0xe0
 800b1ba:	589b      	ldr	r3, [r3, r2]
 800b1bc:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800b1be:	687b      	ldr	r3, [r7, #4]
 800b1c0:	601a      	str	r2, [r3, #0]
	break;
 800b1c2:	e013      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
	case VL53L1_TUNINGPARM_LOWPOWERAUTO_RANGE_CONFIG_TIMEOUT_US:
		*ptuning_parm_value =
				(int32_t)pdev->tuning_parms.tp_range_timeout_lpa_us;
 800b1c4:	693b      	ldr	r3, [r7, #16]
 800b1c6:	22ec      	movs	r2, #236	; 0xec
 800b1c8:	589b      	ldr	r3, [r3, r2]
 800b1ca:	001a      	movs	r2, r3
		*ptuning_parm_value =
 800b1cc:	687b      	ldr	r3, [r7, #4]
 800b1ce:	601a      	str	r2, [r3, #0]
	break;
 800b1d0:	e00c      	b.n	800b1ec <VL53L1_get_tuning_parm+0x398>
 800b1d2:	46c0      	nop			; (mov r8, r8)
 800b1d4:	ffff8000 	.word	0xffff8000
 800b1d8:	080150d0 	.word	0x080150d0


	default:
		*ptuning_parm_value = 0x7FFFFFFF;
 800b1dc:	687b      	ldr	r3, [r7, #4]
 800b1de:	4a07      	ldr	r2, [pc, #28]	; (800b1fc <VL53L1_get_tuning_parm+0x3a8>)
 800b1e0:	601a      	str	r2, [r3, #0]
		status = VL53L1_ERROR_INVALID_PARAMS;
 800b1e2:	2317      	movs	r3, #23
 800b1e4:	18fb      	adds	r3, r7, r3
 800b1e6:	22fc      	movs	r2, #252	; 0xfc
 800b1e8:	701a      	strb	r2, [r3, #0]
	break;
 800b1ea:	46c0      	nop			; (mov r8, r8)

	}

	LOG_FUNCTION_END(status);

	return status;
 800b1ec:	2317      	movs	r3, #23
 800b1ee:	18fb      	adds	r3, r7, r3
 800b1f0:	781b      	ldrb	r3, [r3, #0]
 800b1f2:	b25b      	sxtb	r3, r3
}
 800b1f4:	0018      	movs	r0, r3
 800b1f6:	46bd      	mov	sp, r7
 800b1f8:	b006      	add	sp, #24
 800b1fa:	bd80      	pop	{r7, pc}
 800b1fc:	7fffffff 	.word	0x7fffffff

0800b200 <VL53L1_init_refspadchar_config_struct>:


#ifndef VL53L1_NOCALIB
VL53L1_Error VL53L1_init_refspadchar_config_struct(
	VL53L1_refspadchar_config_t   *pdata)
{
 800b200:	b580      	push	{r7, lr}
 800b202:	b084      	sub	sp, #16
 800b204:	af00      	add	r7, sp, #0
 800b206:	6078      	str	r0, [r7, #4]
	/*
	 * Initializes Ref SPAD Char data structures preset mode
	 */

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 800b208:	210f      	movs	r1, #15
 800b20a:	187b      	adds	r3, r7, r1
 800b20c:	2200      	movs	r2, #0
 800b20e:	701a      	strb	r2, [r3, #0]
	 * target_count_rate_mcps    = 0x0A00 - 9.7 -> 20.0 Mcps
	 * min_count_rate_limit_mcps = 0x0500 - 9.7 -> 10.0 Mcps
	 * max_count_rate_limit_mcps = 0x1400 - 9.7 -> 40.0 Mcps
	 */

	pdata->device_test_mode =
 800b210:	687b      	ldr	r3, [r7, #4]
 800b212:	2208      	movs	r2, #8
 800b214:	701a      	strb	r2, [r3, #0]
			VL53L1_TUNINGPARM_REFSPADCHAR_DEVICE_TEST_MODE_DEFAULT;
	pdata->vcsel_period              =
 800b216:	687b      	ldr	r3, [r7, #4]
 800b218:	220b      	movs	r2, #11
 800b21a:	705a      	strb	r2, [r3, #1]
			VL53L1_TUNINGPARM_REFSPADCHAR_VCSEL_PERIOD_DEFAULT;
	pdata->timeout_us                =
 800b21c:	687b      	ldr	r3, [r7, #4]
 800b21e:	22fa      	movs	r2, #250	; 0xfa
 800b220:	0092      	lsls	r2, r2, #2
 800b222:	605a      	str	r2, [r3, #4]
			VL53L1_TUNINGPARM_REFSPADCHAR_PHASECAL_TIMEOUT_US_DEFAULT;
	pdata->target_count_rate_mcps    =
 800b224:	687b      	ldr	r3, [r7, #4]
 800b226:	22a0      	movs	r2, #160	; 0xa0
 800b228:	0112      	lsls	r2, r2, #4
 800b22a:	811a      	strh	r2, [r3, #8]
			VL53L1_TUNINGPARM_REFSPADCHAR_TARGET_COUNT_RATE_MCPS_DEFAULT;
	pdata->min_count_rate_limit_mcps =
 800b22c:	687b      	ldr	r3, [r7, #4]
 800b22e:	22a0      	movs	r2, #160	; 0xa0
 800b230:	00d2      	lsls	r2, r2, #3
 800b232:	815a      	strh	r2, [r3, #10]
			VL53L1_TUNINGPARM_REFSPADCHAR_MIN_COUNTRATE_LIMIT_MCPS_DEFAULT;
	pdata->max_count_rate_limit_mcps =
 800b234:	687b      	ldr	r3, [r7, #4]
 800b236:	22a0      	movs	r2, #160	; 0xa0
 800b238:	0152      	lsls	r2, r2, #5
 800b23a:	819a      	strh	r2, [r3, #12]
			VL53L1_TUNINGPARM_REFSPADCHAR_MAX_COUNTRATE_LIMIT_MCPS_DEFAULT;

	LOG_FUNCTION_END(status);

	return status;
 800b23c:	187b      	adds	r3, r7, r1
 800b23e:	781b      	ldrb	r3, [r3, #0]
 800b240:	b25b      	sxtb	r3, r3
}
 800b242:	0018      	movs	r0, r3
 800b244:	46bd      	mov	sp, r7
 800b246:	b004      	add	sp, #16
 800b248:	bd80      	pop	{r7, pc}
	...

0800b24c <VL53L1_init_ssc_config_struct>:


#ifndef VL53L1_NOCALIB
VL53L1_Error VL53L1_init_ssc_config_struct(
	VL53L1_ssc_config_t   *pdata)
{
 800b24c:	b580      	push	{r7, lr}
 800b24e:	b084      	sub	sp, #16
 800b250:	af00      	add	r7, sp, #0
 800b252:	6078      	str	r0, [r7, #4]
	/*
	 * Initializes SPAD Self Check (SSC) data structure
	 */

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 800b254:	210f      	movs	r1, #15
 800b256:	187b      	adds	r3, r7, r1
 800b258:	2200      	movs	r2, #0
 800b25a:	701a      	strb	r2, [r3, #0]
	/* SPAD Select Check Configuration */

	/* 0 - store RTN count rates
	 * 1 - store REF count rates
	 */
	pdata->array_select = VL53L1_DEVICESSCARRAY_RTN;
 800b25c:	687b      	ldr	r3, [r7, #4]
 800b25e:	2200      	movs	r2, #0
 800b260:	701a      	strb	r2, [r3, #0]

	/* VCSEL period register value  0x12 (18) -> 38 VCSEL clocks */
	pdata->vcsel_period =
 800b262:	687b      	ldr	r3, [r7, #4]
 800b264:	2212      	movs	r2, #18
 800b266:	705a      	strb	r2, [r3, #1]
			VL53L1_TUNINGPARM_SPADMAP_VCSEL_PERIOD_DEFAULT;

	/* VCSEL pulse start */
	pdata->vcsel_start  =
 800b268:	687b      	ldr	r3, [r7, #4]
 800b26a:	220f      	movs	r2, #15
 800b26c:	709a      	strb	r2, [r3, #2]
			VL53L1_TUNINGPARM_SPADMAP_VCSEL_START_DEFAULT;

	/* VCSEL pulse width */
	pdata->vcsel_width  = 0x02;
 800b26e:	687b      	ldr	r3, [r7, #4]
 800b270:	2202      	movs	r2, #2
 800b272:	70da      	strb	r2, [r3, #3]

	/* SSC timeout [us] */
	pdata->timeout_us   = 36000;
 800b274:	687b      	ldr	r3, [r7, #4]
 800b276:	4a06      	ldr	r2, [pc, #24]	; (800b290 <VL53L1_init_ssc_config_struct+0x44>)
 800b278:	605a      	str	r2, [r3, #4]

	/* SSC rate limit [Mcps]
	 * - 9.7 for VCSEL ON
	 * - 1.15 for VCSEL OFF
	 */
	pdata->rate_limit_mcps =
 800b27a:	687b      	ldr	r3, [r7, #4]
 800b27c:	220c      	movs	r2, #12
 800b27e:	811a      	strh	r2, [r3, #8]
			VL53L1_TUNINGPARM_SPADMAP_RATE_LIMIT_MCPS_DEFAULT;

	LOG_FUNCTION_END(status);

	return status;
 800b280:	187b      	adds	r3, r7, r1
 800b282:	781b      	ldrb	r3, [r3, #0]
 800b284:	b25b      	sxtb	r3, r3
}
 800b286:	0018      	movs	r0, r3
 800b288:	46bd      	mov	sp, r7
 800b28a:	b004      	add	sp, #16
 800b28c:	bd80      	pop	{r7, pc}
 800b28e:	46c0      	nop			; (mov r8, r8)
 800b290:	00008ca0 	.word	0x00008ca0

0800b294 <VL53L1_init_xtalk_config_struct>:


VL53L1_Error VL53L1_init_xtalk_config_struct(
	VL53L1_customer_nvm_managed_t *pnvm,
	VL53L1_xtalk_config_t   *pdata)
{
 800b294:	b580      	push	{r7, lr}
 800b296:	b084      	sub	sp, #16
 800b298:	af00      	add	r7, sp, #0
 800b29a:	6078      	str	r0, [r7, #4]
 800b29c:	6039      	str	r1, [r7, #0]
	/*
	 * Initializes Xtalk Config structure
	 */

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 800b29e:	230f      	movs	r3, #15
 800b2a0:	18fb      	adds	r3, r7, r3
 800b2a2:	2200      	movs	r2, #0
 800b2a4:	701a      	strb	r2, [r3, #0]
	 */

	/* Store xtalk data into golden copy */

	pdata->algo__crosstalk_compensation_plane_offset_kcps      =
		pnvm->algo__crosstalk_compensation_plane_offset_kcps;
 800b2a6:	687b      	ldr	r3, [r7, #4]
 800b2a8:	895b      	ldrh	r3, [r3, #10]
 800b2aa:	001a      	movs	r2, r3
	pdata->algo__crosstalk_compensation_plane_offset_kcps      =
 800b2ac:	683b      	ldr	r3, [r7, #0]
 800b2ae:	601a      	str	r2, [r3, #0]
	pdata->algo__crosstalk_compensation_x_plane_gradient_kcps  =
		pnvm->algo__crosstalk_compensation_x_plane_gradient_kcps;
 800b2b0:	687b      	ldr	r3, [r7, #4]
 800b2b2:	220c      	movs	r2, #12
 800b2b4:	5e9a      	ldrsh	r2, [r3, r2]
	pdata->algo__crosstalk_compensation_x_plane_gradient_kcps  =
 800b2b6:	683b      	ldr	r3, [r7, #0]
 800b2b8:	809a      	strh	r2, [r3, #4]
	pdata->algo__crosstalk_compensation_y_plane_gradient_kcps  =
		pnvm->algo__crosstalk_compensation_y_plane_gradient_kcps;
 800b2ba:	687b      	ldr	r3, [r7, #4]
 800b2bc:	220e      	movs	r2, #14
 800b2be:	5e9a      	ldrsh	r2, [r3, r2]
	pdata->algo__crosstalk_compensation_y_plane_gradient_kcps  =
 800b2c0:	683b      	ldr	r3, [r7, #0]
 800b2c2:	80da      	strh	r2, [r3, #6]

	/* Store NVM defaults for later use */

	pdata->nvm_default__crosstalk_compensation_plane_offset_kcps      =
		(uint32_t)pnvm->algo__crosstalk_compensation_plane_offset_kcps;
 800b2c4:	687b      	ldr	r3, [r7, #4]
 800b2c6:	895b      	ldrh	r3, [r3, #10]
 800b2c8:	001a      	movs	r2, r3
	pdata->nvm_default__crosstalk_compensation_plane_offset_kcps      =
 800b2ca:	683b      	ldr	r3, [r7, #0]
 800b2cc:	609a      	str	r2, [r3, #8]
	pdata->nvm_default__crosstalk_compensation_x_plane_gradient_kcps  =
		pnvm->algo__crosstalk_compensation_x_plane_gradient_kcps;
 800b2ce:	687b      	ldr	r3, [r7, #4]
 800b2d0:	220c      	movs	r2, #12
 800b2d2:	5e9a      	ldrsh	r2, [r3, r2]
	pdata->nvm_default__crosstalk_compensation_x_plane_gradient_kcps  =
 800b2d4:	683b      	ldr	r3, [r7, #0]
 800b2d6:	819a      	strh	r2, [r3, #12]
	pdata->nvm_default__crosstalk_compensation_y_plane_gradient_kcps  =
		pnvm->algo__crosstalk_compensation_y_plane_gradient_kcps;
 800b2d8:	687b      	ldr	r3, [r7, #4]
 800b2da:	220e      	movs	r2, #14
 800b2dc:	5e9a      	ldrsh	r2, [r3, r2]
	pdata->nvm_default__crosstalk_compensation_y_plane_gradient_kcps  =
 800b2de:	683b      	ldr	r3, [r7, #0]
 800b2e0:	81da      	strh	r2, [r3, #14]

	pdata->lite_mode_crosstalk_margin_kcps                     =
 800b2e2:	683b      	ldr	r3, [r7, #0]
 800b2e4:	2200      	movs	r2, #0
 800b2e6:	825a      	strh	r2, [r3, #18]
			VL53L1_TUNINGPARM_LITE_XTALK_MARGIN_KCPS_DEFAULT;

	/* Default for Range Ignore Threshold Mult = 2.0 */

	pdata->crosstalk_range_ignore_threshold_mult =
 800b2e8:	683b      	ldr	r3, [r7, #0]
 800b2ea:	2240      	movs	r2, #64	; 0x40
 800b2ec:	751a      	strb	r2, [r3, #20]
			VL53L1_TUNINGPARM_LITE_RIT_MULT_DEFAULT;

	if ((pdata->algo__crosstalk_compensation_plane_offset_kcps == 0x00)
 800b2ee:	683b      	ldr	r3, [r7, #0]
 800b2f0:	681b      	ldr	r3, [r3, #0]
 800b2f2:	2b00      	cmp	r3, #0
 800b2f4:	d10d      	bne.n	800b312 <VL53L1_init_xtalk_config_struct+0x7e>
		&& (pdata->algo__crosstalk_compensation_x_plane_gradient_kcps == 0x00)
 800b2f6:	683b      	ldr	r3, [r7, #0]
 800b2f8:	2204      	movs	r2, #4
 800b2fa:	5e9b      	ldrsh	r3, [r3, r2]
 800b2fc:	2b00      	cmp	r3, #0
 800b2fe:	d108      	bne.n	800b312 <VL53L1_init_xtalk_config_struct+0x7e>
		&& (pdata->algo__crosstalk_compensation_y_plane_gradient_kcps == 0x00))
 800b300:	683b      	ldr	r3, [r7, #0]
 800b302:	2206      	movs	r2, #6
 800b304:	5e9b      	ldrsh	r3, [r3, r2]
 800b306:	2b00      	cmp	r3, #0
 800b308:	d103      	bne.n	800b312 <VL53L1_init_xtalk_config_struct+0x7e>
		pdata->global_crosstalk_compensation_enable = 0x00;
 800b30a:	683b      	ldr	r3, [r7, #0]
 800b30c:	2200      	movs	r2, #0
 800b30e:	741a      	strb	r2, [r3, #16]
 800b310:	e002      	b.n	800b318 <VL53L1_init_xtalk_config_struct+0x84>
	else
		pdata->global_crosstalk_compensation_enable = 0x01;
 800b312:	683b      	ldr	r3, [r7, #0]
 800b314:	2201      	movs	r2, #1
 800b316:	741a      	strb	r2, [r3, #16]


	if ((status == VL53L1_ERROR_NONE) &&
 800b318:	230f      	movs	r3, #15
 800b31a:	18fb      	adds	r3, r7, r3
 800b31c:	781b      	ldrb	r3, [r3, #0]
 800b31e:	b25b      	sxtb	r3, r3
 800b320:	2b00      	cmp	r3, #0
 800b322:	d114      	bne.n	800b34e <VL53L1_init_xtalk_config_struct+0xba>
		(pdata->global_crosstalk_compensation_enable == 0x01)) {
 800b324:	683b      	ldr	r3, [r7, #0]
 800b326:	7c1b      	ldrb	r3, [r3, #16]
	if ((status == VL53L1_ERROR_NONE) &&
 800b328:	2b01      	cmp	r3, #1
 800b32a:	d110      	bne.n	800b34e <VL53L1_init_xtalk_config_struct+0xba>
		pdata->crosstalk_range_ignore_threshold_rate_mcps =
			VL53L1_calc_range_ignore_threshold(
 800b32c:	683b      	ldr	r3, [r7, #0]
 800b32e:	6818      	ldr	r0, [r3, #0]
 800b330:	683b      	ldr	r3, [r7, #0]
 800b332:	2104      	movs	r1, #4
 800b334:	5e59      	ldrsh	r1, [r3, r1]
 800b336:	683b      	ldr	r3, [r7, #0]
 800b338:	2206      	movs	r2, #6
 800b33a:	5e9a      	ldrsh	r2, [r3, r2]
 800b33c:	683b      	ldr	r3, [r7, #0]
 800b33e:	7d1b      	ldrb	r3, [r3, #20]
 800b340:	f001 f864 	bl	800c40c <VL53L1_calc_range_ignore_threshold>
 800b344:	0003      	movs	r3, r0
 800b346:	001a      	movs	r2, r3
		pdata->crosstalk_range_ignore_threshold_rate_mcps =
 800b348:	683b      	ldr	r3, [r7, #0]
 800b34a:	82da      	strh	r2, [r3, #22]
 800b34c:	e002      	b.n	800b354 <VL53L1_init_xtalk_config_struct+0xc0>
				pdata->algo__crosstalk_compensation_plane_offset_kcps,
				pdata->algo__crosstalk_compensation_x_plane_gradient_kcps,
				pdata->algo__crosstalk_compensation_y_plane_gradient_kcps,
				pdata->crosstalk_range_ignore_threshold_mult);
	} else {
		pdata->crosstalk_range_ignore_threshold_rate_mcps = 0;
 800b34e:	683b      	ldr	r3, [r7, #0]
 800b350:	2200      	movs	r2, #0
 800b352:	82da      	strh	r2, [r3, #22]
	}

	LOG_FUNCTION_END(status);

	return status;
 800b354:	230f      	movs	r3, #15
 800b356:	18fb      	adds	r3, r7, r3
 800b358:	781b      	ldrb	r3, [r3, #0]
 800b35a:	b25b      	sxtb	r3, r3
}
 800b35c:	0018      	movs	r0, r3
 800b35e:	46bd      	mov	sp, r7
 800b360:	b004      	add	sp, #16
 800b362:	bd80      	pop	{r7, pc}

0800b364 <VL53L1_init_offset_cal_config_struct>:

#ifndef VL53L1_NOCALIB
VL53L1_Error VL53L1_init_offset_cal_config_struct(
	VL53L1_offsetcal_config_t   *pdata)
{
 800b364:	b580      	push	{r7, lr}
 800b366:	b084      	sub	sp, #16
 800b368:	af00      	add	r7, sp, #0
 800b36a:	6078      	str	r0, [r7, #4]
	/*
	 * Initializes Offset Calibration Config structure
	 * - for use with VL53L1_run_offset_calibration()
	 */

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 800b36c:	210f      	movs	r1, #15
 800b36e:	187b      	adds	r3, r7, r1
 800b370:	2200      	movs	r2, #0
 800b372:	701a      	strb	r2, [r3, #0]

	LOG_FUNCTION_START("");

	/* Preset Timeout and DSS defaults */

	pdata->dss_config__target_total_rate_mcps          =
 800b374:	687b      	ldr	r3, [r7, #4]
 800b376:	22a0      	movs	r2, #160	; 0xa0
 800b378:	0112      	lsls	r2, r2, #4
 800b37a:	801a      	strh	r2, [r3, #0]
			VL53L1_TUNINGPARM_OFFSET_CAL_DSS_RATE_MCPS_DEFAULT;
	/* 20.0 Mcps */
	pdata->phasecal_config_timeout_us                  =
 800b37c:	687b      	ldr	r3, [r7, #4]
 800b37e:	22fa      	movs	r2, #250	; 0xfa
 800b380:	0092      	lsls	r2, r2, #2
 800b382:	605a      	str	r2, [r3, #4]
			VL53L1_TUNINGPARM_OFFSET_CAL_PHASECAL_TIMEOUT_US_DEFAULT;
	/* 1000 us */
	pdata->range_config_timeout_us                     =
 800b384:	687b      	ldr	r3, [r7, #4]
 800b386:	4a0a      	ldr	r2, [pc, #40]	; (800b3b0 <VL53L1_init_offset_cal_config_struct+0x4c>)
 800b388:	609a      	str	r2, [r3, #8]
			VL53L1_TUNINGPARM_OFFSET_CAL_RANGE_TIMEOUT_US_DEFAULT;
	/* 13000 us */
	pdata->mm_config_timeout_us                        =
 800b38a:	687b      	ldr	r3, [r7, #4]
 800b38c:	4a08      	ldr	r2, [pc, #32]	; (800b3b0 <VL53L1_init_offset_cal_config_struct+0x4c>)
 800b38e:	60da      	str	r2, [r3, #12]
			VL53L1_TUNINGPARM_OFFSET_CAL_MM_TIMEOUT_US_DEFAULT;
	/* 13000 us - Added as part of Patch_AddedOffsetCalMMTuningParm_11791 */

	/* Init number of averaged samples */

	pdata->pre_num_of_samples                          =
 800b390:	687b      	ldr	r3, [r7, #4]
 800b392:	2208      	movs	r2, #8
 800b394:	741a      	strb	r2, [r3, #16]
			VL53L1_TUNINGPARM_OFFSET_CAL_PRE_SAMPLES_DEFAULT;
	pdata->mm1_num_of_samples                          =
 800b396:	687b      	ldr	r3, [r7, #4]
 800b398:	2228      	movs	r2, #40	; 0x28
 800b39a:	745a      	strb	r2, [r3, #17]
			VL53L1_TUNINGPARM_OFFSET_CAL_MM1_SAMPLES_DEFAULT;
	pdata->mm2_num_of_samples                          =
 800b39c:	687b      	ldr	r3, [r7, #4]
 800b39e:	2209      	movs	r2, #9
 800b3a0:	749a      	strb	r2, [r3, #18]
			VL53L1_TUNINGPARM_OFFSET_CAL_MM2_SAMPLES_DEFAULT;

	LOG_FUNCTION_END(status);

	return status;
 800b3a2:	187b      	adds	r3, r7, r1
 800b3a4:	781b      	ldrb	r3, [r3, #0]
 800b3a6:	b25b      	sxtb	r3, r3
}
 800b3a8:	0018      	movs	r0, r3
 800b3aa:	46bd      	mov	sp, r7
 800b3ac:	b004      	add	sp, #16
 800b3ae:	bd80      	pop	{r7, pc}
 800b3b0:	000032c8 	.word	0x000032c8

0800b3b4 <VL53L1_init_tuning_parm_storage_struct>:
#endif

VL53L1_Error VL53L1_init_tuning_parm_storage_struct(
	VL53L1_tuning_parm_storage_t   *pdata)
{
 800b3b4:	b580      	push	{r7, lr}
 800b3b6:	b084      	sub	sp, #16
 800b3b8:	af00      	add	r7, sp, #0
 800b3ba:	6078      	str	r0, [r7, #4]
	/*
	 * Initializes  Tuning Param storage structure
	 */

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 800b3bc:	200f      	movs	r0, #15
 800b3be:	183b      	adds	r3, r7, r0
 800b3c0:	2200      	movs	r2, #0
 800b3c2:	701a      	strb	r2, [r3, #0]
	 *
	 * - Custom overwrite possible from vl53l1_set_tuning_parms()
	 * - via tuning file input
	 */

	pdata->tp_tuning_parm_version              =
 800b3c4:	687b      	ldr	r3, [r7, #4]
 800b3c6:	4a40      	ldr	r2, [pc, #256]	; (800b4c8 <VL53L1_init_tuning_parm_storage_struct+0x114>)
 800b3c8:	801a      	strh	r2, [r3, #0]
			VL53L1_TUNINGPARM_VERSION_DEFAULT;
	pdata->tp_tuning_parm_key_table_version    =
 800b3ca:	687b      	ldr	r3, [r7, #4]
 800b3cc:	4a3f      	ldr	r2, [pc, #252]	; (800b4cc <VL53L1_init_tuning_parm_storage_struct+0x118>)
 800b3ce:	805a      	strh	r2, [r3, #2]
			VL53L1_TUNINGPARM_KEY_TABLE_VERSION_DEFAULT;
	pdata->tp_tuning_parm_lld_version          =
 800b3d0:	687b      	ldr	r3, [r7, #4]
 800b3d2:	4a3f      	ldr	r2, [pc, #252]	; (800b4d0 <VL53L1_init_tuning_parm_storage_struct+0x11c>)
 800b3d4:	809a      	strh	r2, [r3, #4]
			VL53L1_TUNINGPARM_LLD_VERSION_DEFAULT;
	pdata->tp_init_phase_rtn_lite_long         =
 800b3d6:	687b      	ldr	r3, [r7, #4]
 800b3d8:	220e      	movs	r2, #14
 800b3da:	719a      	strb	r2, [r3, #6]
			VL53L1_TUNINGPARM_INITIAL_PHASE_RTN_LITE_LONG_RANGE_DEFAULT;
	pdata->tp_init_phase_rtn_lite_med          =
 800b3dc:	687b      	ldr	r3, [r7, #4]
 800b3de:	220a      	movs	r2, #10
 800b3e0:	71da      	strb	r2, [r3, #7]
			VL53L1_TUNINGPARM_INITIAL_PHASE_RTN_LITE_MED_RANGE_DEFAULT;
	pdata->tp_init_phase_rtn_lite_short        =
 800b3e2:	687b      	ldr	r3, [r7, #4]
 800b3e4:	2206      	movs	r2, #6
 800b3e6:	721a      	strb	r2, [r3, #8]
			VL53L1_TUNINGPARM_INITIAL_PHASE_RTN_LITE_SHORT_RANGE_DEFAULT;
	pdata->tp_init_phase_ref_lite_long         =
 800b3e8:	687b      	ldr	r3, [r7, #4]
 800b3ea:	220e      	movs	r2, #14
 800b3ec:	725a      	strb	r2, [r3, #9]
			VL53L1_TUNINGPARM_INITIAL_PHASE_REF_LITE_LONG_RANGE_DEFAULT;
	pdata->tp_init_phase_ref_lite_med          =
 800b3ee:	687b      	ldr	r3, [r7, #4]
 800b3f0:	220a      	movs	r2, #10
 800b3f2:	729a      	strb	r2, [r3, #10]
			VL53L1_TUNINGPARM_INITIAL_PHASE_REF_LITE_MED_RANGE_DEFAULT;
	pdata->tp_init_phase_ref_lite_short        =
 800b3f4:	687b      	ldr	r3, [r7, #4]
 800b3f6:	2206      	movs	r2, #6
 800b3f8:	72da      	strb	r2, [r3, #11]
			VL53L1_TUNINGPARM_INITIAL_PHASE_REF_LITE_SHORT_RANGE_DEFAULT;
	pdata->tp_consistency_lite_phase_tolerance =
 800b3fa:	687b      	ldr	r3, [r7, #4]
 800b3fc:	2202      	movs	r2, #2
 800b3fe:	731a      	strb	r2, [r3, #12]
			VL53L1_TUNINGPARM_CONSISTENCY_LITE_PHASE_TOLERANCE_DEFAULT;
	pdata->tp_phasecal_target                  =
 800b400:	687b      	ldr	r3, [r7, #4]
 800b402:	2221      	movs	r2, #33	; 0x21
 800b404:	735a      	strb	r2, [r3, #13]
			VL53L1_TUNINGPARM_PHASECAL_TARGET_DEFAULT;
	pdata->tp_cal_repeat_rate                  =
 800b406:	687b      	ldr	r3, [r7, #4]
 800b408:	2200      	movs	r2, #0
 800b40a:	81da      	strh	r2, [r3, #14]
			VL53L1_TUNINGPARM_LITE_CAL_REPEAT_RATE_DEFAULT;
	pdata->tp_lite_min_clip                    =
 800b40c:	687b      	ldr	r3, [r7, #4]
 800b40e:	2200      	movs	r2, #0
 800b410:	741a      	strb	r2, [r3, #16]
			VL53L1_TUNINGPARM_LITE_MIN_CLIP_MM_DEFAULT;
	pdata->tp_lite_long_sigma_thresh_mm        =
 800b412:	687b      	ldr	r3, [r7, #4]
 800b414:	22b4      	movs	r2, #180	; 0xb4
 800b416:	0052      	lsls	r2, r2, #1
 800b418:	825a      	strh	r2, [r3, #18]
			VL53L1_TUNINGPARM_LITE_LONG_SIGMA_THRESH_MM_DEFAULT;
	pdata->tp_lite_med_sigma_thresh_mm         =
 800b41a:	687b      	ldr	r3, [r7, #4]
 800b41c:	22b4      	movs	r2, #180	; 0xb4
 800b41e:	0052      	lsls	r2, r2, #1
 800b420:	829a      	strh	r2, [r3, #20]
			VL53L1_TUNINGPARM_LITE_MED_SIGMA_THRESH_MM_DEFAULT;
	pdata->tp_lite_short_sigma_thresh_mm       =
 800b422:	687b      	ldr	r3, [r7, #4]
 800b424:	22b4      	movs	r2, #180	; 0xb4
 800b426:	0052      	lsls	r2, r2, #1
 800b428:	82da      	strh	r2, [r3, #22]
			VL53L1_TUNINGPARM_LITE_SHORT_SIGMA_THRESH_MM_DEFAULT;
	pdata->tp_lite_long_min_count_rate_rtn_mcps  =
 800b42a:	687b      	ldr	r3, [r7, #4]
 800b42c:	22c0      	movs	r2, #192	; 0xc0
 800b42e:	831a      	strh	r2, [r3, #24]
			VL53L1_TUNINGPARM_LITE_LONG_MIN_COUNT_RATE_RTN_MCPS_DEFAULT;
	pdata->tp_lite_med_min_count_rate_rtn_mcps   =
 800b430:	687b      	ldr	r3, [r7, #4]
 800b432:	22c0      	movs	r2, #192	; 0xc0
 800b434:	835a      	strh	r2, [r3, #26]
			VL53L1_TUNINGPARM_LITE_MED_MIN_COUNT_RATE_RTN_MCPS_DEFAULT;
	pdata->tp_lite_short_min_count_rate_rtn_mcps =
 800b436:	687b      	ldr	r3, [r7, #4]
 800b438:	22c0      	movs	r2, #192	; 0xc0
 800b43a:	839a      	strh	r2, [r3, #28]
			VL53L1_TUNINGPARM_LITE_SHORT_MIN_COUNT_RATE_RTN_MCPS_DEFAULT;
	pdata->tp_lite_sigma_est_pulse_width_ns      =
 800b43c:	687b      	ldr	r3, [r7, #4]
 800b43e:	2208      	movs	r2, #8
 800b440:	779a      	strb	r2, [r3, #30]
			VL53L1_TUNINGPARM_LITE_SIGMA_EST_PULSE_WIDTH_DEFAULT;
	pdata->tp_lite_sigma_est_amb_width_ns        =
 800b442:	687b      	ldr	r3, [r7, #4]
 800b444:	2210      	movs	r2, #16
 800b446:	77da      	strb	r2, [r3, #31]
			VL53L1_TUNINGPARM_LITE_SIGMA_EST_AMB_WIDTH_NS_DEFAULT;
	pdata->tp_lite_sigma_ref_mm                  =
 800b448:	687b      	ldr	r3, [r7, #4]
 800b44a:	2220      	movs	r2, #32
 800b44c:	2101      	movs	r1, #1
 800b44e:	5499      	strb	r1, [r3, r2]
			VL53L1_TUNINGPARM_LITE_SIGMA_REF_MM_DEFAULT;
	pdata->tp_lite_seed_cfg                      =
 800b450:	687b      	ldr	r3, [r7, #4]
 800b452:	2221      	movs	r2, #33	; 0x21
 800b454:	2102      	movs	r1, #2
 800b456:	5499      	strb	r1, [r3, r2]
			VL53L1_TUNINGPARM_LITE_SEED_CONFIG_DEFAULT;
	pdata->tp_timed_seed_cfg                     =
 800b458:	687b      	ldr	r3, [r7, #4]
 800b45a:	2222      	movs	r2, #34	; 0x22
 800b45c:	2101      	movs	r1, #1
 800b45e:	5499      	strb	r1, [r3, r2]
			VL53L1_TUNINGPARM_TIMED_SEED_CONFIG_DEFAULT;
	pdata->tp_lite_quantifier                    =
 800b460:	687b      	ldr	r3, [r7, #4]
 800b462:	2223      	movs	r2, #35	; 0x23
 800b464:	2102      	movs	r1, #2
 800b466:	5499      	strb	r1, [r3, r2]
			VL53L1_TUNINGPARM_LITE_QUANTIFIER_DEFAULT;
	pdata->tp_lite_first_order_select            =
 800b468:	687b      	ldr	r3, [r7, #4]
 800b46a:	2224      	movs	r2, #36	; 0x24
 800b46c:	2100      	movs	r1, #0
 800b46e:	5499      	strb	r1, [r3, r2]
			VL53L1_TUNINGPARM_LITE_FIRST_ORDER_SELECT_DEFAULT;

	/* Preset Mode Configurations */
	/* - New parms added as part of Patch_TuningParmPresetModeAddition_11839 */

	pdata->tp_dss_target_lite_mcps               =
 800b470:	687b      	ldr	r3, [r7, #4]
 800b472:	22a0      	movs	r2, #160	; 0xa0
 800b474:	0112      	lsls	r2, r2, #4
 800b476:	84da      	strh	r2, [r3, #38]	; 0x26
			VL53L1_TUNINGPARM_LITE_DSS_CONFIG_TARGET_TOTAL_RATE_MCPS_DEFAULT;
	pdata->tp_dss_target_timed_mcps              =
 800b478:	687b      	ldr	r3, [r7, #4]
 800b47a:	22a0      	movs	r2, #160	; 0xa0
 800b47c:	0112      	lsls	r2, r2, #4
 800b47e:	851a      	strh	r2, [r3, #40]	; 0x28
			VL53L1_TUNINGPARM_TIMED_DSS_CONFIG_TARGET_TOTAL_RATE_MCPS_DEFAULT;
	pdata->tp_phasecal_timeout_lite_us           =
 800b480:	687b      	ldr	r3, [r7, #4]
 800b482:	4a14      	ldr	r2, [pc, #80]	; (800b4d4 <VL53L1_init_tuning_parm_storage_struct+0x120>)
 800b484:	62da      	str	r2, [r3, #44]	; 0x2c
			VL53L1_TUNINGPARM_LITE_PHASECAL_CONFIG_TIMEOUT_US;
	pdata->tp_phasecal_timeout_timed_us          =
 800b486:	687b      	ldr	r3, [r7, #4]
 800b488:	22fa      	movs	r2, #250	; 0xfa
 800b48a:	0092      	lsls	r2, r2, #2
 800b48c:	631a      	str	r2, [r3, #48]	; 0x30
			VL53L1_TUNINGPARM_TIMED_PHASECAL_CONFIG_TIMEOUT_US_DEFAULT;
	pdata->tp_mm_timeout_lite_us                 =
 800b48e:	687b      	ldr	r3, [r7, #4]
 800b490:	22fa      	movs	r2, #250	; 0xfa
 800b492:	00d2      	lsls	r2, r2, #3
 800b494:	635a      	str	r2, [r3, #52]	; 0x34
			VL53L1_TUNINGPARM_LITE_MM_CONFIG_TIMEOUT_US_DEFAULT;
	pdata->tp_mm_timeout_timed_us                =
 800b496:	687b      	ldr	r3, [r7, #4]
 800b498:	22fa      	movs	r2, #250	; 0xfa
 800b49a:	00d2      	lsls	r2, r2, #3
 800b49c:	639a      	str	r2, [r3, #56]	; 0x38
			VL53L1_TUNINGPARM_TIMED_MM_CONFIG_TIMEOUT_US_DEFAULT;
	pdata->tp_range_timeout_lite_us              =
 800b49e:	687b      	ldr	r3, [r7, #4]
 800b4a0:	4a0d      	ldr	r2, [pc, #52]	; (800b4d8 <VL53L1_init_tuning_parm_storage_struct+0x124>)
 800b4a2:	641a      	str	r2, [r3, #64]	; 0x40
			VL53L1_TUNINGPARM_LITE_RANGE_CONFIG_TIMEOUT_US_DEFAULT;
	pdata->tp_range_timeout_timed_us             =
 800b4a4:	687b      	ldr	r3, [r7, #4]
 800b4a6:	4a0d      	ldr	r2, [pc, #52]	; (800b4dc <VL53L1_init_tuning_parm_storage_struct+0x128>)
 800b4a8:	645a      	str	r2, [r3, #68]	; 0x44
			VL53L1_TUNINGPARM_TIMED_RANGE_CONFIG_TIMEOUT_US_DEFAULT;

	/* Added for Patch_LowPowerAutoMode */

	pdata->tp_mm_timeout_lpa_us =
 800b4aa:	687b      	ldr	r3, [r7, #4]
 800b4ac:	2201      	movs	r2, #1
 800b4ae:	63da      	str	r2, [r3, #60]	; 0x3c
			VL53L1_TUNINGPARM_LOWPOWERAUTO_MM_CONFIG_TIMEOUT_US_DEFAULT;
	pdata->tp_range_timeout_lpa_us =
 800b4b0:	687b      	ldr	r3, [r7, #4]
 800b4b2:	22fa      	movs	r2, #250	; 0xfa
 800b4b4:	0152      	lsls	r2, r2, #5
 800b4b6:	649a      	str	r2, [r3, #72]	; 0x48
			VL53L1_TUNINGPARM_LOWPOWERAUTO_RANGE_CONFIG_TIMEOUT_US_DEFAULT;


	LOG_FUNCTION_END(status);

	return status;
 800b4b8:	183b      	adds	r3, r7, r0
 800b4ba:	781b      	ldrb	r3, [r3, #0]
 800b4bc:	b25b      	sxtb	r3, r3
}
 800b4be:	0018      	movs	r0, r3
 800b4c0:	46bd      	mov	sp, r7
 800b4c2:	b004      	add	sp, #16
 800b4c4:	bd80      	pop	{r7, pc}
 800b4c6:	46c0      	nop			; (mov r8, r8)
 800b4c8:	ffff8003 	.word	0xffff8003
 800b4cc:	ffff8001 	.word	0xffff8001
 800b4d0:	ffff8041 	.word	0xffff8041
 800b4d4:	00008030 	.word	0x00008030
 800b4d8:	0000f618 	.word	0x0000f618
 800b4dc:	000032c8 	.word	0x000032c8

0800b4e0 <VL53L1_preset_mode_standard_ranging>:
	VL53L1_general_config_t   *pgeneral,
	VL53L1_timing_config_t    *ptiming,
	VL53L1_dynamic_config_t   *pdynamic,
	VL53L1_system_control_t   *psystem,
	VL53L1_tuning_parm_storage_t *ptuning_parms)
{
 800b4e0:	b580      	push	{r7, lr}
 800b4e2:	b086      	sub	sp, #24
 800b4e4:	af00      	add	r7, sp, #0
 800b4e6:	60f8      	str	r0, [r7, #12]
 800b4e8:	60b9      	str	r1, [r7, #8]
 800b4ea:	607a      	str	r2, [r7, #4]
 800b4ec:	603b      	str	r3, [r7, #0]
	 *  - back to back
	 *
	 *  PLEASE NOTE THE SETTINGS BELOW AT PROVISIONAL AND WILL CHANGE!
	 */

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 800b4ee:	2117      	movs	r1, #23
 800b4f0:	187b      	adds	r3, r7, r1
 800b4f2:	2200      	movs	r2, #0
 800b4f4:	701a      	strb	r2, [r3, #0]
	LOG_FUNCTION_START("");

	/* Static Configuration */

	/* dss_config__target_total_rate_mcps = 20.0 Mcps 9.7 fp */
	pstatic->dss_config__target_total_rate_mcps               = 0x0A00;
 800b4f6:	68fb      	ldr	r3, [r7, #12]
 800b4f8:	22a0      	movs	r2, #160	; 0xa0
 800b4fa:	0112      	lsls	r2, r2, #4
 800b4fc:	801a      	strh	r2, [r3, #0]
	pstatic->debug__ctrl                                      = 0x00;
 800b4fe:	68fb      	ldr	r3, [r7, #12]
 800b500:	2200      	movs	r2, #0
 800b502:	709a      	strb	r2, [r3, #2]
	pstatic->test_mode__ctrl                                  = 0x00;
 800b504:	68fb      	ldr	r3, [r7, #12]
 800b506:	2200      	movs	r2, #0
 800b508:	70da      	strb	r2, [r3, #3]
	pstatic->clk_gating__ctrl                                 = 0x00;
 800b50a:	68fb      	ldr	r3, [r7, #12]
 800b50c:	2200      	movs	r2, #0
 800b50e:	711a      	strb	r2, [r3, #4]
	pstatic->nvm_bist__ctrl                                   = 0x00;
 800b510:	68fb      	ldr	r3, [r7, #12]
 800b512:	2200      	movs	r2, #0
 800b514:	715a      	strb	r2, [r3, #5]
	pstatic->nvm_bist__num_nvm_words                          = 0x00;
 800b516:	68fb      	ldr	r3, [r7, #12]
 800b518:	2200      	movs	r2, #0
 800b51a:	719a      	strb	r2, [r3, #6]
	pstatic->nvm_bist__start_address                          = 0x00;
 800b51c:	68fb      	ldr	r3, [r7, #12]
 800b51e:	2200      	movs	r2, #0
 800b520:	71da      	strb	r2, [r3, #7]
	pstatic->host_if__status                                  = 0x00;
 800b522:	68fb      	ldr	r3, [r7, #12]
 800b524:	2200      	movs	r2, #0
 800b526:	721a      	strb	r2, [r3, #8]
	pstatic->pad_i2c_hv__config                               = 0x00;
 800b528:	68fb      	ldr	r3, [r7, #12]
 800b52a:	2200      	movs	r2, #0
 800b52c:	725a      	strb	r2, [r3, #9]
	pstatic->pad_i2c_hv__extsup_config                        = 0x00;
 800b52e:	68fb      	ldr	r3, [r7, #12]
 800b530:	2200      	movs	r2, #0
 800b532:	729a      	strb	r2, [r3, #10]

	/*
	 *  0 - gpio__extsup_hv
	 *  1 - gpio__vmodeint_hv
	 */
	pstatic->gpio_hv_pad__ctrl                                = 0x00;
 800b534:	68fb      	ldr	r3, [r7, #12]
 800b536:	2200      	movs	r2, #0
 800b538:	72da      	strb	r2, [r3, #11]
	 * Set interrupt active low
	 *
	 *  3:0 - gpio__mux_select_hv
	 *    4 - gpio__mux_active_high_hv
	 */
	pstatic->gpio_hv_mux__ctrl  = \
 800b53a:	68fb      	ldr	r3, [r7, #12]
 800b53c:	2211      	movs	r2, #17
 800b53e:	731a      	strb	r2, [r3, #12]
			VL53L1_DEVICEINTERRUPTPOLARITY_ACTIVE_LOW | \
			VL53L1_DEVICEGPIOMODE_OUTPUT_RANGE_AND_ERROR_INTERRUPTS;

	pstatic->gpio__tio_hv_status                              = 0x02;
 800b540:	68fb      	ldr	r3, [r7, #12]
 800b542:	2202      	movs	r2, #2
 800b544:	735a      	strb	r2, [r3, #13]
	pstatic->gpio__fio_hv_status                              = 0x00;
 800b546:	68fb      	ldr	r3, [r7, #12]
 800b548:	2200      	movs	r2, #0
 800b54a:	739a      	strb	r2, [r3, #14]
	pstatic->ana_config__spad_sel_pswidth                     = 0x02;
 800b54c:	68fb      	ldr	r3, [r7, #12]
 800b54e:	2202      	movs	r2, #2
 800b550:	73da      	strb	r2, [r3, #15]
	pstatic->ana_config__vcsel_pulse_width_offset             = 0x08;
 800b552:	68fb      	ldr	r3, [r7, #12]
 800b554:	2208      	movs	r2, #8
 800b556:	741a      	strb	r2, [r3, #16]
	pstatic->ana_config__fast_osc__config_ctrl                = 0x00;
 800b558:	68fb      	ldr	r3, [r7, #12]
 800b55a:	2200      	movs	r2, #0
 800b55c:	745a      	strb	r2, [r3, #17]

	pstatic->sigma_estimator__effective_pulse_width_ns        =
			ptuning_parms->tp_lite_sigma_est_pulse_width_ns;
 800b55e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b560:	7f9a      	ldrb	r2, [r3, #30]
	pstatic->sigma_estimator__effective_pulse_width_ns        =
 800b562:	68fb      	ldr	r3, [r7, #12]
 800b564:	749a      	strb	r2, [r3, #18]
	pstatic->sigma_estimator__effective_ambient_width_ns      =
			ptuning_parms->tp_lite_sigma_est_amb_width_ns;
 800b566:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b568:	7fda      	ldrb	r2, [r3, #31]
	pstatic->sigma_estimator__effective_ambient_width_ns      =
 800b56a:	68fb      	ldr	r3, [r7, #12]
 800b56c:	74da      	strb	r2, [r3, #19]
	pstatic->sigma_estimator__sigma_ref_mm                    =
			ptuning_parms->tp_lite_sigma_ref_mm;
 800b56e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b570:	2220      	movs	r2, #32
 800b572:	5c9a      	ldrb	r2, [r3, r2]
	pstatic->sigma_estimator__sigma_ref_mm                    =
 800b574:	68fb      	ldr	r3, [r7, #12]
 800b576:	751a      	strb	r2, [r3, #20]
	/* Minimum allowable value of 1 - 0 disables the feature */
	pstatic->algo__crosstalk_compensation_valid_height_mm     = 0x01;
 800b578:	68fb      	ldr	r3, [r7, #12]
 800b57a:	2201      	movs	r2, #1
 800b57c:	755a      	strb	r2, [r3, #21]
	pstatic->spare_host_config__static_config_spare_0         = 0x00;
 800b57e:	68fb      	ldr	r3, [r7, #12]
 800b580:	2200      	movs	r2, #0
 800b582:	759a      	strb	r2, [r3, #22]
	pstatic->spare_host_config__static_config_spare_1         = 0x00;
 800b584:	68fb      	ldr	r3, [r7, #12]
 800b586:	2200      	movs	r2, #0
 800b588:	75da      	strb	r2, [r3, #23]

	pstatic->algo__range_ignore_threshold_mcps                = 0x0000;
 800b58a:	68fb      	ldr	r3, [r7, #12]
 800b58c:	2200      	movs	r2, #0
 800b58e:	831a      	strh	r2, [r3, #24]

	/* set RIT distance to 20 mm */
	pstatic->algo__range_ignore_valid_height_mm               = 0xff;
 800b590:	68fb      	ldr	r3, [r7, #12]
 800b592:	22ff      	movs	r2, #255	; 0xff
 800b594:	769a      	strb	r2, [r3, #26]
	pstatic->algo__range_min_clip                             =
			ptuning_parms->tp_lite_min_clip;
 800b596:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b598:	7c1a      	ldrb	r2, [r3, #16]
	pstatic->algo__range_min_clip                             =
 800b59a:	68fb      	ldr	r3, [r7, #12]
 800b59c:	76da      	strb	r2, [r3, #27]
	 * Phase consistency check limit - format 1.3 fp
	 * 0x02 -> 0.25
	 * 0x08 -> 1.00
	 */
	pstatic->algo__consistency_check__tolerance               =
			ptuning_parms->tp_consistency_lite_phase_tolerance;
 800b59e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b5a0:	7b1a      	ldrb	r2, [r3, #12]
	pstatic->algo__consistency_check__tolerance               =
 800b5a2:	68fb      	ldr	r3, [r7, #12]
 800b5a4:	771a      	strb	r2, [r3, #28]
	pstatic->spare_host_config__static_config_spare_2         = 0x00;
 800b5a6:	68fb      	ldr	r3, [r7, #12]
 800b5a8:	2200      	movs	r2, #0
 800b5aa:	775a      	strb	r2, [r3, #29]
	pstatic->sd_config__reset_stages_msb                      = 0x00;
 800b5ac:	68fb      	ldr	r3, [r7, #12]
 800b5ae:	2200      	movs	r2, #0
 800b5b0:	779a      	strb	r2, [r3, #30]
	pstatic->sd_config__reset_stages_lsb                      = 0x00;
 800b5b2:	68fb      	ldr	r3, [r7, #12]
 800b5b4:	2200      	movs	r2, #0
 800b5b6:	77da      	strb	r2, [r3, #31]

	pgeneral->gph_config__stream_count_update_value           = 0x00;
 800b5b8:	68bb      	ldr	r3, [r7, #8]
 800b5ba:	2200      	movs	r2, #0
 800b5bc:	701a      	strb	r2, [r3, #0]
	pgeneral->global_config__stream_divider                   = 0x00;
 800b5be:	68bb      	ldr	r3, [r7, #8]
 800b5c0:	2200      	movs	r2, #0
 800b5c2:	705a      	strb	r2, [r3, #1]
	pgeneral->system__interrupt_config_gpio =
 800b5c4:	68bb      	ldr	r3, [r7, #8]
 800b5c6:	2220      	movs	r2, #32
 800b5c8:	709a      	strb	r2, [r3, #2]
			VL53L1_INTERRUPT_CONFIG_NEW_SAMPLE_READY;
	pgeneral->cal_config__vcsel_start                         = 0x0B;
 800b5ca:	68bb      	ldr	r3, [r7, #8]
 800b5cc:	220b      	movs	r2, #11
 800b5ce:	70da      	strb	r2, [r3, #3]
	 * 60 * 60 ranges (once every minute @ 60Hz)
	 * 0 - disables
	 * 12-bit value -> 4095 max
	 */
	pgeneral->cal_config__repeat_rate                         =
			ptuning_parms->tp_cal_repeat_rate;
 800b5d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b5d2:	89da      	ldrh	r2, [r3, #14]
	pgeneral->cal_config__repeat_rate                         =
 800b5d4:	68bb      	ldr	r3, [r7, #8]
 800b5d6:	809a      	strh	r2, [r3, #4]
	pgeneral->global_config__vcsel_width                      = 0x02;
 800b5d8:	68bb      	ldr	r3, [r7, #8]
 800b5da:	2202      	movs	r2, #2
 800b5dc:	719a      	strb	r2, [r3, #6]
	/* 13 macro periods gives a timeout of 1ms */
	pgeneral->phasecal_config__timeout_macrop                 = 0x0D;
 800b5de:	68bb      	ldr	r3, [r7, #8]
 800b5e0:	220d      	movs	r2, #13
 800b5e2:	71da      	strb	r2, [r3, #7]
	/* Phase cal target phase 2.0625 - 4.4 fp -> 0x21*/
	pgeneral->phasecal_config__target                         =
			ptuning_parms->tp_phasecal_target;
 800b5e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b5e6:	7b5a      	ldrb	r2, [r3, #13]
	pgeneral->phasecal_config__target                         =
 800b5e8:	68bb      	ldr	r3, [r7, #8]
 800b5ea:	721a      	strb	r2, [r3, #8]
	pgeneral->phasecal_config__override                       = 0x00;
 800b5ec:	68bb      	ldr	r3, [r7, #8]
 800b5ee:	2200      	movs	r2, #0
 800b5f0:	725a      	strb	r2, [r3, #9]
	pgeneral->dss_config__roi_mode_control =
 800b5f2:	68bb      	ldr	r3, [r7, #8]
 800b5f4:	2201      	movs	r2, #1
 800b5f6:	729a      	strb	r2, [r3, #10]
			VL53L1_DEVICEDSSMODE__TARGET_RATE;
	/* format for threshold high and low is 9.7 fp */
	pgeneral->system__thresh_rate_high                        = 0x0000;
 800b5f8:	68bb      	ldr	r3, [r7, #8]
 800b5fa:	2200      	movs	r2, #0
 800b5fc:	819a      	strh	r2, [r3, #12]
	pgeneral->system__thresh_rate_low                         = 0x0000;
 800b5fe:	68bb      	ldr	r3, [r7, #8]
 800b600:	2200      	movs	r2, #0
 800b602:	81da      	strh	r2, [r3, #14]
	/* The format for manual effective spads is 8.8 -> 0x8C00 = 140.00 */
	pgeneral->dss_config__manual_effective_spads_select       = 0x8C00;
 800b604:	68bb      	ldr	r3, [r7, #8]
 800b606:	4a45      	ldr	r2, [pc, #276]	; (800b71c <VL53L1_preset_mode_standard_ranging+0x23c>)
 800b608:	821a      	strh	r2, [r3, #16]
	pgeneral->dss_config__manual_block_select                 = 0x00;
 800b60a:	68bb      	ldr	r3, [r7, #8]
 800b60c:	2200      	movs	r2, #0
 800b60e:	749a      	strb	r2, [r3, #18]
	 * Aperture attenuation value - format 0.8
	 *
	 * Nominal:  5x   -> 0.200000 * 256 = 51 = 0x33
	 * Measured: 4.6x -> 0.217391 * 256 = 56 = 0x38
	 */
	pgeneral->dss_config__aperture_attenuation                = 0x38;
 800b610:	68bb      	ldr	r3, [r7, #8]
 800b612:	2238      	movs	r2, #56	; 0x38
 800b614:	74da      	strb	r2, [r3, #19]
	pgeneral->dss_config__max_spads_limit                     = 0xFF;
 800b616:	68bb      	ldr	r3, [r7, #8]
 800b618:	22ff      	movs	r2, #255	; 0xff
 800b61a:	751a      	strb	r2, [r3, #20]
	pgeneral->dss_config__min_spads_limit                     = 0x01;
 800b61c:	68bb      	ldr	r3, [r7, #8]
 800b61e:	2201      	movs	r2, #1
 800b620:	755a      	strb	r2, [r3, #21]

	/* Timing Configuration */

	/* Default timing of 2ms */
	ptiming->mm_config__timeout_macrop_a_hi                   = 0x00;
 800b622:	687b      	ldr	r3, [r7, #4]
 800b624:	2200      	movs	r2, #0
 800b626:	701a      	strb	r2, [r3, #0]
	ptiming->mm_config__timeout_macrop_a_lo                   = 0x1a;
 800b628:	687b      	ldr	r3, [r7, #4]
 800b62a:	221a      	movs	r2, #26
 800b62c:	705a      	strb	r2, [r3, #1]
	ptiming->mm_config__timeout_macrop_b_hi                   = 0x00;
 800b62e:	687b      	ldr	r3, [r7, #4]
 800b630:	2200      	movs	r2, #0
 800b632:	709a      	strb	r2, [r3, #2]
	ptiming->mm_config__timeout_macrop_b_lo                   = 0x20;
 800b634:	687b      	ldr	r3, [r7, #4]
 800b636:	2220      	movs	r2, #32
 800b638:	70da      	strb	r2, [r3, #3]
	/* Setup for 30ms default */
	ptiming->range_config__timeout_macrop_a_hi                = 0x01;
 800b63a:	687b      	ldr	r3, [r7, #4]
 800b63c:	2201      	movs	r2, #1
 800b63e:	711a      	strb	r2, [r3, #4]
	ptiming->range_config__timeout_macrop_a_lo                = 0xCC;
 800b640:	687b      	ldr	r3, [r7, #4]
 800b642:	22cc      	movs	r2, #204	; 0xcc
 800b644:	715a      	strb	r2, [r3, #5]
	/* register value 11 gives a 24 VCSEL period */
	ptiming->range_config__vcsel_period_a                     = 0x0B;
 800b646:	687b      	ldr	r3, [r7, #4]
 800b648:	220b      	movs	r2, #11
 800b64a:	719a      	strb	r2, [r3, #6]
	/* Setup for 30ms default */
	ptiming->range_config__timeout_macrop_b_hi                = 0x01;
 800b64c:	687b      	ldr	r3, [r7, #4]
 800b64e:	2201      	movs	r2, #1
 800b650:	71da      	strb	r2, [r3, #7]
	ptiming->range_config__timeout_macrop_b_lo                = 0xF5;
 800b652:	687b      	ldr	r3, [r7, #4]
 800b654:	22f5      	movs	r2, #245	; 0xf5
 800b656:	721a      	strb	r2, [r3, #8]
	/* register value  09 gives a 20 VCSEL period */
	ptiming->range_config__vcsel_period_b                     = 0x09;
 800b658:	687b      	ldr	r3, [r7, #4]
 800b65a:	2209      	movs	r2, #9
 800b65c:	725a      	strb	r2, [r3, #9]
	 *
	 * 0x003C -> 15.0 mm
	 * 0x0050 -> 20.0 mm
	 */
	ptiming->range_config__sigma_thresh                       =
			ptuning_parms->tp_lite_med_sigma_thresh_mm;
 800b65e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b660:	8a9a      	ldrh	r2, [r3, #20]
	ptiming->range_config__sigma_thresh                       =
 800b662:	687b      	ldr	r3, [r7, #4]
 800b664:	815a      	strh	r2, [r3, #10]
	 *  Rate Limit - format 9.7fp
	 *  0x0020 -> 0.250 Mcps
	 *  0x0080 -> 1.000 Mcps
	 */
	ptiming->range_config__min_count_rate_rtn_limit_mcps      =
			ptuning_parms->tp_lite_med_min_count_rate_rtn_mcps;
 800b666:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b668:	8b5a      	ldrh	r2, [r3, #26]
	ptiming->range_config__min_count_rate_rtn_limit_mcps      =
 800b66a:	687b      	ldr	r3, [r7, #4]
 800b66c:	819a      	strh	r2, [r3, #12]

	/* Phase limit register formats = 5.3
	 * low   = 0x08 ->  1.0
	 * high  = 0x78 -> 15.0 -> 3.0m
	 */
	ptiming->range_config__valid_phase_low                    = 0x08;
 800b66e:	687b      	ldr	r3, [r7, #4]
 800b670:	2208      	movs	r2, #8
 800b672:	739a      	strb	r2, [r3, #14]
	ptiming->range_config__valid_phase_high                   = 0x78;
 800b674:	687b      	ldr	r3, [r7, #4]
 800b676:	2278      	movs	r2, #120	; 0x78
 800b678:	73da      	strb	r2, [r3, #15]
	ptiming->system__intermeasurement_period                  = 0x00000000;
 800b67a:	687b      	ldr	r3, [r7, #4]
 800b67c:	2200      	movs	r2, #0
 800b67e:	611a      	str	r2, [r3, #16]
	ptiming->system__fractional_enable                        = 0x00;
 800b680:	687b      	ldr	r3, [r7, #4]
 800b682:	2200      	movs	r2, #0
 800b684:	751a      	strb	r2, [r3, #20]

	/* Dynamic Configuration */

	pdynamic->system__grouped_parameter_hold_0                 = 0x01;
 800b686:	683b      	ldr	r3, [r7, #0]
 800b688:	2201      	movs	r2, #1
 800b68a:	701a      	strb	r2, [r3, #0]

	pdynamic->system__thresh_high                              = 0x0000;
 800b68c:	683b      	ldr	r3, [r7, #0]
 800b68e:	2200      	movs	r2, #0
 800b690:	805a      	strh	r2, [r3, #2]
	pdynamic->system__thresh_low                               = 0x0000;
 800b692:	683b      	ldr	r3, [r7, #0]
 800b694:	2200      	movs	r2, #0
 800b696:	809a      	strh	r2, [r3, #4]
	pdynamic->system__enable_xtalk_per_quadrant                = 0x00;
 800b698:	683b      	ldr	r3, [r7, #0]
 800b69a:	2200      	movs	r2, #0
 800b69c:	719a      	strb	r2, [r3, #6]
	pdynamic->system__seed_config =
			ptuning_parms->tp_lite_seed_cfg;
 800b69e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b6a0:	2221      	movs	r2, #33	; 0x21
 800b6a2:	5c9a      	ldrb	r2, [r3, r2]
	pdynamic->system__seed_config =
 800b6a4:	683b      	ldr	r3, [r7, #0]
 800b6a6:	71da      	strb	r2, [r3, #7]

	/* Timing A */
	pdynamic->sd_config__woi_sd0                               = 0x0B;
 800b6a8:	683b      	ldr	r3, [r7, #0]
 800b6aa:	220b      	movs	r2, #11
 800b6ac:	721a      	strb	r2, [r3, #8]
	/* Timing B */
	pdynamic->sd_config__woi_sd1                               = 0x09;
 800b6ae:	683b      	ldr	r3, [r7, #0]
 800b6b0:	2209      	movs	r2, #9
 800b6b2:	725a      	strb	r2, [r3, #9]

	pdynamic->sd_config__initial_phase_sd0                     =
			ptuning_parms->tp_init_phase_rtn_lite_med;
 800b6b4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b6b6:	79da      	ldrb	r2, [r3, #7]
	pdynamic->sd_config__initial_phase_sd0                     =
 800b6b8:	683b      	ldr	r3, [r7, #0]
 800b6ba:	729a      	strb	r2, [r3, #10]
	pdynamic->sd_config__initial_phase_sd1                     =
			ptuning_parms->tp_init_phase_ref_lite_med;;
 800b6bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b6be:	7a9a      	ldrb	r2, [r3, #10]
	pdynamic->sd_config__initial_phase_sd1                     =
 800b6c0:	683b      	ldr	r3, [r7, #0]
 800b6c2:	72da      	strb	r2, [r3, #11]

	pdynamic->system__grouped_parameter_hold_1                 = 0x01;
 800b6c4:	683b      	ldr	r3, [r7, #0]
 800b6c6:	2201      	movs	r2, #1
 800b6c8:	731a      	strb	r2, [r3, #12]
	 *
	 *  Setting below 2nd order, Quantifier = 1024
	 */

	pdynamic->sd_config__first_order_select =
			ptuning_parms->tp_lite_first_order_select;
 800b6ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b6cc:	2224      	movs	r2, #36	; 0x24
 800b6ce:	5c9a      	ldrb	r2, [r3, r2]
	pdynamic->sd_config__first_order_select =
 800b6d0:	683b      	ldr	r3, [r7, #0]
 800b6d2:	735a      	strb	r2, [r3, #13]
	pdynamic->sd_config__quantifier         =
			ptuning_parms->tp_lite_quantifier;
 800b6d4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b6d6:	2223      	movs	r2, #35	; 0x23
 800b6d8:	5c9a      	ldrb	r2, [r3, r2]
	pdynamic->sd_config__quantifier         =
 800b6da:	683b      	ldr	r3, [r7, #0]
 800b6dc:	739a      	strb	r2, [r3, #14]

	/* Below defaults will be overwritten by zone_cfg
	 * Spad no = 199 (0xC7)
	 * Spad no =  63 (0x3F)
	 */
	pdynamic->roi_config__user_roi_centre_spad              = 0xC7;
 800b6de:	683b      	ldr	r3, [r7, #0]
 800b6e0:	22c7      	movs	r2, #199	; 0xc7
 800b6e2:	73da      	strb	r2, [r3, #15]
	/* 16x16 ROI */
	pdynamic->roi_config__user_roi_requested_global_xy_size = 0xFF;
 800b6e4:	683b      	ldr	r3, [r7, #0]
 800b6e6:	22ff      	movs	r2, #255	; 0xff
 800b6e8:	741a      	strb	r2, [r3, #16]


	pdynamic->system__sequence_config                          = \
 800b6ea:	683b      	ldr	r3, [r7, #0]
 800b6ec:	22db      	movs	r2, #219	; 0xdb
 800b6ee:	745a      	strb	r2, [r3, #17]
			VL53L1_SEQUENCE_DSS1_EN | \
			VL53L1_SEQUENCE_DSS2_EN | \
			VL53L1_SEQUENCE_MM2_EN | \
			VL53L1_SEQUENCE_RANGE_EN;

	pdynamic->system__grouped_parameter_hold                   = 0x02;
 800b6f0:	683b      	ldr	r3, [r7, #0]
 800b6f2:	2202      	movs	r2, #2
 800b6f4:	749a      	strb	r2, [r3, #18]

	/* System control */


	psystem->system__stream_count_ctrl                         = 0x00;
 800b6f6:	6a3b      	ldr	r3, [r7, #32]
 800b6f8:	2200      	movs	r2, #0
 800b6fa:	705a      	strb	r2, [r3, #1]
	psystem->firmware__enable                                  = 0x01;
 800b6fc:	6a3b      	ldr	r3, [r7, #32]
 800b6fe:	2201      	movs	r2, #1
 800b700:	709a      	strb	r2, [r3, #2]
	psystem->system__interrupt_clear                           = \
 800b702:	6a3b      	ldr	r3, [r7, #32]
 800b704:	2201      	movs	r2, #1
 800b706:	70da      	strb	r2, [r3, #3]
			VL53L1_CLEAR_RANGE_INT;

	psystem->system__mode_start                                = \
 800b708:	6a3b      	ldr	r3, [r7, #32]
 800b70a:	2221      	movs	r2, #33	; 0x21
 800b70c:	711a      	strb	r2, [r3, #4]
			VL53L1_DEVICEREADOUTMODE_SINGLE_SD | \
			VL53L1_DEVICEMEASUREMENTMODE_BACKTOBACK;

	LOG_FUNCTION_END(status);

	return status;
 800b70e:	187b      	adds	r3, r7, r1
 800b710:	781b      	ldrb	r3, [r3, #0]
 800b712:	b25b      	sxtb	r3, r3
}
 800b714:	0018      	movs	r0, r3
 800b716:	46bd      	mov	sp, r7
 800b718:	b006      	add	sp, #24
 800b71a:	bd80      	pop	{r7, pc}
 800b71c:	ffff8c00 	.word	0xffff8c00

0800b720 <VL53L1_preset_mode_standard_ranging_short_range>:
	VL53L1_general_config_t   *pgeneral,
	VL53L1_timing_config_t    *ptiming,
	VL53L1_dynamic_config_t   *pdynamic,
	VL53L1_system_control_t   *psystem,
	VL53L1_tuning_parm_storage_t *ptuning_parms)
{
 800b720:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b722:	b089      	sub	sp, #36	; 0x24
 800b724:	af02      	add	r7, sp, #8
 800b726:	60f8      	str	r0, [r7, #12]
 800b728:	60b9      	str	r1, [r7, #8]
 800b72a:	607a      	str	r2, [r7, #4]
 800b72c:	603b      	str	r3, [r7, #0]
	 * (up to 1.4 metres)
	 *
	 * PLEASE NOTE THE SETTINGS BELOW AT PROVISIONAL AND WILL CHANGE!
	 */

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 800b72e:	2617      	movs	r6, #23
 800b730:	19bb      	adds	r3, r7, r6
 800b732:	2200      	movs	r2, #0
 800b734:	701a      	strb	r2, [r3, #0]

	/* Call standard ranging configuration followed by
	 * overrides for the  short range configuration
	 */

	status = VL53L1_preset_mode_standard_ranging(
 800b736:	19bc      	adds	r4, r7, r6
 800b738:	683d      	ldr	r5, [r7, #0]
 800b73a:	687a      	ldr	r2, [r7, #4]
 800b73c:	68b9      	ldr	r1, [r7, #8]
 800b73e:	68f8      	ldr	r0, [r7, #12]
 800b740:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b742:	9301      	str	r3, [sp, #4]
 800b744:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b746:	9300      	str	r3, [sp, #0]
 800b748:	002b      	movs	r3, r5
 800b74a:	f7ff fec9 	bl	800b4e0 <VL53L1_preset_mode_standard_ranging>
 800b74e:	0003      	movs	r3, r0
 800b750:	7023      	strb	r3, [r4, #0]
		psystem,
		ptuning_parms);

	/* now override standard ranging specific registers */

	if (status == VL53L1_ERROR_NONE) {
 800b752:	19bb      	adds	r3, r7, r6
 800b754:	781b      	ldrb	r3, [r3, #0]
 800b756:	b25b      	sxtb	r3, r3
 800b758:	2b00      	cmp	r3, #0
 800b75a:	d121      	bne.n	800b7a0 <VL53L1_preset_mode_standard_ranging_short_range+0x80>
		 * min_count_rate_rtn_limit_mcps = 0x0080 ->  9.7fp ->  1.0 Mcps
		 * valid_phase_low               = 0x08 -> 5.3fp -> 1.0
		 * valid_phase_high              = 0x38 -> 5.3fp -> 7.0 -> 1.4m
		 */

		ptiming->range_config__vcsel_period_a                = 0x07;
 800b75c:	687b      	ldr	r3, [r7, #4]
 800b75e:	2207      	movs	r2, #7
 800b760:	719a      	strb	r2, [r3, #6]
		ptiming->range_config__vcsel_period_b                = 0x05;
 800b762:	687b      	ldr	r3, [r7, #4]
 800b764:	2205      	movs	r2, #5
 800b766:	725a      	strb	r2, [r3, #9]
		ptiming->range_config__sigma_thresh                  =
				ptuning_parms->tp_lite_short_sigma_thresh_mm;
 800b768:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b76a:	8ada      	ldrh	r2, [r3, #22]
		ptiming->range_config__sigma_thresh                  =
 800b76c:	687b      	ldr	r3, [r7, #4]
 800b76e:	815a      	strh	r2, [r3, #10]
		ptiming->range_config__min_count_rate_rtn_limit_mcps =
				ptuning_parms->tp_lite_short_min_count_rate_rtn_mcps;
 800b770:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b772:	8b9a      	ldrh	r2, [r3, #28]
		ptiming->range_config__min_count_rate_rtn_limit_mcps =
 800b774:	687b      	ldr	r3, [r7, #4]
 800b776:	819a      	strh	r2, [r3, #12]
		ptiming->range_config__valid_phase_low               = 0x08;
 800b778:	687b      	ldr	r3, [r7, #4]
 800b77a:	2208      	movs	r2, #8
 800b77c:	739a      	strb	r2, [r3, #14]
		ptiming->range_config__valid_phase_high              = 0x38;
 800b77e:	687b      	ldr	r3, [r7, #4]
 800b780:	2238      	movs	r2, #56	; 0x38
 800b782:	73da      	strb	r2, [r3, #15]
		/* Dynamic Configuration
		 * SD0 -> Timing A
		 * SD1 -> Timing B
		 */

		pdynamic->sd_config__woi_sd0                         = 0x07;
 800b784:	683b      	ldr	r3, [r7, #0]
 800b786:	2207      	movs	r2, #7
 800b788:	721a      	strb	r2, [r3, #8]
		pdynamic->sd_config__woi_sd1                         = 0x05;
 800b78a:	683b      	ldr	r3, [r7, #0]
 800b78c:	2205      	movs	r2, #5
 800b78e:	725a      	strb	r2, [r3, #9]
		pdynamic->sd_config__initial_phase_sd0               =
				ptuning_parms->tp_init_phase_rtn_lite_short;
 800b790:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b792:	7a1a      	ldrb	r2, [r3, #8]
		pdynamic->sd_config__initial_phase_sd0               =
 800b794:	683b      	ldr	r3, [r7, #0]
 800b796:	729a      	strb	r2, [r3, #10]
		pdynamic->sd_config__initial_phase_sd1               =
				ptuning_parms->tp_init_phase_ref_lite_short;
 800b798:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b79a:	7ada      	ldrb	r2, [r3, #11]
		pdynamic->sd_config__initial_phase_sd1               =
 800b79c:	683b      	ldr	r3, [r7, #0]
 800b79e:	72da      	strb	r2, [r3, #11]
	}

	LOG_FUNCTION_END(status);

	return status;
 800b7a0:	2317      	movs	r3, #23
 800b7a2:	18fb      	adds	r3, r7, r3
 800b7a4:	781b      	ldrb	r3, [r3, #0]
 800b7a6:	b25b      	sxtb	r3, r3
}
 800b7a8:	0018      	movs	r0, r3
 800b7aa:	46bd      	mov	sp, r7
 800b7ac:	b007      	add	sp, #28
 800b7ae:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800b7b0 <VL53L1_preset_mode_standard_ranging_long_range>:
	VL53L1_general_config_t   *pgeneral,
	VL53L1_timing_config_t    *ptiming,
	VL53L1_dynamic_config_t   *pdynamic,
	VL53L1_system_control_t   *psystem,
	VL53L1_tuning_parm_storage_t *ptuning_parms)
{
 800b7b0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b7b2:	b089      	sub	sp, #36	; 0x24
 800b7b4:	af02      	add	r7, sp, #8
 800b7b6:	60f8      	str	r0, [r7, #12]
 800b7b8:	60b9      	str	r1, [r7, #8]
 800b7ba:	607a      	str	r2, [r7, #4]
 800b7bc:	603b      	str	r3, [r7, #0]
	 * (up to 4.8 metres)
	 *
	 *  PLEASE NOTE THE SETTINGS BELOW AT PROVISIONAL AND WILL CHANGE!
	 */

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 800b7be:	2617      	movs	r6, #23
 800b7c0:	19bb      	adds	r3, r7, r6
 800b7c2:	2200      	movs	r2, #0
 800b7c4:	701a      	strb	r2, [r3, #0]

	/* Call standard ranging configuration with
	 * overrides for long range configuration
	 */

	status = VL53L1_preset_mode_standard_ranging(
 800b7c6:	19bc      	adds	r4, r7, r6
 800b7c8:	683d      	ldr	r5, [r7, #0]
 800b7ca:	687a      	ldr	r2, [r7, #4]
 800b7cc:	68b9      	ldr	r1, [r7, #8]
 800b7ce:	68f8      	ldr	r0, [r7, #12]
 800b7d0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b7d2:	9301      	str	r3, [sp, #4]
 800b7d4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b7d6:	9300      	str	r3, [sp, #0]
 800b7d8:	002b      	movs	r3, r5
 800b7da:	f7ff fe81 	bl	800b4e0 <VL53L1_preset_mode_standard_ranging>
 800b7de:	0003      	movs	r3, r0
 800b7e0:	7023      	strb	r3, [r4, #0]
		psystem,
		ptuning_parms);

	/* now override standard ranging specific registers */

	if (status == VL53L1_ERROR_NONE) {
 800b7e2:	19bb      	adds	r3, r7, r6
 800b7e4:	781b      	ldrb	r3, [r3, #0]
 800b7e6:	b25b      	sxtb	r3, r3
 800b7e8:	2b00      	cmp	r3, #0
 800b7ea:	d121      	bne.n	800b830 <VL53L1_preset_mode_standard_ranging_long_range+0x80>
		 * min_count_rate_rtn_limit_mcps = 0x0080 ->  9.7fp ->  1.0 Mcps
		 * valid_phase_low               = 0x08 -> 5.3fp ->  1.0
		 * valid_phase_high              = 0xB8 -> 5.3fp -> 23.0 -> 4.6m
		 */

		ptiming->range_config__vcsel_period_a                = 0x0F;
 800b7ec:	687b      	ldr	r3, [r7, #4]
 800b7ee:	220f      	movs	r2, #15
 800b7f0:	719a      	strb	r2, [r3, #6]
		ptiming->range_config__vcsel_period_b                = 0x0D;
 800b7f2:	687b      	ldr	r3, [r7, #4]
 800b7f4:	220d      	movs	r2, #13
 800b7f6:	725a      	strb	r2, [r3, #9]
		ptiming->range_config__sigma_thresh                  =
				ptuning_parms->tp_lite_long_sigma_thresh_mm;
 800b7f8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b7fa:	8a5a      	ldrh	r2, [r3, #18]
		ptiming->range_config__sigma_thresh                  =
 800b7fc:	687b      	ldr	r3, [r7, #4]
 800b7fe:	815a      	strh	r2, [r3, #10]
		ptiming->range_config__min_count_rate_rtn_limit_mcps =
				ptuning_parms->tp_lite_long_min_count_rate_rtn_mcps;
 800b800:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b802:	8b1a      	ldrh	r2, [r3, #24]
		ptiming->range_config__min_count_rate_rtn_limit_mcps =
 800b804:	687b      	ldr	r3, [r7, #4]
 800b806:	819a      	strh	r2, [r3, #12]
		ptiming->range_config__valid_phase_low               = 0x08;
 800b808:	687b      	ldr	r3, [r7, #4]
 800b80a:	2208      	movs	r2, #8
 800b80c:	739a      	strb	r2, [r3, #14]
		ptiming->range_config__valid_phase_high              = 0xB8;
 800b80e:	687b      	ldr	r3, [r7, #4]
 800b810:	22b8      	movs	r2, #184	; 0xb8
 800b812:	73da      	strb	r2, [r3, #15]
		/* Dynamic Configuration
		 * SD0 -> Timing A
		 * SD1 -> Timing B
		 */

		pdynamic->sd_config__woi_sd0                         = 0x0F;
 800b814:	683b      	ldr	r3, [r7, #0]
 800b816:	220f      	movs	r2, #15
 800b818:	721a      	strb	r2, [r3, #8]
		pdynamic->sd_config__woi_sd1                         = 0x0D;
 800b81a:	683b      	ldr	r3, [r7, #0]
 800b81c:	220d      	movs	r2, #13
 800b81e:	725a      	strb	r2, [r3, #9]
		pdynamic->sd_config__initial_phase_sd0               =
				ptuning_parms->tp_init_phase_rtn_lite_long;
 800b820:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b822:	799a      	ldrb	r2, [r3, #6]
		pdynamic->sd_config__initial_phase_sd0               =
 800b824:	683b      	ldr	r3, [r7, #0]
 800b826:	729a      	strb	r2, [r3, #10]
		pdynamic->sd_config__initial_phase_sd1               =
				ptuning_parms->tp_init_phase_ref_lite_long;
 800b828:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b82a:	7a5a      	ldrb	r2, [r3, #9]
		pdynamic->sd_config__initial_phase_sd1               =
 800b82c:	683b      	ldr	r3, [r7, #0]
 800b82e:	72da      	strb	r2, [r3, #11]
	}

	LOG_FUNCTION_END(status);

	return status;
 800b830:	2317      	movs	r3, #23
 800b832:	18fb      	adds	r3, r7, r3
 800b834:	781b      	ldrb	r3, [r3, #0]
 800b836:	b25b      	sxtb	r3, r3
}
 800b838:	0018      	movs	r0, r3
 800b83a:	46bd      	mov	sp, r7
 800b83c:	b007      	add	sp, #28
 800b83e:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800b840 <VL53L1_preset_mode_standard_ranging_mm1_cal>:
	VL53L1_general_config_t   *pgeneral,
	VL53L1_timing_config_t    *ptiming,
	VL53L1_dynamic_config_t   *pdynamic,
	VL53L1_system_control_t   *psystem,
	VL53L1_tuning_parm_storage_t *ptuning_parms)
{
 800b840:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b842:	b089      	sub	sp, #36	; 0x24
 800b844:	af02      	add	r7, sp, #8
 800b846:	60f8      	str	r0, [r7, #12]
 800b848:	60b9      	str	r1, [r7, #8]
 800b84a:	607a      	str	r2, [r7, #4]
 800b84c:	603b      	str	r3, [r7, #0]
	 * VL53L1_DEVICEPRESETMODE_STANDARD_RANGING_MM1_CAL
	 *
	 * PLEASE NOTE THE SETTINGS BELOW AT PROVISIONAL AND WILL CHANGE!
	 */

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 800b84e:	2617      	movs	r6, #23
 800b850:	19bb      	adds	r3, r7, r6
 800b852:	2200      	movs	r2, #0
 800b854:	701a      	strb	r2, [r3, #0]

	/* Call standard ranging configuration with
	 * overrides for long range configuration
	 */

	status = VL53L1_preset_mode_standard_ranging(
 800b856:	19bc      	adds	r4, r7, r6
 800b858:	683d      	ldr	r5, [r7, #0]
 800b85a:	687a      	ldr	r2, [r7, #4]
 800b85c:	68b9      	ldr	r1, [r7, #8]
 800b85e:	68f8      	ldr	r0, [r7, #12]
 800b860:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b862:	9301      	str	r3, [sp, #4]
 800b864:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b866:	9300      	str	r3, [sp, #0]
 800b868:	002b      	movs	r3, r5
 800b86a:	f7ff fe39 	bl	800b4e0 <VL53L1_preset_mode_standard_ranging>
 800b86e:	0003      	movs	r3, r0
 800b870:	7023      	strb	r3, [r4, #0]
		psystem,
		ptuning_parms);

	/* now override standard ranging specific registers */

	if (status == VL53L1_ERROR_NONE) {
 800b872:	19bb      	adds	r3, r7, r6
 800b874:	781b      	ldrb	r3, [r3, #0]
 800b876:	b25b      	sxtb	r3, r3
 800b878:	2b00      	cmp	r3, #0
 800b87a:	d105      	bne.n	800b888 <VL53L1_preset_mode_standard_ranging_mm1_cal+0x48>

		pgeneral->dss_config__roi_mode_control =
 800b87c:	68bb      	ldr	r3, [r7, #8]
 800b87e:	2202      	movs	r2, #2
 800b880:	729a      	strb	r2, [r3, #10]
				VL53L1_DEVICEDSSMODE__REQUESTED_EFFFECTIVE_SPADS;

		pdynamic->system__sequence_config  = \
 800b882:	683b      	ldr	r3, [r7, #0]
 800b884:	223b      	movs	r2, #59	; 0x3b
 800b886:	745a      	strb	r2, [r3, #17]
				VL53L1_SEQUENCE_MM1_EN;
	}

	LOG_FUNCTION_END(status);

	return status;
 800b888:	2317      	movs	r3, #23
 800b88a:	18fb      	adds	r3, r7, r3
 800b88c:	781b      	ldrb	r3, [r3, #0]
 800b88e:	b25b      	sxtb	r3, r3
}
 800b890:	0018      	movs	r0, r3
 800b892:	46bd      	mov	sp, r7
 800b894:	b007      	add	sp, #28
 800b896:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800b898 <VL53L1_preset_mode_standard_ranging_mm2_cal>:
	VL53L1_general_config_t   *pgeneral,
	VL53L1_timing_config_t    *ptiming,
	VL53L1_dynamic_config_t   *pdynamic,
	VL53L1_system_control_t   *psystem,
	VL53L1_tuning_parm_storage_t *ptuning_parms)
{
 800b898:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b89a:	b089      	sub	sp, #36	; 0x24
 800b89c:	af02      	add	r7, sp, #8
 800b89e:	60f8      	str	r0, [r7, #12]
 800b8a0:	60b9      	str	r1, [r7, #8]
 800b8a2:	607a      	str	r2, [r7, #4]
 800b8a4:	603b      	str	r3, [r7, #0]
	 * VL53L1_DEVICEPRESETMODE_STANDARD_RANGING_MM2_CAL
	 *
	 * PLEASE NOTE THE SETTINGS BELOW AT PROVISIONAL AND WILL CHANGE!
	 */

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 800b8a6:	2617      	movs	r6, #23
 800b8a8:	19bb      	adds	r3, r7, r6
 800b8aa:	2200      	movs	r2, #0
 800b8ac:	701a      	strb	r2, [r3, #0]

	/* Call standard ranging configuration with
	 * overrides for long range configuration
	 */

	status = VL53L1_preset_mode_standard_ranging(
 800b8ae:	19bc      	adds	r4, r7, r6
 800b8b0:	683d      	ldr	r5, [r7, #0]
 800b8b2:	687a      	ldr	r2, [r7, #4]
 800b8b4:	68b9      	ldr	r1, [r7, #8]
 800b8b6:	68f8      	ldr	r0, [r7, #12]
 800b8b8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b8ba:	9301      	str	r3, [sp, #4]
 800b8bc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b8be:	9300      	str	r3, [sp, #0]
 800b8c0:	002b      	movs	r3, r5
 800b8c2:	f7ff fe0d 	bl	800b4e0 <VL53L1_preset_mode_standard_ranging>
 800b8c6:	0003      	movs	r3, r0
 800b8c8:	7023      	strb	r3, [r4, #0]
		psystem,
		ptuning_parms);

	/* now override standard ranging specific registers */

	if (status == VL53L1_ERROR_NONE) {
 800b8ca:	19bb      	adds	r3, r7, r6
 800b8cc:	781b      	ldrb	r3, [r3, #0]
 800b8ce:	b25b      	sxtb	r3, r3
 800b8d0:	2b00      	cmp	r3, #0
 800b8d2:	d105      	bne.n	800b8e0 <VL53L1_preset_mode_standard_ranging_mm2_cal+0x48>

		pgeneral->dss_config__roi_mode_control =
 800b8d4:	68bb      	ldr	r3, [r7, #8]
 800b8d6:	2202      	movs	r2, #2
 800b8d8:	729a      	strb	r2, [r3, #10]
				VL53L1_DEVICEDSSMODE__REQUESTED_EFFFECTIVE_SPADS;

		pdynamic->system__sequence_config  = \
 800b8da:	683b      	ldr	r3, [r7, #0]
 800b8dc:	225b      	movs	r2, #91	; 0x5b
 800b8de:	745a      	strb	r2, [r3, #17]
				VL53L1_SEQUENCE_MM2_EN;
	}

	LOG_FUNCTION_END(status);

	return status;
 800b8e0:	2317      	movs	r3, #23
 800b8e2:	18fb      	adds	r3, r7, r3
 800b8e4:	781b      	ldrb	r3, [r3, #0]
 800b8e6:	b25b      	sxtb	r3, r3
}
 800b8e8:	0018      	movs	r0, r3
 800b8ea:	46bd      	mov	sp, r7
 800b8ec:	b007      	add	sp, #28
 800b8ee:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800b8f0 <VL53L1_preset_mode_timed_ranging>:
	VL53L1_general_config_t   *pgeneral,
	VL53L1_timing_config_t    *ptiming,
	VL53L1_dynamic_config_t   *pdynamic,
	VL53L1_system_control_t   *psystem,
	VL53L1_tuning_parm_storage_t *ptuning_parms)
{
 800b8f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b8f2:	b089      	sub	sp, #36	; 0x24
 800b8f4:	af02      	add	r7, sp, #8
 800b8f6:	60f8      	str	r0, [r7, #12]
 800b8f8:	60b9      	str	r1, [r7, #8]
 800b8fa:	607a      	str	r2, [r7, #4]
 800b8fc:	603b      	str	r3, [r7, #0]
	*  - timed
	*
	*  PLEASE NOTE THE SETTINGS BELOW AT PROVISIONAL AND WILL CHANGE!
	*/

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 800b8fe:	2617      	movs	r6, #23
 800b900:	19bb      	adds	r3, r7, r6
 800b902:	2200      	movs	r2, #0
 800b904:	701a      	strb	r2, [r3, #0]

	LOG_FUNCTION_START("");

	/* Call standard ranging configuration */

	status = VL53L1_preset_mode_standard_ranging(
 800b906:	19bc      	adds	r4, r7, r6
 800b908:	683d      	ldr	r5, [r7, #0]
 800b90a:	687a      	ldr	r2, [r7, #4]
 800b90c:	68b9      	ldr	r1, [r7, #8]
 800b90e:	68f8      	ldr	r0, [r7, #12]
 800b910:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b912:	9301      	str	r3, [sp, #4]
 800b914:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b916:	9300      	str	r3, [sp, #0]
 800b918:	002b      	movs	r3, r5
 800b91a:	f7ff fde1 	bl	800b4e0 <VL53L1_preset_mode_standard_ranging>
 800b91e:	0003      	movs	r3, r0
 800b920:	7023      	strb	r3, [r4, #0]
					psystem,
					ptuning_parms);

	/* now override standard ranging specific registers */

	if (status == VL53L1_ERROR_NONE) {
 800b922:	19bb      	adds	r3, r7, r6
 800b924:	781b      	ldrb	r3, [r3, #0]
 800b926:	b25b      	sxtb	r3, r3
 800b928:	2b00      	cmp	r3, #0
 800b92a:	d11a      	bne.n	800b962 <VL53L1_preset_mode_timed_ranging+0x72>

		/* Dynamic Configuration */

		/* Disable GPH  */
		pdynamic->system__grouped_parameter_hold = 0x00;
 800b92c:	683b      	ldr	r3, [r7, #0]
 800b92e:	2200      	movs	r2, #0
 800b930:	749a      	strb	r2, [r3, #18]

		/* Re-Configure timing budget default for 13ms */
		ptiming->range_config__timeout_macrop_a_hi                = 0x00;
 800b932:	687b      	ldr	r3, [r7, #4]
 800b934:	2200      	movs	r2, #0
 800b936:	711a      	strb	r2, [r3, #4]
		ptiming->range_config__timeout_macrop_a_lo                = 0xB1;
 800b938:	687b      	ldr	r3, [r7, #4]
 800b93a:	22b1      	movs	r2, #177	; 0xb1
 800b93c:	715a      	strb	r2, [r3, #5]
		/* Setup for 13ms default */
		ptiming->range_config__timeout_macrop_b_hi                = 0x00;
 800b93e:	687b      	ldr	r3, [r7, #4]
 800b940:	2200      	movs	r2, #0
 800b942:	71da      	strb	r2, [r3, #7]
		ptiming->range_config__timeout_macrop_b_lo                = 0xD4;
 800b944:	687b      	ldr	r3, [r7, #4]
 800b946:	22d4      	movs	r2, #212	; 0xd4
 800b948:	721a      	strb	r2, [r3, #8]

		/* Timing Configuration */

		ptiming->system__intermeasurement_period = 0x00000600;
 800b94a:	687b      	ldr	r3, [r7, #4]
 800b94c:	22c0      	movs	r2, #192	; 0xc0
 800b94e:	00d2      	lsls	r2, r2, #3
 800b950:	611a      	str	r2, [r3, #16]
		pdynamic->system__seed_config =
				ptuning_parms->tp_timed_seed_cfg;
 800b952:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b954:	2222      	movs	r2, #34	; 0x22
 800b956:	5c9a      	ldrb	r2, [r3, r2]
		pdynamic->system__seed_config =
 800b958:	683b      	ldr	r3, [r7, #0]
 800b95a:	71da      	strb	r2, [r3, #7]

		/* System control */

		/* Configure Timed/Psuedo-solo mode */
		psystem->system__mode_start =
 800b95c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b95e:	2240      	movs	r2, #64	; 0x40
 800b960:	711a      	strb	r2, [r3, #4]
				VL53L1_DEVICEMEASUREMENTMODE_TIMED;
	}

	LOG_FUNCTION_END(status);

	return status;
 800b962:	2317      	movs	r3, #23
 800b964:	18fb      	adds	r3, r7, r3
 800b966:	781b      	ldrb	r3, [r3, #0]
 800b968:	b25b      	sxtb	r3, r3
}
 800b96a:	0018      	movs	r0, r3
 800b96c:	46bd      	mov	sp, r7
 800b96e:	b007      	add	sp, #28
 800b970:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800b972 <VL53L1_preset_mode_timed_ranging_short_range>:
	VL53L1_general_config_t   *pgeneral,
	VL53L1_timing_config_t    *ptiming,
	VL53L1_dynamic_config_t   *pdynamic,
	VL53L1_system_control_t   *psystem,
	VL53L1_tuning_parm_storage_t *ptuning_parms)
{
 800b972:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b974:	b089      	sub	sp, #36	; 0x24
 800b976:	af02      	add	r7, sp, #8
 800b978:	60f8      	str	r0, [r7, #12]
 800b97a:	60b9      	str	r1, [r7, #8]
 800b97c:	607a      	str	r2, [r7, #4]
 800b97e:	603b      	str	r3, [r7, #0]
	*  - timed
	*
	*  PLEASE NOTE THE SETTINGS BELOW AT PROVISIONAL AND WILL CHANGE!
	*/

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 800b980:	2617      	movs	r6, #23
 800b982:	19bb      	adds	r3, r7, r6
 800b984:	2200      	movs	r2, #0
 800b986:	701a      	strb	r2, [r3, #0]

	LOG_FUNCTION_START("");

	/* Call standard ranging configuration */

	status = VL53L1_preset_mode_standard_ranging_short_range(
 800b988:	19bc      	adds	r4, r7, r6
 800b98a:	683d      	ldr	r5, [r7, #0]
 800b98c:	687a      	ldr	r2, [r7, #4]
 800b98e:	68b9      	ldr	r1, [r7, #8]
 800b990:	68f8      	ldr	r0, [r7, #12]
 800b992:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b994:	9301      	str	r3, [sp, #4]
 800b996:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b998:	9300      	str	r3, [sp, #0]
 800b99a:	002b      	movs	r3, r5
 800b99c:	f7ff fec0 	bl	800b720 <VL53L1_preset_mode_standard_ranging_short_range>
 800b9a0:	0003      	movs	r3, r0
 800b9a2:	7023      	strb	r3, [r4, #0]
					psystem,
					ptuning_parms);

	/* now override standard ranging specific registers */

	if (status == VL53L1_ERROR_NONE) {
 800b9a4:	19bb      	adds	r3, r7, r6
 800b9a6:	781b      	ldrb	r3, [r3, #0]
 800b9a8:	b25b      	sxtb	r3, r3
 800b9aa:	2b00      	cmp	r3, #0
 800b9ac:	d11a      	bne.n	800b9e4 <VL53L1_preset_mode_timed_ranging_short_range+0x72>

		/* Dynamic Configuration */

		/* Disable GPH  */
		pdynamic->system__grouped_parameter_hold = 0x00;
 800b9ae:	683b      	ldr	r3, [r7, #0]
 800b9b0:	2200      	movs	r2, #0
 800b9b2:	749a      	strb	r2, [r3, #18]


		/* Timing Configuration */

		/* Re-Configure timing budget default for 13ms */
		ptiming->range_config__timeout_macrop_a_hi                = 0x01;
 800b9b4:	687b      	ldr	r3, [r7, #4]
 800b9b6:	2201      	movs	r2, #1
 800b9b8:	711a      	strb	r2, [r3, #4]
		ptiming->range_config__timeout_macrop_a_lo                = 0x84;
 800b9ba:	687b      	ldr	r3, [r7, #4]
 800b9bc:	2284      	movs	r2, #132	; 0x84
 800b9be:	715a      	strb	r2, [r3, #5]
		/* Setup for 13ms default */
		ptiming->range_config__timeout_macrop_b_hi                = 0x01;
 800b9c0:	687b      	ldr	r3, [r7, #4]
 800b9c2:	2201      	movs	r2, #1
 800b9c4:	71da      	strb	r2, [r3, #7]
		ptiming->range_config__timeout_macrop_b_lo                = 0xB1;
 800b9c6:	687b      	ldr	r3, [r7, #4]
 800b9c8:	22b1      	movs	r2, #177	; 0xb1
 800b9ca:	721a      	strb	r2, [r3, #8]

		ptiming->system__intermeasurement_period = 0x00000600;
 800b9cc:	687b      	ldr	r3, [r7, #4]
 800b9ce:	22c0      	movs	r2, #192	; 0xc0
 800b9d0:	00d2      	lsls	r2, r2, #3
 800b9d2:	611a      	str	r2, [r3, #16]
		pdynamic->system__seed_config =
				ptuning_parms->tp_timed_seed_cfg;
 800b9d4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b9d6:	2222      	movs	r2, #34	; 0x22
 800b9d8:	5c9a      	ldrb	r2, [r3, r2]
		pdynamic->system__seed_config =
 800b9da:	683b      	ldr	r3, [r7, #0]
 800b9dc:	71da      	strb	r2, [r3, #7]

		/* System control */

		/* Configure Timed/Psuedo-solo mode */
		psystem->system__mode_start =
 800b9de:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b9e0:	2240      	movs	r2, #64	; 0x40
 800b9e2:	711a      	strb	r2, [r3, #4]
				VL53L1_DEVICEMEASUREMENTMODE_TIMED;
	}

	LOG_FUNCTION_END(status);

	return status;
 800b9e4:	2317      	movs	r3, #23
 800b9e6:	18fb      	adds	r3, r7, r3
 800b9e8:	781b      	ldrb	r3, [r3, #0]
 800b9ea:	b25b      	sxtb	r3, r3
}
 800b9ec:	0018      	movs	r0, r3
 800b9ee:	46bd      	mov	sp, r7
 800b9f0:	b007      	add	sp, #28
 800b9f2:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800b9f4 <VL53L1_preset_mode_timed_ranging_long_range>:
	VL53L1_general_config_t   *pgeneral,
	VL53L1_timing_config_t    *ptiming,
	VL53L1_dynamic_config_t   *pdynamic,
	VL53L1_system_control_t   *psystem,
	VL53L1_tuning_parm_storage_t *ptuning_parms)
{
 800b9f4:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b9f6:	b089      	sub	sp, #36	; 0x24
 800b9f8:	af02      	add	r7, sp, #8
 800b9fa:	60f8      	str	r0, [r7, #12]
 800b9fc:	60b9      	str	r1, [r7, #8]
 800b9fe:	607a      	str	r2, [r7, #4]
 800ba00:	603b      	str	r3, [r7, #0]
	*  - timed
	*
	*  PLEASE NOTE THE SETTINGS BELOW AT PROVISIONAL AND WILL CHANGE!
	*/

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 800ba02:	2617      	movs	r6, #23
 800ba04:	19bb      	adds	r3, r7, r6
 800ba06:	2200      	movs	r2, #0
 800ba08:	701a      	strb	r2, [r3, #0]

	LOG_FUNCTION_START("");

	/* Call standard ranging configuration */

	status = VL53L1_preset_mode_standard_ranging_long_range(
 800ba0a:	19bc      	adds	r4, r7, r6
 800ba0c:	683d      	ldr	r5, [r7, #0]
 800ba0e:	687a      	ldr	r2, [r7, #4]
 800ba10:	68b9      	ldr	r1, [r7, #8]
 800ba12:	68f8      	ldr	r0, [r7, #12]
 800ba14:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ba16:	9301      	str	r3, [sp, #4]
 800ba18:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ba1a:	9300      	str	r3, [sp, #0]
 800ba1c:	002b      	movs	r3, r5
 800ba1e:	f7ff fec7 	bl	800b7b0 <VL53L1_preset_mode_standard_ranging_long_range>
 800ba22:	0003      	movs	r3, r0
 800ba24:	7023      	strb	r3, [r4, #0]
					psystem,
					ptuning_parms);

	/* now override standard ranging specific registers */

	if (status == VL53L1_ERROR_NONE) {
 800ba26:	19bb      	adds	r3, r7, r6
 800ba28:	781b      	ldrb	r3, [r3, #0]
 800ba2a:	b25b      	sxtb	r3, r3
 800ba2c:	2b00      	cmp	r3, #0
 800ba2e:	d11a      	bne.n	800ba66 <VL53L1_preset_mode_timed_ranging_long_range+0x72>

		/* Dynamic Configuration */

		/* Disable GPH  */
		pdynamic->system__grouped_parameter_hold = 0x00;
 800ba30:	683b      	ldr	r3, [r7, #0]
 800ba32:	2200      	movs	r2, #0
 800ba34:	749a      	strb	r2, [r3, #18]


		/* Timing Configuration */

		/* Re-Configure timing budget default for 13ms */
		ptiming->range_config__timeout_macrop_a_hi                = 0x00;
 800ba36:	687b      	ldr	r3, [r7, #4]
 800ba38:	2200      	movs	r2, #0
 800ba3a:	711a      	strb	r2, [r3, #4]
		ptiming->range_config__timeout_macrop_a_lo                = 0x97;
 800ba3c:	687b      	ldr	r3, [r7, #4]
 800ba3e:	2297      	movs	r2, #151	; 0x97
 800ba40:	715a      	strb	r2, [r3, #5]
		/* Setup for 13ms default */
		ptiming->range_config__timeout_macrop_b_hi                = 0x00;
 800ba42:	687b      	ldr	r3, [r7, #4]
 800ba44:	2200      	movs	r2, #0
 800ba46:	71da      	strb	r2, [r3, #7]
		ptiming->range_config__timeout_macrop_b_lo                = 0xB1;
 800ba48:	687b      	ldr	r3, [r7, #4]
 800ba4a:	22b1      	movs	r2, #177	; 0xb1
 800ba4c:	721a      	strb	r2, [r3, #8]

		ptiming->system__intermeasurement_period = 0x00000600;
 800ba4e:	687b      	ldr	r3, [r7, #4]
 800ba50:	22c0      	movs	r2, #192	; 0xc0
 800ba52:	00d2      	lsls	r2, r2, #3
 800ba54:	611a      	str	r2, [r3, #16]
		pdynamic->system__seed_config =
				ptuning_parms->tp_timed_seed_cfg;
 800ba56:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ba58:	2222      	movs	r2, #34	; 0x22
 800ba5a:	5c9a      	ldrb	r2, [r3, r2]
		pdynamic->system__seed_config =
 800ba5c:	683b      	ldr	r3, [r7, #0]
 800ba5e:	71da      	strb	r2, [r3, #7]

		/* System control */

		/* Configure Timed/Psuedo-solo mode */
		psystem->system__mode_start =
 800ba60:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ba62:	2240      	movs	r2, #64	; 0x40
 800ba64:	711a      	strb	r2, [r3, #4]
				VL53L1_DEVICEMEASUREMENTMODE_TIMED;
	}

	LOG_FUNCTION_END(status);

	return status;
 800ba66:	2317      	movs	r3, #23
 800ba68:	18fb      	adds	r3, r7, r3
 800ba6a:	781b      	ldrb	r3, [r3, #0]
 800ba6c:	b25b      	sxtb	r3, r3
}
 800ba6e:	0018      	movs	r0, r3
 800ba70:	46bd      	mov	sp, r7
 800ba72:	b007      	add	sp, #28
 800ba74:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800ba76 <VL53L1_preset_mode_low_power_auto_ranging>:
	VL53L1_timing_config_t    *ptiming,
	VL53L1_dynamic_config_t   *pdynamic,
	VL53L1_system_control_t   *psystem,
	VL53L1_tuning_parm_storage_t *ptuning_parms,
	VL53L1_low_power_auto_data_t *plpadata)
{
 800ba76:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ba78:	b089      	sub	sp, #36	; 0x24
 800ba7a:	af02      	add	r7, sp, #8
 800ba7c:	60f8      	str	r0, [r7, #12]
 800ba7e:	60b9      	str	r1, [r7, #8]
 800ba80:	607a      	str	r2, [r7, #4]
 800ba82:	603b      	str	r3, [r7, #0]
	*  - special low power auto mode for Presence application
	*
	*  PLEASE NOTE THE SETTINGS BELOW ARE PROVISIONAL AND WILL CHANGE!
	*/

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 800ba84:	2617      	movs	r6, #23
 800ba86:	19bb      	adds	r3, r7, r6
 800ba88:	2200      	movs	r2, #0
 800ba8a:	701a      	strb	r2, [r3, #0]

	LOG_FUNCTION_START("");

	/* Call standard ranging configuration */

	status = VL53L1_preset_mode_timed_ranging(
 800ba8c:	19bc      	adds	r4, r7, r6
 800ba8e:	683d      	ldr	r5, [r7, #0]
 800ba90:	687a      	ldr	r2, [r7, #4]
 800ba92:	68b9      	ldr	r1, [r7, #8]
 800ba94:	68f8      	ldr	r0, [r7, #12]
 800ba96:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ba98:	9301      	str	r3, [sp, #4]
 800ba9a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ba9c:	9300      	str	r3, [sp, #0]
 800ba9e:	002b      	movs	r3, r5
 800baa0:	f7ff ff26 	bl	800b8f0 <VL53L1_preset_mode_timed_ranging>
 800baa4:	0003      	movs	r3, r0
 800baa6:	7023      	strb	r3, [r4, #0]
					psystem,
					ptuning_parms);

	/* now setup the low power auto mode */

	if (status == VL53L1_ERROR_NONE) {
 800baa8:	19bb      	adds	r3, r7, r6
 800baaa:	781b      	ldrb	r3, [r3, #0]
 800baac:	b25b      	sxtb	r3, r3
 800baae:	2b00      	cmp	r3, #0
 800bab0:	d109      	bne.n	800bac6 <VL53L1_preset_mode_low_power_auto_ranging+0x50>
		status = VL53L1_config_low_power_auto_mode(
 800bab2:	2317      	movs	r3, #23
 800bab4:	18fc      	adds	r4, r7, r3
 800bab6:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800bab8:	6839      	ldr	r1, [r7, #0]
 800baba:	68bb      	ldr	r3, [r7, #8]
 800babc:	0018      	movs	r0, r3
 800babe:	f000 ff95 	bl	800c9ec <VL53L1_config_low_power_auto_mode>
 800bac2:	0003      	movs	r3, r0
 800bac4:	7023      	strb	r3, [r4, #0]
				);
	}

	LOG_FUNCTION_END(status);

	return status;
 800bac6:	2317      	movs	r3, #23
 800bac8:	18fb      	adds	r3, r7, r3
 800baca:	781b      	ldrb	r3, [r3, #0]
 800bacc:	b25b      	sxtb	r3, r3
}
 800bace:	0018      	movs	r0, r3
 800bad0:	46bd      	mov	sp, r7
 800bad2:	b007      	add	sp, #28
 800bad4:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800bad6 <VL53L1_preset_mode_low_power_auto_short_ranging>:
	VL53L1_timing_config_t    *ptiming,
	VL53L1_dynamic_config_t   *pdynamic,
	VL53L1_system_control_t   *psystem,
	VL53L1_tuning_parm_storage_t *ptuning_parms,
	VL53L1_low_power_auto_data_t *plpadata)
{
 800bad6:	b5f0      	push	{r4, r5, r6, r7, lr}
 800bad8:	b089      	sub	sp, #36	; 0x24
 800bada:	af02      	add	r7, sp, #8
 800badc:	60f8      	str	r0, [r7, #12]
 800bade:	60b9      	str	r1, [r7, #8]
 800bae0:	607a      	str	r2, [r7, #4]
 800bae2:	603b      	str	r3, [r7, #0]
	*  - special low power auto mode for Presence application
	*
	*  PLEASE NOTE THE SETTINGS BELOW ARE PROVISIONAL AND WILL CHANGE!
	*/

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 800bae4:	2617      	movs	r6, #23
 800bae6:	19bb      	adds	r3, r7, r6
 800bae8:	2200      	movs	r2, #0
 800baea:	701a      	strb	r2, [r3, #0]

	LOG_FUNCTION_START("");

	/* Call standard ranging configuration */

	status = VL53L1_preset_mode_timed_ranging_short_range(
 800baec:	19bc      	adds	r4, r7, r6
 800baee:	683d      	ldr	r5, [r7, #0]
 800baf0:	687a      	ldr	r2, [r7, #4]
 800baf2:	68b9      	ldr	r1, [r7, #8]
 800baf4:	68f8      	ldr	r0, [r7, #12]
 800baf6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800baf8:	9301      	str	r3, [sp, #4]
 800bafa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bafc:	9300      	str	r3, [sp, #0]
 800bafe:	002b      	movs	r3, r5
 800bb00:	f7ff ff37 	bl	800b972 <VL53L1_preset_mode_timed_ranging_short_range>
 800bb04:	0003      	movs	r3, r0
 800bb06:	7023      	strb	r3, [r4, #0]
					psystem,
					ptuning_parms);

	/* now setup the low power auto mode */

	if (status == VL53L1_ERROR_NONE) {
 800bb08:	19bb      	adds	r3, r7, r6
 800bb0a:	781b      	ldrb	r3, [r3, #0]
 800bb0c:	b25b      	sxtb	r3, r3
 800bb0e:	2b00      	cmp	r3, #0
 800bb10:	d109      	bne.n	800bb26 <VL53L1_preset_mode_low_power_auto_short_ranging+0x50>
		status = VL53L1_config_low_power_auto_mode(
 800bb12:	2317      	movs	r3, #23
 800bb14:	18fc      	adds	r4, r7, r3
 800bb16:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800bb18:	6839      	ldr	r1, [r7, #0]
 800bb1a:	68bb      	ldr	r3, [r7, #8]
 800bb1c:	0018      	movs	r0, r3
 800bb1e:	f000 ff65 	bl	800c9ec <VL53L1_config_low_power_auto_mode>
 800bb22:	0003      	movs	r3, r0
 800bb24:	7023      	strb	r3, [r4, #0]
				);
	}

	LOG_FUNCTION_END(status);

	return status;
 800bb26:	2317      	movs	r3, #23
 800bb28:	18fb      	adds	r3, r7, r3
 800bb2a:	781b      	ldrb	r3, [r3, #0]
 800bb2c:	b25b      	sxtb	r3, r3
}
 800bb2e:	0018      	movs	r0, r3
 800bb30:	46bd      	mov	sp, r7
 800bb32:	b007      	add	sp, #28
 800bb34:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800bb36 <VL53L1_preset_mode_low_power_auto_long_ranging>:
	VL53L1_timing_config_t    *ptiming,
	VL53L1_dynamic_config_t   *pdynamic,
	VL53L1_system_control_t   *psystem,
	VL53L1_tuning_parm_storage_t *ptuning_parms,
	VL53L1_low_power_auto_data_t *plpadata)
{
 800bb36:	b5f0      	push	{r4, r5, r6, r7, lr}
 800bb38:	b089      	sub	sp, #36	; 0x24
 800bb3a:	af02      	add	r7, sp, #8
 800bb3c:	60f8      	str	r0, [r7, #12]
 800bb3e:	60b9      	str	r1, [r7, #8]
 800bb40:	607a      	str	r2, [r7, #4]
 800bb42:	603b      	str	r3, [r7, #0]
	*  - special low power auto mode for Presence application
	*
	*  PLEASE NOTE THE SETTINGS BELOW ARE PROVISIONAL AND WILL CHANGE!
	*/

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 800bb44:	2617      	movs	r6, #23
 800bb46:	19bb      	adds	r3, r7, r6
 800bb48:	2200      	movs	r2, #0
 800bb4a:	701a      	strb	r2, [r3, #0]

	LOG_FUNCTION_START("");

	/* Call standard ranging configuration */

	status = VL53L1_preset_mode_timed_ranging_long_range(
 800bb4c:	19bc      	adds	r4, r7, r6
 800bb4e:	683d      	ldr	r5, [r7, #0]
 800bb50:	687a      	ldr	r2, [r7, #4]
 800bb52:	68b9      	ldr	r1, [r7, #8]
 800bb54:	68f8      	ldr	r0, [r7, #12]
 800bb56:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800bb58:	9301      	str	r3, [sp, #4]
 800bb5a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bb5c:	9300      	str	r3, [sp, #0]
 800bb5e:	002b      	movs	r3, r5
 800bb60:	f7ff ff48 	bl	800b9f4 <VL53L1_preset_mode_timed_ranging_long_range>
 800bb64:	0003      	movs	r3, r0
 800bb66:	7023      	strb	r3, [r4, #0]
					psystem,
					ptuning_parms);

	/* now setup the low power auto mode */

	if (status == VL53L1_ERROR_NONE) {
 800bb68:	19bb      	adds	r3, r7, r6
 800bb6a:	781b      	ldrb	r3, [r3, #0]
 800bb6c:	b25b      	sxtb	r3, r3
 800bb6e:	2b00      	cmp	r3, #0
 800bb70:	d109      	bne.n	800bb86 <VL53L1_preset_mode_low_power_auto_long_ranging+0x50>
		status = VL53L1_config_low_power_auto_mode(
 800bb72:	2317      	movs	r3, #23
 800bb74:	18fc      	adds	r4, r7, r3
 800bb76:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800bb78:	6839      	ldr	r1, [r7, #0]
 800bb7a:	68bb      	ldr	r3, [r7, #8]
 800bb7c:	0018      	movs	r0, r3
 800bb7e:	f000 ff35 	bl	800c9ec <VL53L1_config_low_power_auto_mode>
 800bb82:	0003      	movs	r3, r0
 800bb84:	7023      	strb	r3, [r4, #0]
				);
	}

	LOG_FUNCTION_END(status);

	return status;
 800bb86:	2317      	movs	r3, #23
 800bb88:	18fb      	adds	r3, r7, r3
 800bb8a:	781b      	ldrb	r3, [r3, #0]
 800bb8c:	b25b      	sxtb	r3, r3
}
 800bb8e:	0018      	movs	r0, r3
 800bb90:	46bd      	mov	sp, r7
 800bb92:	b007      	add	sp, #28
 800bb94:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800bb96 <VL53L1_preset_mode_singleshot_ranging>:
	VL53L1_general_config_t   *pgeneral,
	VL53L1_timing_config_t    *ptiming,
	VL53L1_dynamic_config_t   *pdynamic,
	VL53L1_system_control_t   *psystem,
	VL53L1_tuning_parm_storage_t *ptuning_parms)
{
 800bb96:	b5f0      	push	{r4, r5, r6, r7, lr}
 800bb98:	b089      	sub	sp, #36	; 0x24
 800bb9a:	af02      	add	r7, sp, #8
 800bb9c:	60f8      	str	r0, [r7, #12]
 800bb9e:	60b9      	str	r1, [r7, #8]
 800bba0:	607a      	str	r2, [r7, #4]
 800bba2:	603b      	str	r3, [r7, #0]
	*  - timed
	*
	*  PLEASE NOTE THE SETTINGS BELOW AT PROVISIONAL AND WILL CHANGE!
	*/

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 800bba4:	2617      	movs	r6, #23
 800bba6:	19bb      	adds	r3, r7, r6
 800bba8:	2200      	movs	r2, #0
 800bbaa:	701a      	strb	r2, [r3, #0]

	LOG_FUNCTION_START("");

	/* Call standard ranging configuration */

	status = VL53L1_preset_mode_standard_ranging(
 800bbac:	19bc      	adds	r4, r7, r6
 800bbae:	683d      	ldr	r5, [r7, #0]
 800bbb0:	687a      	ldr	r2, [r7, #4]
 800bbb2:	68b9      	ldr	r1, [r7, #8]
 800bbb4:	68f8      	ldr	r0, [r7, #12]
 800bbb6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800bbb8:	9301      	str	r3, [sp, #4]
 800bbba:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bbbc:	9300      	str	r3, [sp, #0]
 800bbbe:	002b      	movs	r3, r5
 800bbc0:	f7ff fc8e 	bl	800b4e0 <VL53L1_preset_mode_standard_ranging>
 800bbc4:	0003      	movs	r3, r0
 800bbc6:	7023      	strb	r3, [r4, #0]
		psystem,
		ptuning_parms);

	/* now override standard ranging specific registers */

	if (status == VL53L1_ERROR_NONE) {
 800bbc8:	19bb      	adds	r3, r7, r6
 800bbca:	781b      	ldrb	r3, [r3, #0]
 800bbcc:	b25b      	sxtb	r3, r3
 800bbce:	2b00      	cmp	r3, #0
 800bbd0:	d116      	bne.n	800bc00 <VL53L1_preset_mode_singleshot_ranging+0x6a>

		/* Dynamic Configuration */

		/* Disable GPH  */
		pdynamic->system__grouped_parameter_hold = 0x00;
 800bbd2:	683b      	ldr	r3, [r7, #0]
 800bbd4:	2200      	movs	r2, #0
 800bbd6:	749a      	strb	r2, [r3, #18]

		/* Timing Configuration */

		/* Re-Configure timing budget default for 13ms */
		ptiming->range_config__timeout_macrop_a_hi                = 0x00;
 800bbd8:	687b      	ldr	r3, [r7, #4]
 800bbda:	2200      	movs	r2, #0
 800bbdc:	711a      	strb	r2, [r3, #4]
		ptiming->range_config__timeout_macrop_a_lo                = 0xB1;
 800bbde:	687b      	ldr	r3, [r7, #4]
 800bbe0:	22b1      	movs	r2, #177	; 0xb1
 800bbe2:	715a      	strb	r2, [r3, #5]
		/* Setup for 13ms default */
		ptiming->range_config__timeout_macrop_b_hi                = 0x00;
 800bbe4:	687b      	ldr	r3, [r7, #4]
 800bbe6:	2200      	movs	r2, #0
 800bbe8:	71da      	strb	r2, [r3, #7]
		ptiming->range_config__timeout_macrop_b_lo                = 0xD4;
 800bbea:	687b      	ldr	r3, [r7, #4]
 800bbec:	22d4      	movs	r2, #212	; 0xd4
 800bbee:	721a      	strb	r2, [r3, #8]

		pdynamic->system__seed_config =
				ptuning_parms->tp_timed_seed_cfg;
 800bbf0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800bbf2:	2222      	movs	r2, #34	; 0x22
 800bbf4:	5c9a      	ldrb	r2, [r3, r2]
		pdynamic->system__seed_config =
 800bbf6:	683b      	ldr	r3, [r7, #0]
 800bbf8:	71da      	strb	r2, [r3, #7]

		/* System control */

		/* Configure Timed/Psuedo-solo mode */
		psystem->system__mode_start = \
 800bbfa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bbfc:	2210      	movs	r2, #16
 800bbfe:	711a      	strb	r2, [r3, #4]
				VL53L1_DEVICEMEASUREMENTMODE_SINGLESHOT;
	}

	LOG_FUNCTION_END(status);

	return status;
 800bc00:	2317      	movs	r3, #23
 800bc02:	18fb      	adds	r3, r7, r3
 800bc04:	781b      	ldrb	r3, [r3, #0]
 800bc06:	b25b      	sxtb	r3, r3
}
 800bc08:	0018      	movs	r0, r3
 800bc0a:	46bd      	mov	sp, r7
 800bc0c:	b007      	add	sp, #28
 800bc0e:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800bc10 <VL53L1_preset_mode_olt>:
	VL53L1_general_config_t   *pgeneral,
	VL53L1_timing_config_t    *ptiming,
	VL53L1_dynamic_config_t   *pdynamic,
	VL53L1_system_control_t   *psystem,
	VL53L1_tuning_parm_storage_t *ptuning_parms)
{
 800bc10:	b5f0      	push	{r4, r5, r6, r7, lr}
 800bc12:	b089      	sub	sp, #36	; 0x24
 800bc14:	af02      	add	r7, sp, #8
 800bc16:	60f8      	str	r0, [r7, #12]
 800bc18:	60b9      	str	r1, [r7, #8]
 800bc1a:	607a      	str	r2, [r7, #4]
 800bc1c:	603b      	str	r3, [r7, #0]
	 * VL53L1_DEVICEPRESETMODE_OLT
	 *
	 *  PLEASE NOTE THE SETTINGS BELOW AT PROVISIONAL AND WILL CHANGE!
	 */

	VL53L1_Error  status = VL53L1_ERROR_NONE;
 800bc1e:	2617      	movs	r6, #23
 800bc20:	19bb      	adds	r3, r7, r6
 800bc22:	2200      	movs	r2, #0
 800bc24:	701a      	strb	r2, [r3, #0]

	LOG_FUNCTION_START("");

	/* Call standard ranging configuration */

	status = VL53L1_preset_mode_standard_ranging(
 800bc26:	19bc      	adds	r4, r7, r6
 800bc28:	683d      	ldr	r5, [r7, #0]
 800bc2a:	687a      	ldr	r2, [r7, #4]
 800bc2c:	68b9      	ldr	r1, [r7, #8]
 800bc2e:	68f8      	ldr	r0, [r7, #12]
 800bc30:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800bc32:	9301      	str	r3, [sp, #4]
 800bc34:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bc36:	9300      	str	r3, [sp, #0]
 800bc38:	002b      	movs	r3, r5
 800bc3a:	f7ff fc51 	bl	800b4e0 <VL53L1_preset_mode_standard_ranging>
 800bc3e:	0003      	movs	r3, r0
 800bc40:	7023      	strb	r3, [r4, #0]
					psystem,
					ptuning_parms);

	/* now override OLT specific registers */

	if (status == VL53L1_ERROR_NONE) {
 800bc42:	19bb      	adds	r3, r7, r6
 800bc44:	781b      	ldrb	r3, [r3, #0]
 800bc46:	b25b      	sxtb	r3, r3
 800bc48:	2b00      	cmp	r3, #0
 800bc4a:	d102      	bne.n	800bc52 <VL53L1_preset_mode_olt+0x42>

		/* Disables requirement for host handshake */
		psystem->system__stream_count_ctrl  = 0x01;
 800bc4c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bc4e:	2201      	movs	r2, #1
 800bc50:	705a      	strb	r2, [r3, #1]
	}

	LOG_FUNCTION_END(status);

	return status;
 800bc52:	2317      	movs	r3, #23
 800bc54:	18fb      	adds	r3, r7, r3
 800bc56:	781b      	ldrb	r3, [r3, #0]
 800bc58:	b25b      	sxtb	r3, r3
}
 800bc5a:	0018      	movs	r0, r3
 800bc5c:	46bd      	mov	sp, r7
 800bc5e:	b007      	add	sp, #28
 800bc60:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800bc62 <VL53L1_init_version>:
	level, VL53L1_TRACE_FUNCTION_NONE, ##__VA_ARGS__)


void  VL53L1_init_version(
	VL53L1_DEV        Dev)
{
 800bc62:	b580      	push	{r7, lr}
 800bc64:	b084      	sub	sp, #16
 800bc66:	af00      	add	r7, sp, #0
 800bc68:	6078      	str	r0, [r7, #4]
	/**
	 * Initialise version structure
	 */

	VL53L1_LLDriverData_t *pdev = VL53L1DevStructGetLLDriverHandle(Dev);
 800bc6a:	687b      	ldr	r3, [r7, #4]
 800bc6c:	60fb      	str	r3, [r7, #12]

	pdev->version.ll_major    = VL53L1_LL_API_IMPLEMENTATION_VER_MAJOR;
 800bc6e:	68fb      	ldr	r3, [r7, #12]
 800bc70:	2228      	movs	r2, #40	; 0x28
 800bc72:	2101      	movs	r1, #1
 800bc74:	5499      	strb	r1, [r3, r2]
	pdev->version.ll_minor    = VL53L1_LL_API_IMPLEMENTATION_VER_MINOR;
 800bc76:	68fb      	ldr	r3, [r7, #12]
 800bc78:	2229      	movs	r2, #41	; 0x29
 800bc7a:	2102      	movs	r1, #2
 800bc7c:	5499      	strb	r1, [r3, r2]
	pdev->version.ll_build    = VL53L1_LL_API_IMPLEMENTATION_VER_SUB;
 800bc7e:	68fb      	ldr	r3, [r7, #12]
 800bc80:	222a      	movs	r2, #42	; 0x2a
 800bc82:	210a      	movs	r1, #10
 800bc84:	5499      	strb	r1, [r3, r2]
	pdev->version.ll_revision = VL53L1_LL_API_IMPLEMENTATION_VER_REVISION;
 800bc86:	68fb      	ldr	r3, [r7, #12]
 800bc88:	22e6      	movs	r2, #230	; 0xe6
 800bc8a:	00d2      	lsls	r2, r2, #3
 800bc8c:	625a      	str	r2, [r3, #36]	; 0x24
}
 800bc8e:	46c0      	nop			; (mov r8, r8)
 800bc90:	46bd      	mov	sp, r7
 800bc92:	b004      	add	sp, #16
 800bc94:	bd80      	pop	{r7, pc}

0800bc96 <VL53L1_init_ll_driver_state>:


void  VL53L1_init_ll_driver_state(
	VL53L1_DEV         Dev,
	VL53L1_DeviceState device_state)
{
 800bc96:	b580      	push	{r7, lr}
 800bc98:	b084      	sub	sp, #16
 800bc9a:	af00      	add	r7, sp, #0
 800bc9c:	6078      	str	r0, [r7, #4]
 800bc9e:	000a      	movs	r2, r1
 800bca0:	1cfb      	adds	r3, r7, #3
 800bca2:	701a      	strb	r2, [r3, #0]
	/**
	 * Initialise LL Driver state variables
	 */

	VL53L1_LLDriverData_t *pdev = VL53L1DevStructGetLLDriverHandle(Dev);
 800bca4:	687b      	ldr	r3, [r7, #4]
 800bca6:	60fb      	str	r3, [r7, #12]
	VL53L1_ll_driver_state_t *pstate = &(pdev->ll_state);
 800bca8:	68fb      	ldr	r3, [r7, #12]
 800bcaa:	332c      	adds	r3, #44	; 0x2c
 800bcac:	60bb      	str	r3, [r7, #8]

	pstate->cfg_device_state  = device_state;
 800bcae:	68bb      	ldr	r3, [r7, #8]
 800bcb0:	1cfa      	adds	r2, r7, #3
 800bcb2:	7812      	ldrb	r2, [r2, #0]
 800bcb4:	701a      	strb	r2, [r3, #0]
	pstate->cfg_stream_count  = 0;
 800bcb6:	68bb      	ldr	r3, [r7, #8]
 800bcb8:	2200      	movs	r2, #0
 800bcba:	705a      	strb	r2, [r3, #1]
	pstate->cfg_gph_id        = VL53L1_GROUPEDPARAMETERHOLD_ID_MASK;
 800bcbc:	68bb      	ldr	r3, [r7, #8]
 800bcbe:	2202      	movs	r2, #2
 800bcc0:	709a      	strb	r2, [r3, #2]
	pstate->cfg_timing_status = 0;
 800bcc2:	68bb      	ldr	r3, [r7, #8]
 800bcc4:	2200      	movs	r2, #0
 800bcc6:	70da      	strb	r2, [r3, #3]

	pstate->rd_device_state   = device_state;
 800bcc8:	68bb      	ldr	r3, [r7, #8]
 800bcca:	1cfa      	adds	r2, r7, #3
 800bccc:	7812      	ldrb	r2, [r2, #0]
 800bcce:	711a      	strb	r2, [r3, #4]
	pstate->rd_stream_count   = 0;
 800bcd0:	68bb      	ldr	r3, [r7, #8]
 800bcd2:	2200      	movs	r2, #0
 800bcd4:	715a      	strb	r2, [r3, #5]
	pstate->rd_gph_id         = VL53L1_GROUPEDPARAMETERHOLD_ID_MASK;
 800bcd6:	68bb      	ldr	r3, [r7, #8]
 800bcd8:	2202      	movs	r2, #2
 800bcda:	719a      	strb	r2, [r3, #6]
	pstate->rd_timing_status  = 0;
 800bcdc:	68bb      	ldr	r3, [r7, #8]
 800bcde:	2200      	movs	r2, #0
 800bce0:	71da      	strb	r2, [r3, #7]

}
 800bce2:	46c0      	nop			; (mov r8, r8)
 800bce4:	46bd      	mov	sp, r7
 800bce6:	b004      	add	sp, #16
 800bce8:	bd80      	pop	{r7, pc}

0800bcea <VL53L1_update_ll_driver_rd_state>:


VL53L1_Error  VL53L1_update_ll_driver_rd_state(
	VL53L1_DEV         Dev)
{
 800bcea:	b580      	push	{r7, lr}
 800bcec:	b086      	sub	sp, #24
 800bcee:	af00      	add	r7, sp, #0
 800bcf0:	6078      	str	r0, [r7, #4]
	 * VL53L1_DEVICESTATE_RANGING_WAIT_GPH_SYNC
	 * VL53L1_DEVICESTATE_RANGING_GATHER_DATA
	 * VL53L1_DEVICESTATE_RANGING_OUTPUT_DATA
	 */

	VL53L1_Error        status  = VL53L1_ERROR_NONE;
 800bcf2:	2317      	movs	r3, #23
 800bcf4:	18fb      	adds	r3, r7, r3
 800bcf6:	2200      	movs	r2, #0
 800bcf8:	701a      	strb	r2, [r3, #0]
	VL53L1_LLDriverData_t *pdev = VL53L1DevStructGetLLDriverHandle(Dev);
 800bcfa:	687b      	ldr	r3, [r7, #4]
 800bcfc:	613b      	str	r3, [r7, #16]
	VL53L1_ll_driver_state_t *pstate = &(pdev->ll_state);
 800bcfe:	693b      	ldr	r3, [r7, #16]
 800bd00:	332c      	adds	r3, #44	; 0x2c
 800bd02:	60fb      	str	r3, [r7, #12]

#ifdef VL53L1_LOGGING
	VL53L1_print_ll_driver_state(pstate);
#endif

	if ((pdev->sys_ctrl.system__mode_start &
 800bd04:	693a      	ldr	r2, [r7, #16]
 800bd06:	23e6      	movs	r3, #230	; 0xe6
 800bd08:	005b      	lsls	r3, r3, #1
 800bd0a:	5cd3      	ldrb	r3, [r2, r3]
 800bd0c:	001a      	movs	r2, r3
 800bd0e:	23f0      	movs	r3, #240	; 0xf0
 800bd10:	4013      	ands	r3, r2
 800bd12:	d10c      	bne.n	800bd2e <VL53L1_update_ll_driver_rd_state+0x44>
		VL53L1_DEVICEMEASUREMENTMODE_MODE_MASK) == 0x00) {

		pstate->rd_device_state  = VL53L1_DEVICESTATE_SW_STANDBY;
 800bd14:	68fb      	ldr	r3, [r7, #12]
 800bd16:	2203      	movs	r2, #3
 800bd18:	711a      	strb	r2, [r3, #4]
		pstate->rd_stream_count  = 0;
 800bd1a:	68fb      	ldr	r3, [r7, #12]
 800bd1c:	2200      	movs	r2, #0
 800bd1e:	715a      	strb	r2, [r3, #5]
		pstate->rd_gph_id = VL53L1_GROUPEDPARAMETERHOLD_ID_MASK;
 800bd20:	68fb      	ldr	r3, [r7, #12]
 800bd22:	2202      	movs	r2, #2
 800bd24:	719a      	strb	r2, [r3, #6]
		pstate->rd_timing_status = 0;
 800bd26:	68fb      	ldr	r3, [r7, #12]
 800bd28:	2200      	movs	r2, #0
 800bd2a:	71da      	strb	r2, [r3, #7]
 800bd2c:	e05b      	b.n	800bde6 <VL53L1_update_ll_driver_rd_state+0xfc>

		/*
		 * implement read stream count
		 */

		if (pstate->rd_stream_count == 0xFF) {
 800bd2e:	68fb      	ldr	r3, [r7, #12]
 800bd30:	795b      	ldrb	r3, [r3, #5]
 800bd32:	2bff      	cmp	r3, #255	; 0xff
 800bd34:	d103      	bne.n	800bd3e <VL53L1_update_ll_driver_rd_state+0x54>
			pstate->rd_stream_count = 0x80;
 800bd36:	68fb      	ldr	r3, [r7, #12]
 800bd38:	2280      	movs	r2, #128	; 0x80
 800bd3a:	715a      	strb	r2, [r3, #5]
 800bd3c:	e005      	b.n	800bd4a <VL53L1_update_ll_driver_rd_state+0x60>
		} else {
			pstate->rd_stream_count++;
 800bd3e:	68fb      	ldr	r3, [r7, #12]
 800bd40:	795b      	ldrb	r3, [r3, #5]
 800bd42:	3301      	adds	r3, #1
 800bd44:	b2da      	uxtb	r2, r3
 800bd46:	68fb      	ldr	r3, [r7, #12]
 800bd48:	715a      	strb	r2, [r3, #5]

		/*
		 * Toggle grouped parameter hold ID
		 */

		pstate->rd_gph_id ^= VL53L1_GROUPEDPARAMETERHOLD_ID_MASK;
 800bd4a:	68fb      	ldr	r3, [r7, #12]
 800bd4c:	799b      	ldrb	r3, [r3, #6]
 800bd4e:	2202      	movs	r2, #2
 800bd50:	4053      	eors	r3, r2
 800bd52:	b2da      	uxtb	r2, r3
 800bd54:	68fb      	ldr	r3, [r7, #12]
 800bd56:	719a      	strb	r2, [r3, #6]

		/* Ok now ranging  */

		switch (pstate->rd_device_state) {
 800bd58:	68fb      	ldr	r3, [r7, #12]
 800bd5a:	791b      	ldrb	r3, [r3, #4]
 800bd5c:	2b06      	cmp	r3, #6
 800bd5e:	d01f      	beq.n	800bda0 <VL53L1_update_ll_driver_rd_state+0xb6>
 800bd60:	dc02      	bgt.n	800bd68 <VL53L1_update_ll_driver_rd_state+0x7e>
 800bd62:	2b03      	cmp	r3, #3
 800bd64:	d005      	beq.n	800bd72 <VL53L1_update_ll_driver_rd_state+0x88>
 800bd66:	e031      	b.n	800bdcc <VL53L1_update_ll_driver_rd_state+0xe2>
 800bd68:	2b07      	cmp	r3, #7
 800bd6a:	d020      	beq.n	800bdae <VL53L1_update_ll_driver_rd_state+0xc4>
 800bd6c:	2b08      	cmp	r3, #8
 800bd6e:	d022      	beq.n	800bdb6 <VL53L1_update_ll_driver_rd_state+0xcc>
 800bd70:	e02c      	b.n	800bdcc <VL53L1_update_ll_driver_rd_state+0xe2>

		case VL53L1_DEVICESTATE_SW_STANDBY:

			if ((pdev->dyn_cfg.system__grouped_parameter_hold &
 800bd72:	693a      	ldr	r2, [r7, #16]
 800bd74:	23e3      	movs	r3, #227	; 0xe3
 800bd76:	005b      	lsls	r3, r3, #1
 800bd78:	5cd3      	ldrb	r3, [r2, r3]
 800bd7a:	001a      	movs	r2, r3
 800bd7c:	2302      	movs	r3, #2
 800bd7e:	4013      	ands	r3, r2
 800bd80:	2b00      	cmp	r3, #0
 800bd82:	dd03      	ble.n	800bd8c <VL53L1_update_ll_driver_rd_state+0xa2>
				VL53L1_GROUPEDPARAMETERHOLD_ID_MASK) > 0) {
				pstate->rd_device_state =
 800bd84:	68fb      	ldr	r3, [r7, #12]
 800bd86:	2206      	movs	r2, #6
 800bd88:	711a      	strb	r2, [r3, #4]
 800bd8a:	e002      	b.n	800bd92 <VL53L1_update_ll_driver_rd_state+0xa8>
					VL53L1_DEVICESTATE_RANGING_WAIT_GPH_SYNC;
			} else {
				pstate->rd_device_state =
 800bd8c:	68fb      	ldr	r3, [r7, #12]
 800bd8e:	2208      	movs	r2, #8
 800bd90:	711a      	strb	r2, [r3, #4]
					VL53L1_DEVICESTATE_RANGING_OUTPUT_DATA;
			}

			pstate->rd_stream_count  = 0;
 800bd92:	68fb      	ldr	r3, [r7, #12]
 800bd94:	2200      	movs	r2, #0
 800bd96:	715a      	strb	r2, [r3, #5]
			pstate->rd_timing_status = 0;
 800bd98:	68fb      	ldr	r3, [r7, #12]
 800bd9a:	2200      	movs	r2, #0
 800bd9c:	71da      	strb	r2, [r3, #7]

		break;
 800bd9e:	e022      	b.n	800bde6 <VL53L1_update_ll_driver_rd_state+0xfc>

		case VL53L1_DEVICESTATE_RANGING_WAIT_GPH_SYNC:

			pstate->rd_stream_count = 0;
 800bda0:	68fb      	ldr	r3, [r7, #12]
 800bda2:	2200      	movs	r2, #0
 800bda4:	715a      	strb	r2, [r3, #5]
			pstate->rd_device_state =
 800bda6:	68fb      	ldr	r3, [r7, #12]
 800bda8:	2208      	movs	r2, #8
 800bdaa:	711a      	strb	r2, [r3, #4]
				VL53L1_DEVICESTATE_RANGING_OUTPUT_DATA;

		break;
 800bdac:	e01b      	b.n	800bde6 <VL53L1_update_ll_driver_rd_state+0xfc>

		case VL53L1_DEVICESTATE_RANGING_GATHER_DATA:

			pstate->rd_device_state =
 800bdae:	68fb      	ldr	r3, [r7, #12]
 800bdb0:	2208      	movs	r2, #8
 800bdb2:	711a      	strb	r2, [r3, #4]
				VL53L1_DEVICESTATE_RANGING_OUTPUT_DATA;

		break;
 800bdb4:	e017      	b.n	800bde6 <VL53L1_update_ll_driver_rd_state+0xfc>

		case VL53L1_DEVICESTATE_RANGING_OUTPUT_DATA:

			pstate->rd_timing_status ^= 0x01;
 800bdb6:	68fb      	ldr	r3, [r7, #12]
 800bdb8:	79db      	ldrb	r3, [r3, #7]
 800bdba:	2201      	movs	r2, #1
 800bdbc:	4053      	eors	r3, r2
 800bdbe:	b2da      	uxtb	r2, r3
 800bdc0:	68fb      	ldr	r3, [r7, #12]
 800bdc2:	71da      	strb	r2, [r3, #7]

			pstate->rd_device_state =
 800bdc4:	68fb      	ldr	r3, [r7, #12]
 800bdc6:	2208      	movs	r2, #8
 800bdc8:	711a      	strb	r2, [r3, #4]
				VL53L1_DEVICESTATE_RANGING_OUTPUT_DATA;

		break;
 800bdca:	e00c      	b.n	800bde6 <VL53L1_update_ll_driver_rd_state+0xfc>

		default:

			pstate->rd_device_state  =
 800bdcc:	68fb      	ldr	r3, [r7, #12]
 800bdce:	2203      	movs	r2, #3
 800bdd0:	711a      	strb	r2, [r3, #4]
				VL53L1_DEVICESTATE_SW_STANDBY;
			pstate->rd_stream_count  = 0;
 800bdd2:	68fb      	ldr	r3, [r7, #12]
 800bdd4:	2200      	movs	r2, #0
 800bdd6:	715a      	strb	r2, [r3, #5]
			pstate->rd_gph_id = VL53L1_GROUPEDPARAMETERHOLD_ID_MASK;
 800bdd8:	68fb      	ldr	r3, [r7, #12]
 800bdda:	2202      	movs	r2, #2
 800bddc:	719a      	strb	r2, [r3, #6]
			pstate->rd_timing_status = 0;
 800bdde:	68fb      	ldr	r3, [r7, #12]
 800bde0:	2200      	movs	r2, #0
 800bde2:	71da      	strb	r2, [r3, #7]

		break;
 800bde4:	46c0      	nop			; (mov r8, r8)
	VL53L1_print_ll_driver_state(pstate);
#endif

	LOG_FUNCTION_END(status);

	return status;
 800bde6:	2317      	movs	r3, #23
 800bde8:	18fb      	adds	r3, r7, r3
 800bdea:	781b      	ldrb	r3, [r3, #0]
 800bdec:	b25b      	sxtb	r3, r3
}
 800bdee:	0018      	movs	r0, r3
 800bdf0:	46bd      	mov	sp, r7
 800bdf2:	b006      	add	sp, #24
 800bdf4:	bd80      	pop	{r7, pc}

0800bdf6 <VL53L1_check_ll_driver_rd_state>:


VL53L1_Error VL53L1_check_ll_driver_rd_state(
	VL53L1_DEV         Dev)
{
 800bdf6:	b590      	push	{r4, r7, lr}
 800bdf8:	b089      	sub	sp, #36	; 0x24
 800bdfa:	af00      	add	r7, sp, #0
 800bdfc:	6078      	str	r0, [r7, #4]
	 * matches the state and stream count received from the device
	 *
	 * Check is only use in back to back mode
	 */

	VL53L1_Error         status = VL53L1_ERROR_NONE;
 800bdfe:	231f      	movs	r3, #31
 800be00:	18fb      	adds	r3, r7, r3
 800be02:	2200      	movs	r2, #0
 800be04:	701a      	strb	r2, [r3, #0]
	VL53L1_LLDriverData_t  *pdev =
 800be06:	687b      	ldr	r3, [r7, #4]
 800be08:	61bb      	str	r3, [r7, #24]
			VL53L1DevStructGetLLDriverHandle(Dev);

	VL53L1_ll_driver_state_t  *pstate       = &(pdev->ll_state);
 800be0a:	69bb      	ldr	r3, [r7, #24]
 800be0c:	332c      	adds	r3, #44	; 0x2c
 800be0e:	617b      	str	r3, [r7, #20]
	VL53L1_system_results_t   *psys_results = &(pdev->sys_results);
 800be10:	69bb      	ldr	r3, [r7, #24]
 800be12:	33cf      	adds	r3, #207	; 0xcf
 800be14:	33ff      	adds	r3, #255	; 0xff
 800be16:	613b      	str	r3, [r7, #16]

	uint8_t   device_range_status   = 0;
 800be18:	210f      	movs	r1, #15
 800be1a:	187b      	adds	r3, r7, r1
 800be1c:	2200      	movs	r2, #0
 800be1e:	701a      	strb	r2, [r3, #0]
	uint8_t   device_stream_count   = 0;
 800be20:	200e      	movs	r0, #14
 800be22:	183b      	adds	r3, r7, r0
 800be24:	2200      	movs	r2, #0
 800be26:	701a      	strb	r2, [r3, #0]
	uint8_t   device_gph_id         = 0;
 800be28:	240d      	movs	r4, #13
 800be2a:	193b      	adds	r3, r7, r4
 800be2c:	2200      	movs	r2, #0
 800be2e:	701a      	strb	r2, [r3, #0]
#ifdef VL53L1_LOGGING
	VL53L1_print_ll_driver_state(pstate);
#endif

	device_range_status =
			psys_results->result__range_status &
 800be30:	693b      	ldr	r3, [r7, #16]
 800be32:	785a      	ldrb	r2, [r3, #1]
	device_range_status =
 800be34:	187b      	adds	r3, r7, r1
 800be36:	211f      	movs	r1, #31
 800be38:	400a      	ands	r2, r1
 800be3a:	701a      	strb	r2, [r3, #0]
			VL53L1_RANGE_STATUS__RANGE_STATUS_MASK;

	device_stream_count = psys_results->result__stream_count;
 800be3c:	183b      	adds	r3, r7, r0
 800be3e:	693a      	ldr	r2, [r7, #16]
 800be40:	78d2      	ldrb	r2, [r2, #3]
 800be42:	701a      	strb	r2, [r3, #0]

	/* load the correct GPH ID */
	device_gph_id = (psys_results->result__interrupt_status &
 800be44:	693b      	ldr	r3, [r7, #16]
 800be46:	781b      	ldrb	r3, [r3, #0]
		VL53L1_INTERRUPT_STATUS__GPH_ID_INT_STATUS_MASK) >> 4;
 800be48:	111b      	asrs	r3, r3, #4
 800be4a:	b2da      	uxtb	r2, r3
	device_gph_id = (psys_results->result__interrupt_status &
 800be4c:	193b      	adds	r3, r7, r4
 800be4e:	2102      	movs	r1, #2
 800be50:	400a      	ands	r2, r1
 800be52:	701a      	strb	r2, [r3, #0]

	/* only apply checks in back to back mode */

	if ((pdev->sys_ctrl.system__mode_start &
 800be54:	69ba      	ldr	r2, [r7, #24]
 800be56:	23e6      	movs	r3, #230	; 0xe6
 800be58:	005b      	lsls	r3, r3, #1
 800be5a:	5cd3      	ldrb	r3, [r2, r3]
 800be5c:	001a      	movs	r2, r3
 800be5e:	2320      	movs	r3, #32
 800be60:	4013      	ands	r3, r2
 800be62:	d023      	beq.n	800beac <VL53L1_check_ll_driver_rd_state+0xb6>
		 *
		 * In theory the stream count should zero for the GPH interrupt
		 * but that is not the case after at abort ....
		 */

		if (pstate->rd_device_state ==
 800be64:	697b      	ldr	r3, [r7, #20]
 800be66:	791b      	ldrb	r3, [r3, #4]
 800be68:	2b06      	cmp	r3, #6
 800be6a:	d109      	bne.n	800be80 <VL53L1_check_ll_driver_rd_state+0x8a>
			VL53L1_DEVICESTATE_RANGING_WAIT_GPH_SYNC) {

			if (device_range_status !=
 800be6c:	230f      	movs	r3, #15
 800be6e:	18fb      	adds	r3, r7, r3
 800be70:	781b      	ldrb	r3, [r3, #0]
 800be72:	2b12      	cmp	r3, #18
 800be74:	d01a      	beq.n	800beac <VL53L1_check_ll_driver_rd_state+0xb6>
				VL53L1_DEVICEERROR_GPHSTREAMCOUNT0READY) {
				status = VL53L1_ERROR_GPH_SYNC_CHECK_FAIL;
 800be76:	231f      	movs	r3, #31
 800be78:	18fb      	adds	r3, r7, r3
 800be7a:	22ef      	movs	r2, #239	; 0xef
 800be7c:	701a      	strb	r2, [r3, #0]
 800be7e:	e015      	b.n	800beac <VL53L1_check_ll_driver_rd_state+0xb6>
			}
		} else {
			if (pstate->rd_stream_count != device_stream_count) {
 800be80:	697b      	ldr	r3, [r7, #20]
 800be82:	795b      	ldrb	r3, [r3, #5]
 800be84:	220e      	movs	r2, #14
 800be86:	18ba      	adds	r2, r7, r2
 800be88:	7812      	ldrb	r2, [r2, #0]
 800be8a:	429a      	cmp	r2, r3
 800be8c:	d003      	beq.n	800be96 <VL53L1_check_ll_driver_rd_state+0xa0>
				status = VL53L1_ERROR_STREAM_COUNT_CHECK_FAIL;
 800be8e:	231f      	movs	r3, #31
 800be90:	18fb      	adds	r3, r7, r3
 800be92:	22ee      	movs	r2, #238	; 0xee
 800be94:	701a      	strb	r2, [r3, #0]

		/*
		 * Check Read state GPH ID
		 */

		if (pstate->rd_gph_id != device_gph_id) {
 800be96:	697b      	ldr	r3, [r7, #20]
 800be98:	799b      	ldrb	r3, [r3, #6]
 800be9a:	220d      	movs	r2, #13
 800be9c:	18ba      	adds	r2, r7, r2
 800be9e:	7812      	ldrb	r2, [r2, #0]
 800bea0:	429a      	cmp	r2, r3
 800bea2:	d003      	beq.n	800beac <VL53L1_check_ll_driver_rd_state+0xb6>
			status = VL53L1_ERROR_GPH_ID_CHECK_FAIL;
 800bea4:	231f      	movs	r3, #31
 800bea6:	18fb      	adds	r3, r7, r3
 800bea8:	22ed      	movs	r2, #237	; 0xed
 800beaa:	701a      	strb	r2, [r3, #0]

	} /* if back to back */

	LOG_FUNCTION_END(status);

	return status;
 800beac:	231f      	movs	r3, #31
 800beae:	18fb      	adds	r3, r7, r3
 800beb0:	781b      	ldrb	r3, [r3, #0]
 800beb2:	b25b      	sxtb	r3, r3
}
 800beb4:	0018      	movs	r0, r3
 800beb6:	46bd      	mov	sp, r7
 800beb8:	b009      	add	sp, #36	; 0x24
 800beba:	bd90      	pop	{r4, r7, pc}

0800bebc <VL53L1_update_ll_driver_cfg_state>:


VL53L1_Error  VL53L1_update_ll_driver_cfg_state(
	VL53L1_DEV         Dev)
{
 800bebc:	b580      	push	{r7, lr}
 800bebe:	b086      	sub	sp, #24
 800bec0:	af00      	add	r7, sp, #0
 800bec2:	6078      	str	r0, [r7, #4]
	/**
	 * State machine for configuration device state
	 */

	VL53L1_Error         status = VL53L1_ERROR_NONE;
 800bec4:	2317      	movs	r3, #23
 800bec6:	18fb      	adds	r3, r7, r3
 800bec8:	2200      	movs	r2, #0
 800beca:	701a      	strb	r2, [r3, #0]
	VL53L1_LLDriverData_t  *pdev =
 800becc:	687b      	ldr	r3, [r7, #4]
 800bece:	613b      	str	r3, [r7, #16]
			VL53L1DevStructGetLLDriverHandle(Dev);

	VL53L1_ll_driver_state_t *pstate = &(pdev->ll_state);
 800bed0:	693b      	ldr	r3, [r7, #16]
 800bed2:	332c      	adds	r3, #44	; 0x2c
 800bed4:	60fb      	str	r3, [r7, #12]
	VL53L1_print_ll_driver_state(pstate);
#endif

	/* if top bits of mode start reset are zero then in standby state */

	if ((pdev->sys_ctrl.system__mode_start &
 800bed6:	693a      	ldr	r2, [r7, #16]
 800bed8:	23e6      	movs	r3, #230	; 0xe6
 800beda:	005b      	lsls	r3, r3, #1
 800bedc:	5cd3      	ldrb	r3, [r2, r3]
 800bede:	001a      	movs	r2, r3
 800bee0:	23f0      	movs	r3, #240	; 0xf0
 800bee2:	4013      	ands	r3, r2
 800bee4:	d10c      	bne.n	800bf00 <VL53L1_update_ll_driver_cfg_state+0x44>
		VL53L1_DEVICEMEASUREMENTMODE_MODE_MASK) == 0x00) {

		pstate->cfg_device_state  = VL53L1_DEVICESTATE_SW_STANDBY;
 800bee6:	68fb      	ldr	r3, [r7, #12]
 800bee8:	2203      	movs	r2, #3
 800beea:	701a      	strb	r2, [r3, #0]
		pstate->cfg_stream_count  = 0;
 800beec:	68fb      	ldr	r3, [r7, #12]
 800beee:	2200      	movs	r2, #0
 800bef0:	705a      	strb	r2, [r3, #1]
		pstate->cfg_gph_id = VL53L1_GROUPEDPARAMETERHOLD_ID_MASK;
 800bef2:	68fb      	ldr	r3, [r7, #12]
 800bef4:	2202      	movs	r2, #2
 800bef6:	709a      	strb	r2, [r3, #2]
		pstate->cfg_timing_status = 0;
 800bef8:	68fb      	ldr	r3, [r7, #12]
 800befa:	2200      	movs	r2, #0
 800befc:	70da      	strb	r2, [r3, #3]
 800befe:	e03e      	b.n	800bf7e <VL53L1_update_ll_driver_cfg_state+0xc2>

		/*
		 * implement configuration stream count
		 */

		if (pstate->cfg_stream_count == 0xFF) {
 800bf00:	68fb      	ldr	r3, [r7, #12]
 800bf02:	785b      	ldrb	r3, [r3, #1]
 800bf04:	2bff      	cmp	r3, #255	; 0xff
 800bf06:	d103      	bne.n	800bf10 <VL53L1_update_ll_driver_cfg_state+0x54>
			pstate->cfg_stream_count = 0x80;
 800bf08:	68fb      	ldr	r3, [r7, #12]
 800bf0a:	2280      	movs	r2, #128	; 0x80
 800bf0c:	705a      	strb	r2, [r3, #1]
 800bf0e:	e005      	b.n	800bf1c <VL53L1_update_ll_driver_cfg_state+0x60>
		} else {
			pstate->cfg_stream_count++;
 800bf10:	68fb      	ldr	r3, [r7, #12]
 800bf12:	785b      	ldrb	r3, [r3, #1]
 800bf14:	3301      	adds	r3, #1
 800bf16:	b2da      	uxtb	r2, r3
 800bf18:	68fb      	ldr	r3, [r7, #12]
 800bf1a:	705a      	strb	r2, [r3, #1]

		/*
		 * Toggle grouped parameter hold ID
		 */

		pstate->cfg_gph_id ^= VL53L1_GROUPEDPARAMETERHOLD_ID_MASK;
 800bf1c:	68fb      	ldr	r3, [r7, #12]
 800bf1e:	789b      	ldrb	r3, [r3, #2]
 800bf20:	2202      	movs	r2, #2
 800bf22:	4053      	eors	r3, r2
 800bf24:	b2da      	uxtb	r2, r3
 800bf26:	68fb      	ldr	r3, [r7, #12]
 800bf28:	709a      	strb	r2, [r3, #2]

		/*
		 * Implement configuration state machine
		 */

		switch (pstate->cfg_device_state) {
 800bf2a:	68fb      	ldr	r3, [r7, #12]
 800bf2c:	781b      	ldrb	r3, [r3, #0]
 800bf2e:	2b03      	cmp	r3, #3
 800bf30:	d002      	beq.n	800bf38 <VL53L1_update_ll_driver_cfg_state+0x7c>
 800bf32:	2b04      	cmp	r3, #4
 800bf34:	d00e      	beq.n	800bf54 <VL53L1_update_ll_driver_cfg_state+0x98>
 800bf36:	e015      	b.n	800bf64 <VL53L1_update_ll_driver_cfg_state+0xa8>

		case VL53L1_DEVICESTATE_SW_STANDBY:

			pstate->cfg_timing_status ^= 0x01;
 800bf38:	68fb      	ldr	r3, [r7, #12]
 800bf3a:	78db      	ldrb	r3, [r3, #3]
 800bf3c:	2201      	movs	r2, #1
 800bf3e:	4053      	eors	r3, r2
 800bf40:	b2da      	uxtb	r2, r3
 800bf42:	68fb      	ldr	r3, [r7, #12]
 800bf44:	70da      	strb	r2, [r3, #3]
			pstate->cfg_stream_count = 1;
 800bf46:	68fb      	ldr	r3, [r7, #12]
 800bf48:	2201      	movs	r2, #1
 800bf4a:	705a      	strb	r2, [r3, #1]

			pstate->cfg_device_state = VL53L1_DEVICESTATE_RANGING_DSS_AUTO;
 800bf4c:	68fb      	ldr	r3, [r7, #12]
 800bf4e:	2204      	movs	r2, #4
 800bf50:	701a      	strb	r2, [r3, #0]
		break;
 800bf52:	e014      	b.n	800bf7e <VL53L1_update_ll_driver_cfg_state+0xc2>

		case VL53L1_DEVICESTATE_RANGING_DSS_AUTO:

			pstate->cfg_timing_status ^= 0x01;
 800bf54:	68fb      	ldr	r3, [r7, #12]
 800bf56:	78db      	ldrb	r3, [r3, #3]
 800bf58:	2201      	movs	r2, #1
 800bf5a:	4053      	eors	r3, r2
 800bf5c:	b2da      	uxtb	r2, r3
 800bf5e:	68fb      	ldr	r3, [r7, #12]
 800bf60:	70da      	strb	r2, [r3, #3]

		break;
 800bf62:	e00c      	b.n	800bf7e <VL53L1_update_ll_driver_cfg_state+0xc2>

		default:

			pstate->cfg_device_state = VL53L1_DEVICESTATE_SW_STANDBY;
 800bf64:	68fb      	ldr	r3, [r7, #12]
 800bf66:	2203      	movs	r2, #3
 800bf68:	701a      	strb	r2, [r3, #0]
			pstate->cfg_stream_count = 0;
 800bf6a:	68fb      	ldr	r3, [r7, #12]
 800bf6c:	2200      	movs	r2, #0
 800bf6e:	705a      	strb	r2, [r3, #1]
			pstate->cfg_gph_id = VL53L1_GROUPEDPARAMETERHOLD_ID_MASK;
 800bf70:	68fb      	ldr	r3, [r7, #12]
 800bf72:	2202      	movs	r2, #2
 800bf74:	709a      	strb	r2, [r3, #2]
			pstate->cfg_timing_status = 0;
 800bf76:	68fb      	ldr	r3, [r7, #12]
 800bf78:	2200      	movs	r2, #0
 800bf7a:	70da      	strb	r2, [r3, #3]

		break;
 800bf7c:	46c0      	nop			; (mov r8, r8)
	VL53L1_print_ll_driver_state(pstate);
#endif

	LOG_FUNCTION_END(status);

	return status;
 800bf7e:	2317      	movs	r3, #23
 800bf80:	18fb      	adds	r3, r7, r3
 800bf82:	781b      	ldrb	r3, [r3, #0]
 800bf84:	b25b      	sxtb	r3, r3
}
 800bf86:	0018      	movs	r0, r3
 800bf88:	46bd      	mov	sp, r7
 800bf8a:	b006      	add	sp, #24
 800bf8c:	bd80      	pop	{r7, pc}

0800bf8e <VL53L1_copy_rtn_good_spads_to_buffer>:


void VL53L1_copy_rtn_good_spads_to_buffer(
	VL53L1_nvm_copy_data_t  *pdata,
	uint8_t                 *pbuffer)
{
 800bf8e:	b580      	push	{r7, lr}
 800bf90:	b082      	sub	sp, #8
 800bf92:	af00      	add	r7, sp, #0
 800bf94:	6078      	str	r0, [r7, #4]
 800bf96:	6039      	str	r1, [r7, #0]
	/*
	 * Convenience function to copy return SPAD enables to buffer
	 */

	*(pbuffer +  0) = pdata->global_config__spad_enables_rtn_0;
 800bf98:	687b      	ldr	r3, [r7, #4]
 800bf9a:	7c1a      	ldrb	r2, [r3, #16]
 800bf9c:	683b      	ldr	r3, [r7, #0]
 800bf9e:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  1) = pdata->global_config__spad_enables_rtn_1;
 800bfa0:	683b      	ldr	r3, [r7, #0]
 800bfa2:	3301      	adds	r3, #1
 800bfa4:	687a      	ldr	r2, [r7, #4]
 800bfa6:	7c52      	ldrb	r2, [r2, #17]
 800bfa8:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  2) = pdata->global_config__spad_enables_rtn_2;
 800bfaa:	683b      	ldr	r3, [r7, #0]
 800bfac:	3302      	adds	r3, #2
 800bfae:	687a      	ldr	r2, [r7, #4]
 800bfb0:	7c92      	ldrb	r2, [r2, #18]
 800bfb2:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  3) = pdata->global_config__spad_enables_rtn_3;
 800bfb4:	683b      	ldr	r3, [r7, #0]
 800bfb6:	3303      	adds	r3, #3
 800bfb8:	687a      	ldr	r2, [r7, #4]
 800bfba:	7cd2      	ldrb	r2, [r2, #19]
 800bfbc:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  4) = pdata->global_config__spad_enables_rtn_4;
 800bfbe:	683b      	ldr	r3, [r7, #0]
 800bfc0:	3304      	adds	r3, #4
 800bfc2:	687a      	ldr	r2, [r7, #4]
 800bfc4:	7d12      	ldrb	r2, [r2, #20]
 800bfc6:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  5) = pdata->global_config__spad_enables_rtn_5;
 800bfc8:	683b      	ldr	r3, [r7, #0]
 800bfca:	3305      	adds	r3, #5
 800bfcc:	687a      	ldr	r2, [r7, #4]
 800bfce:	7d52      	ldrb	r2, [r2, #21]
 800bfd0:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  6) = pdata->global_config__spad_enables_rtn_6;
 800bfd2:	683b      	ldr	r3, [r7, #0]
 800bfd4:	3306      	adds	r3, #6
 800bfd6:	687a      	ldr	r2, [r7, #4]
 800bfd8:	7d92      	ldrb	r2, [r2, #22]
 800bfda:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  7) = pdata->global_config__spad_enables_rtn_7;
 800bfdc:	683b      	ldr	r3, [r7, #0]
 800bfde:	3307      	adds	r3, #7
 800bfe0:	687a      	ldr	r2, [r7, #4]
 800bfe2:	7dd2      	ldrb	r2, [r2, #23]
 800bfe4:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  8) = pdata->global_config__spad_enables_rtn_8;
 800bfe6:	683b      	ldr	r3, [r7, #0]
 800bfe8:	3308      	adds	r3, #8
 800bfea:	687a      	ldr	r2, [r7, #4]
 800bfec:	7e12      	ldrb	r2, [r2, #24]
 800bfee:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  9) = pdata->global_config__spad_enables_rtn_9;
 800bff0:	683b      	ldr	r3, [r7, #0]
 800bff2:	3309      	adds	r3, #9
 800bff4:	687a      	ldr	r2, [r7, #4]
 800bff6:	7e52      	ldrb	r2, [r2, #25]
 800bff8:	701a      	strb	r2, [r3, #0]
	*(pbuffer + 10) = pdata->global_config__spad_enables_rtn_10;
 800bffa:	683b      	ldr	r3, [r7, #0]
 800bffc:	330a      	adds	r3, #10
 800bffe:	687a      	ldr	r2, [r7, #4]
 800c000:	7e92      	ldrb	r2, [r2, #26]
 800c002:	701a      	strb	r2, [r3, #0]
	*(pbuffer + 11) = pdata->global_config__spad_enables_rtn_11;
 800c004:	683b      	ldr	r3, [r7, #0]
 800c006:	330b      	adds	r3, #11
 800c008:	687a      	ldr	r2, [r7, #4]
 800c00a:	7ed2      	ldrb	r2, [r2, #27]
 800c00c:	701a      	strb	r2, [r3, #0]
	*(pbuffer + 12) = pdata->global_config__spad_enables_rtn_12;
 800c00e:	683b      	ldr	r3, [r7, #0]
 800c010:	330c      	adds	r3, #12
 800c012:	687a      	ldr	r2, [r7, #4]
 800c014:	7f12      	ldrb	r2, [r2, #28]
 800c016:	701a      	strb	r2, [r3, #0]
	*(pbuffer + 13) = pdata->global_config__spad_enables_rtn_13;
 800c018:	683b      	ldr	r3, [r7, #0]
 800c01a:	330d      	adds	r3, #13
 800c01c:	687a      	ldr	r2, [r7, #4]
 800c01e:	7f52      	ldrb	r2, [r2, #29]
 800c020:	701a      	strb	r2, [r3, #0]
	*(pbuffer + 14) = pdata->global_config__spad_enables_rtn_14;
 800c022:	683b      	ldr	r3, [r7, #0]
 800c024:	330e      	adds	r3, #14
 800c026:	687a      	ldr	r2, [r7, #4]
 800c028:	7f92      	ldrb	r2, [r2, #30]
 800c02a:	701a      	strb	r2, [r3, #0]
	*(pbuffer + 15) = pdata->global_config__spad_enables_rtn_15;
 800c02c:	683b      	ldr	r3, [r7, #0]
 800c02e:	330f      	adds	r3, #15
 800c030:	687a      	ldr	r2, [r7, #4]
 800c032:	7fd2      	ldrb	r2, [r2, #31]
 800c034:	701a      	strb	r2, [r3, #0]
	*(pbuffer + 16) = pdata->global_config__spad_enables_rtn_16;
 800c036:	683b      	ldr	r3, [r7, #0]
 800c038:	3310      	adds	r3, #16
 800c03a:	687a      	ldr	r2, [r7, #4]
 800c03c:	2120      	movs	r1, #32
 800c03e:	5c52      	ldrb	r2, [r2, r1]
 800c040:	701a      	strb	r2, [r3, #0]
	*(pbuffer + 17) = pdata->global_config__spad_enables_rtn_17;
 800c042:	683b      	ldr	r3, [r7, #0]
 800c044:	3311      	adds	r3, #17
 800c046:	687a      	ldr	r2, [r7, #4]
 800c048:	2121      	movs	r1, #33	; 0x21
 800c04a:	5c52      	ldrb	r2, [r2, r1]
 800c04c:	701a      	strb	r2, [r3, #0]
	*(pbuffer + 18) = pdata->global_config__spad_enables_rtn_18;
 800c04e:	683b      	ldr	r3, [r7, #0]
 800c050:	3312      	adds	r3, #18
 800c052:	687a      	ldr	r2, [r7, #4]
 800c054:	2122      	movs	r1, #34	; 0x22
 800c056:	5c52      	ldrb	r2, [r2, r1]
 800c058:	701a      	strb	r2, [r3, #0]
	*(pbuffer + 19) = pdata->global_config__spad_enables_rtn_19;
 800c05a:	683b      	ldr	r3, [r7, #0]
 800c05c:	3313      	adds	r3, #19
 800c05e:	687a      	ldr	r2, [r7, #4]
 800c060:	2123      	movs	r1, #35	; 0x23
 800c062:	5c52      	ldrb	r2, [r2, r1]
 800c064:	701a      	strb	r2, [r3, #0]
	*(pbuffer + 20) = pdata->global_config__spad_enables_rtn_20;
 800c066:	683b      	ldr	r3, [r7, #0]
 800c068:	3314      	adds	r3, #20
 800c06a:	687a      	ldr	r2, [r7, #4]
 800c06c:	2124      	movs	r1, #36	; 0x24
 800c06e:	5c52      	ldrb	r2, [r2, r1]
 800c070:	701a      	strb	r2, [r3, #0]
	*(pbuffer + 21) = pdata->global_config__spad_enables_rtn_21;
 800c072:	683b      	ldr	r3, [r7, #0]
 800c074:	3315      	adds	r3, #21
 800c076:	687a      	ldr	r2, [r7, #4]
 800c078:	2125      	movs	r1, #37	; 0x25
 800c07a:	5c52      	ldrb	r2, [r2, r1]
 800c07c:	701a      	strb	r2, [r3, #0]
	*(pbuffer + 22) = pdata->global_config__spad_enables_rtn_22;
 800c07e:	683b      	ldr	r3, [r7, #0]
 800c080:	3316      	adds	r3, #22
 800c082:	687a      	ldr	r2, [r7, #4]
 800c084:	2126      	movs	r1, #38	; 0x26
 800c086:	5c52      	ldrb	r2, [r2, r1]
 800c088:	701a      	strb	r2, [r3, #0]
	*(pbuffer + 23) = pdata->global_config__spad_enables_rtn_23;
 800c08a:	683b      	ldr	r3, [r7, #0]
 800c08c:	3317      	adds	r3, #23
 800c08e:	687a      	ldr	r2, [r7, #4]
 800c090:	2127      	movs	r1, #39	; 0x27
 800c092:	5c52      	ldrb	r2, [r2, r1]
 800c094:	701a      	strb	r2, [r3, #0]
	*(pbuffer + 24) = pdata->global_config__spad_enables_rtn_24;
 800c096:	683b      	ldr	r3, [r7, #0]
 800c098:	3318      	adds	r3, #24
 800c09a:	687a      	ldr	r2, [r7, #4]
 800c09c:	2128      	movs	r1, #40	; 0x28
 800c09e:	5c52      	ldrb	r2, [r2, r1]
 800c0a0:	701a      	strb	r2, [r3, #0]
	*(pbuffer + 25) = pdata->global_config__spad_enables_rtn_25;
 800c0a2:	683b      	ldr	r3, [r7, #0]
 800c0a4:	3319      	adds	r3, #25
 800c0a6:	687a      	ldr	r2, [r7, #4]
 800c0a8:	2129      	movs	r1, #41	; 0x29
 800c0aa:	5c52      	ldrb	r2, [r2, r1]
 800c0ac:	701a      	strb	r2, [r3, #0]
	*(pbuffer + 26) = pdata->global_config__spad_enables_rtn_26;
 800c0ae:	683b      	ldr	r3, [r7, #0]
 800c0b0:	331a      	adds	r3, #26
 800c0b2:	687a      	ldr	r2, [r7, #4]
 800c0b4:	212a      	movs	r1, #42	; 0x2a
 800c0b6:	5c52      	ldrb	r2, [r2, r1]
 800c0b8:	701a      	strb	r2, [r3, #0]
	*(pbuffer + 27) = pdata->global_config__spad_enables_rtn_27;
 800c0ba:	683b      	ldr	r3, [r7, #0]
 800c0bc:	331b      	adds	r3, #27
 800c0be:	687a      	ldr	r2, [r7, #4]
 800c0c0:	212b      	movs	r1, #43	; 0x2b
 800c0c2:	5c52      	ldrb	r2, [r2, r1]
 800c0c4:	701a      	strb	r2, [r3, #0]
	*(pbuffer + 28) = pdata->global_config__spad_enables_rtn_28;
 800c0c6:	683b      	ldr	r3, [r7, #0]
 800c0c8:	331c      	adds	r3, #28
 800c0ca:	687a      	ldr	r2, [r7, #4]
 800c0cc:	212c      	movs	r1, #44	; 0x2c
 800c0ce:	5c52      	ldrb	r2, [r2, r1]
 800c0d0:	701a      	strb	r2, [r3, #0]
	*(pbuffer + 29) = pdata->global_config__spad_enables_rtn_29;
 800c0d2:	683b      	ldr	r3, [r7, #0]
 800c0d4:	331d      	adds	r3, #29
 800c0d6:	687a      	ldr	r2, [r7, #4]
 800c0d8:	212d      	movs	r1, #45	; 0x2d
 800c0da:	5c52      	ldrb	r2, [r2, r1]
 800c0dc:	701a      	strb	r2, [r3, #0]
	*(pbuffer + 30) = pdata->global_config__spad_enables_rtn_30;
 800c0de:	683b      	ldr	r3, [r7, #0]
 800c0e0:	331e      	adds	r3, #30
 800c0e2:	687a      	ldr	r2, [r7, #4]
 800c0e4:	212e      	movs	r1, #46	; 0x2e
 800c0e6:	5c52      	ldrb	r2, [r2, r1]
 800c0e8:	701a      	strb	r2, [r3, #0]
	*(pbuffer + 31) = pdata->global_config__spad_enables_rtn_31;
 800c0ea:	683b      	ldr	r3, [r7, #0]
 800c0ec:	331f      	adds	r3, #31
 800c0ee:	687a      	ldr	r2, [r7, #4]
 800c0f0:	212f      	movs	r1, #47	; 0x2f
 800c0f2:	5c52      	ldrb	r2, [r2, r1]
 800c0f4:	701a      	strb	r2, [r3, #0]
}
 800c0f6:	46c0      	nop			; (mov r8, r8)
 800c0f8:	46bd      	mov	sp, r7
 800c0fa:	b002      	add	sp, #8
 800c0fc:	bd80      	pop	{r7, pc}

0800c0fe <VL53L1_i2c_encode_uint16_t>:

void VL53L1_i2c_encode_uint16_t(
	uint16_t    ip_value,
	uint16_t    count,
	uint8_t    *pbuffer)
{
 800c0fe:	b580      	push	{r7, lr}
 800c100:	b084      	sub	sp, #16
 800c102:	af00      	add	r7, sp, #0
 800c104:	603a      	str	r2, [r7, #0]
 800c106:	1dbb      	adds	r3, r7, #6
 800c108:	1c02      	adds	r2, r0, #0
 800c10a:	801a      	strh	r2, [r3, #0]
 800c10c:	1d3b      	adds	r3, r7, #4
 800c10e:	1c0a      	adds	r2, r1, #0
 800c110:	801a      	strh	r2, [r3, #0]
	/*
	 * Encodes a uint16_t register value into an I2C write buffer
	 * MS byte first order (as per I2C register map.
	 */

	uint16_t   i    = 0;
 800c112:	210e      	movs	r1, #14
 800c114:	187b      	adds	r3, r7, r1
 800c116:	2200      	movs	r2, #0
 800c118:	801a      	strh	r2, [r3, #0]
	uint16_t   data = 0;
 800c11a:	200c      	movs	r0, #12
 800c11c:	183b      	adds	r3, r7, r0
 800c11e:	2200      	movs	r2, #0
 800c120:	801a      	strh	r2, [r3, #0]

	data =  ip_value;
 800c122:	183b      	adds	r3, r7, r0
 800c124:	1dba      	adds	r2, r7, #6
 800c126:	8812      	ldrh	r2, [r2, #0]
 800c128:	801a      	strh	r2, [r3, #0]

	for (i = 0; i < count ; i++) {
 800c12a:	187b      	adds	r3, r7, r1
 800c12c:	2200      	movs	r2, #0
 800c12e:	801a      	strh	r2, [r3, #0]
 800c130:	e017      	b.n	800c162 <VL53L1_i2c_encode_uint16_t+0x64>
		pbuffer[count-i-1] = (uint8_t)(data & 0x00FF);
 800c132:	1d3b      	adds	r3, r7, #4
 800c134:	881a      	ldrh	r2, [r3, #0]
 800c136:	210e      	movs	r1, #14
 800c138:	187b      	adds	r3, r7, r1
 800c13a:	881b      	ldrh	r3, [r3, #0]
 800c13c:	1ad3      	subs	r3, r2, r3
 800c13e:	3b01      	subs	r3, #1
 800c140:	683a      	ldr	r2, [r7, #0]
 800c142:	18d3      	adds	r3, r2, r3
 800c144:	200c      	movs	r0, #12
 800c146:	183a      	adds	r2, r7, r0
 800c148:	8812      	ldrh	r2, [r2, #0]
 800c14a:	b2d2      	uxtb	r2, r2
 800c14c:	701a      	strb	r2, [r3, #0]
		data = data >> 8;
 800c14e:	183b      	adds	r3, r7, r0
 800c150:	183a      	adds	r2, r7, r0
 800c152:	8812      	ldrh	r2, [r2, #0]
 800c154:	0a12      	lsrs	r2, r2, #8
 800c156:	801a      	strh	r2, [r3, #0]
	for (i = 0; i < count ; i++) {
 800c158:	187b      	adds	r3, r7, r1
 800c15a:	881a      	ldrh	r2, [r3, #0]
 800c15c:	187b      	adds	r3, r7, r1
 800c15e:	3201      	adds	r2, #1
 800c160:	801a      	strh	r2, [r3, #0]
 800c162:	230e      	movs	r3, #14
 800c164:	18fa      	adds	r2, r7, r3
 800c166:	1d3b      	adds	r3, r7, #4
 800c168:	8812      	ldrh	r2, [r2, #0]
 800c16a:	881b      	ldrh	r3, [r3, #0]
 800c16c:	429a      	cmp	r2, r3
 800c16e:	d3e0      	bcc.n	800c132 <VL53L1_i2c_encode_uint16_t+0x34>
	}
}
 800c170:	46c0      	nop			; (mov r8, r8)
 800c172:	46bd      	mov	sp, r7
 800c174:	b004      	add	sp, #16
 800c176:	bd80      	pop	{r7, pc}

0800c178 <VL53L1_i2c_decode_uint16_t>:

uint16_t VL53L1_i2c_decode_uint16_t(
	uint16_t    count,
	uint8_t    *pbuffer)
{
 800c178:	b580      	push	{r7, lr}
 800c17a:	b084      	sub	sp, #16
 800c17c:	af00      	add	r7, sp, #0
 800c17e:	0002      	movs	r2, r0
 800c180:	6039      	str	r1, [r7, #0]
 800c182:	1dbb      	adds	r3, r7, #6
 800c184:	801a      	strh	r2, [r3, #0]
	/*
	 * Decodes a uint16_t from the input I2C read buffer
	 * (MS byte first order)
	 */

	uint16_t   value = 0x00;
 800c186:	230e      	movs	r3, #14
 800c188:	18fb      	adds	r3, r7, r3
 800c18a:	2200      	movs	r2, #0
 800c18c:	801a      	strh	r2, [r3, #0]

	while (count-- > 0) {
 800c18e:	e00d      	b.n	800c1ac <VL53L1_i2c_decode_uint16_t+0x34>
		value = (value << 8) | (uint16_t)*pbuffer++;
 800c190:	200e      	movs	r0, #14
 800c192:	183b      	adds	r3, r7, r0
 800c194:	881b      	ldrh	r3, [r3, #0]
 800c196:	021b      	lsls	r3, r3, #8
 800c198:	b21a      	sxth	r2, r3
 800c19a:	683b      	ldr	r3, [r7, #0]
 800c19c:	1c59      	adds	r1, r3, #1
 800c19e:	6039      	str	r1, [r7, #0]
 800c1a0:	781b      	ldrb	r3, [r3, #0]
 800c1a2:	b21b      	sxth	r3, r3
 800c1a4:	4313      	orrs	r3, r2
 800c1a6:	b21a      	sxth	r2, r3
 800c1a8:	183b      	adds	r3, r7, r0
 800c1aa:	801a      	strh	r2, [r3, #0]
	while (count-- > 0) {
 800c1ac:	1dbb      	adds	r3, r7, #6
 800c1ae:	881b      	ldrh	r3, [r3, #0]
 800c1b0:	1dba      	adds	r2, r7, #6
 800c1b2:	1e59      	subs	r1, r3, #1
 800c1b4:	8011      	strh	r1, [r2, #0]
 800c1b6:	2b00      	cmp	r3, #0
 800c1b8:	d1ea      	bne.n	800c190 <VL53L1_i2c_decode_uint16_t+0x18>
	}

	return value;
 800c1ba:	230e      	movs	r3, #14
 800c1bc:	18fb      	adds	r3, r7, r3
 800c1be:	881b      	ldrh	r3, [r3, #0]
}
 800c1c0:	0018      	movs	r0, r3
 800c1c2:	46bd      	mov	sp, r7
 800c1c4:	b004      	add	sp, #16
 800c1c6:	bd80      	pop	{r7, pc}

0800c1c8 <VL53L1_i2c_encode_int16_t>:

void VL53L1_i2c_encode_int16_t(
	int16_t     ip_value,
	uint16_t    count,
	uint8_t    *pbuffer)
{
 800c1c8:	b580      	push	{r7, lr}
 800c1ca:	b084      	sub	sp, #16
 800c1cc:	af00      	add	r7, sp, #0
 800c1ce:	603a      	str	r2, [r7, #0]
 800c1d0:	1dbb      	adds	r3, r7, #6
 800c1d2:	1c02      	adds	r2, r0, #0
 800c1d4:	801a      	strh	r2, [r3, #0]
 800c1d6:	1d3b      	adds	r3, r7, #4
 800c1d8:	1c0a      	adds	r2, r1, #0
 800c1da:	801a      	strh	r2, [r3, #0]
	/*
	 * Encodes a int16_t register value into an I2C write buffer
	 * MS byte first order (as per I2C register map.
	 */

	uint16_t   i    = 0;
 800c1dc:	210e      	movs	r1, #14
 800c1de:	187b      	adds	r3, r7, r1
 800c1e0:	2200      	movs	r2, #0
 800c1e2:	801a      	strh	r2, [r3, #0]
	int16_t    data = 0;
 800c1e4:	200c      	movs	r0, #12
 800c1e6:	183b      	adds	r3, r7, r0
 800c1e8:	2200      	movs	r2, #0
 800c1ea:	801a      	strh	r2, [r3, #0]

	data =  ip_value;
 800c1ec:	183b      	adds	r3, r7, r0
 800c1ee:	1dba      	adds	r2, r7, #6
 800c1f0:	8812      	ldrh	r2, [r2, #0]
 800c1f2:	801a      	strh	r2, [r3, #0]

	for (i = 0; i < count ; i++) {
 800c1f4:	187b      	adds	r3, r7, r1
 800c1f6:	2200      	movs	r2, #0
 800c1f8:	801a      	strh	r2, [r3, #0]
 800c1fa:	e018      	b.n	800c22e <VL53L1_i2c_encode_int16_t+0x66>
		pbuffer[count-i-1] = (uint8_t)(data & 0x00FF);
 800c1fc:	1d3b      	adds	r3, r7, #4
 800c1fe:	881a      	ldrh	r2, [r3, #0]
 800c200:	210e      	movs	r1, #14
 800c202:	187b      	adds	r3, r7, r1
 800c204:	881b      	ldrh	r3, [r3, #0]
 800c206:	1ad3      	subs	r3, r2, r3
 800c208:	3b01      	subs	r3, #1
 800c20a:	683a      	ldr	r2, [r7, #0]
 800c20c:	18d3      	adds	r3, r2, r3
 800c20e:	200c      	movs	r0, #12
 800c210:	183a      	adds	r2, r7, r0
 800c212:	8812      	ldrh	r2, [r2, #0]
 800c214:	b2d2      	uxtb	r2, r2
 800c216:	701a      	strb	r2, [r3, #0]
		data = data >> 8;
 800c218:	183b      	adds	r3, r7, r0
 800c21a:	183a      	adds	r2, r7, r0
 800c21c:	2000      	movs	r0, #0
 800c21e:	5e12      	ldrsh	r2, [r2, r0]
 800c220:	1212      	asrs	r2, r2, #8
 800c222:	801a      	strh	r2, [r3, #0]
	for (i = 0; i < count ; i++) {
 800c224:	187b      	adds	r3, r7, r1
 800c226:	881a      	ldrh	r2, [r3, #0]
 800c228:	187b      	adds	r3, r7, r1
 800c22a:	3201      	adds	r2, #1
 800c22c:	801a      	strh	r2, [r3, #0]
 800c22e:	230e      	movs	r3, #14
 800c230:	18fa      	adds	r2, r7, r3
 800c232:	1d3b      	adds	r3, r7, #4
 800c234:	8812      	ldrh	r2, [r2, #0]
 800c236:	881b      	ldrh	r3, [r3, #0]
 800c238:	429a      	cmp	r2, r3
 800c23a:	d3df      	bcc.n	800c1fc <VL53L1_i2c_encode_int16_t+0x34>
	}
}
 800c23c:	46c0      	nop			; (mov r8, r8)
 800c23e:	46bd      	mov	sp, r7
 800c240:	b004      	add	sp, #16
 800c242:	bd80      	pop	{r7, pc}

0800c244 <VL53L1_i2c_decode_int16_t>:

int16_t VL53L1_i2c_decode_int16_t(
	uint16_t    count,
	uint8_t    *pbuffer)
{
 800c244:	b580      	push	{r7, lr}
 800c246:	b084      	sub	sp, #16
 800c248:	af00      	add	r7, sp, #0
 800c24a:	0002      	movs	r2, r0
 800c24c:	6039      	str	r1, [r7, #0]
 800c24e:	1dbb      	adds	r3, r7, #6
 800c250:	801a      	strh	r2, [r3, #0]
	/*
	 * Decodes a int16_t from the input I2C read buffer
	 * (MS byte first order)
	 */

	int16_t    value = 0x00;
 800c252:	230e      	movs	r3, #14
 800c254:	18fb      	adds	r3, r7, r3
 800c256:	2200      	movs	r2, #0
 800c258:	801a      	strh	r2, [r3, #0]

	/* implement sign extension */
	if (*pbuffer >= 0x80) {
 800c25a:	683b      	ldr	r3, [r7, #0]
 800c25c:	781b      	ldrb	r3, [r3, #0]
 800c25e:	b25b      	sxtb	r3, r3
 800c260:	2b00      	cmp	r3, #0
 800c262:	da13      	bge.n	800c28c <VL53L1_i2c_decode_int16_t+0x48>
		value = 0xFFFF;
 800c264:	230e      	movs	r3, #14
 800c266:	18fb      	adds	r3, r7, r3
 800c268:	2201      	movs	r2, #1
 800c26a:	4252      	negs	r2, r2
 800c26c:	801a      	strh	r2, [r3, #0]
	}

	while (count-- > 0) {
 800c26e:	e00d      	b.n	800c28c <VL53L1_i2c_decode_int16_t+0x48>
		value = (value << 8) | (int16_t)*pbuffer++;
 800c270:	200e      	movs	r0, #14
 800c272:	183b      	adds	r3, r7, r0
 800c274:	2200      	movs	r2, #0
 800c276:	5e9b      	ldrsh	r3, [r3, r2]
 800c278:	021b      	lsls	r3, r3, #8
 800c27a:	b219      	sxth	r1, r3
 800c27c:	683b      	ldr	r3, [r7, #0]
 800c27e:	1c5a      	adds	r2, r3, #1
 800c280:	603a      	str	r2, [r7, #0]
 800c282:	781b      	ldrb	r3, [r3, #0]
 800c284:	b21a      	sxth	r2, r3
 800c286:	183b      	adds	r3, r7, r0
 800c288:	430a      	orrs	r2, r1
 800c28a:	801a      	strh	r2, [r3, #0]
	while (count-- > 0) {
 800c28c:	1dbb      	adds	r3, r7, #6
 800c28e:	881b      	ldrh	r3, [r3, #0]
 800c290:	1dba      	adds	r2, r7, #6
 800c292:	1e59      	subs	r1, r3, #1
 800c294:	8011      	strh	r1, [r2, #0]
 800c296:	2b00      	cmp	r3, #0
 800c298:	d1ea      	bne.n	800c270 <VL53L1_i2c_decode_int16_t+0x2c>
	}

	return value;
 800c29a:	230e      	movs	r3, #14
 800c29c:	18fb      	adds	r3, r7, r3
 800c29e:	2200      	movs	r2, #0
 800c2a0:	5e9b      	ldrsh	r3, [r3, r2]
}
 800c2a2:	0018      	movs	r0, r3
 800c2a4:	46bd      	mov	sp, r7
 800c2a6:	b004      	add	sp, #16
 800c2a8:	bd80      	pop	{r7, pc}

0800c2aa <VL53L1_i2c_encode_uint32_t>:

void VL53L1_i2c_encode_uint32_t(
	uint32_t    ip_value,
	uint16_t    count,
	uint8_t    *pbuffer)
{
 800c2aa:	b580      	push	{r7, lr}
 800c2ac:	b086      	sub	sp, #24
 800c2ae:	af00      	add	r7, sp, #0
 800c2b0:	60f8      	str	r0, [r7, #12]
 800c2b2:	607a      	str	r2, [r7, #4]
 800c2b4:	230a      	movs	r3, #10
 800c2b6:	18fb      	adds	r3, r7, r3
 800c2b8:	1c0a      	adds	r2, r1, #0
 800c2ba:	801a      	strh	r2, [r3, #0]
	/*
	 * Encodes a uint32_t register value into an I2C write buffer
	 * MS byte first order (as per I2C register map.
	 */

	uint16_t   i    = 0;
 800c2bc:	2116      	movs	r1, #22
 800c2be:	187b      	adds	r3, r7, r1
 800c2c0:	2200      	movs	r2, #0
 800c2c2:	801a      	strh	r2, [r3, #0]
	uint32_t   data = 0;
 800c2c4:	2300      	movs	r3, #0
 800c2c6:	613b      	str	r3, [r7, #16]

	data =  ip_value;
 800c2c8:	68fb      	ldr	r3, [r7, #12]
 800c2ca:	613b      	str	r3, [r7, #16]

	for (i = 0; i < count ; i++) {
 800c2cc:	187b      	adds	r3, r7, r1
 800c2ce:	2200      	movs	r2, #0
 800c2d0:	801a      	strh	r2, [r3, #0]
 800c2d2:	e014      	b.n	800c2fe <VL53L1_i2c_encode_uint32_t+0x54>
		pbuffer[count-i-1] = (uint8_t)(data & 0x00FF);
 800c2d4:	230a      	movs	r3, #10
 800c2d6:	18fb      	adds	r3, r7, r3
 800c2d8:	881a      	ldrh	r2, [r3, #0]
 800c2da:	2116      	movs	r1, #22
 800c2dc:	187b      	adds	r3, r7, r1
 800c2de:	881b      	ldrh	r3, [r3, #0]
 800c2e0:	1ad3      	subs	r3, r2, r3
 800c2e2:	3b01      	subs	r3, #1
 800c2e4:	687a      	ldr	r2, [r7, #4]
 800c2e6:	18d3      	adds	r3, r2, r3
 800c2e8:	693a      	ldr	r2, [r7, #16]
 800c2ea:	b2d2      	uxtb	r2, r2
 800c2ec:	701a      	strb	r2, [r3, #0]
		data = data >> 8;
 800c2ee:	693b      	ldr	r3, [r7, #16]
 800c2f0:	0a1b      	lsrs	r3, r3, #8
 800c2f2:	613b      	str	r3, [r7, #16]
	for (i = 0; i < count ; i++) {
 800c2f4:	187b      	adds	r3, r7, r1
 800c2f6:	881a      	ldrh	r2, [r3, #0]
 800c2f8:	187b      	adds	r3, r7, r1
 800c2fa:	3201      	adds	r2, #1
 800c2fc:	801a      	strh	r2, [r3, #0]
 800c2fe:	2316      	movs	r3, #22
 800c300:	18fa      	adds	r2, r7, r3
 800c302:	230a      	movs	r3, #10
 800c304:	18fb      	adds	r3, r7, r3
 800c306:	8812      	ldrh	r2, [r2, #0]
 800c308:	881b      	ldrh	r3, [r3, #0]
 800c30a:	429a      	cmp	r2, r3
 800c30c:	d3e2      	bcc.n	800c2d4 <VL53L1_i2c_encode_uint32_t+0x2a>
	}
}
 800c30e:	46c0      	nop			; (mov r8, r8)
 800c310:	46bd      	mov	sp, r7
 800c312:	b006      	add	sp, #24
 800c314:	bd80      	pop	{r7, pc}

0800c316 <VL53L1_i2c_decode_uint32_t>:

uint32_t VL53L1_i2c_decode_uint32_t(
	uint16_t    count,
	uint8_t    *pbuffer)
{
 800c316:	b580      	push	{r7, lr}
 800c318:	b084      	sub	sp, #16
 800c31a:	af00      	add	r7, sp, #0
 800c31c:	0002      	movs	r2, r0
 800c31e:	6039      	str	r1, [r7, #0]
 800c320:	1dbb      	adds	r3, r7, #6
 800c322:	801a      	strh	r2, [r3, #0]
	/*
	 * Decodes a uint32_t from the input I2C read buffer
	 * (MS byte first order)
	 */

	uint32_t   value = 0x00;
 800c324:	2300      	movs	r3, #0
 800c326:	60fb      	str	r3, [r7, #12]

	while (count-- > 0) {
 800c328:	e007      	b.n	800c33a <VL53L1_i2c_decode_uint32_t+0x24>
		value = (value << 8) | (uint32_t)*pbuffer++;
 800c32a:	68fb      	ldr	r3, [r7, #12]
 800c32c:	021a      	lsls	r2, r3, #8
 800c32e:	683b      	ldr	r3, [r7, #0]
 800c330:	1c59      	adds	r1, r3, #1
 800c332:	6039      	str	r1, [r7, #0]
 800c334:	781b      	ldrb	r3, [r3, #0]
 800c336:	4313      	orrs	r3, r2
 800c338:	60fb      	str	r3, [r7, #12]
	while (count-- > 0) {
 800c33a:	1dbb      	adds	r3, r7, #6
 800c33c:	881b      	ldrh	r3, [r3, #0]
 800c33e:	1dba      	adds	r2, r7, #6
 800c340:	1e59      	subs	r1, r3, #1
 800c342:	8011      	strh	r1, [r2, #0]
 800c344:	2b00      	cmp	r3, #0
 800c346:	d1f0      	bne.n	800c32a <VL53L1_i2c_decode_uint32_t+0x14>
	}

	return value;
 800c348:	68fb      	ldr	r3, [r7, #12]
}
 800c34a:	0018      	movs	r0, r3
 800c34c:	46bd      	mov	sp, r7
 800c34e:	b004      	add	sp, #16
 800c350:	bd80      	pop	{r7, pc}

0800c352 <VL53L1_i2c_decode_int32_t>:
}

int32_t VL53L1_i2c_decode_int32_t(
	uint16_t    count,
	uint8_t    *pbuffer)
{
 800c352:	b580      	push	{r7, lr}
 800c354:	b084      	sub	sp, #16
 800c356:	af00      	add	r7, sp, #0
 800c358:	0002      	movs	r2, r0
 800c35a:	6039      	str	r1, [r7, #0]
 800c35c:	1dbb      	adds	r3, r7, #6
 800c35e:	801a      	strh	r2, [r3, #0]
	/*
	 * Decodes a int32_t from the input I2C read buffer
	 * (MS byte first order)
	 */

	int32_t    value = 0x00;
 800c360:	2300      	movs	r3, #0
 800c362:	60fb      	str	r3, [r7, #12]

	/* implement sign extension */
	if (*pbuffer >= 0x80) {
 800c364:	683b      	ldr	r3, [r7, #0]
 800c366:	781b      	ldrb	r3, [r3, #0]
 800c368:	b25b      	sxtb	r3, r3
 800c36a:	2b00      	cmp	r3, #0
 800c36c:	da0b      	bge.n	800c386 <VL53L1_i2c_decode_int32_t+0x34>
		value = 0xFFFFFFFF;
 800c36e:	2301      	movs	r3, #1
 800c370:	425b      	negs	r3, r3
 800c372:	60fb      	str	r3, [r7, #12]
	}

	while (count-- > 0) {
 800c374:	e007      	b.n	800c386 <VL53L1_i2c_decode_int32_t+0x34>
		value = (value << 8) | (int32_t)*pbuffer++;
 800c376:	68fb      	ldr	r3, [r7, #12]
 800c378:	021a      	lsls	r2, r3, #8
 800c37a:	683b      	ldr	r3, [r7, #0]
 800c37c:	1c59      	adds	r1, r3, #1
 800c37e:	6039      	str	r1, [r7, #0]
 800c380:	781b      	ldrb	r3, [r3, #0]
 800c382:	4313      	orrs	r3, r2
 800c384:	60fb      	str	r3, [r7, #12]
	while (count-- > 0) {
 800c386:	1dbb      	adds	r3, r7, #6
 800c388:	881b      	ldrh	r3, [r3, #0]
 800c38a:	1dba      	adds	r2, r7, #6
 800c38c:	1e59      	subs	r1, r3, #1
 800c38e:	8011      	strh	r1, [r2, #0]
 800c390:	2b00      	cmp	r3, #0
 800c392:	d1f0      	bne.n	800c376 <VL53L1_i2c_decode_int32_t+0x24>
	}

	return value;
 800c394:	68fb      	ldr	r3, [r7, #12]
}
 800c396:	0018      	movs	r0, r3
 800c398:	46bd      	mov	sp, r7
 800c39a:	b004      	add	sp, #16
 800c39c:	bd80      	pop	{r7, pc}

0800c39e <VL53L1_calc_macro_period_us>:
#endif

uint32_t VL53L1_calc_macro_period_us(
	uint16_t  fast_osc_frequency,
	uint8_t   vcsel_period)
{
 800c39e:	b5b0      	push	{r4, r5, r7, lr}
 800c3a0:	b086      	sub	sp, #24
 800c3a2:	af00      	add	r7, sp, #0
 800c3a4:	0002      	movs	r2, r0
 800c3a6:	1dbb      	adds	r3, r7, #6
 800c3a8:	801a      	strh	r2, [r3, #0]
 800c3aa:	1d7b      	adds	r3, r7, #5
 800c3ac:	1c0a      	adds	r2, r1, #0
 800c3ae:	701a      	strb	r2, [r3, #0]
	 *
	 * Macro period fixed point format = unsigned 12.12
	 * Maximum supported macro period  = 4095.9999 us
	 */

	uint32_t  pll_period_us        = 0;
 800c3b0:	2300      	movs	r3, #0
 800c3b2:	617b      	str	r3, [r7, #20]
	uint8_t   vcsel_period_pclks   = 0;
 800c3b4:	2513      	movs	r5, #19
 800c3b6:	197b      	adds	r3, r7, r5
 800c3b8:	2200      	movs	r2, #0
 800c3ba:	701a      	strb	r2, [r3, #0]
	uint32_t  macro_period_us      = 0;
 800c3bc:	2300      	movs	r3, #0
 800c3be:	60fb      	str	r3, [r7, #12]

	/*  Calculate PLL period in [us] from the  fast_osc_frequency
	 *  Fast osc frequency fixed point format = unsigned 4.12
	 */

	pll_period_us = VL53L1_calc_pll_period_us(fast_osc_frequency);
 800c3c0:	1dbb      	adds	r3, r7, #6
 800c3c2:	881b      	ldrh	r3, [r3, #0]
 800c3c4:	0018      	movs	r0, r3
 800c3c6:	f000 fc1d 	bl	800cc04 <VL53L1_calc_pll_period_us>
 800c3ca:	0003      	movs	r3, r0
 800c3cc:	617b      	str	r3, [r7, #20]

	/*  VCSEL period
	 *  - the real VCSEL period in PLL clocks = 2*(VCSEL_PERIOD+1)
	 */

	vcsel_period_pclks = VL53L1_decode_vcsel_period(vcsel_period);
 800c3ce:	197c      	adds	r4, r7, r5
 800c3d0:	1d7b      	adds	r3, r7, #5
 800c3d2:	781b      	ldrb	r3, [r3, #0]
 800c3d4:	0018      	movs	r0, r3
 800c3d6:	f000 fc2b 	bl	800cc30 <VL53L1_decode_vcsel_period>
 800c3da:	0003      	movs	r3, r0
 800c3dc:	7023      	strb	r3, [r4, #0]
	 *  Max bits (24 - 6) + 12 = 30-bits usage
	 *
	 *  Downshift by 6 before multiplying by the VCSEL Period
	 */

	macro_period_us =
 800c3de:	697a      	ldr	r2, [r7, #20]
 800c3e0:	0013      	movs	r3, r2
 800c3e2:	00db      	lsls	r3, r3, #3
 800c3e4:	189b      	adds	r3, r3, r2
 800c3e6:	021b      	lsls	r3, r3, #8
 800c3e8:	60fb      	str	r3, [r7, #12]
			(uint32_t)VL53L1_MACRO_PERIOD_VCSEL_PERIODS *
			pll_period_us;
	macro_period_us = macro_period_us >> 6;
 800c3ea:	68fb      	ldr	r3, [r7, #12]
 800c3ec:	099b      	lsrs	r3, r3, #6
 800c3ee:	60fb      	str	r3, [r7, #12]

	macro_period_us = macro_period_us * (uint32_t)vcsel_period_pclks;
 800c3f0:	197b      	adds	r3, r7, r5
 800c3f2:	781a      	ldrb	r2, [r3, #0]
 800c3f4:	68fb      	ldr	r3, [r7, #12]
 800c3f6:	4353      	muls	r3, r2
 800c3f8:	60fb      	str	r3, [r7, #12]
	macro_period_us = macro_period_us >> 6;
 800c3fa:	68fb      	ldr	r3, [r7, #12]
 800c3fc:	099b      	lsrs	r3, r3, #6
 800c3fe:	60fb      	str	r3, [r7, #12]
			macro_period_us);
#endif

	LOG_FUNCTION_END(0);

	return macro_period_us;
 800c400:	68fb      	ldr	r3, [r7, #12]
}
 800c402:	0018      	movs	r0, r3
 800c404:	46bd      	mov	sp, r7
 800c406:	b006      	add	sp, #24
 800c408:	bdb0      	pop	{r4, r5, r7, pc}
	...

0800c40c <VL53L1_calc_range_ignore_threshold>:
uint16_t VL53L1_calc_range_ignore_threshold(
	uint32_t central_rate,
	int16_t  x_gradient,
	int16_t  y_gradient,
	uint8_t  rate_mult)
{
 800c40c:	b5b0      	push	{r4, r5, r7, lr}
 800c40e:	b088      	sub	sp, #32
 800c410:	af00      	add	r7, sp, #0
 800c412:	60f8      	str	r0, [r7, #12]
 800c414:	000c      	movs	r4, r1
 800c416:	0010      	movs	r0, r2
 800c418:	0019      	movs	r1, r3
 800c41a:	250a      	movs	r5, #10
 800c41c:	197b      	adds	r3, r7, r5
 800c41e:	1c22      	adds	r2, r4, #0
 800c420:	801a      	strh	r2, [r3, #0]
 800c422:	2308      	movs	r3, #8
 800c424:	18fb      	adds	r3, r7, r3
 800c426:	1c02      	adds	r2, r0, #0
 800c428:	801a      	strh	r2, [r3, #0]
 800c42a:	1dfb      	adds	r3, r7, #7
 800c42c:	1c0a      	adds	r2, r1, #0
 800c42e:	701a      	strb	r2, [r3, #0]
	 * Range ignore threshold rate is then multiplied by user input
	 * rate_mult (in 3.5 fractional format)
	 *
	 */

	int32_t    range_ignore_thresh_int  = 0;
 800c430:	2300      	movs	r3, #0
 800c432:	617b      	str	r3, [r7, #20]
	uint16_t   range_ignore_thresh_kcps = 0;
 800c434:	231e      	movs	r3, #30
 800c436:	18fb      	adds	r3, r7, r3
 800c438:	2200      	movs	r2, #0
 800c43a:	801a      	strh	r2, [r3, #0]
	int32_t    central_rate_int         = 0;
 800c43c:	2300      	movs	r3, #0
 800c43e:	613b      	str	r3, [r7, #16]
	int16_t    x_gradient_int           = 0;
 800c440:	231c      	movs	r3, #28
 800c442:	18fb      	adds	r3, r7, r3
 800c444:	2200      	movs	r2, #0
 800c446:	801a      	strh	r2, [r3, #0]
	int16_t    y_gradient_int           = 0;
 800c448:	231a      	movs	r3, #26
 800c44a:	18fb      	adds	r3, r7, r3
 800c44c:	2200      	movs	r2, #0
 800c44e:	801a      	strh	r2, [r3, #0]

	LOG_FUNCTION_START("");

	/* Shift central_rate to .13 fractional for simple addition */

	central_rate_int = ((int32_t)central_rate * (1 << 4)) / (1000);
 800c450:	68fb      	ldr	r3, [r7, #12]
 800c452:	011a      	lsls	r2, r3, #4
 800c454:	23fa      	movs	r3, #250	; 0xfa
 800c456:	0099      	lsls	r1, r3, #2
 800c458:	0010      	movs	r0, r2
 800c45a:	f7f3 fef1 	bl	8000240 <__divsi3>
 800c45e:	0003      	movs	r3, r0
 800c460:	613b      	str	r3, [r7, #16]

	if (x_gradient < 0) {
 800c462:	197b      	adds	r3, r7, r5
 800c464:	2200      	movs	r2, #0
 800c466:	5e9b      	ldrsh	r3, [r3, r2]
 800c468:	2b00      	cmp	r3, #0
 800c46a:	da07      	bge.n	800c47c <VL53L1_calc_range_ignore_threshold+0x70>
		x_gradient_int = x_gradient * -1;
 800c46c:	230a      	movs	r3, #10
 800c46e:	18fb      	adds	r3, r7, r3
 800c470:	881b      	ldrh	r3, [r3, #0]
 800c472:	425b      	negs	r3, r3
 800c474:	b29a      	uxth	r2, r3
 800c476:	231c      	movs	r3, #28
 800c478:	18fb      	adds	r3, r7, r3
 800c47a:	801a      	strh	r2, [r3, #0]
	}

	if (y_gradient < 0) {
 800c47c:	2308      	movs	r3, #8
 800c47e:	18fb      	adds	r3, r7, r3
 800c480:	2200      	movs	r2, #0
 800c482:	5e9b      	ldrsh	r3, [r3, r2]
 800c484:	2b00      	cmp	r3, #0
 800c486:	da07      	bge.n	800c498 <VL53L1_calc_range_ignore_threshold+0x8c>
		y_gradient_int = y_gradient * -1;
 800c488:	2308      	movs	r3, #8
 800c48a:	18fb      	adds	r3, r7, r3
 800c48c:	881b      	ldrh	r3, [r3, #0]
 800c48e:	425b      	negs	r3, r3
 800c490:	b29a      	uxth	r2, r3
 800c492:	231a      	movs	r3, #26
 800c494:	18fb      	adds	r3, r7, r3
 800c496:	801a      	strh	r2, [r3, #0]

	/* Calculate full rate per spad - worst case from measured xtalk */
	/* Generated here from .11 fractional kcps */
	/* Additional factor of 4 applied to bring fractional precision to .13 */

	range_ignore_thresh_int = (8 * x_gradient_int * 4) + (8 * y_gradient_int * 4);
 800c498:	231c      	movs	r3, #28
 800c49a:	18fb      	adds	r3, r7, r3
 800c49c:	2200      	movs	r2, #0
 800c49e:	5e9a      	ldrsh	r2, [r3, r2]
 800c4a0:	231a      	movs	r3, #26
 800c4a2:	18fb      	adds	r3, r7, r3
 800c4a4:	2100      	movs	r1, #0
 800c4a6:	5e5b      	ldrsh	r3, [r3, r1]
 800c4a8:	18d3      	adds	r3, r2, r3
 800c4aa:	015b      	lsls	r3, r3, #5
 800c4ac:	617b      	str	r3, [r7, #20]

	/* Convert Kcps to Mcps */

	range_ignore_thresh_int = range_ignore_thresh_int / 1000;
 800c4ae:	697a      	ldr	r2, [r7, #20]
 800c4b0:	23fa      	movs	r3, #250	; 0xfa
 800c4b2:	0099      	lsls	r1, r3, #2
 800c4b4:	0010      	movs	r0, r2
 800c4b6:	f7f3 fec3 	bl	8000240 <__divsi3>
 800c4ba:	0003      	movs	r3, r0
 800c4bc:	617b      	str	r3, [r7, #20]

	/* Combine with Central Rate - Mcps .13 format*/

	range_ignore_thresh_int = range_ignore_thresh_int + central_rate_int;
 800c4be:	697a      	ldr	r2, [r7, #20]
 800c4c0:	693b      	ldr	r3, [r7, #16]
 800c4c2:	18d3      	adds	r3, r2, r3
 800c4c4:	617b      	str	r3, [r7, #20]

	/* Mult by user input */

	range_ignore_thresh_int = (int32_t)rate_mult * range_ignore_thresh_int;
 800c4c6:	1dfb      	adds	r3, r7, #7
 800c4c8:	781a      	ldrb	r2, [r3, #0]
 800c4ca:	697b      	ldr	r3, [r7, #20]
 800c4cc:	4353      	muls	r3, r2
 800c4ce:	617b      	str	r3, [r7, #20]

	range_ignore_thresh_int = (range_ignore_thresh_int + (1<<4)) / (1<<5);
 800c4d0:	697b      	ldr	r3, [r7, #20]
 800c4d2:	3310      	adds	r3, #16
 800c4d4:	2b00      	cmp	r3, #0
 800c4d6:	da00      	bge.n	800c4da <VL53L1_calc_range_ignore_threshold+0xce>
 800c4d8:	331f      	adds	r3, #31
 800c4da:	115b      	asrs	r3, r3, #5
 800c4dc:	617b      	str	r3, [r7, #20]

	/* Finally clip and output in correct format */

	if (range_ignore_thresh_int > 0xFFFF) {
 800c4de:	697b      	ldr	r3, [r7, #20]
 800c4e0:	4a09      	ldr	r2, [pc, #36]	; (800c508 <VL53L1_calc_range_ignore_threshold+0xfc>)
 800c4e2:	4293      	cmp	r3, r2
 800c4e4:	dd05      	ble.n	800c4f2 <VL53L1_calc_range_ignore_threshold+0xe6>
		range_ignore_thresh_kcps = 0xFFFF;
 800c4e6:	231e      	movs	r3, #30
 800c4e8:	18fb      	adds	r3, r7, r3
 800c4ea:	2201      	movs	r2, #1
 800c4ec:	4252      	negs	r2, r2
 800c4ee:	801a      	strh	r2, [r3, #0]
 800c4f0:	e003      	b.n	800c4fa <VL53L1_calc_range_ignore_threshold+0xee>
	} else {
		range_ignore_thresh_kcps = (uint16_t)range_ignore_thresh_int;
 800c4f2:	231e      	movs	r3, #30
 800c4f4:	18fb      	adds	r3, r7, r3
 800c4f6:	697a      	ldr	r2, [r7, #20]
 800c4f8:	801a      	strh	r2, [r3, #0]
			range_ignore_thresh_kcps);
#endif

	LOG_FUNCTION_END(0);

	return range_ignore_thresh_kcps;
 800c4fa:	231e      	movs	r3, #30
 800c4fc:	18fb      	adds	r3, r7, r3
 800c4fe:	881b      	ldrh	r3, [r3, #0]
}
 800c500:	0018      	movs	r0, r3
 800c502:	46bd      	mov	sp, r7
 800c504:	b008      	add	sp, #32
 800c506:	bdb0      	pop	{r4, r5, r7, pc}
 800c508:	0000ffff 	.word	0x0000ffff

0800c50c <VL53L1_calc_timeout_mclks>:


uint32_t VL53L1_calc_timeout_mclks(
	uint32_t timeout_us,
	uint32_t macro_period_us)
{
 800c50c:	b580      	push	{r7, lr}
 800c50e:	b084      	sub	sp, #16
 800c510:	af00      	add	r7, sp, #0
 800c512:	6078      	str	r0, [r7, #4]
 800c514:	6039      	str	r1, [r7, #0]
	 *  Max timeout in 20.12 format = 32-bits
	 *
	 *  Macro period [us] = 12.12 format
	 */

	uint32_t timeout_mclks   = 0;
 800c516:	2300      	movs	r3, #0
 800c518:	60fb      	str	r3, [r7, #12]

	LOG_FUNCTION_START("");

	timeout_mclks   =
			((timeout_us << 12) + (macro_period_us>>1)) /
 800c51a:	687b      	ldr	r3, [r7, #4]
 800c51c:	031a      	lsls	r2, r3, #12
 800c51e:	683b      	ldr	r3, [r7, #0]
 800c520:	085b      	lsrs	r3, r3, #1
 800c522:	18d3      	adds	r3, r2, r3
	timeout_mclks   =
 800c524:	6839      	ldr	r1, [r7, #0]
 800c526:	0018      	movs	r0, r3
 800c528:	f7f3 fe00 	bl	800012c <__udivsi3>
 800c52c:	0003      	movs	r3, r0
 800c52e:	60fb      	str	r3, [r7, #12]
			macro_period_us;

	LOG_FUNCTION_END(0);

	return timeout_mclks;
 800c530:	68fb      	ldr	r3, [r7, #12]
}
 800c532:	0018      	movs	r0, r3
 800c534:	46bd      	mov	sp, r7
 800c536:	b004      	add	sp, #16
 800c538:	bd80      	pop	{r7, pc}

0800c53a <VL53L1_calc_encoded_timeout>:


uint16_t VL53L1_calc_encoded_timeout(
	uint32_t timeout_us,
	uint32_t macro_period_us)
{
 800c53a:	b5b0      	push	{r4, r5, r7, lr}
 800c53c:	b084      	sub	sp, #16
 800c53e:	af00      	add	r7, sp, #0
 800c540:	6078      	str	r0, [r7, #4]
 800c542:	6039      	str	r1, [r7, #0]
	 *  Max timeout in 20.12 format = 32-bits
	 *
	 *  Macro period [us] = 12.12 format
	 */

	uint32_t timeout_mclks   = 0;
 800c544:	2300      	movs	r3, #0
 800c546:	60fb      	str	r3, [r7, #12]
	uint16_t timeout_encoded = 0;
 800c548:	250a      	movs	r5, #10
 800c54a:	197b      	adds	r3, r7, r5
 800c54c:	2200      	movs	r2, #0
 800c54e:	801a      	strh	r2, [r3, #0]

	LOG_FUNCTION_START("");

	timeout_mclks   =
 800c550:	683a      	ldr	r2, [r7, #0]
 800c552:	687b      	ldr	r3, [r7, #4]
 800c554:	0011      	movs	r1, r2
 800c556:	0018      	movs	r0, r3
 800c558:	f7ff ffd8 	bl	800c50c <VL53L1_calc_timeout_mclks>
 800c55c:	0003      	movs	r3, r0
 800c55e:	60fb      	str	r3, [r7, #12]
		VL53L1_calc_timeout_mclks(timeout_us, macro_period_us);

	timeout_encoded =
 800c560:	197c      	adds	r4, r7, r5
 800c562:	68fb      	ldr	r3, [r7, #12]
 800c564:	0018      	movs	r0, r3
 800c566:	f000 f85d 	bl	800c624 <VL53L1_encode_timeout>
 800c56a:	0003      	movs	r3, r0
 800c56c:	8023      	strh	r3, [r4, #0]
			timeout_encoded, timeout_encoded);
#endif

	LOG_FUNCTION_END(0);

	return timeout_encoded;
 800c56e:	197b      	adds	r3, r7, r5
 800c570:	881b      	ldrh	r3, [r3, #0]
}
 800c572:	0018      	movs	r0, r3
 800c574:	46bd      	mov	sp, r7
 800c576:	b004      	add	sp, #16
 800c578:	bdb0      	pop	{r4, r5, r7, pc}

0800c57a <VL53L1_calc_timeout_us>:


uint32_t VL53L1_calc_timeout_us(
	uint32_t timeout_mclks,
	uint32_t macro_period_us)
{
 800c57a:	b5f0      	push	{r4, r5, r6, r7, lr}
 800c57c:	b089      	sub	sp, #36	; 0x24
 800c57e:	af00      	add	r7, sp, #0
 800c580:	60f8      	str	r0, [r7, #12]
 800c582:	60b9      	str	r1, [r7, #8]
	 *  Max timeout in 20.12 format = 32-bits
	 *
	 *  Macro period [us] = 12.12 format
	 */

	uint32_t timeout_us     = 0;
 800c584:	2300      	movs	r3, #0
 800c586:	61fb      	str	r3, [r7, #28]
	uint64_t tmp            = 0;
 800c588:	2300      	movs	r3, #0
 800c58a:	2400      	movs	r4, #0
 800c58c:	613b      	str	r3, [r7, #16]
 800c58e:	617c      	str	r4, [r7, #20]

	LOG_FUNCTION_START("");

	tmp  = (uint64_t)timeout_mclks * (uint64_t)macro_period_us;
 800c590:	68fb      	ldr	r3, [r7, #12]
 800c592:	001d      	movs	r5, r3
 800c594:	2300      	movs	r3, #0
 800c596:	001e      	movs	r6, r3
 800c598:	68bb      	ldr	r3, [r7, #8]
 800c59a:	603b      	str	r3, [r7, #0]
 800c59c:	2300      	movs	r3, #0
 800c59e:	607b      	str	r3, [r7, #4]
 800c5a0:	683a      	ldr	r2, [r7, #0]
 800c5a2:	687b      	ldr	r3, [r7, #4]
 800c5a4:	0028      	movs	r0, r5
 800c5a6:	0031      	movs	r1, r6
 800c5a8:	f7f3 ff94 	bl	80004d4 <__aeabi_lmul>
 800c5ac:	0003      	movs	r3, r0
 800c5ae:	000c      	movs	r4, r1
 800c5b0:	613b      	str	r3, [r7, #16]
 800c5b2:	617c      	str	r4, [r7, #20]
	tmp += 0x00800;
 800c5b4:	693b      	ldr	r3, [r7, #16]
 800c5b6:	697c      	ldr	r4, [r7, #20]
 800c5b8:	2180      	movs	r1, #128	; 0x80
 800c5ba:	0109      	lsls	r1, r1, #4
 800c5bc:	2200      	movs	r2, #0
 800c5be:	185b      	adds	r3, r3, r1
 800c5c0:	4154      	adcs	r4, r2
 800c5c2:	613b      	str	r3, [r7, #16]
 800c5c4:	617c      	str	r4, [r7, #20]
	tmp  = tmp >> 12;
 800c5c6:	697b      	ldr	r3, [r7, #20]
 800c5c8:	051b      	lsls	r3, r3, #20
 800c5ca:	693a      	ldr	r2, [r7, #16]
 800c5cc:	0b12      	lsrs	r2, r2, #12
 800c5ce:	4313      	orrs	r3, r2
 800c5d0:	613b      	str	r3, [r7, #16]
 800c5d2:	697b      	ldr	r3, [r7, #20]
 800c5d4:	0b1b      	lsrs	r3, r3, #12
 800c5d6:	617b      	str	r3, [r7, #20]

	timeout_us = (uint32_t)tmp;
 800c5d8:	693b      	ldr	r3, [r7, #16]
 800c5da:	61fb      	str	r3, [r7, #28]
			timeout_us, timeout_us);
#endif

	LOG_FUNCTION_END(0);

	return timeout_us;
 800c5dc:	69fb      	ldr	r3, [r7, #28]
}
 800c5de:	0018      	movs	r0, r3
 800c5e0:	46bd      	mov	sp, r7
 800c5e2:	b009      	add	sp, #36	; 0x24
 800c5e4:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800c5e6 <VL53L1_calc_decoded_timeout_us>:
}

uint32_t VL53L1_calc_decoded_timeout_us(
	uint16_t timeout_encoded,
	uint32_t macro_period_us)
{
 800c5e6:	b580      	push	{r7, lr}
 800c5e8:	b084      	sub	sp, #16
 800c5ea:	af00      	add	r7, sp, #0
 800c5ec:	0002      	movs	r2, r0
 800c5ee:	6039      	str	r1, [r7, #0]
 800c5f0:	1dbb      	adds	r3, r7, #6
 800c5f2:	801a      	strh	r2, [r3, #0]
	 *  Max timeout in 20.12 format = 32-bits
	 *
	 *  Macro period [us] = 12.12 format
	 */

	uint32_t timeout_mclks  = 0;
 800c5f4:	2300      	movs	r3, #0
 800c5f6:	60fb      	str	r3, [r7, #12]
	uint32_t timeout_us     = 0;
 800c5f8:	2300      	movs	r3, #0
 800c5fa:	60bb      	str	r3, [r7, #8]

	LOG_FUNCTION_START("");

	timeout_mclks =
 800c5fc:	1dbb      	adds	r3, r7, #6
 800c5fe:	881b      	ldrh	r3, [r3, #0]
 800c600:	0018      	movs	r0, r3
 800c602:	f000 f846 	bl	800c692 <VL53L1_decode_timeout>
 800c606:	0003      	movs	r3, r0
 800c608:	60fb      	str	r3, [r7, #12]
		VL53L1_decode_timeout(timeout_encoded);

	timeout_us    =
 800c60a:	683a      	ldr	r2, [r7, #0]
 800c60c:	68fb      	ldr	r3, [r7, #12]
 800c60e:	0011      	movs	r1, r2
 800c610:	0018      	movs	r0, r3
 800c612:	f7ff ffb2 	bl	800c57a <VL53L1_calc_timeout_us>
 800c616:	0003      	movs	r3, r0
 800c618:	60bb      	str	r3, [r7, #8]
		VL53L1_calc_timeout_us(timeout_mclks, macro_period_us);

	LOG_FUNCTION_END(0);

	return timeout_us;
 800c61a:	68bb      	ldr	r3, [r7, #8]
}
 800c61c:	0018      	movs	r0, r3
 800c61e:	46bd      	mov	sp, r7
 800c620:	b004      	add	sp, #16
 800c622:	bd80      	pop	{r7, pc}

0800c624 <VL53L1_encode_timeout>:


uint16_t VL53L1_encode_timeout(uint32_t timeout_mclks)
{
 800c624:	b580      	push	{r7, lr}
 800c626:	b086      	sub	sp, #24
 800c628:	af00      	add	r7, sp, #0
 800c62a:	6078      	str	r0, [r7, #4]
	/*
	 * Encode timeout in macro periods in (LSByte * 2^MSByte) + 1 format
	 */

	uint16_t encoded_timeout = 0;
 800c62c:	2316      	movs	r3, #22
 800c62e:	18fb      	adds	r3, r7, r3
 800c630:	2200      	movs	r2, #0
 800c632:	801a      	strh	r2, [r3, #0]
	uint32_t ls_byte = 0;
 800c634:	2300      	movs	r3, #0
 800c636:	613b      	str	r3, [r7, #16]
	uint16_t ms_byte = 0;
 800c638:	230e      	movs	r3, #14
 800c63a:	18fb      	adds	r3, r7, r3
 800c63c:	2200      	movs	r2, #0
 800c63e:	801a      	strh	r2, [r3, #0]

	if (timeout_mclks > 0) {
 800c640:	687b      	ldr	r3, [r7, #4]
 800c642:	2b00      	cmp	r3, #0
 800c644:	d01e      	beq.n	800c684 <VL53L1_encode_timeout+0x60>
		ls_byte = timeout_mclks - 1;
 800c646:	687b      	ldr	r3, [r7, #4]
 800c648:	3b01      	subs	r3, #1
 800c64a:	613b      	str	r3, [r7, #16]

		while ((ls_byte & 0xFFFFFF00) > 0) {
 800c64c:	e008      	b.n	800c660 <VL53L1_encode_timeout+0x3c>
			ls_byte = ls_byte >> 1;
 800c64e:	693b      	ldr	r3, [r7, #16]
 800c650:	085b      	lsrs	r3, r3, #1
 800c652:	613b      	str	r3, [r7, #16]
			ms_byte++;
 800c654:	210e      	movs	r1, #14
 800c656:	187b      	adds	r3, r7, r1
 800c658:	881a      	ldrh	r2, [r3, #0]
 800c65a:	187b      	adds	r3, r7, r1
 800c65c:	3201      	adds	r2, #1
 800c65e:	801a      	strh	r2, [r3, #0]
		while ((ls_byte & 0xFFFFFF00) > 0) {
 800c660:	693b      	ldr	r3, [r7, #16]
 800c662:	22ff      	movs	r2, #255	; 0xff
 800c664:	4393      	bics	r3, r2
 800c666:	d1f2      	bne.n	800c64e <VL53L1_encode_timeout+0x2a>
		}

		encoded_timeout = (ms_byte << 8)
 800c668:	230e      	movs	r3, #14
 800c66a:	18fb      	adds	r3, r7, r3
 800c66c:	881b      	ldrh	r3, [r3, #0]
 800c66e:	021b      	lsls	r3, r3, #8
 800c670:	b299      	uxth	r1, r3
				+ (uint16_t) (ls_byte & 0x000000FF);
 800c672:	693b      	ldr	r3, [r7, #16]
 800c674:	b29b      	uxth	r3, r3
 800c676:	22ff      	movs	r2, #255	; 0xff
 800c678:	4013      	ands	r3, r2
 800c67a:	b29a      	uxth	r2, r3
		encoded_timeout = (ms_byte << 8)
 800c67c:	2316      	movs	r3, #22
 800c67e:	18fb      	adds	r3, r7, r3
 800c680:	188a      	adds	r2, r1, r2
 800c682:	801a      	strh	r2, [r3, #0]
	}

	return encoded_timeout;
 800c684:	2316      	movs	r3, #22
 800c686:	18fb      	adds	r3, r7, r3
 800c688:	881b      	ldrh	r3, [r3, #0]
}
 800c68a:	0018      	movs	r0, r3
 800c68c:	46bd      	mov	sp, r7
 800c68e:	b006      	add	sp, #24
 800c690:	bd80      	pop	{r7, pc}

0800c692 <VL53L1_decode_timeout>:


uint32_t VL53L1_decode_timeout(uint16_t encoded_timeout)
{
 800c692:	b580      	push	{r7, lr}
 800c694:	b084      	sub	sp, #16
 800c696:	af00      	add	r7, sp, #0
 800c698:	0002      	movs	r2, r0
 800c69a:	1dbb      	adds	r3, r7, #6
 800c69c:	801a      	strh	r2, [r3, #0]
	/*
	 * Decode 16-bit timeout register value
	 * format (LSByte * 2^MSByte) + 1
	 */

	uint32_t timeout_macro_clks = 0;
 800c69e:	2300      	movs	r3, #0
 800c6a0:	60fb      	str	r3, [r7, #12]

	timeout_macro_clks = ((uint32_t) (encoded_timeout & 0x00FF)
 800c6a2:	1dbb      	adds	r3, r7, #6
 800c6a4:	881b      	ldrh	r3, [r3, #0]
 800c6a6:	22ff      	movs	r2, #255	; 0xff
 800c6a8:	4013      	ands	r3, r2
			<< (uint32_t) ((encoded_timeout & 0xFF00) >> 8)) + 1;
 800c6aa:	1dba      	adds	r2, r7, #6
 800c6ac:	8812      	ldrh	r2, [r2, #0]
 800c6ae:	0a12      	lsrs	r2, r2, #8
 800c6b0:	b292      	uxth	r2, r2
 800c6b2:	4093      	lsls	r3, r2
	timeout_macro_clks = ((uint32_t) (encoded_timeout & 0x00FF)
 800c6b4:	3301      	adds	r3, #1
 800c6b6:	60fb      	str	r3, [r7, #12]

	return timeout_macro_clks;
 800c6b8:	68fb      	ldr	r3, [r7, #12]
}
 800c6ba:	0018      	movs	r0, r3
 800c6bc:	46bd      	mov	sp, r7
 800c6be:	b004      	add	sp, #16
 800c6c0:	bd80      	pop	{r7, pc}

0800c6c2 <VL53L1_calc_timeout_register_values>:
	uint32_t                 mm_config_timeout_us,
	uint32_t                 range_config_timeout_us,
	uint16_t                 fast_osc_frequency,
	VL53L1_general_config_t *pgeneral,
	VL53L1_timing_config_t  *ptiming)
{
 800c6c2:	b5b0      	push	{r4, r5, r7, lr}
 800c6c4:	b088      	sub	sp, #32
 800c6c6:	af00      	add	r7, sp, #0
 800c6c8:	60f8      	str	r0, [r7, #12]
 800c6ca:	60b9      	str	r1, [r7, #8]
 800c6cc:	607a      	str	r2, [r7, #4]
 800c6ce:	001a      	movs	r2, r3
 800c6d0:	1cbb      	adds	r3, r7, #2
 800c6d2:	801a      	strh	r2, [r3, #0]
	 * into the appropriate register values
	 *
	 * Must also be run after the VCSEL period settings are changed
	 */

	VL53L1_Error status = VL53L1_ERROR_NONE;
 800c6d4:	231f      	movs	r3, #31
 800c6d6:	18fb      	adds	r3, r7, r3
 800c6d8:	2200      	movs	r2, #0
 800c6da:	701a      	strb	r2, [r3, #0]

	uint32_t macro_period_us    = 0;
 800c6dc:	2300      	movs	r3, #0
 800c6de:	617b      	str	r3, [r7, #20]
	uint32_t timeout_mclks      = 0;
 800c6e0:	2300      	movs	r3, #0
 800c6e2:	61bb      	str	r3, [r7, #24]
	uint16_t timeout_encoded    = 0;
 800c6e4:	2312      	movs	r3, #18
 800c6e6:	18fb      	adds	r3, r7, r3
 800c6e8:	2200      	movs	r2, #0
 800c6ea:	801a      	strh	r2, [r3, #0]

	LOG_FUNCTION_START("");

	if (fast_osc_frequency == 0) {
 800c6ec:	1cbb      	adds	r3, r7, #2
 800c6ee:	881b      	ldrh	r3, [r3, #0]
 800c6f0:	2b00      	cmp	r3, #0
 800c6f2:	d104      	bne.n	800c6fe <VL53L1_calc_timeout_register_values+0x3c>
		status = VL53L1_ERROR_DIVISION_BY_ZERO;
 800c6f4:	231f      	movs	r3, #31
 800c6f6:	18fb      	adds	r3, r7, r3
 800c6f8:	22f1      	movs	r2, #241	; 0xf1
 800c6fa:	701a      	strb	r2, [r3, #0]
 800c6fc:	e082      	b.n	800c804 <VL53L1_calc_timeout_register_values+0x142>
	} else {
		/* Update Macro Period for Range A VCSEL Period */
		macro_period_us =
				VL53L1_calc_macro_period_us(
 800c6fe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c700:	799a      	ldrb	r2, [r3, #6]
		macro_period_us =
 800c702:	1cbb      	adds	r3, r7, #2
 800c704:	881b      	ldrh	r3, [r3, #0]
 800c706:	0011      	movs	r1, r2
 800c708:	0018      	movs	r0, r3
 800c70a:	f7ff fe48 	bl	800c39e <VL53L1_calc_macro_period_us>
 800c70e:	0003      	movs	r3, r0
 800c710:	617b      	str	r3, [r7, #20]
					fast_osc_frequency,
					ptiming->range_config__vcsel_period_a);

		/*  Update Phase timeout - uses Timing A */
		timeout_mclks =
 800c712:	697a      	ldr	r2, [r7, #20]
 800c714:	68fb      	ldr	r3, [r7, #12]
 800c716:	0011      	movs	r1, r2
 800c718:	0018      	movs	r0, r3
 800c71a:	f7ff fef7 	bl	800c50c <VL53L1_calc_timeout_mclks>
 800c71e:	0003      	movs	r3, r0
 800c720:	61bb      	str	r3, [r7, #24]
			VL53L1_calc_timeout_mclks(
				phasecal_config_timeout_us,
				macro_period_us);

		/* clip as the phase cal timeout register is only 8-bits */
		if (timeout_mclks > 0xFF)
 800c722:	69bb      	ldr	r3, [r7, #24]
 800c724:	2bff      	cmp	r3, #255	; 0xff
 800c726:	d901      	bls.n	800c72c <VL53L1_calc_timeout_register_values+0x6a>
			timeout_mclks = 0xFF;
 800c728:	23ff      	movs	r3, #255	; 0xff
 800c72a:	61bb      	str	r3, [r7, #24]

		pgeneral->phasecal_config__timeout_macrop =
				(uint8_t)timeout_mclks;
 800c72c:	69bb      	ldr	r3, [r7, #24]
 800c72e:	b2da      	uxtb	r2, r3
		pgeneral->phasecal_config__timeout_macrop =
 800c730:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c732:	71da      	strb	r2, [r3, #7]

		/*  Update MM Timing A timeout */
		timeout_encoded =
 800c734:	2412      	movs	r4, #18
 800c736:	0025      	movs	r5, r4
 800c738:	193c      	adds	r4, r7, r4
 800c73a:	697a      	ldr	r2, [r7, #20]
 800c73c:	68bb      	ldr	r3, [r7, #8]
 800c73e:	0011      	movs	r1, r2
 800c740:	0018      	movs	r0, r3
 800c742:	f7ff fefa 	bl	800c53a <VL53L1_calc_encoded_timeout>
 800c746:	0003      	movs	r3, r0
 800c748:	8023      	strh	r3, [r4, #0]
			VL53L1_calc_encoded_timeout(
				mm_config_timeout_us,
				macro_period_us);

		ptiming->mm_config__timeout_macrop_a_hi =
				(uint8_t)((timeout_encoded & 0xFF00) >> 8);
 800c74a:	002c      	movs	r4, r5
 800c74c:	193b      	adds	r3, r7, r4
 800c74e:	881b      	ldrh	r3, [r3, #0]
 800c750:	0a1b      	lsrs	r3, r3, #8
 800c752:	b29b      	uxth	r3, r3
 800c754:	b2da      	uxtb	r2, r3
		ptiming->mm_config__timeout_macrop_a_hi =
 800c756:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c758:	701a      	strb	r2, [r3, #0]
		ptiming->mm_config__timeout_macrop_a_lo =
				(uint8_t) (timeout_encoded & 0x00FF);
 800c75a:	193b      	adds	r3, r7, r4
 800c75c:	881b      	ldrh	r3, [r3, #0]
 800c75e:	b2da      	uxtb	r2, r3
		ptiming->mm_config__timeout_macrop_a_lo =
 800c760:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c762:	705a      	strb	r2, [r3, #1]

		/* Update Range Timing A timeout */
		timeout_encoded =
 800c764:	0025      	movs	r5, r4
 800c766:	193c      	adds	r4, r7, r4
 800c768:	697a      	ldr	r2, [r7, #20]
 800c76a:	687b      	ldr	r3, [r7, #4]
 800c76c:	0011      	movs	r1, r2
 800c76e:	0018      	movs	r0, r3
 800c770:	f7ff fee3 	bl	800c53a <VL53L1_calc_encoded_timeout>
 800c774:	0003      	movs	r3, r0
 800c776:	8023      	strh	r3, [r4, #0]
			VL53L1_calc_encoded_timeout(
				range_config_timeout_us,
				macro_period_us);

		ptiming->range_config__timeout_macrop_a_hi =
				(uint8_t)((timeout_encoded & 0xFF00) >> 8);
 800c778:	002c      	movs	r4, r5
 800c77a:	193b      	adds	r3, r7, r4
 800c77c:	881b      	ldrh	r3, [r3, #0]
 800c77e:	0a1b      	lsrs	r3, r3, #8
 800c780:	b29b      	uxth	r3, r3
 800c782:	b2da      	uxtb	r2, r3
		ptiming->range_config__timeout_macrop_a_hi =
 800c784:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c786:	711a      	strb	r2, [r3, #4]
		ptiming->range_config__timeout_macrop_a_lo =
				(uint8_t) (timeout_encoded & 0x00FF);
 800c788:	193b      	adds	r3, r7, r4
 800c78a:	881b      	ldrh	r3, [r3, #0]
 800c78c:	b2da      	uxtb	r2, r3
		ptiming->range_config__timeout_macrop_a_lo =
 800c78e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c790:	715a      	strb	r2, [r3, #5]

		/* Update Macro Period for Range B VCSEL Period */
		macro_period_us =
				VL53L1_calc_macro_period_us(
 800c792:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c794:	7a5a      	ldrb	r2, [r3, #9]
		macro_period_us =
 800c796:	1cbb      	adds	r3, r7, #2
 800c798:	881b      	ldrh	r3, [r3, #0]
 800c79a:	0011      	movs	r1, r2
 800c79c:	0018      	movs	r0, r3
 800c79e:	f7ff fdfe 	bl	800c39e <VL53L1_calc_macro_period_us>
 800c7a2:	0003      	movs	r3, r0
 800c7a4:	617b      	str	r3, [r7, #20]
					fast_osc_frequency,
					ptiming->range_config__vcsel_period_b);

		/* Update MM Timing B timeout */
		timeout_encoded =
 800c7a6:	0021      	movs	r1, r4
 800c7a8:	000d      	movs	r5, r1
 800c7aa:	187c      	adds	r4, r7, r1
 800c7ac:	697a      	ldr	r2, [r7, #20]
 800c7ae:	68bb      	ldr	r3, [r7, #8]
 800c7b0:	0011      	movs	r1, r2
 800c7b2:	0018      	movs	r0, r3
 800c7b4:	f7ff fec1 	bl	800c53a <VL53L1_calc_encoded_timeout>
 800c7b8:	0003      	movs	r3, r0
 800c7ba:	8023      	strh	r3, [r4, #0]
				VL53L1_calc_encoded_timeout(
					mm_config_timeout_us,
					macro_period_us);

		ptiming->mm_config__timeout_macrop_b_hi =
				(uint8_t)((timeout_encoded & 0xFF00) >> 8);
 800c7bc:	0029      	movs	r1, r5
 800c7be:	187b      	adds	r3, r7, r1
 800c7c0:	881b      	ldrh	r3, [r3, #0]
 800c7c2:	0a1b      	lsrs	r3, r3, #8
 800c7c4:	b29b      	uxth	r3, r3
 800c7c6:	b2da      	uxtb	r2, r3
		ptiming->mm_config__timeout_macrop_b_hi =
 800c7c8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c7ca:	709a      	strb	r2, [r3, #2]
		ptiming->mm_config__timeout_macrop_b_lo =
				(uint8_t) (timeout_encoded & 0x00FF);
 800c7cc:	187b      	adds	r3, r7, r1
 800c7ce:	881b      	ldrh	r3, [r3, #0]
 800c7d0:	b2da      	uxtb	r2, r3
		ptiming->mm_config__timeout_macrop_b_lo =
 800c7d2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c7d4:	70da      	strb	r2, [r3, #3]

		/* Update Range Timing B timeout */
		timeout_encoded = VL53L1_calc_encoded_timeout(
 800c7d6:	000d      	movs	r5, r1
 800c7d8:	187c      	adds	r4, r7, r1
 800c7da:	697a      	ldr	r2, [r7, #20]
 800c7dc:	687b      	ldr	r3, [r7, #4]
 800c7de:	0011      	movs	r1, r2
 800c7e0:	0018      	movs	r0, r3
 800c7e2:	f7ff feaa 	bl	800c53a <VL53L1_calc_encoded_timeout>
 800c7e6:	0003      	movs	r3, r0
 800c7e8:	8023      	strh	r3, [r4, #0]
							range_config_timeout_us,
							macro_period_us);

		ptiming->range_config__timeout_macrop_b_hi =
				(uint8_t)((timeout_encoded & 0xFF00) >> 8);
 800c7ea:	0029      	movs	r1, r5
 800c7ec:	187b      	adds	r3, r7, r1
 800c7ee:	881b      	ldrh	r3, [r3, #0]
 800c7f0:	0a1b      	lsrs	r3, r3, #8
 800c7f2:	b29b      	uxth	r3, r3
 800c7f4:	b2da      	uxtb	r2, r3
		ptiming->range_config__timeout_macrop_b_hi =
 800c7f6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c7f8:	71da      	strb	r2, [r3, #7]
		ptiming->range_config__timeout_macrop_b_lo =
				(uint8_t) (timeout_encoded & 0x00FF);
 800c7fa:	187b      	adds	r3, r7, r1
 800c7fc:	881b      	ldrh	r3, [r3, #0]
 800c7fe:	b2da      	uxtb	r2, r3
		ptiming->range_config__timeout_macrop_b_lo =
 800c800:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c802:	721a      	strb	r2, [r3, #8]
	}

	LOG_FUNCTION_END(0);

	return status;
 800c804:	231f      	movs	r3, #31
 800c806:	18fb      	adds	r3, r7, r3
 800c808:	781b      	ldrb	r3, [r3, #0]
 800c80a:	b25b      	sxtb	r3, r3

}
 800c80c:	0018      	movs	r0, r3
 800c80e:	46bd      	mov	sp, r7
 800c810:	b008      	add	sp, #32
 800c812:	bdb0      	pop	{r4, r5, r7, pc}

0800c814 <VL53L1_encode_row_col>:

void VL53L1_encode_row_col(
	uint8_t  row,
	uint8_t  col,
	uint8_t *pspad_number)
{
 800c814:	b580      	push	{r7, lr}
 800c816:	b082      	sub	sp, #8
 800c818:	af00      	add	r7, sp, #0
 800c81a:	603a      	str	r2, [r7, #0]
 800c81c:	1dfb      	adds	r3, r7, #7
 800c81e:	1c02      	adds	r2, r0, #0
 800c820:	701a      	strb	r2, [r3, #0]
 800c822:	1dbb      	adds	r3, r7, #6
 800c824:	1c0a      	adds	r2, r1, #0
 800c826:	701a      	strb	r2, [r3, #0]
	/**
	 *  Encodes the input array(row,col) location as SPAD number.
	 */

	if (row > 7) {
 800c828:	1dfb      	adds	r3, r7, #7
 800c82a:	781b      	ldrb	r3, [r3, #0]
 800c82c:	2b07      	cmp	r3, #7
 800c82e:	d90c      	bls.n	800c84a <VL53L1_encode_row_col+0x36>
		*pspad_number = 128 + (col << 3) + (15-row);
 800c830:	1dbb      	adds	r3, r7, #6
 800c832:	781b      	ldrb	r3, [r3, #0]
 800c834:	00db      	lsls	r3, r3, #3
 800c836:	b2da      	uxtb	r2, r3
 800c838:	1dfb      	adds	r3, r7, #7
 800c83a:	781b      	ldrb	r3, [r3, #0]
 800c83c:	1ad3      	subs	r3, r2, r3
 800c83e:	b2db      	uxtb	r3, r3
 800c840:	3b71      	subs	r3, #113	; 0x71
 800c842:	b2da      	uxtb	r2, r3
 800c844:	683b      	ldr	r3, [r7, #0]
 800c846:	701a      	strb	r2, [r3, #0]
	} else {
		*pspad_number = ((15-col) << 3) + row;
	}
}
 800c848:	e00c      	b.n	800c864 <VL53L1_encode_row_col+0x50>
		*pspad_number = ((15-col) << 3) + row;
 800c84a:	1dbb      	adds	r3, r7, #6
 800c84c:	781b      	ldrb	r3, [r3, #0]
 800c84e:	220f      	movs	r2, #15
 800c850:	1ad3      	subs	r3, r2, r3
 800c852:	b2db      	uxtb	r3, r3
 800c854:	00db      	lsls	r3, r3, #3
 800c856:	b2da      	uxtb	r2, r3
 800c858:	1dfb      	adds	r3, r7, #7
 800c85a:	781b      	ldrb	r3, [r3, #0]
 800c85c:	18d3      	adds	r3, r2, r3
 800c85e:	b2da      	uxtb	r2, r3
 800c860:	683b      	ldr	r3, [r7, #0]
 800c862:	701a      	strb	r2, [r3, #0]
}
 800c864:	46c0      	nop			; (mov r8, r8)
 800c866:	46bd      	mov	sp, r7
 800c868:	b002      	add	sp, #8
 800c86a:	bd80      	pop	{r7, pc}

0800c86c <VL53L1_decode_zone_size>:

void VL53L1_decode_zone_size(
	uint8_t  encoded_xy_size,
	uint8_t  *pwidth,
	uint8_t  *pheight)
{
 800c86c:	b580      	push	{r7, lr}
 800c86e:	b084      	sub	sp, #16
 800c870:	af00      	add	r7, sp, #0
 800c872:	60b9      	str	r1, [r7, #8]
 800c874:	607a      	str	r2, [r7, #4]
 800c876:	210f      	movs	r1, #15
 800c878:	187b      	adds	r3, r7, r1
 800c87a:	1c02      	adds	r2, r0, #0
 800c87c:	701a      	strb	r2, [r3, #0]
	 *
	 * MS Nibble = height
	 * LS Nibble = width
	 */

	*pheight = encoded_xy_size >> 4;
 800c87e:	187b      	adds	r3, r7, r1
 800c880:	781b      	ldrb	r3, [r3, #0]
 800c882:	091b      	lsrs	r3, r3, #4
 800c884:	b2da      	uxtb	r2, r3
 800c886:	687b      	ldr	r3, [r7, #4]
 800c888:	701a      	strb	r2, [r3, #0]
	*pwidth  = encoded_xy_size & 0x0F;
 800c88a:	187b      	adds	r3, r7, r1
 800c88c:	781b      	ldrb	r3, [r3, #0]
 800c88e:	220f      	movs	r2, #15
 800c890:	4013      	ands	r3, r2
 800c892:	b2da      	uxtb	r2, r3
 800c894:	68bb      	ldr	r3, [r7, #8]
 800c896:	701a      	strb	r2, [r3, #0]

}
 800c898:	46c0      	nop			; (mov r8, r8)
 800c89a:	46bd      	mov	sp, r7
 800c89c:	b004      	add	sp, #16
 800c89e:	bd80      	pop	{r7, pc}

0800c8a0 <VL53L1_encode_zone_size>:

void VL53L1_encode_zone_size(
	uint8_t  width,
	uint8_t  height,
	uint8_t *pencoded_xy_size)
{
 800c8a0:	b580      	push	{r7, lr}
 800c8a2:	b082      	sub	sp, #8
 800c8a4:	af00      	add	r7, sp, #0
 800c8a6:	603a      	str	r2, [r7, #0]
 800c8a8:	1dfb      	adds	r3, r7, #7
 800c8aa:	1c02      	adds	r2, r0, #0
 800c8ac:	701a      	strb	r2, [r3, #0]
 800c8ae:	1dbb      	adds	r3, r7, #6
 800c8b0:	1c0a      	adds	r2, r1, #0
 800c8b2:	701a      	strb	r2, [r3, #0]
	 *
	 * MS Nibble = height
	 * LS Nibble = width
	 */

	*pencoded_xy_size = (height << 4) + width;
 800c8b4:	1dbb      	adds	r3, r7, #6
 800c8b6:	781b      	ldrb	r3, [r3, #0]
 800c8b8:	011b      	lsls	r3, r3, #4
 800c8ba:	b2da      	uxtb	r2, r3
 800c8bc:	1dfb      	adds	r3, r7, #7
 800c8be:	781b      	ldrb	r3, [r3, #0]
 800c8c0:	18d3      	adds	r3, r2, r3
 800c8c2:	b2da      	uxtb	r2, r3
 800c8c4:	683b      	ldr	r3, [r7, #0]
 800c8c6:	701a      	strb	r2, [r3, #0]

}
 800c8c8:	46c0      	nop			; (mov r8, r8)
 800c8ca:	46bd      	mov	sp, r7
 800c8cc:	b002      	add	sp, #8
 800c8ce:	bd80      	pop	{r7, pc}

0800c8d0 <VL53L1_low_power_auto_data_init>:
/* Start Patch_LowPowerAutoMode */

VL53L1_Error VL53L1_low_power_auto_data_init(
	VL53L1_DEV                          Dev
	)
{
 800c8d0:	b580      	push	{r7, lr}
 800c8d2:	b084      	sub	sp, #16
 800c8d4:	af00      	add	r7, sp, #0
 800c8d6:	6078      	str	r0, [r7, #4]
	/*
	 * Initializes internal data structures for low power auto mode
	 */

	/* don't really use this here */
	VL53L1_Error  status = VL53L1_ERROR_NONE;
 800c8d8:	200f      	movs	r0, #15
 800c8da:	183b      	adds	r3, r7, r0
 800c8dc:	2200      	movs	r2, #0
 800c8de:	701a      	strb	r2, [r3, #0]

	VL53L1_LLDriverData_t *pdev = VL53L1DevStructGetLLDriverHandle(Dev);
 800c8e0:	687b      	ldr	r3, [r7, #4]
 800c8e2:	60bb      	str	r3, [r7, #8]

	LOG_FUNCTION_START("");

	pdev->low_power_auto_data.vhv_loop_bound =
 800c8e4:	68ba      	ldr	r2, [r7, #8]
 800c8e6:	23b9      	movs	r3, #185	; 0xb9
 800c8e8:	009b      	lsls	r3, r3, #2
 800c8ea:	2103      	movs	r1, #3
 800c8ec:	54d1      	strb	r1, [r2, r3]
		VL53L1_TUNINGPARM_LOWPOWERAUTO_VHV_LOOP_BOUND_DEFAULT;
	pdev->low_power_auto_data.is_low_power_auto_mode = 0;
 800c8ee:	68bb      	ldr	r3, [r7, #8]
 800c8f0:	4a14      	ldr	r2, [pc, #80]	; (800c944 <VL53L1_low_power_auto_data_init+0x74>)
 800c8f2:	2100      	movs	r1, #0
 800c8f4:	5499      	strb	r1, [r3, r2]
	pdev->low_power_auto_data.low_power_auto_range_count = 0;
 800c8f6:	68bb      	ldr	r3, [r7, #8]
 800c8f8:	4a13      	ldr	r2, [pc, #76]	; (800c948 <VL53L1_low_power_auto_data_init+0x78>)
 800c8fa:	2100      	movs	r1, #0
 800c8fc:	5499      	strb	r1, [r3, r2]
	pdev->low_power_auto_data.saved_interrupt_config = 0;
 800c8fe:	68bb      	ldr	r3, [r7, #8]
 800c900:	4a12      	ldr	r2, [pc, #72]	; (800c94c <VL53L1_low_power_auto_data_init+0x7c>)
 800c902:	2100      	movs	r1, #0
 800c904:	5499      	strb	r1, [r3, r2]
	pdev->low_power_auto_data.saved_vhv_init = 0;
 800c906:	68ba      	ldr	r2, [r7, #8]
 800c908:	23ba      	movs	r3, #186	; 0xba
 800c90a:	009b      	lsls	r3, r3, #2
 800c90c:	2100      	movs	r1, #0
 800c90e:	54d1      	strb	r1, [r2, r3]
	pdev->low_power_auto_data.saved_vhv_timeout = 0;
 800c910:	68bb      	ldr	r3, [r7, #8]
 800c912:	4a0f      	ldr	r2, [pc, #60]	; (800c950 <VL53L1_low_power_auto_data_init+0x80>)
 800c914:	2100      	movs	r1, #0
 800c916:	5499      	strb	r1, [r3, r2]
	pdev->low_power_auto_data.first_run_phasecal_result = 0;
 800c918:	68bb      	ldr	r3, [r7, #8]
 800c91a:	4a0e      	ldr	r2, [pc, #56]	; (800c954 <VL53L1_low_power_auto_data_init+0x84>)
 800c91c:	2100      	movs	r1, #0
 800c91e:	5499      	strb	r1, [r3, r2]
	pdev->low_power_auto_data.dss__total_rate_per_spad_mcps = 0;
 800c920:	68ba      	ldr	r2, [r7, #8]
 800c922:	23bb      	movs	r3, #187	; 0xbb
 800c924:	009b      	lsls	r3, r3, #2
 800c926:	2100      	movs	r1, #0
 800c928:	50d1      	str	r1, [r2, r3]
	pdev->low_power_auto_data.dss__required_spads = 0;
 800c92a:	68ba      	ldr	r2, [r7, #8]
 800c92c:	23bc      	movs	r3, #188	; 0xbc
 800c92e:	009b      	lsls	r3, r3, #2
 800c930:	2100      	movs	r1, #0
 800c932:	52d1      	strh	r1, [r2, r3]

	LOG_FUNCTION_END(status);

	return status;
 800c934:	183b      	adds	r3, r7, r0
 800c936:	781b      	ldrb	r3, [r3, #0]
 800c938:	b25b      	sxtb	r3, r3
}
 800c93a:	0018      	movs	r0, r3
 800c93c:	46bd      	mov	sp, r7
 800c93e:	b004      	add	sp, #16
 800c940:	bd80      	pop	{r7, pc}
 800c942:	46c0      	nop			; (mov r8, r8)
 800c944:	000002e5 	.word	0x000002e5
 800c948:	000002e6 	.word	0x000002e6
 800c94c:	000002e7 	.word	0x000002e7
 800c950:	000002e9 	.word	0x000002e9
 800c954:	000002ea 	.word	0x000002ea

0800c958 <VL53L1_low_power_auto_data_stop_range>:

VL53L1_Error VL53L1_low_power_auto_data_stop_range(
	VL53L1_DEV                          Dev
	)
{
 800c958:	b580      	push	{r7, lr}
 800c95a:	b084      	sub	sp, #16
 800c95c:	af00      	add	r7, sp, #0
 800c95e:	6078      	str	r0, [r7, #4]
	/*
	 * Range has been paused but may continue later
	 */

	/* don't really use this here */
	VL53L1_Error  status = VL53L1_ERROR_NONE;
 800c960:	230f      	movs	r3, #15
 800c962:	18fb      	adds	r3, r7, r3
 800c964:	2200      	movs	r2, #0
 800c966:	701a      	strb	r2, [r3, #0]

	VL53L1_LLDriverData_t *pdev = VL53L1DevStructGetLLDriverHandle(Dev);
 800c968:	687b      	ldr	r3, [r7, #4]
 800c96a:	60bb      	str	r3, [r7, #8]
	LOG_FUNCTION_START("");

	/* doing this ensures stop_range followed by a get_device_results does
	 * not mess up the counters */

	pdev->low_power_auto_data.low_power_auto_range_count = 0xFF;
 800c96c:	68bb      	ldr	r3, [r7, #8]
 800c96e:	4a1c      	ldr	r2, [pc, #112]	; (800c9e0 <VL53L1_low_power_auto_data_stop_range+0x88>)
 800c970:	21ff      	movs	r1, #255	; 0xff
 800c972:	5499      	strb	r1, [r3, r2]

	pdev->low_power_auto_data.first_run_phasecal_result = 0;
 800c974:	68bb      	ldr	r3, [r7, #8]
 800c976:	4a1b      	ldr	r2, [pc, #108]	; (800c9e4 <VL53L1_low_power_auto_data_stop_range+0x8c>)
 800c978:	2100      	movs	r1, #0
 800c97a:	5499      	strb	r1, [r3, r2]
	pdev->low_power_auto_data.dss__total_rate_per_spad_mcps = 0;
 800c97c:	68ba      	ldr	r2, [r7, #8]
 800c97e:	23bb      	movs	r3, #187	; 0xbb
 800c980:	009b      	lsls	r3, r3, #2
 800c982:	2100      	movs	r1, #0
 800c984:	50d1      	str	r1, [r2, r3]
	pdev->low_power_auto_data.dss__required_spads = 0;
 800c986:	68ba      	ldr	r2, [r7, #8]
 800c988:	23bc      	movs	r3, #188	; 0xbc
 800c98a:	009b      	lsls	r3, r3, #2
 800c98c:	2100      	movs	r1, #0
 800c98e:	52d1      	strh	r1, [r2, r3]

	/* restore vhv configs */
	if (pdev->low_power_auto_data.saved_vhv_init != 0)
 800c990:	68ba      	ldr	r2, [r7, #8]
 800c992:	23ba      	movs	r3, #186	; 0xba
 800c994:	009b      	lsls	r3, r3, #2
 800c996:	5cd3      	ldrb	r3, [r2, r3]
 800c998:	2b00      	cmp	r3, #0
 800c99a:	d007      	beq.n	800c9ac <VL53L1_low_power_auto_data_stop_range+0x54>
		pdev->stat_nvm.vhv_config__init =
			pdev->low_power_auto_data.saved_vhv_init;
 800c99c:	68ba      	ldr	r2, [r7, #8]
 800c99e:	23ba      	movs	r3, #186	; 0xba
 800c9a0:	009b      	lsls	r3, r3, #2
 800c9a2:	5cd1      	ldrb	r1, [r2, r3]
		pdev->stat_nvm.vhv_config__init =
 800c9a4:	68ba      	ldr	r2, [r7, #8]
 800c9a6:	2364      	movs	r3, #100	; 0x64
 800c9a8:	33ff      	adds	r3, #255	; 0xff
 800c9aa:	54d1      	strb	r1, [r2, r3]
	if (pdev->low_power_auto_data.saved_vhv_timeout != 0)
 800c9ac:	68bb      	ldr	r3, [r7, #8]
 800c9ae:	4a0e      	ldr	r2, [pc, #56]	; (800c9e8 <VL53L1_low_power_auto_data_stop_range+0x90>)
 800c9b0:	5c9b      	ldrb	r3, [r3, r2]
 800c9b2:	2b00      	cmp	r3, #0
 800c9b4:	d006      	beq.n	800c9c4 <VL53L1_low_power_auto_data_stop_range+0x6c>
		pdev->stat_nvm.vhv_config__timeout_macrop_loop_bound =
			pdev->low_power_auto_data.saved_vhv_timeout;
 800c9b6:	68bb      	ldr	r3, [r7, #8]
 800c9b8:	4a0b      	ldr	r2, [pc, #44]	; (800c9e8 <VL53L1_low_power_auto_data_stop_range+0x90>)
 800c9ba:	5c99      	ldrb	r1, [r3, r2]
		pdev->stat_nvm.vhv_config__timeout_macrop_loop_bound =
 800c9bc:	68ba      	ldr	r2, [r7, #8]
 800c9be:	23b0      	movs	r3, #176	; 0xb0
 800c9c0:	005b      	lsls	r3, r3, #1
 800c9c2:	54d1      	strb	r1, [r2, r3]

	/* remove phasecal override */
	pdev->gen_cfg.phasecal_config__override = 0x00;
 800c9c4:	68ba      	ldr	r2, [r7, #8]
 800c9c6:	238e      	movs	r3, #142	; 0x8e
 800c9c8:	33ff      	adds	r3, #255	; 0xff
 800c9ca:	2100      	movs	r1, #0
 800c9cc:	54d1      	strb	r1, [r2, r3]

	LOG_FUNCTION_END(status);

	return status;
 800c9ce:	230f      	movs	r3, #15
 800c9d0:	18fb      	adds	r3, r7, r3
 800c9d2:	781b      	ldrb	r3, [r3, #0]
 800c9d4:	b25b      	sxtb	r3, r3
}
 800c9d6:	0018      	movs	r0, r3
 800c9d8:	46bd      	mov	sp, r7
 800c9da:	b004      	add	sp, #16
 800c9dc:	bd80      	pop	{r7, pc}
 800c9de:	46c0      	nop			; (mov r8, r8)
 800c9e0:	000002e6 	.word	0x000002e6
 800c9e4:	000002ea 	.word	0x000002ea
 800c9e8:	000002e9 	.word	0x000002e9

0800c9ec <VL53L1_config_low_power_auto_mode>:
VL53L1_Error VL53L1_config_low_power_auto_mode(
	VL53L1_general_config_t   *pgeneral,
	VL53L1_dynamic_config_t   *pdynamic,
	VL53L1_low_power_auto_data_t *plpadata
	)
{
 800c9ec:	b580      	push	{r7, lr}
 800c9ee:	b086      	sub	sp, #24
 800c9f0:	af00      	add	r7, sp, #0
 800c9f2:	60f8      	str	r0, [r7, #12]
 800c9f4:	60b9      	str	r1, [r7, #8]
 800c9f6:	607a      	str	r2, [r7, #4]
	/*
	 * Initializes configs for when low power auto presets are selected
	 */

	/* don't really use this here */
	VL53L1_Error  status = VL53L1_ERROR_NONE;
 800c9f8:	2117      	movs	r1, #23
 800c9fa:	187b      	adds	r3, r7, r1
 800c9fc:	2200      	movs	r2, #0
 800c9fe:	701a      	strb	r2, [r3, #0]

	LOG_FUNCTION_START("");

	/* set low power auto mode */
	plpadata->is_low_power_auto_mode = 1;
 800ca00:	687b      	ldr	r3, [r7, #4]
 800ca02:	2201      	movs	r2, #1
 800ca04:	705a      	strb	r2, [r3, #1]

	/* set low power range count to 0 */
	plpadata->low_power_auto_range_count = 0;
 800ca06:	687b      	ldr	r3, [r7, #4]
 800ca08:	2200      	movs	r2, #0
 800ca0a:	709a      	strb	r2, [r3, #2]

	/* Turn off MM1/MM2 and DSS2 */
	pdynamic->system__sequence_config = \
 800ca0c:	68bb      	ldr	r3, [r7, #8]
 800ca0e:	228b      	movs	r2, #139	; 0x8b
 800ca10:	745a      	strb	r2, [r3, #17]
			/* VL53L1_SEQUENCE_MM1_EN | \*/
			/* VL53L1_SEQUENCE_MM2_EN | \*/
			VL53L1_SEQUENCE_RANGE_EN;

	/* Set DSS to manual/expected SPADs */
	pgeneral->dss_config__manual_effective_spads_select = 200 << 8;
 800ca12:	68fb      	ldr	r3, [r7, #12]
 800ca14:	4a05      	ldr	r2, [pc, #20]	; (800ca2c <VL53L1_config_low_power_auto_mode+0x40>)
 800ca16:	821a      	strh	r2, [r3, #16]
	pgeneral->dss_config__roi_mode_control =
 800ca18:	68fb      	ldr	r3, [r7, #12]
 800ca1a:	2202      	movs	r2, #2
 800ca1c:	729a      	strb	r2, [r3, #10]
		VL53L1_DEVICEDSSMODE__REQUESTED_EFFFECTIVE_SPADS;

	LOG_FUNCTION_END(status);

	return status;
 800ca1e:	187b      	adds	r3, r7, r1
 800ca20:	781b      	ldrb	r3, [r3, #0]
 800ca22:	b25b      	sxtb	r3, r3
}
 800ca24:	0018      	movs	r0, r3
 800ca26:	46bd      	mov	sp, r7
 800ca28:	b006      	add	sp, #24
 800ca2a:	bd80      	pop	{r7, pc}
 800ca2c:	ffffc800 	.word	0xffffc800

0800ca30 <VL53L1_low_power_auto_setup_manual_calibration>:

VL53L1_Error VL53L1_low_power_auto_setup_manual_calibration(
	VL53L1_DEV        Dev)
{
 800ca30:	b580      	push	{r7, lr}
 800ca32:	b084      	sub	sp, #16
 800ca34:	af00      	add	r7, sp, #0
 800ca36:	6078      	str	r0, [r7, #4]
	/*
	 * Setup ranges after the first one in low power auto mode by turning
	 * off FW calibration steps and programming static values
	 */

	VL53L1_LLDriverData_t *pdev = VL53L1DevStructGetLLDriverHandle(Dev);
 800ca38:	687b      	ldr	r3, [r7, #4]
 800ca3a:	60fb      	str	r3, [r7, #12]

	/* don't really use this here */
	VL53L1_Error  status = VL53L1_ERROR_NONE;
 800ca3c:	200b      	movs	r0, #11
 800ca3e:	183b      	adds	r3, r7, r0
 800ca40:	2200      	movs	r2, #0
 800ca42:	701a      	strb	r2, [r3, #0]

	LOG_FUNCTION_START("");

	/* save original vhv configs */
	pdev->low_power_auto_data.saved_vhv_init =
		pdev->stat_nvm.vhv_config__init;
 800ca44:	68fa      	ldr	r2, [r7, #12]
 800ca46:	2364      	movs	r3, #100	; 0x64
 800ca48:	33ff      	adds	r3, #255	; 0xff
 800ca4a:	5cd1      	ldrb	r1, [r2, r3]
	pdev->low_power_auto_data.saved_vhv_init =
 800ca4c:	68fa      	ldr	r2, [r7, #12]
 800ca4e:	23ba      	movs	r3, #186	; 0xba
 800ca50:	009b      	lsls	r3, r3, #2
 800ca52:	54d1      	strb	r1, [r2, r3]
	pdev->low_power_auto_data.saved_vhv_timeout =
		pdev->stat_nvm.vhv_config__timeout_macrop_loop_bound;
 800ca54:	68fa      	ldr	r2, [r7, #12]
 800ca56:	23b0      	movs	r3, #176	; 0xb0
 800ca58:	005b      	lsls	r3, r3, #1
 800ca5a:	5cd1      	ldrb	r1, [r2, r3]
	pdev->low_power_auto_data.saved_vhv_timeout =
 800ca5c:	68fb      	ldr	r3, [r7, #12]
 800ca5e:	4a1c      	ldr	r2, [pc, #112]	; (800cad0 <VL53L1_low_power_auto_setup_manual_calibration+0xa0>)
 800ca60:	5499      	strb	r1, [r3, r2]

	/* disable VHV init */
	pdev->stat_nvm.vhv_config__init &= 0x7F;
 800ca62:	68fa      	ldr	r2, [r7, #12]
 800ca64:	2364      	movs	r3, #100	; 0x64
 800ca66:	33ff      	adds	r3, #255	; 0xff
 800ca68:	5cd3      	ldrb	r3, [r2, r3]
 800ca6a:	227f      	movs	r2, #127	; 0x7f
 800ca6c:	4013      	ands	r3, r2
 800ca6e:	b2d9      	uxtb	r1, r3
 800ca70:	68fa      	ldr	r2, [r7, #12]
 800ca72:	2364      	movs	r3, #100	; 0x64
 800ca74:	33ff      	adds	r3, #255	; 0xff
 800ca76:	54d1      	strb	r1, [r2, r3]
	/* set loop bound to tuning param */
	pdev->stat_nvm.vhv_config__timeout_macrop_loop_bound =
		(pdev->stat_nvm.vhv_config__timeout_macrop_loop_bound & 0x03) +
 800ca78:	68fa      	ldr	r2, [r7, #12]
 800ca7a:	23b0      	movs	r3, #176	; 0xb0
 800ca7c:	005b      	lsls	r3, r3, #1
 800ca7e:	5cd3      	ldrb	r3, [r2, r3]
 800ca80:	2203      	movs	r2, #3
 800ca82:	4013      	ands	r3, r2
 800ca84:	b2da      	uxtb	r2, r3
		(pdev->low_power_auto_data.vhv_loop_bound << 2);
 800ca86:	68f9      	ldr	r1, [r7, #12]
 800ca88:	23b9      	movs	r3, #185	; 0xb9
 800ca8a:	009b      	lsls	r3, r3, #2
 800ca8c:	5ccb      	ldrb	r3, [r1, r3]
 800ca8e:	009b      	lsls	r3, r3, #2
 800ca90:	b2db      	uxtb	r3, r3
		(pdev->stat_nvm.vhv_config__timeout_macrop_loop_bound & 0x03) +
 800ca92:	18d3      	adds	r3, r2, r3
 800ca94:	b2d9      	uxtb	r1, r3
	pdev->stat_nvm.vhv_config__timeout_macrop_loop_bound =
 800ca96:	68fa      	ldr	r2, [r7, #12]
 800ca98:	23b0      	movs	r3, #176	; 0xb0
 800ca9a:	005b      	lsls	r3, r3, #1
 800ca9c:	54d1      	strb	r1, [r2, r3]
	/* override phasecal */
	pdev->gen_cfg.phasecal_config__override = 0x01;
 800ca9e:	68fa      	ldr	r2, [r7, #12]
 800caa0:	238e      	movs	r3, #142	; 0x8e
 800caa2:	33ff      	adds	r3, #255	; 0xff
 800caa4:	2101      	movs	r1, #1
 800caa6:	54d1      	strb	r1, [r2, r3]
	pdev->low_power_auto_data.first_run_phasecal_result =
		pdev->dbg_results.phasecal_result__vcsel_start;
 800caa8:	68fb      	ldr	r3, [r7, #12]
 800caaa:	4a0a      	ldr	r2, [pc, #40]	; (800cad4 <VL53L1_low_power_auto_setup_manual_calibration+0xa4>)
 800caac:	5c99      	ldrb	r1, [r3, r2]
	pdev->low_power_auto_data.first_run_phasecal_result =
 800caae:	68fb      	ldr	r3, [r7, #12]
 800cab0:	4a09      	ldr	r2, [pc, #36]	; (800cad8 <VL53L1_low_power_auto_setup_manual_calibration+0xa8>)
 800cab2:	5499      	strb	r1, [r3, r2]
	pdev->gen_cfg.cal_config__vcsel_start =
		pdev->low_power_auto_data.first_run_phasecal_result;
 800cab4:	68fb      	ldr	r3, [r7, #12]
 800cab6:	4a08      	ldr	r2, [pc, #32]	; (800cad8 <VL53L1_low_power_auto_setup_manual_calibration+0xa8>)
 800cab8:	5c99      	ldrb	r1, [r3, r2]
	pdev->gen_cfg.cal_config__vcsel_start =
 800caba:	68fa      	ldr	r2, [r7, #12]
 800cabc:	2388      	movs	r3, #136	; 0x88
 800cabe:	33ff      	adds	r3, #255	; 0xff
 800cac0:	54d1      	strb	r1, [r2, r3]

	LOG_FUNCTION_END(status);

	return status;
 800cac2:	183b      	adds	r3, r7, r0
 800cac4:	781b      	ldrb	r3, [r3, #0]
 800cac6:	b25b      	sxtb	r3, r3
}
 800cac8:	0018      	movs	r0, r3
 800caca:	46bd      	mov	sp, r7
 800cacc:	b004      	add	sp, #16
 800cace:	bd80      	pop	{r7, pc}
 800cad0:	000002e9 	.word	0x000002e9
 800cad4:	000002ae 	.word	0x000002ae
 800cad8:	000002ea 	.word	0x000002ea

0800cadc <VL53L1_low_power_auto_update_DSS>:

VL53L1_Error VL53L1_low_power_auto_update_DSS(
	VL53L1_DEV        Dev)
{
 800cadc:	b580      	push	{r7, lr}
 800cade:	b086      	sub	sp, #24
 800cae0:	af00      	add	r7, sp, #0
 800cae2:	6078      	str	r0, [r7, #4]

	/*
	 * Do a DSS calculation and update manual config
	 */

	VL53L1_LLDriverData_t *pdev = VL53L1DevStructGetLLDriverHandle(Dev);
 800cae4:	687b      	ldr	r3, [r7, #4]
 800cae6:	60fb      	str	r3, [r7, #12]

	/* don't really use this here */
	VL53L1_Error  status = VL53L1_ERROR_NONE;
 800cae8:	2317      	movs	r3, #23
 800caea:	18fb      	adds	r3, r7, r3
 800caec:	2200      	movs	r2, #0
 800caee:	701a      	strb	r2, [r3, #0]
	LOG_FUNCTION_START("");

	/* Calc total rate per spad */

	/* 9.7 format */
	utemp32a = pdev->sys_results.result__peak_signal_count_rate_crosstalk_corrected_mcps_sd0 +
 800caf0:	68fa      	ldr	r2, [r7, #12]
 800caf2:	23ef      	movs	r3, #239	; 0xef
 800caf4:	005b      	lsls	r3, r3, #1
 800caf6:	5ad3      	ldrh	r3, [r2, r3]
 800caf8:	0019      	movs	r1, r3
		pdev->sys_results.result__ambient_count_rate_mcps_sd0;
 800cafa:	68fa      	ldr	r2, [r7, #12]
 800cafc:	23eb      	movs	r3, #235	; 0xeb
 800cafe:	005b      	lsls	r3, r3, #1
 800cb00:	5ad3      	ldrh	r3, [r2, r3]
	utemp32a = pdev->sys_results.result__peak_signal_count_rate_crosstalk_corrected_mcps_sd0 +
 800cb02:	18cb      	adds	r3, r1, r3
 800cb04:	613b      	str	r3, [r7, #16]

	/* clip to 16 bits */
	if (utemp32a > 0xFFFF)
 800cb06:	693b      	ldr	r3, [r7, #16]
 800cb08:	4a3c      	ldr	r2, [pc, #240]	; (800cbfc <VL53L1_low_power_auto_update_DSS+0x120>)
 800cb0a:	4293      	cmp	r3, r2
 800cb0c:	d901      	bls.n	800cb12 <VL53L1_low_power_auto_update_DSS+0x36>
		utemp32a = 0xFFFF;
 800cb0e:	4b3b      	ldr	r3, [pc, #236]	; (800cbfc <VL53L1_low_power_auto_update_DSS+0x120>)
 800cb10:	613b      	str	r3, [r7, #16]

	/* shift up to take advantage of 32 bits */
	/* 9.23 format */
	utemp32a = utemp32a << 16;
 800cb12:	693b      	ldr	r3, [r7, #16]
 800cb14:	041b      	lsls	r3, r3, #16
 800cb16:	613b      	str	r3, [r7, #16]

	/* check SPAD count */
	if (pdev->sys_results.result__dss_actual_effective_spads_sd0 == 0)
 800cb18:	68fa      	ldr	r2, [r7, #12]
 800cb1a:	23e9      	movs	r3, #233	; 0xe9
 800cb1c:	005b      	lsls	r3, r3, #1
 800cb1e:	5ad3      	ldrh	r3, [r2, r3]
 800cb20:	2b00      	cmp	r3, #0
 800cb22:	d104      	bne.n	800cb2e <VL53L1_low_power_auto_update_DSS+0x52>
		status = VL53L1_ERROR_DIVISION_BY_ZERO;
 800cb24:	2317      	movs	r3, #23
 800cb26:	18fb      	adds	r3, r7, r3
 800cb28:	22f1      	movs	r2, #241	; 0xf1
 800cb2a:	701a      	strb	r2, [r3, #0]
 800cb2c:	e042      	b.n	800cbb4 <VL53L1_low_power_auto_update_DSS+0xd8>
	else {
		/* format 17.15 */
		utemp32a = utemp32a /
			pdev->sys_results.result__dss_actual_effective_spads_sd0;
 800cb2e:	68fa      	ldr	r2, [r7, #12]
 800cb30:	23e9      	movs	r3, #233	; 0xe9
 800cb32:	005b      	lsls	r3, r3, #1
 800cb34:	5ad3      	ldrh	r3, [r2, r3]
		utemp32a = utemp32a /
 800cb36:	0019      	movs	r1, r3
 800cb38:	6938      	ldr	r0, [r7, #16]
 800cb3a:	f7f3 faf7 	bl	800012c <__udivsi3>
 800cb3e:	0003      	movs	r3, r0
 800cb40:	613b      	str	r3, [r7, #16]
		/* save intermediate result */
		pdev->low_power_auto_data.dss__total_rate_per_spad_mcps =
 800cb42:	68fa      	ldr	r2, [r7, #12]
 800cb44:	23bb      	movs	r3, #187	; 0xbb
 800cb46:	009b      	lsls	r3, r3, #2
 800cb48:	6939      	ldr	r1, [r7, #16]
 800cb4a:	50d1      	str	r1, [r2, r3]
			utemp32a;

		/* get the target rate and shift up by 16
		 * format 9.23 */
		utemp32a = pdev->stat_cfg.dss_config__target_total_rate_mcps <<
 800cb4c:	68fa      	ldr	r2, [r7, #12]
 800cb4e:	23b2      	movs	r3, #178	; 0xb2
 800cb50:	005b      	lsls	r3, r3, #1
 800cb52:	5ad3      	ldrh	r3, [r2, r3]
 800cb54:	041b      	lsls	r3, r3, #16
 800cb56:	613b      	str	r3, [r7, #16]
			16;

		/* check for divide by zero */
		if (pdev->low_power_auto_data.dss__total_rate_per_spad_mcps == 0)
 800cb58:	68fa      	ldr	r2, [r7, #12]
 800cb5a:	23bb      	movs	r3, #187	; 0xbb
 800cb5c:	009b      	lsls	r3, r3, #2
 800cb5e:	58d3      	ldr	r3, [r2, r3]
 800cb60:	2b00      	cmp	r3, #0
 800cb62:	d104      	bne.n	800cb6e <VL53L1_low_power_auto_update_DSS+0x92>
			status = VL53L1_ERROR_DIVISION_BY_ZERO;
 800cb64:	2317      	movs	r3, #23
 800cb66:	18fb      	adds	r3, r7, r3
 800cb68:	22f1      	movs	r2, #241	; 0xf1
 800cb6a:	701a      	strb	r2, [r3, #0]
 800cb6c:	e022      	b.n	800cbb4 <VL53L1_low_power_auto_update_DSS+0xd8>
		else {
			/* divide by rate per spad
			 * format 24.8 */
			utemp32a = utemp32a /
				pdev->low_power_auto_data.dss__total_rate_per_spad_mcps;
 800cb6e:	68fa      	ldr	r2, [r7, #12]
 800cb70:	23bb      	movs	r3, #187	; 0xbb
 800cb72:	009b      	lsls	r3, r3, #2
 800cb74:	58d3      	ldr	r3, [r2, r3]
			utemp32a = utemp32a /
 800cb76:	0019      	movs	r1, r3
 800cb78:	6938      	ldr	r0, [r7, #16]
 800cb7a:	f7f3 fad7 	bl	800012c <__udivsi3>
 800cb7e:	0003      	movs	r3, r0
 800cb80:	613b      	str	r3, [r7, #16]

			/* clip to 16 bit */
			if (utemp32a > 0xFFFF)
 800cb82:	693b      	ldr	r3, [r7, #16]
 800cb84:	4a1d      	ldr	r2, [pc, #116]	; (800cbfc <VL53L1_low_power_auto_update_DSS+0x120>)
 800cb86:	4293      	cmp	r3, r2
 800cb88:	d901      	bls.n	800cb8e <VL53L1_low_power_auto_update_DSS+0xb2>
				utemp32a = 0xFFFF;
 800cb8a:	4b1c      	ldr	r3, [pc, #112]	; (800cbfc <VL53L1_low_power_auto_update_DSS+0x120>)
 800cb8c:	613b      	str	r3, [r7, #16]

			/* save result in low power auto data */
			pdev->low_power_auto_data.dss__required_spads =
				(uint16_t)utemp32a;
 800cb8e:	693b      	ldr	r3, [r7, #16]
 800cb90:	b299      	uxth	r1, r3
			pdev->low_power_auto_data.dss__required_spads =
 800cb92:	68fa      	ldr	r2, [r7, #12]
 800cb94:	23bc      	movs	r3, #188	; 0xbc
 800cb96:	009b      	lsls	r3, r3, #2
 800cb98:	52d1      	strh	r1, [r2, r3]

			/* override DSS config */
			pdev->gen_cfg.dss_config__manual_effective_spads_select =
				pdev->low_power_auto_data.dss__required_spads;
 800cb9a:	68fa      	ldr	r2, [r7, #12]
 800cb9c:	23bc      	movs	r3, #188	; 0xbc
 800cb9e:	009b      	lsls	r3, r3, #2
 800cba0:	5ad1      	ldrh	r1, [r2, r3]
			pdev->gen_cfg.dss_config__manual_effective_spads_select =
 800cba2:	68fa      	ldr	r2, [r7, #12]
 800cba4:	23ca      	movs	r3, #202	; 0xca
 800cba6:	005b      	lsls	r3, r3, #1
 800cba8:	52d1      	strh	r1, [r2, r3]
			pdev->gen_cfg.dss_config__roi_mode_control =
 800cbaa:	68fa      	ldr	r2, [r7, #12]
 800cbac:	23c7      	movs	r3, #199	; 0xc7
 800cbae:	005b      	lsls	r3, r3, #1
 800cbb0:	2102      	movs	r1, #2
 800cbb2:	54d1      	strb	r1, [r2, r3]
				VL53L1_DEVICEDSSMODE__REQUESTED_EFFFECTIVE_SPADS;
		}

	}

	if (status == VL53L1_ERROR_DIVISION_BY_ZERO) {
 800cbb4:	2317      	movs	r3, #23
 800cbb6:	18fb      	adds	r3, r7, r3
 800cbb8:	781b      	ldrb	r3, [r3, #0]
 800cbba:	b25b      	sxtb	r3, r3
 800cbbc:	330f      	adds	r3, #15
 800cbbe:	d115      	bne.n	800cbec <VL53L1_low_power_auto_update_DSS+0x110>
		/* We want to gracefully set a spad target, not just exit with
		* an error */

		/* set target to mid point */
		pdev->low_power_auto_data.dss__required_spads = 0x8000;
 800cbc0:	68fa      	ldr	r2, [r7, #12]
 800cbc2:	23bc      	movs	r3, #188	; 0xbc
 800cbc4:	009b      	lsls	r3, r3, #2
 800cbc6:	490e      	ldr	r1, [pc, #56]	; (800cc00 <VL53L1_low_power_auto_update_DSS+0x124>)
 800cbc8:	52d1      	strh	r1, [r2, r3]

		/* override DSS config */
		pdev->gen_cfg.dss_config__manual_effective_spads_select =
		pdev->low_power_auto_data.dss__required_spads;
 800cbca:	68fa      	ldr	r2, [r7, #12]
 800cbcc:	23bc      	movs	r3, #188	; 0xbc
 800cbce:	009b      	lsls	r3, r3, #2
 800cbd0:	5ad1      	ldrh	r1, [r2, r3]
		pdev->gen_cfg.dss_config__manual_effective_spads_select =
 800cbd2:	68fa      	ldr	r2, [r7, #12]
 800cbd4:	23ca      	movs	r3, #202	; 0xca
 800cbd6:	005b      	lsls	r3, r3, #1
 800cbd8:	52d1      	strh	r1, [r2, r3]
		pdev->gen_cfg.dss_config__roi_mode_control =
 800cbda:	68fa      	ldr	r2, [r7, #12]
 800cbdc:	23c7      	movs	r3, #199	; 0xc7
 800cbde:	005b      	lsls	r3, r3, #1
 800cbe0:	2102      	movs	r1, #2
 800cbe2:	54d1      	strb	r1, [r2, r3]
		VL53L1_DEVICEDSSMODE__REQUESTED_EFFFECTIVE_SPADS;

		/* reset error */
		status = VL53L1_ERROR_NONE;
 800cbe4:	2317      	movs	r3, #23
 800cbe6:	18fb      	adds	r3, r7, r3
 800cbe8:	2200      	movs	r2, #0
 800cbea:	701a      	strb	r2, [r3, #0]
	}

	LOG_FUNCTION_END(status);

	return status;
 800cbec:	2317      	movs	r3, #23
 800cbee:	18fb      	adds	r3, r7, r3
 800cbf0:	781b      	ldrb	r3, [r3, #0]
 800cbf2:	b25b      	sxtb	r3, r3
}
 800cbf4:	0018      	movs	r0, r3
 800cbf6:	46bd      	mov	sp, r7
 800cbf8:	b006      	add	sp, #24
 800cbfa:	bd80      	pop	{r7, pc}
 800cbfc:	0000ffff 	.word	0x0000ffff
 800cc00:	ffff8000 	.word	0xffff8000

0800cc04 <VL53L1_calc_pll_period_us>:
	level, VL53L1_TRACE_FUNCTION_NONE, ##__VA_ARGS__)


uint32_t VL53L1_calc_pll_period_us(
	uint16_t  fast_osc_frequency)
{
 800cc04:	b580      	push	{r7, lr}
 800cc06:	b084      	sub	sp, #16
 800cc08:	af00      	add	r7, sp, #0
 800cc0a:	0002      	movs	r2, r0
 800cc0c:	1dbb      	adds	r3, r7, #6
 800cc0e:	801a      	strh	r2, [r3, #0]
	 *  ->  only the 18 LS bits are used
	 *
	 *  2^30 = (2^24) (1.0us) * 4096 (2^12) / 64 (PLL Multiplier)
	 */

	uint32_t  pll_period_us        = 0;
 800cc10:	2300      	movs	r3, #0
 800cc12:	60fb      	str	r3, [r7, #12]

	LOG_FUNCTION_START("");

	pll_period_us = (0x01 << 30) / fast_osc_frequency;
 800cc14:	1dbb      	adds	r3, r7, #6
 800cc16:	881b      	ldrh	r3, [r3, #0]
 800cc18:	0019      	movs	r1, r3
 800cc1a:	2380      	movs	r3, #128	; 0x80
 800cc1c:	05d8      	lsls	r0, r3, #23
 800cc1e:	f7f3 fb0f 	bl	8000240 <__divsi3>
 800cc22:	0003      	movs	r3, r0
 800cc24:	60fb      	str	r3, [r7, #12]
			pll_period_us);
#endif

	LOG_FUNCTION_END(0);

	return pll_period_us;
 800cc26:	68fb      	ldr	r3, [r7, #12]
}
 800cc28:	0018      	movs	r0, r3
 800cc2a:	46bd      	mov	sp, r7
 800cc2c:	b004      	add	sp, #16
 800cc2e:	bd80      	pop	{r7, pc}

0800cc30 <VL53L1_decode_vcsel_period>:
	return range_mm;
}
#endif

uint8_t VL53L1_decode_vcsel_period(uint8_t vcsel_period_reg)
{
 800cc30:	b580      	push	{r7, lr}
 800cc32:	b084      	sub	sp, #16
 800cc34:	af00      	add	r7, sp, #0
 800cc36:	0002      	movs	r2, r0
 800cc38:	1dfb      	adds	r3, r7, #7
 800cc3a:	701a      	strb	r2, [r3, #0]
	/*
	 * Converts the encoded VCSEL period register value into
	 * the real period in PLL clocks
	 */

	uint8_t vcsel_period_pclks = 0;
 800cc3c:	210f      	movs	r1, #15
 800cc3e:	187b      	adds	r3, r7, r1
 800cc40:	2200      	movs	r2, #0
 800cc42:	701a      	strb	r2, [r3, #0]

	vcsel_period_pclks = (vcsel_period_reg + 1) << 1;
 800cc44:	1dfb      	adds	r3, r7, #7
 800cc46:	781b      	ldrb	r3, [r3, #0]
 800cc48:	3301      	adds	r3, #1
 800cc4a:	b2db      	uxtb	r3, r3
 800cc4c:	187a      	adds	r2, r7, r1
 800cc4e:	18db      	adds	r3, r3, r3
 800cc50:	7013      	strb	r3, [r2, #0]

	return vcsel_period_pclks;
 800cc52:	187b      	adds	r3, r7, r1
 800cc54:	781b      	ldrb	r3, [r3, #0]
}
 800cc56:	0018      	movs	r0, r3
 800cc58:	46bd      	mov	sp, r7
 800cc5a:	b004      	add	sp, #16
 800cc5c:	bd80      	pop	{r7, pc}

0800cc5e <VL53L1_decode_row_col>:

void VL53L1_decode_row_col(
	uint8_t  spad_number,
	uint8_t  *prow,
	uint8_t  *pcol)
{
 800cc5e:	b580      	push	{r7, lr}
 800cc60:	b084      	sub	sp, #16
 800cc62:	af00      	add	r7, sp, #0
 800cc64:	60b9      	str	r1, [r7, #8]
 800cc66:	607a      	str	r2, [r7, #4]
 800cc68:	210f      	movs	r1, #15
 800cc6a:	187b      	adds	r3, r7, r1
 800cc6c:	1c02      	adds	r2, r0, #0
 800cc6e:	701a      	strb	r2, [r3, #0]
	/**
	 *  Decodes the array (row,col) location from
	 *  the input SPAD number
	 */

	if (spad_number > 127) {
 800cc70:	187b      	adds	r3, r7, r1
 800cc72:	781b      	ldrb	r3, [r3, #0]
 800cc74:	b25b      	sxtb	r3, r3
 800cc76:	2b00      	cmp	r3, #0
 800cc78:	da13      	bge.n	800cca2 <VL53L1_decode_row_col+0x44>
		*prow = 8 + ((255-spad_number) & 0x07);
 800cc7a:	210f      	movs	r1, #15
 800cc7c:	187b      	adds	r3, r7, r1
 800cc7e:	781b      	ldrb	r3, [r3, #0]
 800cc80:	43db      	mvns	r3, r3
 800cc82:	b2db      	uxtb	r3, r3
 800cc84:	2207      	movs	r2, #7
 800cc86:	4013      	ands	r3, r2
 800cc88:	b2db      	uxtb	r3, r3
 800cc8a:	3308      	adds	r3, #8
 800cc8c:	b2da      	uxtb	r2, r3
 800cc8e:	68bb      	ldr	r3, [r7, #8]
 800cc90:	701a      	strb	r2, [r3, #0]
		*pcol = (spad_number-128) >> 3;
 800cc92:	187b      	adds	r3, r7, r1
 800cc94:	781b      	ldrb	r3, [r3, #0]
 800cc96:	3b80      	subs	r3, #128	; 0x80
 800cc98:	10db      	asrs	r3, r3, #3
 800cc9a:	b2da      	uxtb	r2, r3
 800cc9c:	687b      	ldr	r3, [r7, #4]
 800cc9e:	701a      	strb	r2, [r3, #0]
	} else {
		*prow = spad_number & 0x07;
		*pcol = (127-spad_number) >> 3;
	}
}
 800cca0:	e00f      	b.n	800ccc2 <VL53L1_decode_row_col+0x64>
		*prow = spad_number & 0x07;
 800cca2:	210f      	movs	r1, #15
 800cca4:	187b      	adds	r3, r7, r1
 800cca6:	781b      	ldrb	r3, [r3, #0]
 800cca8:	2207      	movs	r2, #7
 800ccaa:	4013      	ands	r3, r2
 800ccac:	b2da      	uxtb	r2, r3
 800ccae:	68bb      	ldr	r3, [r7, #8]
 800ccb0:	701a      	strb	r2, [r3, #0]
		*pcol = (127-spad_number) >> 3;
 800ccb2:	187b      	adds	r3, r7, r1
 800ccb4:	781b      	ldrb	r3, [r3, #0]
 800ccb6:	227f      	movs	r2, #127	; 0x7f
 800ccb8:	1ad3      	subs	r3, r2, r3
 800ccba:	10db      	asrs	r3, r3, #3
 800ccbc:	b2da      	uxtb	r2, r3
 800ccbe:	687b      	ldr	r3, [r7, #4]
 800ccc0:	701a      	strb	r2, [r3, #0]
}
 800ccc2:	46c0      	nop			; (mov r8, r8)
 800ccc4:	46bd      	mov	sp, r7
 800ccc6:	b004      	add	sp, #16
 800ccc8:	bd80      	pop	{r7, pc}

0800ccca <VL53L1_i2c_encode_static_nvm_managed>:

VL53L1_Error VL53L1_i2c_encode_static_nvm_managed(
	VL53L1_static_nvm_managed_t *pdata,
	uint16_t                  buf_size,
	uint8_t                  *pbuffer)
{
 800ccca:	b580      	push	{r7, lr}
 800cccc:	b086      	sub	sp, #24
 800ccce:	af00      	add	r7, sp, #0
 800ccd0:	60f8      	str	r0, [r7, #12]
 800ccd2:	607a      	str	r2, [r7, #4]
 800ccd4:	200a      	movs	r0, #10
 800ccd6:	183b      	adds	r3, r7, r0
 800ccd8:	1c0a      	adds	r2, r1, #0
 800ccda:	801a      	strh	r2, [r3, #0]
	/**
	 * Encodes data structure VL53L1_static_nvm_managed_t into a I2C write buffer
	 * Buffer must be at least 11 bytes
	*/

	VL53L1_Error status = VL53L1_ERROR_NONE;
 800ccdc:	2317      	movs	r3, #23
 800ccde:	18fb      	adds	r3, r7, r3
 800cce0:	2200      	movs	r2, #0
 800cce2:	701a      	strb	r2, [r3, #0]

	LOG_FUNCTION_START("");

	if (VL53L1_STATIC_NVM_MANAGED_I2C_SIZE_BYTES > buf_size)
 800cce4:	183b      	adds	r3, r7, r0
 800cce6:	881b      	ldrh	r3, [r3, #0]
 800cce8:	2b0a      	cmp	r3, #10
 800ccea:	d802      	bhi.n	800ccf2 <VL53L1_i2c_encode_static_nvm_managed+0x28>
		return VL53L1_ERROR_COMMS_BUFFER_TOO_SMALL;
 800ccec:	230a      	movs	r3, #10
 800ccee:	425b      	negs	r3, r3
 800ccf0:	e049      	b.n	800cd86 <VL53L1_i2c_encode_static_nvm_managed+0xbc>

	*(pbuffer +   0) =
		pdata->i2c_slave__device_address & 0x7F;
 800ccf2:	68fb      	ldr	r3, [r7, #12]
 800ccf4:	781b      	ldrb	r3, [r3, #0]
 800ccf6:	227f      	movs	r2, #127	; 0x7f
 800ccf8:	4013      	ands	r3, r2
 800ccfa:	b2da      	uxtb	r2, r3
	*(pbuffer +   0) =
 800ccfc:	687b      	ldr	r3, [r7, #4]
 800ccfe:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   1) =
		pdata->ana_config__vhv_ref_sel_vddpix & 0xF;
 800cd00:	68fb      	ldr	r3, [r7, #12]
 800cd02:	785a      	ldrb	r2, [r3, #1]
	*(pbuffer +   1) =
 800cd04:	687b      	ldr	r3, [r7, #4]
 800cd06:	3301      	adds	r3, #1
		pdata->ana_config__vhv_ref_sel_vddpix & 0xF;
 800cd08:	210f      	movs	r1, #15
 800cd0a:	400a      	ands	r2, r1
 800cd0c:	b2d2      	uxtb	r2, r2
	*(pbuffer +   1) =
 800cd0e:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   2) =
		pdata->ana_config__vhv_ref_sel_vquench & 0x7F;
 800cd10:	68fb      	ldr	r3, [r7, #12]
 800cd12:	789a      	ldrb	r2, [r3, #2]
	*(pbuffer +   2) =
 800cd14:	687b      	ldr	r3, [r7, #4]
 800cd16:	3302      	adds	r3, #2
		pdata->ana_config__vhv_ref_sel_vquench & 0x7F;
 800cd18:	217f      	movs	r1, #127	; 0x7f
 800cd1a:	400a      	ands	r2, r1
 800cd1c:	b2d2      	uxtb	r2, r2
	*(pbuffer +   2) =
 800cd1e:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   3) =
		pdata->ana_config__reg_avdd1v2_sel & 0x3;
 800cd20:	68fb      	ldr	r3, [r7, #12]
 800cd22:	78da      	ldrb	r2, [r3, #3]
	*(pbuffer +   3) =
 800cd24:	687b      	ldr	r3, [r7, #4]
 800cd26:	3303      	adds	r3, #3
		pdata->ana_config__reg_avdd1v2_sel & 0x3;
 800cd28:	2103      	movs	r1, #3
 800cd2a:	400a      	ands	r2, r1
 800cd2c:	b2d2      	uxtb	r2, r2
	*(pbuffer +   3) =
 800cd2e:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   4) =
		pdata->ana_config__fast_osc__trim & 0x7F;
 800cd30:	68fb      	ldr	r3, [r7, #12]
 800cd32:	791a      	ldrb	r2, [r3, #4]
	*(pbuffer +   4) =
 800cd34:	687b      	ldr	r3, [r7, #4]
 800cd36:	3304      	adds	r3, #4
		pdata->ana_config__fast_osc__trim & 0x7F;
 800cd38:	217f      	movs	r1, #127	; 0x7f
 800cd3a:	400a      	ands	r2, r1
 800cd3c:	b2d2      	uxtb	r2, r2
	*(pbuffer +   4) =
 800cd3e:	701a      	strb	r2, [r3, #0]
	VL53L1_i2c_encode_uint16_t(
 800cd40:	68fb      	ldr	r3, [r7, #12]
 800cd42:	88d8      	ldrh	r0, [r3, #6]
 800cd44:	687b      	ldr	r3, [r7, #4]
 800cd46:	3305      	adds	r3, #5
 800cd48:	001a      	movs	r2, r3
 800cd4a:	2102      	movs	r1, #2
 800cd4c:	f7ff f9d7 	bl	800c0fe <VL53L1_i2c_encode_uint16_t>
		pdata->osc_measured__fast_osc__frequency,
		2,
		pbuffer +   5);
	*(pbuffer +   7) =
 800cd50:	687b      	ldr	r3, [r7, #4]
 800cd52:	3307      	adds	r3, #7
		pdata->vhv_config__timeout_macrop_loop_bound;
 800cd54:	68fa      	ldr	r2, [r7, #12]
 800cd56:	7a12      	ldrb	r2, [r2, #8]
	*(pbuffer +   7) =
 800cd58:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   8) =
 800cd5a:	687b      	ldr	r3, [r7, #4]
 800cd5c:	3308      	adds	r3, #8
		pdata->vhv_config__count_thresh;
 800cd5e:	68fa      	ldr	r2, [r7, #12]
 800cd60:	7a52      	ldrb	r2, [r2, #9]
	*(pbuffer +   8) =
 800cd62:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   9) =
		pdata->vhv_config__offset & 0x3F;
 800cd64:	68fb      	ldr	r3, [r7, #12]
 800cd66:	7a9a      	ldrb	r2, [r3, #10]
	*(pbuffer +   9) =
 800cd68:	687b      	ldr	r3, [r7, #4]
 800cd6a:	3309      	adds	r3, #9
		pdata->vhv_config__offset & 0x3F;
 800cd6c:	213f      	movs	r1, #63	; 0x3f
 800cd6e:	400a      	ands	r2, r1
 800cd70:	b2d2      	uxtb	r2, r2
	*(pbuffer +   9) =
 800cd72:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  10) =
 800cd74:	687b      	ldr	r3, [r7, #4]
 800cd76:	330a      	adds	r3, #10
		pdata->vhv_config__init;
 800cd78:	68fa      	ldr	r2, [r7, #12]
 800cd7a:	7ad2      	ldrb	r2, [r2, #11]
	*(pbuffer +  10) =
 800cd7c:	701a      	strb	r2, [r3, #0]
	LOG_FUNCTION_END(status);


	return status;
 800cd7e:	2317      	movs	r3, #23
 800cd80:	18fb      	adds	r3, r7, r3
 800cd82:	781b      	ldrb	r3, [r3, #0]
 800cd84:	b25b      	sxtb	r3, r3
}
 800cd86:	0018      	movs	r0, r3
 800cd88:	46bd      	mov	sp, r7
 800cd8a:	b006      	add	sp, #24
 800cd8c:	bd80      	pop	{r7, pc}

0800cd8e <VL53L1_i2c_decode_static_nvm_managed>:

VL53L1_Error VL53L1_i2c_decode_static_nvm_managed(
	uint16_t                   buf_size,
	uint8_t                   *pbuffer,
	VL53L1_static_nvm_managed_t  *pdata)
{
 800cd8e:	b580      	push	{r7, lr}
 800cd90:	b086      	sub	sp, #24
 800cd92:	af00      	add	r7, sp, #0
 800cd94:	60b9      	str	r1, [r7, #8]
 800cd96:	607a      	str	r2, [r7, #4]
 800cd98:	210e      	movs	r1, #14
 800cd9a:	187b      	adds	r3, r7, r1
 800cd9c:	1c02      	adds	r2, r0, #0
 800cd9e:	801a      	strh	r2, [r3, #0]
	/**
	 * Decodes data structure VL53L1_static_nvm_managed_t from the input I2C read buffer
	 * Buffer must be at least 11 bytes
	*/

	VL53L1_Error status = VL53L1_ERROR_NONE;
 800cda0:	2317      	movs	r3, #23
 800cda2:	18fb      	adds	r3, r7, r3
 800cda4:	2200      	movs	r2, #0
 800cda6:	701a      	strb	r2, [r3, #0]

	LOG_FUNCTION_START("");

	if (VL53L1_STATIC_NVM_MANAGED_I2C_SIZE_BYTES > buf_size)
 800cda8:	187b      	adds	r3, r7, r1
 800cdaa:	881b      	ldrh	r3, [r3, #0]
 800cdac:	2b0a      	cmp	r3, #10
 800cdae:	d802      	bhi.n	800cdb6 <VL53L1_i2c_decode_static_nvm_managed+0x28>
		return VL53L1_ERROR_COMMS_BUFFER_TOO_SMALL;
 800cdb0:	230a      	movs	r3, #10
 800cdb2:	425b      	negs	r3, r3
 800cdb4:	e048      	b.n	800ce48 <VL53L1_i2c_decode_static_nvm_managed+0xba>

	pdata->i2c_slave__device_address =
		(*(pbuffer +   0)) & 0x7F;
 800cdb6:	68bb      	ldr	r3, [r7, #8]
 800cdb8:	781b      	ldrb	r3, [r3, #0]
 800cdba:	227f      	movs	r2, #127	; 0x7f
 800cdbc:	4013      	ands	r3, r2
 800cdbe:	b2da      	uxtb	r2, r3
	pdata->i2c_slave__device_address =
 800cdc0:	687b      	ldr	r3, [r7, #4]
 800cdc2:	701a      	strb	r2, [r3, #0]
	pdata->ana_config__vhv_ref_sel_vddpix =
		(*(pbuffer +   1)) & 0xF;
 800cdc4:	68bb      	ldr	r3, [r7, #8]
 800cdc6:	3301      	adds	r3, #1
 800cdc8:	781b      	ldrb	r3, [r3, #0]
 800cdca:	220f      	movs	r2, #15
 800cdcc:	4013      	ands	r3, r2
 800cdce:	b2da      	uxtb	r2, r3
	pdata->ana_config__vhv_ref_sel_vddpix =
 800cdd0:	687b      	ldr	r3, [r7, #4]
 800cdd2:	705a      	strb	r2, [r3, #1]
	pdata->ana_config__vhv_ref_sel_vquench =
		(*(pbuffer +   2)) & 0x7F;
 800cdd4:	68bb      	ldr	r3, [r7, #8]
 800cdd6:	3302      	adds	r3, #2
 800cdd8:	781b      	ldrb	r3, [r3, #0]
 800cdda:	227f      	movs	r2, #127	; 0x7f
 800cddc:	4013      	ands	r3, r2
 800cdde:	b2da      	uxtb	r2, r3
	pdata->ana_config__vhv_ref_sel_vquench =
 800cde0:	687b      	ldr	r3, [r7, #4]
 800cde2:	709a      	strb	r2, [r3, #2]
	pdata->ana_config__reg_avdd1v2_sel =
		(*(pbuffer +   3)) & 0x3;
 800cde4:	68bb      	ldr	r3, [r7, #8]
 800cde6:	3303      	adds	r3, #3
 800cde8:	781b      	ldrb	r3, [r3, #0]
 800cdea:	2203      	movs	r2, #3
 800cdec:	4013      	ands	r3, r2
 800cdee:	b2da      	uxtb	r2, r3
	pdata->ana_config__reg_avdd1v2_sel =
 800cdf0:	687b      	ldr	r3, [r7, #4]
 800cdf2:	70da      	strb	r2, [r3, #3]
	pdata->ana_config__fast_osc__trim =
		(*(pbuffer +   4)) & 0x7F;
 800cdf4:	68bb      	ldr	r3, [r7, #8]
 800cdf6:	3304      	adds	r3, #4
 800cdf8:	781b      	ldrb	r3, [r3, #0]
 800cdfa:	227f      	movs	r2, #127	; 0x7f
 800cdfc:	4013      	ands	r3, r2
 800cdfe:	b2da      	uxtb	r2, r3
	pdata->ana_config__fast_osc__trim =
 800ce00:	687b      	ldr	r3, [r7, #4]
 800ce02:	711a      	strb	r2, [r3, #4]
	pdata->osc_measured__fast_osc__frequency =
		(VL53L1_i2c_decode_uint16_t(2, pbuffer +   5));
 800ce04:	68bb      	ldr	r3, [r7, #8]
 800ce06:	3305      	adds	r3, #5
 800ce08:	0019      	movs	r1, r3
 800ce0a:	2002      	movs	r0, #2
 800ce0c:	f7ff f9b4 	bl	800c178 <VL53L1_i2c_decode_uint16_t>
 800ce10:	0003      	movs	r3, r0
 800ce12:	001a      	movs	r2, r3
	pdata->osc_measured__fast_osc__frequency =
 800ce14:	687b      	ldr	r3, [r7, #4]
 800ce16:	80da      	strh	r2, [r3, #6]
	pdata->vhv_config__timeout_macrop_loop_bound =
 800ce18:	68bb      	ldr	r3, [r7, #8]
 800ce1a:	79da      	ldrb	r2, [r3, #7]
 800ce1c:	687b      	ldr	r3, [r7, #4]
 800ce1e:	721a      	strb	r2, [r3, #8]
		(*(pbuffer +   7));
	pdata->vhv_config__count_thresh =
 800ce20:	68bb      	ldr	r3, [r7, #8]
 800ce22:	7a1a      	ldrb	r2, [r3, #8]
 800ce24:	687b      	ldr	r3, [r7, #4]
 800ce26:	725a      	strb	r2, [r3, #9]
		(*(pbuffer +   8));
	pdata->vhv_config__offset =
		(*(pbuffer +   9)) & 0x3F;
 800ce28:	68bb      	ldr	r3, [r7, #8]
 800ce2a:	3309      	adds	r3, #9
 800ce2c:	781b      	ldrb	r3, [r3, #0]
 800ce2e:	223f      	movs	r2, #63	; 0x3f
 800ce30:	4013      	ands	r3, r2
 800ce32:	b2da      	uxtb	r2, r3
	pdata->vhv_config__offset =
 800ce34:	687b      	ldr	r3, [r7, #4]
 800ce36:	729a      	strb	r2, [r3, #10]
	pdata->vhv_config__init =
 800ce38:	68bb      	ldr	r3, [r7, #8]
 800ce3a:	7a9a      	ldrb	r2, [r3, #10]
 800ce3c:	687b      	ldr	r3, [r7, #4]
 800ce3e:	72da      	strb	r2, [r3, #11]
		(*(pbuffer +  10));

	LOG_FUNCTION_END(status);

	return status;
 800ce40:	2317      	movs	r3, #23
 800ce42:	18fb      	adds	r3, r7, r3
 800ce44:	781b      	ldrb	r3, [r3, #0]
 800ce46:	b25b      	sxtb	r3, r3
}
 800ce48:	0018      	movs	r0, r3
 800ce4a:	46bd      	mov	sp, r7
 800ce4c:	b006      	add	sp, #24
 800ce4e:	bd80      	pop	{r7, pc}

0800ce50 <VL53L1_get_static_nvm_managed>:


VL53L1_Error VL53L1_get_static_nvm_managed(
	VL53L1_DEV                 Dev,
	VL53L1_static_nvm_managed_t  *pdata)
{
 800ce50:	b590      	push	{r4, r7, lr}
 800ce52:	b087      	sub	sp, #28
 800ce54:	af00      	add	r7, sp, #0
 800ce56:	6078      	str	r0, [r7, #4]
 800ce58:	6039      	str	r1, [r7, #0]
	/**
	 * Reads and de-serialises the contents of VL53L1_static_nvm_managed_t
	 * data structure from the device
	 */

	VL53L1_Error status = VL53L1_ERROR_NONE;
 800ce5a:	2117      	movs	r1, #23
 800ce5c:	187b      	adds	r3, r7, r1
 800ce5e:	2200      	movs	r2, #0
 800ce60:	701a      	strb	r2, [r3, #0]
	uint8_t comms_buffer[VL53L1_STATIC_NVM_MANAGED_I2C_SIZE_BYTES];

	LOG_FUNCTION_START("");

	if (status == VL53L1_ERROR_NONE) /*lint !e774 always true*/
 800ce62:	187b      	adds	r3, r7, r1
 800ce64:	781b      	ldrb	r3, [r3, #0]
 800ce66:	b25b      	sxtb	r3, r3
 800ce68:	2b00      	cmp	r3, #0
 800ce6a:	d10a      	bne.n	800ce82 <VL53L1_get_static_nvm_managed+0x32>
		status = VL53L1_ReadMulti(
 800ce6c:	2317      	movs	r3, #23
 800ce6e:	18fc      	adds	r4, r7, r3
 800ce70:	230c      	movs	r3, #12
 800ce72:	18fa      	adds	r2, r7, r3
 800ce74:	6878      	ldr	r0, [r7, #4]
 800ce76:	230b      	movs	r3, #11
 800ce78:	2101      	movs	r1, #1
 800ce7a:	f001 f9b3 	bl	800e1e4 <VL53L1_ReadMulti>
 800ce7e:	0003      	movs	r3, r0
 800ce80:	7023      	strb	r3, [r4, #0]
			Dev,
			VL53L1_I2C_SLAVE__DEVICE_ADDRESS,
			comms_buffer,
			VL53L1_STATIC_NVM_MANAGED_I2C_SIZE_BYTES);

	if (status == VL53L1_ERROR_NONE)
 800ce82:	2317      	movs	r3, #23
 800ce84:	18fb      	adds	r3, r7, r3
 800ce86:	781b      	ldrb	r3, [r3, #0]
 800ce88:	b25b      	sxtb	r3, r3
 800ce8a:	2b00      	cmp	r3, #0
 800ce8c:	d10a      	bne.n	800cea4 <VL53L1_get_static_nvm_managed+0x54>
		status = VL53L1_i2c_decode_static_nvm_managed(
 800ce8e:	2317      	movs	r3, #23
 800ce90:	18fc      	adds	r4, r7, r3
 800ce92:	683a      	ldr	r2, [r7, #0]
 800ce94:	230c      	movs	r3, #12
 800ce96:	18fb      	adds	r3, r7, r3
 800ce98:	0019      	movs	r1, r3
 800ce9a:	200b      	movs	r0, #11
 800ce9c:	f7ff ff77 	bl	800cd8e <VL53L1_i2c_decode_static_nvm_managed>
 800cea0:	0003      	movs	r3, r0
 800cea2:	7023      	strb	r3, [r4, #0]
			comms_buffer,
			pdata);

	LOG_FUNCTION_END(status);

	return status;
 800cea4:	2317      	movs	r3, #23
 800cea6:	18fb      	adds	r3, r7, r3
 800cea8:	781b      	ldrb	r3, [r3, #0]
 800ceaa:	b25b      	sxtb	r3, r3
}
 800ceac:	0018      	movs	r0, r3
 800ceae:	46bd      	mov	sp, r7
 800ceb0:	b007      	add	sp, #28
 800ceb2:	bd90      	pop	{r4, r7, pc}

0800ceb4 <VL53L1_i2c_encode_customer_nvm_managed>:

VL53L1_Error VL53L1_i2c_encode_customer_nvm_managed(
	VL53L1_customer_nvm_managed_t *pdata,
	uint16_t                  buf_size,
	uint8_t                  *pbuffer)
{
 800ceb4:	b580      	push	{r7, lr}
 800ceb6:	b086      	sub	sp, #24
 800ceb8:	af00      	add	r7, sp, #0
 800ceba:	60f8      	str	r0, [r7, #12]
 800cebc:	607a      	str	r2, [r7, #4]
 800cebe:	200a      	movs	r0, #10
 800cec0:	183b      	adds	r3, r7, r0
 800cec2:	1c0a      	adds	r2, r1, #0
 800cec4:	801a      	strh	r2, [r3, #0]
	/**
	 * Encodes data structure VL53L1_customer_nvm_managed_t into a I2C write buffer
	 * Buffer must be at least 23 bytes
	*/

	VL53L1_Error status = VL53L1_ERROR_NONE;
 800cec6:	2317      	movs	r3, #23
 800cec8:	18fb      	adds	r3, r7, r3
 800ceca:	2200      	movs	r2, #0
 800cecc:	701a      	strb	r2, [r3, #0]

	LOG_FUNCTION_START("");

	if (VL53L1_CUSTOMER_NVM_MANAGED_I2C_SIZE_BYTES > buf_size)
 800cece:	183b      	adds	r3, r7, r0
 800ced0:	881b      	ldrh	r3, [r3, #0]
 800ced2:	2b16      	cmp	r3, #22
 800ced4:	d802      	bhi.n	800cedc <VL53L1_i2c_encode_customer_nvm_managed+0x28>
		return VL53L1_ERROR_COMMS_BUFFER_TOO_SMALL;
 800ced6:	230a      	movs	r3, #10
 800ced8:	425b      	negs	r3, r3
 800ceda:	e078      	b.n	800cfce <VL53L1_i2c_encode_customer_nvm_managed+0x11a>

	*(pbuffer +   0) =
		pdata->global_config__spad_enables_ref_0;
 800cedc:	68fb      	ldr	r3, [r7, #12]
 800cede:	781a      	ldrb	r2, [r3, #0]
	*(pbuffer +   0) =
 800cee0:	687b      	ldr	r3, [r7, #4]
 800cee2:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   1) =
 800cee4:	687b      	ldr	r3, [r7, #4]
 800cee6:	3301      	adds	r3, #1
		pdata->global_config__spad_enables_ref_1;
 800cee8:	68fa      	ldr	r2, [r7, #12]
 800ceea:	7852      	ldrb	r2, [r2, #1]
	*(pbuffer +   1) =
 800ceec:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   2) =
 800ceee:	687b      	ldr	r3, [r7, #4]
 800cef0:	3302      	adds	r3, #2
		pdata->global_config__spad_enables_ref_2;
 800cef2:	68fa      	ldr	r2, [r7, #12]
 800cef4:	7892      	ldrb	r2, [r2, #2]
	*(pbuffer +   2) =
 800cef6:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   3) =
 800cef8:	687b      	ldr	r3, [r7, #4]
 800cefa:	3303      	adds	r3, #3
		pdata->global_config__spad_enables_ref_3;
 800cefc:	68fa      	ldr	r2, [r7, #12]
 800cefe:	78d2      	ldrb	r2, [r2, #3]
	*(pbuffer +   3) =
 800cf00:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   4) =
 800cf02:	687b      	ldr	r3, [r7, #4]
 800cf04:	3304      	adds	r3, #4
		pdata->global_config__spad_enables_ref_4;
 800cf06:	68fa      	ldr	r2, [r7, #12]
 800cf08:	7912      	ldrb	r2, [r2, #4]
	*(pbuffer +   4) =
 800cf0a:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   5) =
		pdata->global_config__spad_enables_ref_5 & 0xF;
 800cf0c:	68fb      	ldr	r3, [r7, #12]
 800cf0e:	795a      	ldrb	r2, [r3, #5]
	*(pbuffer +   5) =
 800cf10:	687b      	ldr	r3, [r7, #4]
 800cf12:	3305      	adds	r3, #5
		pdata->global_config__spad_enables_ref_5 & 0xF;
 800cf14:	210f      	movs	r1, #15
 800cf16:	400a      	ands	r2, r1
 800cf18:	b2d2      	uxtb	r2, r2
	*(pbuffer +   5) =
 800cf1a:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   6) =
 800cf1c:	687b      	ldr	r3, [r7, #4]
 800cf1e:	3306      	adds	r3, #6
		pdata->global_config__ref_en_start_select;
 800cf20:	68fa      	ldr	r2, [r7, #12]
 800cf22:	7992      	ldrb	r2, [r2, #6]
	*(pbuffer +   6) =
 800cf24:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   7) =
		pdata->ref_spad_man__num_requested_ref_spads & 0x3F;
 800cf26:	68fb      	ldr	r3, [r7, #12]
 800cf28:	79da      	ldrb	r2, [r3, #7]
	*(pbuffer +   7) =
 800cf2a:	687b      	ldr	r3, [r7, #4]
 800cf2c:	3307      	adds	r3, #7
		pdata->ref_spad_man__num_requested_ref_spads & 0x3F;
 800cf2e:	213f      	movs	r1, #63	; 0x3f
 800cf30:	400a      	ands	r2, r1
 800cf32:	b2d2      	uxtb	r2, r2
	*(pbuffer +   7) =
 800cf34:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   8) =
		pdata->ref_spad_man__ref_location & 0x3;
 800cf36:	68fb      	ldr	r3, [r7, #12]
 800cf38:	7a1a      	ldrb	r2, [r3, #8]
	*(pbuffer +   8) =
 800cf3a:	687b      	ldr	r3, [r7, #4]
 800cf3c:	3308      	adds	r3, #8
		pdata->ref_spad_man__ref_location & 0x3;
 800cf3e:	2103      	movs	r1, #3
 800cf40:	400a      	ands	r2, r1
 800cf42:	b2d2      	uxtb	r2, r2
	*(pbuffer +   8) =
 800cf44:	701a      	strb	r2, [r3, #0]
	VL53L1_i2c_encode_uint16_t(
 800cf46:	68fb      	ldr	r3, [r7, #12]
 800cf48:	8958      	ldrh	r0, [r3, #10]
 800cf4a:	687b      	ldr	r3, [r7, #4]
 800cf4c:	3309      	adds	r3, #9
 800cf4e:	001a      	movs	r2, r3
 800cf50:	2102      	movs	r1, #2
 800cf52:	f7ff f8d4 	bl	800c0fe <VL53L1_i2c_encode_uint16_t>
		pdata->algo__crosstalk_compensation_plane_offset_kcps,
		2,
		pbuffer +   9);
	VL53L1_i2c_encode_int16_t(
 800cf56:	68fb      	ldr	r3, [r7, #12]
 800cf58:	200c      	movs	r0, #12
 800cf5a:	5e18      	ldrsh	r0, [r3, r0]
 800cf5c:	687b      	ldr	r3, [r7, #4]
 800cf5e:	330b      	adds	r3, #11
 800cf60:	001a      	movs	r2, r3
 800cf62:	2102      	movs	r1, #2
 800cf64:	f7ff f930 	bl	800c1c8 <VL53L1_i2c_encode_int16_t>
		pdata->algo__crosstalk_compensation_x_plane_gradient_kcps,
		2,
		pbuffer +  11);
	VL53L1_i2c_encode_int16_t(
 800cf68:	68fb      	ldr	r3, [r7, #12]
 800cf6a:	200e      	movs	r0, #14
 800cf6c:	5e18      	ldrsh	r0, [r3, r0]
 800cf6e:	687b      	ldr	r3, [r7, #4]
 800cf70:	330d      	adds	r3, #13
 800cf72:	001a      	movs	r2, r3
 800cf74:	2102      	movs	r1, #2
 800cf76:	f7ff f927 	bl	800c1c8 <VL53L1_i2c_encode_int16_t>
		pdata->algo__crosstalk_compensation_y_plane_gradient_kcps,
		2,
		pbuffer +  13);
	VL53L1_i2c_encode_uint16_t(
 800cf7a:	68fb      	ldr	r3, [r7, #12]
 800cf7c:	8a18      	ldrh	r0, [r3, #16]
 800cf7e:	687b      	ldr	r3, [r7, #4]
 800cf80:	330f      	adds	r3, #15
 800cf82:	001a      	movs	r2, r3
 800cf84:	2102      	movs	r1, #2
 800cf86:	f7ff f8ba 	bl	800c0fe <VL53L1_i2c_encode_uint16_t>
		pdata->ref_spad_char__total_rate_target_mcps,
		2,
		pbuffer +  15);
	VL53L1_i2c_encode_int16_t(
		pdata->algo__part_to_part_range_offset_mm & 0x1FFF,
 800cf8a:	68fb      	ldr	r3, [r7, #12]
 800cf8c:	2212      	movs	r2, #18
 800cf8e:	5e9b      	ldrsh	r3, [r3, r2]
	VL53L1_i2c_encode_int16_t(
 800cf90:	04db      	lsls	r3, r3, #19
 800cf92:	0cdb      	lsrs	r3, r3, #19
 800cf94:	b218      	sxth	r0, r3
 800cf96:	687b      	ldr	r3, [r7, #4]
 800cf98:	3311      	adds	r3, #17
 800cf9a:	001a      	movs	r2, r3
 800cf9c:	2102      	movs	r1, #2
 800cf9e:	f7ff f913 	bl	800c1c8 <VL53L1_i2c_encode_int16_t>
		2,
		pbuffer +  17);
	VL53L1_i2c_encode_int16_t(
 800cfa2:	68fb      	ldr	r3, [r7, #12]
 800cfa4:	2014      	movs	r0, #20
 800cfa6:	5e18      	ldrsh	r0, [r3, r0]
 800cfa8:	687b      	ldr	r3, [r7, #4]
 800cfaa:	3313      	adds	r3, #19
 800cfac:	001a      	movs	r2, r3
 800cfae:	2102      	movs	r1, #2
 800cfb0:	f7ff f90a 	bl	800c1c8 <VL53L1_i2c_encode_int16_t>
		pdata->mm_config__inner_offset_mm,
		2,
		pbuffer +  19);
	VL53L1_i2c_encode_int16_t(
 800cfb4:	68fb      	ldr	r3, [r7, #12]
 800cfb6:	2016      	movs	r0, #22
 800cfb8:	5e18      	ldrsh	r0, [r3, r0]
 800cfba:	687b      	ldr	r3, [r7, #4]
 800cfbc:	3315      	adds	r3, #21
 800cfbe:	001a      	movs	r2, r3
 800cfc0:	2102      	movs	r1, #2
 800cfc2:	f7ff f901 	bl	800c1c8 <VL53L1_i2c_encode_int16_t>
		2,
		pbuffer +  21);
	LOG_FUNCTION_END(status);


	return status;
 800cfc6:	2317      	movs	r3, #23
 800cfc8:	18fb      	adds	r3, r7, r3
 800cfca:	781b      	ldrb	r3, [r3, #0]
 800cfcc:	b25b      	sxtb	r3, r3
}
 800cfce:	0018      	movs	r0, r3
 800cfd0:	46bd      	mov	sp, r7
 800cfd2:	b006      	add	sp, #24
 800cfd4:	bd80      	pop	{r7, pc}

0800cfd6 <VL53L1_i2c_decode_customer_nvm_managed>:

VL53L1_Error VL53L1_i2c_decode_customer_nvm_managed(
	uint16_t                   buf_size,
	uint8_t                   *pbuffer,
	VL53L1_customer_nvm_managed_t  *pdata)
{
 800cfd6:	b580      	push	{r7, lr}
 800cfd8:	b086      	sub	sp, #24
 800cfda:	af00      	add	r7, sp, #0
 800cfdc:	60b9      	str	r1, [r7, #8]
 800cfde:	607a      	str	r2, [r7, #4]
 800cfe0:	210e      	movs	r1, #14
 800cfe2:	187b      	adds	r3, r7, r1
 800cfe4:	1c02      	adds	r2, r0, #0
 800cfe6:	801a      	strh	r2, [r3, #0]
	/**
	 * Decodes data structure VL53L1_customer_nvm_managed_t from the input I2C read buffer
	 * Buffer must be at least 23 bytes
	*/

	VL53L1_Error status = VL53L1_ERROR_NONE;
 800cfe8:	2317      	movs	r3, #23
 800cfea:	18fb      	adds	r3, r7, r3
 800cfec:	2200      	movs	r2, #0
 800cfee:	701a      	strb	r2, [r3, #0]

	LOG_FUNCTION_START("");

	if (VL53L1_CUSTOMER_NVM_MANAGED_I2C_SIZE_BYTES > buf_size)
 800cff0:	187b      	adds	r3, r7, r1
 800cff2:	881b      	ldrh	r3, [r3, #0]
 800cff4:	2b16      	cmp	r3, #22
 800cff6:	d802      	bhi.n	800cffe <VL53L1_i2c_decode_customer_nvm_managed+0x28>
		return VL53L1_ERROR_COMMS_BUFFER_TOO_SMALL;
 800cff8:	230a      	movs	r3, #10
 800cffa:	425b      	negs	r3, r3
 800cffc:	e07b      	b.n	800d0f6 <VL53L1_i2c_decode_customer_nvm_managed+0x120>

	pdata->global_config__spad_enables_ref_0 =
		(*(pbuffer +   0));
 800cffe:	68bb      	ldr	r3, [r7, #8]
 800d000:	781a      	ldrb	r2, [r3, #0]
	pdata->global_config__spad_enables_ref_0 =
 800d002:	687b      	ldr	r3, [r7, #4]
 800d004:	701a      	strb	r2, [r3, #0]
	pdata->global_config__spad_enables_ref_1 =
 800d006:	68bb      	ldr	r3, [r7, #8]
 800d008:	785a      	ldrb	r2, [r3, #1]
 800d00a:	687b      	ldr	r3, [r7, #4]
 800d00c:	705a      	strb	r2, [r3, #1]
		(*(pbuffer +   1));
	pdata->global_config__spad_enables_ref_2 =
 800d00e:	68bb      	ldr	r3, [r7, #8]
 800d010:	789a      	ldrb	r2, [r3, #2]
 800d012:	687b      	ldr	r3, [r7, #4]
 800d014:	709a      	strb	r2, [r3, #2]
		(*(pbuffer +   2));
	pdata->global_config__spad_enables_ref_3 =
 800d016:	68bb      	ldr	r3, [r7, #8]
 800d018:	78da      	ldrb	r2, [r3, #3]
 800d01a:	687b      	ldr	r3, [r7, #4]
 800d01c:	70da      	strb	r2, [r3, #3]
		(*(pbuffer +   3));
	pdata->global_config__spad_enables_ref_4 =
 800d01e:	68bb      	ldr	r3, [r7, #8]
 800d020:	791a      	ldrb	r2, [r3, #4]
 800d022:	687b      	ldr	r3, [r7, #4]
 800d024:	711a      	strb	r2, [r3, #4]
		(*(pbuffer +   4));
	pdata->global_config__spad_enables_ref_5 =
		(*(pbuffer +   5)) & 0xF;
 800d026:	68bb      	ldr	r3, [r7, #8]
 800d028:	3305      	adds	r3, #5
 800d02a:	781b      	ldrb	r3, [r3, #0]
 800d02c:	220f      	movs	r2, #15
 800d02e:	4013      	ands	r3, r2
 800d030:	b2da      	uxtb	r2, r3
	pdata->global_config__spad_enables_ref_5 =
 800d032:	687b      	ldr	r3, [r7, #4]
 800d034:	715a      	strb	r2, [r3, #5]
	pdata->global_config__ref_en_start_select =
 800d036:	68bb      	ldr	r3, [r7, #8]
 800d038:	799a      	ldrb	r2, [r3, #6]
 800d03a:	687b      	ldr	r3, [r7, #4]
 800d03c:	719a      	strb	r2, [r3, #6]
		(*(pbuffer +   6));
	pdata->ref_spad_man__num_requested_ref_spads =
		(*(pbuffer +   7)) & 0x3F;
 800d03e:	68bb      	ldr	r3, [r7, #8]
 800d040:	3307      	adds	r3, #7
 800d042:	781b      	ldrb	r3, [r3, #0]
 800d044:	223f      	movs	r2, #63	; 0x3f
 800d046:	4013      	ands	r3, r2
 800d048:	b2da      	uxtb	r2, r3
	pdata->ref_spad_man__num_requested_ref_spads =
 800d04a:	687b      	ldr	r3, [r7, #4]
 800d04c:	71da      	strb	r2, [r3, #7]
	pdata->ref_spad_man__ref_location =
		(*(pbuffer +   8)) & 0x3;
 800d04e:	68bb      	ldr	r3, [r7, #8]
 800d050:	3308      	adds	r3, #8
 800d052:	781b      	ldrb	r3, [r3, #0]
 800d054:	2203      	movs	r2, #3
 800d056:	4013      	ands	r3, r2
 800d058:	b2da      	uxtb	r2, r3
	pdata->ref_spad_man__ref_location =
 800d05a:	687b      	ldr	r3, [r7, #4]
 800d05c:	721a      	strb	r2, [r3, #8]
	pdata->algo__crosstalk_compensation_plane_offset_kcps =
		(VL53L1_i2c_decode_uint16_t(2, pbuffer +   9));
 800d05e:	68bb      	ldr	r3, [r7, #8]
 800d060:	3309      	adds	r3, #9
 800d062:	0019      	movs	r1, r3
 800d064:	2002      	movs	r0, #2
 800d066:	f7ff f887 	bl	800c178 <VL53L1_i2c_decode_uint16_t>
 800d06a:	0003      	movs	r3, r0
 800d06c:	001a      	movs	r2, r3
	pdata->algo__crosstalk_compensation_plane_offset_kcps =
 800d06e:	687b      	ldr	r3, [r7, #4]
 800d070:	815a      	strh	r2, [r3, #10]
	pdata->algo__crosstalk_compensation_x_plane_gradient_kcps =
		(VL53L1_i2c_decode_int16_t(2, pbuffer +  11));
 800d072:	68bb      	ldr	r3, [r7, #8]
 800d074:	330b      	adds	r3, #11
 800d076:	0019      	movs	r1, r3
 800d078:	2002      	movs	r0, #2
 800d07a:	f7ff f8e3 	bl	800c244 <VL53L1_i2c_decode_int16_t>
 800d07e:	0003      	movs	r3, r0
 800d080:	001a      	movs	r2, r3
	pdata->algo__crosstalk_compensation_x_plane_gradient_kcps =
 800d082:	687b      	ldr	r3, [r7, #4]
 800d084:	819a      	strh	r2, [r3, #12]
	pdata->algo__crosstalk_compensation_y_plane_gradient_kcps =
		(VL53L1_i2c_decode_int16_t(2, pbuffer +  13));
 800d086:	68bb      	ldr	r3, [r7, #8]
 800d088:	330d      	adds	r3, #13
 800d08a:	0019      	movs	r1, r3
 800d08c:	2002      	movs	r0, #2
 800d08e:	f7ff f8d9 	bl	800c244 <VL53L1_i2c_decode_int16_t>
 800d092:	0003      	movs	r3, r0
 800d094:	001a      	movs	r2, r3
	pdata->algo__crosstalk_compensation_y_plane_gradient_kcps =
 800d096:	687b      	ldr	r3, [r7, #4]
 800d098:	81da      	strh	r2, [r3, #14]
	pdata->ref_spad_char__total_rate_target_mcps =
		(VL53L1_i2c_decode_uint16_t(2, pbuffer +  15));
 800d09a:	68bb      	ldr	r3, [r7, #8]
 800d09c:	330f      	adds	r3, #15
 800d09e:	0019      	movs	r1, r3
 800d0a0:	2002      	movs	r0, #2
 800d0a2:	f7ff f869 	bl	800c178 <VL53L1_i2c_decode_uint16_t>
 800d0a6:	0003      	movs	r3, r0
 800d0a8:	001a      	movs	r2, r3
	pdata->ref_spad_char__total_rate_target_mcps =
 800d0aa:	687b      	ldr	r3, [r7, #4]
 800d0ac:	821a      	strh	r2, [r3, #16]
	pdata->algo__part_to_part_range_offset_mm =
		(VL53L1_i2c_decode_int16_t(2, pbuffer +  17)) & 0x1FFF;
 800d0ae:	68bb      	ldr	r3, [r7, #8]
 800d0b0:	3311      	adds	r3, #17
 800d0b2:	0019      	movs	r1, r3
 800d0b4:	2002      	movs	r0, #2
 800d0b6:	f7ff f8c5 	bl	800c244 <VL53L1_i2c_decode_int16_t>
 800d0ba:	0003      	movs	r3, r0
 800d0bc:	04db      	lsls	r3, r3, #19
 800d0be:	0cdb      	lsrs	r3, r3, #19
 800d0c0:	b21a      	sxth	r2, r3
	pdata->algo__part_to_part_range_offset_mm =
 800d0c2:	687b      	ldr	r3, [r7, #4]
 800d0c4:	825a      	strh	r2, [r3, #18]
	pdata->mm_config__inner_offset_mm =
		(VL53L1_i2c_decode_int16_t(2, pbuffer +  19));
 800d0c6:	68bb      	ldr	r3, [r7, #8]
 800d0c8:	3313      	adds	r3, #19
 800d0ca:	0019      	movs	r1, r3
 800d0cc:	2002      	movs	r0, #2
 800d0ce:	f7ff f8b9 	bl	800c244 <VL53L1_i2c_decode_int16_t>
 800d0d2:	0003      	movs	r3, r0
 800d0d4:	001a      	movs	r2, r3
	pdata->mm_config__inner_offset_mm =
 800d0d6:	687b      	ldr	r3, [r7, #4]
 800d0d8:	829a      	strh	r2, [r3, #20]
	pdata->mm_config__outer_offset_mm =
		(VL53L1_i2c_decode_int16_t(2, pbuffer +  21));
 800d0da:	68bb      	ldr	r3, [r7, #8]
 800d0dc:	3315      	adds	r3, #21
 800d0de:	0019      	movs	r1, r3
 800d0e0:	2002      	movs	r0, #2
 800d0e2:	f7ff f8af 	bl	800c244 <VL53L1_i2c_decode_int16_t>
 800d0e6:	0003      	movs	r3, r0
 800d0e8:	001a      	movs	r2, r3
	pdata->mm_config__outer_offset_mm =
 800d0ea:	687b      	ldr	r3, [r7, #4]
 800d0ec:	82da      	strh	r2, [r3, #22]

	LOG_FUNCTION_END(status);

	return status;
 800d0ee:	2317      	movs	r3, #23
 800d0f0:	18fb      	adds	r3, r7, r3
 800d0f2:	781b      	ldrb	r3, [r3, #0]
 800d0f4:	b25b      	sxtb	r3, r3
}
 800d0f6:	0018      	movs	r0, r3
 800d0f8:	46bd      	mov	sp, r7
 800d0fa:	b006      	add	sp, #24
 800d0fc:	bd80      	pop	{r7, pc}

0800d0fe <VL53L1_get_customer_nvm_managed>:


VL53L1_Error VL53L1_get_customer_nvm_managed(
	VL53L1_DEV                 Dev,
	VL53L1_customer_nvm_managed_t  *pdata)
{
 800d0fe:	b590      	push	{r4, r7, lr}
 800d100:	b089      	sub	sp, #36	; 0x24
 800d102:	af00      	add	r7, sp, #0
 800d104:	6078      	str	r0, [r7, #4]
 800d106:	6039      	str	r1, [r7, #0]
	/**
	 * Reads and de-serialises the contents of VL53L1_customer_nvm_managed_t
	 * data structure from the device
	 */

	VL53L1_Error status = VL53L1_ERROR_NONE;
 800d108:	211f      	movs	r1, #31
 800d10a:	187b      	adds	r3, r7, r1
 800d10c:	2200      	movs	r2, #0
 800d10e:	701a      	strb	r2, [r3, #0]
	uint8_t comms_buffer[VL53L1_CUSTOMER_NVM_MANAGED_I2C_SIZE_BYTES];

	LOG_FUNCTION_START("");

	if (status == VL53L1_ERROR_NONE) /*lint !e774 always true*/
 800d110:	187b      	adds	r3, r7, r1
 800d112:	781b      	ldrb	r3, [r3, #0]
 800d114:	b25b      	sxtb	r3, r3
 800d116:	2b00      	cmp	r3, #0
 800d118:	d10a      	bne.n	800d130 <VL53L1_get_customer_nvm_managed+0x32>
		status = VL53L1_ReadMulti(
 800d11a:	231f      	movs	r3, #31
 800d11c:	18fc      	adds	r4, r7, r3
 800d11e:	2308      	movs	r3, #8
 800d120:	18fa      	adds	r2, r7, r3
 800d122:	6878      	ldr	r0, [r7, #4]
 800d124:	2317      	movs	r3, #23
 800d126:	210d      	movs	r1, #13
 800d128:	f001 f85c 	bl	800e1e4 <VL53L1_ReadMulti>
 800d12c:	0003      	movs	r3, r0
 800d12e:	7023      	strb	r3, [r4, #0]
			Dev,
			VL53L1_GLOBAL_CONFIG__SPAD_ENABLES_REF_0,
			comms_buffer,
			VL53L1_CUSTOMER_NVM_MANAGED_I2C_SIZE_BYTES);

	if (status == VL53L1_ERROR_NONE)
 800d130:	231f      	movs	r3, #31
 800d132:	18fb      	adds	r3, r7, r3
 800d134:	781b      	ldrb	r3, [r3, #0]
 800d136:	b25b      	sxtb	r3, r3
 800d138:	2b00      	cmp	r3, #0
 800d13a:	d10a      	bne.n	800d152 <VL53L1_get_customer_nvm_managed+0x54>
		status = VL53L1_i2c_decode_customer_nvm_managed(
 800d13c:	231f      	movs	r3, #31
 800d13e:	18fc      	adds	r4, r7, r3
 800d140:	683a      	ldr	r2, [r7, #0]
 800d142:	2308      	movs	r3, #8
 800d144:	18fb      	adds	r3, r7, r3
 800d146:	0019      	movs	r1, r3
 800d148:	2017      	movs	r0, #23
 800d14a:	f7ff ff44 	bl	800cfd6 <VL53L1_i2c_decode_customer_nvm_managed>
 800d14e:	0003      	movs	r3, r0
 800d150:	7023      	strb	r3, [r4, #0]
			comms_buffer,
			pdata);

	LOG_FUNCTION_END(status);

	return status;
 800d152:	231f      	movs	r3, #31
 800d154:	18fb      	adds	r3, r7, r3
 800d156:	781b      	ldrb	r3, [r3, #0]
 800d158:	b25b      	sxtb	r3, r3
}
 800d15a:	0018      	movs	r0, r3
 800d15c:	46bd      	mov	sp, r7
 800d15e:	b009      	add	sp, #36	; 0x24
 800d160:	bd90      	pop	{r4, r7, pc}

0800d162 <VL53L1_i2c_encode_static_config>:

VL53L1_Error VL53L1_i2c_encode_static_config(
	VL53L1_static_config_t   *pdata,
	uint16_t                  buf_size,
	uint8_t                  *pbuffer)
{
 800d162:	b580      	push	{r7, lr}
 800d164:	b086      	sub	sp, #24
 800d166:	af00      	add	r7, sp, #0
 800d168:	60f8      	str	r0, [r7, #12]
 800d16a:	607a      	str	r2, [r7, #4]
 800d16c:	200a      	movs	r0, #10
 800d16e:	183b      	adds	r3, r7, r0
 800d170:	1c0a      	adds	r2, r1, #0
 800d172:	801a      	strh	r2, [r3, #0]
	/**
	 * Encodes data structure VL53L1_static_config_t into a I2C write buffer
	 * Buffer must be at least 32 bytes
	*/

	VL53L1_Error status = VL53L1_ERROR_NONE;
 800d174:	2317      	movs	r3, #23
 800d176:	18fb      	adds	r3, r7, r3
 800d178:	2200      	movs	r2, #0
 800d17a:	701a      	strb	r2, [r3, #0]

	LOG_FUNCTION_START("");

	if (VL53L1_STATIC_CONFIG_I2C_SIZE_BYTES > buf_size)
 800d17c:	183b      	adds	r3, r7, r0
 800d17e:	881b      	ldrh	r3, [r3, #0]
 800d180:	2b1f      	cmp	r3, #31
 800d182:	d802      	bhi.n	800d18a <VL53L1_i2c_encode_static_config+0x28>
		return VL53L1_ERROR_COMMS_BUFFER_TOO_SMALL;
 800d184:	230a      	movs	r3, #10
 800d186:	425b      	negs	r3, r3
 800d188:	e0d1      	b.n	800d32e <VL53L1_i2c_encode_static_config+0x1cc>

	VL53L1_i2c_encode_uint16_t(
 800d18a:	68fb      	ldr	r3, [r7, #12]
 800d18c:	881b      	ldrh	r3, [r3, #0]
 800d18e:	687a      	ldr	r2, [r7, #4]
 800d190:	2102      	movs	r1, #2
 800d192:	0018      	movs	r0, r3
 800d194:	f7fe ffb3 	bl	800c0fe <VL53L1_i2c_encode_uint16_t>
		pdata->dss_config__target_total_rate_mcps,
		2,
		pbuffer +   0);
	*(pbuffer +   2) =
		pdata->debug__ctrl & 0x1;
 800d198:	68fb      	ldr	r3, [r7, #12]
 800d19a:	789a      	ldrb	r2, [r3, #2]
	*(pbuffer +   2) =
 800d19c:	687b      	ldr	r3, [r7, #4]
 800d19e:	3302      	adds	r3, #2
		pdata->debug__ctrl & 0x1;
 800d1a0:	2101      	movs	r1, #1
 800d1a2:	400a      	ands	r2, r1
 800d1a4:	b2d2      	uxtb	r2, r2
	*(pbuffer +   2) =
 800d1a6:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   3) =
		pdata->test_mode__ctrl & 0xF;
 800d1a8:	68fb      	ldr	r3, [r7, #12]
 800d1aa:	78da      	ldrb	r2, [r3, #3]
	*(pbuffer +   3) =
 800d1ac:	687b      	ldr	r3, [r7, #4]
 800d1ae:	3303      	adds	r3, #3
		pdata->test_mode__ctrl & 0xF;
 800d1b0:	210f      	movs	r1, #15
 800d1b2:	400a      	ands	r2, r1
 800d1b4:	b2d2      	uxtb	r2, r2
	*(pbuffer +   3) =
 800d1b6:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   4) =
		pdata->clk_gating__ctrl & 0xF;
 800d1b8:	68fb      	ldr	r3, [r7, #12]
 800d1ba:	791a      	ldrb	r2, [r3, #4]
	*(pbuffer +   4) =
 800d1bc:	687b      	ldr	r3, [r7, #4]
 800d1be:	3304      	adds	r3, #4
		pdata->clk_gating__ctrl & 0xF;
 800d1c0:	210f      	movs	r1, #15
 800d1c2:	400a      	ands	r2, r1
 800d1c4:	b2d2      	uxtb	r2, r2
	*(pbuffer +   4) =
 800d1c6:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   5) =
		pdata->nvm_bist__ctrl & 0x1F;
 800d1c8:	68fb      	ldr	r3, [r7, #12]
 800d1ca:	795a      	ldrb	r2, [r3, #5]
	*(pbuffer +   5) =
 800d1cc:	687b      	ldr	r3, [r7, #4]
 800d1ce:	3305      	adds	r3, #5
		pdata->nvm_bist__ctrl & 0x1F;
 800d1d0:	211f      	movs	r1, #31
 800d1d2:	400a      	ands	r2, r1
 800d1d4:	b2d2      	uxtb	r2, r2
	*(pbuffer +   5) =
 800d1d6:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   6) =
		pdata->nvm_bist__num_nvm_words & 0x7F;
 800d1d8:	68fb      	ldr	r3, [r7, #12]
 800d1da:	799a      	ldrb	r2, [r3, #6]
	*(pbuffer +   6) =
 800d1dc:	687b      	ldr	r3, [r7, #4]
 800d1de:	3306      	adds	r3, #6
		pdata->nvm_bist__num_nvm_words & 0x7F;
 800d1e0:	217f      	movs	r1, #127	; 0x7f
 800d1e2:	400a      	ands	r2, r1
 800d1e4:	b2d2      	uxtb	r2, r2
	*(pbuffer +   6) =
 800d1e6:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   7) =
		pdata->nvm_bist__start_address & 0x7F;
 800d1e8:	68fb      	ldr	r3, [r7, #12]
 800d1ea:	79da      	ldrb	r2, [r3, #7]
	*(pbuffer +   7) =
 800d1ec:	687b      	ldr	r3, [r7, #4]
 800d1ee:	3307      	adds	r3, #7
		pdata->nvm_bist__start_address & 0x7F;
 800d1f0:	217f      	movs	r1, #127	; 0x7f
 800d1f2:	400a      	ands	r2, r1
 800d1f4:	b2d2      	uxtb	r2, r2
	*(pbuffer +   7) =
 800d1f6:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   8) =
		pdata->host_if__status & 0x1;
 800d1f8:	68fb      	ldr	r3, [r7, #12]
 800d1fa:	7a1a      	ldrb	r2, [r3, #8]
	*(pbuffer +   8) =
 800d1fc:	687b      	ldr	r3, [r7, #4]
 800d1fe:	3308      	adds	r3, #8
		pdata->host_if__status & 0x1;
 800d200:	2101      	movs	r1, #1
 800d202:	400a      	ands	r2, r1
 800d204:	b2d2      	uxtb	r2, r2
	*(pbuffer +   8) =
 800d206:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   9) =
 800d208:	687b      	ldr	r3, [r7, #4]
 800d20a:	3309      	adds	r3, #9
		pdata->pad_i2c_hv__config;
 800d20c:	68fa      	ldr	r2, [r7, #12]
 800d20e:	7a52      	ldrb	r2, [r2, #9]
	*(pbuffer +   9) =
 800d210:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  10) =
		pdata->pad_i2c_hv__extsup_config & 0x1;
 800d212:	68fb      	ldr	r3, [r7, #12]
 800d214:	7a9a      	ldrb	r2, [r3, #10]
	*(pbuffer +  10) =
 800d216:	687b      	ldr	r3, [r7, #4]
 800d218:	330a      	adds	r3, #10
		pdata->pad_i2c_hv__extsup_config & 0x1;
 800d21a:	2101      	movs	r1, #1
 800d21c:	400a      	ands	r2, r1
 800d21e:	b2d2      	uxtb	r2, r2
	*(pbuffer +  10) =
 800d220:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  11) =
		pdata->gpio_hv_pad__ctrl & 0x3;
 800d222:	68fb      	ldr	r3, [r7, #12]
 800d224:	7ada      	ldrb	r2, [r3, #11]
	*(pbuffer +  11) =
 800d226:	687b      	ldr	r3, [r7, #4]
 800d228:	330b      	adds	r3, #11
		pdata->gpio_hv_pad__ctrl & 0x3;
 800d22a:	2103      	movs	r1, #3
 800d22c:	400a      	ands	r2, r1
 800d22e:	b2d2      	uxtb	r2, r2
	*(pbuffer +  11) =
 800d230:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  12) =
		pdata->gpio_hv_mux__ctrl & 0x1F;
 800d232:	68fb      	ldr	r3, [r7, #12]
 800d234:	7b1a      	ldrb	r2, [r3, #12]
	*(pbuffer +  12) =
 800d236:	687b      	ldr	r3, [r7, #4]
 800d238:	330c      	adds	r3, #12
		pdata->gpio_hv_mux__ctrl & 0x1F;
 800d23a:	211f      	movs	r1, #31
 800d23c:	400a      	ands	r2, r1
 800d23e:	b2d2      	uxtb	r2, r2
	*(pbuffer +  12) =
 800d240:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  13) =
		pdata->gpio__tio_hv_status & 0x3;
 800d242:	68fb      	ldr	r3, [r7, #12]
 800d244:	7b5a      	ldrb	r2, [r3, #13]
	*(pbuffer +  13) =
 800d246:	687b      	ldr	r3, [r7, #4]
 800d248:	330d      	adds	r3, #13
		pdata->gpio__tio_hv_status & 0x3;
 800d24a:	2103      	movs	r1, #3
 800d24c:	400a      	ands	r2, r1
 800d24e:	b2d2      	uxtb	r2, r2
	*(pbuffer +  13) =
 800d250:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  14) =
		pdata->gpio__fio_hv_status & 0x3;
 800d252:	68fb      	ldr	r3, [r7, #12]
 800d254:	7b9a      	ldrb	r2, [r3, #14]
	*(pbuffer +  14) =
 800d256:	687b      	ldr	r3, [r7, #4]
 800d258:	330e      	adds	r3, #14
		pdata->gpio__fio_hv_status & 0x3;
 800d25a:	2103      	movs	r1, #3
 800d25c:	400a      	ands	r2, r1
 800d25e:	b2d2      	uxtb	r2, r2
	*(pbuffer +  14) =
 800d260:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  15) =
		pdata->ana_config__spad_sel_pswidth & 0x7;
 800d262:	68fb      	ldr	r3, [r7, #12]
 800d264:	7bda      	ldrb	r2, [r3, #15]
	*(pbuffer +  15) =
 800d266:	687b      	ldr	r3, [r7, #4]
 800d268:	330f      	adds	r3, #15
		pdata->ana_config__spad_sel_pswidth & 0x7;
 800d26a:	2107      	movs	r1, #7
 800d26c:	400a      	ands	r2, r1
 800d26e:	b2d2      	uxtb	r2, r2
	*(pbuffer +  15) =
 800d270:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  16) =
		pdata->ana_config__vcsel_pulse_width_offset & 0x1F;
 800d272:	68fb      	ldr	r3, [r7, #12]
 800d274:	7c1a      	ldrb	r2, [r3, #16]
	*(pbuffer +  16) =
 800d276:	687b      	ldr	r3, [r7, #4]
 800d278:	3310      	adds	r3, #16
		pdata->ana_config__vcsel_pulse_width_offset & 0x1F;
 800d27a:	211f      	movs	r1, #31
 800d27c:	400a      	ands	r2, r1
 800d27e:	b2d2      	uxtb	r2, r2
	*(pbuffer +  16) =
 800d280:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  17) =
		pdata->ana_config__fast_osc__config_ctrl & 0x1;
 800d282:	68fb      	ldr	r3, [r7, #12]
 800d284:	7c5a      	ldrb	r2, [r3, #17]
	*(pbuffer +  17) =
 800d286:	687b      	ldr	r3, [r7, #4]
 800d288:	3311      	adds	r3, #17
		pdata->ana_config__fast_osc__config_ctrl & 0x1;
 800d28a:	2101      	movs	r1, #1
 800d28c:	400a      	ands	r2, r1
 800d28e:	b2d2      	uxtb	r2, r2
	*(pbuffer +  17) =
 800d290:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  18) =
 800d292:	687b      	ldr	r3, [r7, #4]
 800d294:	3312      	adds	r3, #18
		pdata->sigma_estimator__effective_pulse_width_ns;
 800d296:	68fa      	ldr	r2, [r7, #12]
 800d298:	7c92      	ldrb	r2, [r2, #18]
	*(pbuffer +  18) =
 800d29a:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  19) =
 800d29c:	687b      	ldr	r3, [r7, #4]
 800d29e:	3313      	adds	r3, #19
		pdata->sigma_estimator__effective_ambient_width_ns;
 800d2a0:	68fa      	ldr	r2, [r7, #12]
 800d2a2:	7cd2      	ldrb	r2, [r2, #19]
	*(pbuffer +  19) =
 800d2a4:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  20) =
 800d2a6:	687b      	ldr	r3, [r7, #4]
 800d2a8:	3314      	adds	r3, #20
		pdata->sigma_estimator__sigma_ref_mm;
 800d2aa:	68fa      	ldr	r2, [r7, #12]
 800d2ac:	7d12      	ldrb	r2, [r2, #20]
	*(pbuffer +  20) =
 800d2ae:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  21) =
 800d2b0:	687b      	ldr	r3, [r7, #4]
 800d2b2:	3315      	adds	r3, #21
		pdata->algo__crosstalk_compensation_valid_height_mm;
 800d2b4:	68fa      	ldr	r2, [r7, #12]
 800d2b6:	7d52      	ldrb	r2, [r2, #21]
	*(pbuffer +  21) =
 800d2b8:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  22) =
 800d2ba:	687b      	ldr	r3, [r7, #4]
 800d2bc:	3316      	adds	r3, #22
		pdata->spare_host_config__static_config_spare_0;
 800d2be:	68fa      	ldr	r2, [r7, #12]
 800d2c0:	7d92      	ldrb	r2, [r2, #22]
	*(pbuffer +  22) =
 800d2c2:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  23) =
 800d2c4:	687b      	ldr	r3, [r7, #4]
 800d2c6:	3317      	adds	r3, #23
		pdata->spare_host_config__static_config_spare_1;
 800d2c8:	68fa      	ldr	r2, [r7, #12]
 800d2ca:	7dd2      	ldrb	r2, [r2, #23]
	*(pbuffer +  23) =
 800d2cc:	701a      	strb	r2, [r3, #0]
	VL53L1_i2c_encode_uint16_t(
 800d2ce:	68fb      	ldr	r3, [r7, #12]
 800d2d0:	8b18      	ldrh	r0, [r3, #24]
 800d2d2:	687b      	ldr	r3, [r7, #4]
 800d2d4:	3318      	adds	r3, #24
 800d2d6:	001a      	movs	r2, r3
 800d2d8:	2102      	movs	r1, #2
 800d2da:	f7fe ff10 	bl	800c0fe <VL53L1_i2c_encode_uint16_t>
		pdata->algo__range_ignore_threshold_mcps,
		2,
		pbuffer +  24);
	*(pbuffer +  26) =
 800d2de:	687b      	ldr	r3, [r7, #4]
 800d2e0:	331a      	adds	r3, #26
		pdata->algo__range_ignore_valid_height_mm;
 800d2e2:	68fa      	ldr	r2, [r7, #12]
 800d2e4:	7e92      	ldrb	r2, [r2, #26]
	*(pbuffer +  26) =
 800d2e6:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  27) =
 800d2e8:	687b      	ldr	r3, [r7, #4]
 800d2ea:	331b      	adds	r3, #27
		pdata->algo__range_min_clip;
 800d2ec:	68fa      	ldr	r2, [r7, #12]
 800d2ee:	7ed2      	ldrb	r2, [r2, #27]
	*(pbuffer +  27) =
 800d2f0:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  28) =
		pdata->algo__consistency_check__tolerance & 0xF;
 800d2f2:	68fb      	ldr	r3, [r7, #12]
 800d2f4:	7f1a      	ldrb	r2, [r3, #28]
	*(pbuffer +  28) =
 800d2f6:	687b      	ldr	r3, [r7, #4]
 800d2f8:	331c      	adds	r3, #28
		pdata->algo__consistency_check__tolerance & 0xF;
 800d2fa:	210f      	movs	r1, #15
 800d2fc:	400a      	ands	r2, r1
 800d2fe:	b2d2      	uxtb	r2, r2
	*(pbuffer +  28) =
 800d300:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  29) =
 800d302:	687b      	ldr	r3, [r7, #4]
 800d304:	331d      	adds	r3, #29
		pdata->spare_host_config__static_config_spare_2;
 800d306:	68fa      	ldr	r2, [r7, #12]
 800d308:	7f52      	ldrb	r2, [r2, #29]
	*(pbuffer +  29) =
 800d30a:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  30) =
		pdata->sd_config__reset_stages_msb & 0xF;
 800d30c:	68fb      	ldr	r3, [r7, #12]
 800d30e:	7f9a      	ldrb	r2, [r3, #30]
	*(pbuffer +  30) =
 800d310:	687b      	ldr	r3, [r7, #4]
 800d312:	331e      	adds	r3, #30
		pdata->sd_config__reset_stages_msb & 0xF;
 800d314:	210f      	movs	r1, #15
 800d316:	400a      	ands	r2, r1
 800d318:	b2d2      	uxtb	r2, r2
	*(pbuffer +  30) =
 800d31a:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  31) =
 800d31c:	687b      	ldr	r3, [r7, #4]
 800d31e:	331f      	adds	r3, #31
		pdata->sd_config__reset_stages_lsb;
 800d320:	68fa      	ldr	r2, [r7, #12]
 800d322:	7fd2      	ldrb	r2, [r2, #31]
	*(pbuffer +  31) =
 800d324:	701a      	strb	r2, [r3, #0]
	LOG_FUNCTION_END(status);


	return status;
 800d326:	2317      	movs	r3, #23
 800d328:	18fb      	adds	r3, r7, r3
 800d32a:	781b      	ldrb	r3, [r3, #0]
 800d32c:	b25b      	sxtb	r3, r3
}
 800d32e:	0018      	movs	r0, r3
 800d330:	46bd      	mov	sp, r7
 800d332:	b006      	add	sp, #24
 800d334:	bd80      	pop	{r7, pc}

0800d336 <VL53L1_i2c_encode_general_config>:

VL53L1_Error VL53L1_i2c_encode_general_config(
	VL53L1_general_config_t  *pdata,
	uint16_t                  buf_size,
	uint8_t                  *pbuffer)
{
 800d336:	b580      	push	{r7, lr}
 800d338:	b086      	sub	sp, #24
 800d33a:	af00      	add	r7, sp, #0
 800d33c:	60f8      	str	r0, [r7, #12]
 800d33e:	607a      	str	r2, [r7, #4]
 800d340:	200a      	movs	r0, #10
 800d342:	183b      	adds	r3, r7, r0
 800d344:	1c0a      	adds	r2, r1, #0
 800d346:	801a      	strh	r2, [r3, #0]
	/**
	 * Encodes data structure VL53L1_general_config_t into a I2C write buffer
	 * Buffer must be at least 22 bytes
	*/

	VL53L1_Error status = VL53L1_ERROR_NONE;
 800d348:	2317      	movs	r3, #23
 800d34a:	18fb      	adds	r3, r7, r3
 800d34c:	2200      	movs	r2, #0
 800d34e:	701a      	strb	r2, [r3, #0]

	LOG_FUNCTION_START("");

	if (VL53L1_GENERAL_CONFIG_I2C_SIZE_BYTES > buf_size)
 800d350:	183b      	adds	r3, r7, r0
 800d352:	881b      	ldrh	r3, [r3, #0]
 800d354:	2b15      	cmp	r3, #21
 800d356:	d802      	bhi.n	800d35e <VL53L1_i2c_encode_general_config+0x28>
		return VL53L1_ERROR_COMMS_BUFFER_TOO_SMALL;
 800d358:	230a      	movs	r3, #10
 800d35a:	425b      	negs	r3, r3
 800d35c:	e072      	b.n	800d444 <VL53L1_i2c_encode_general_config+0x10e>

	*(pbuffer +   0) =
		pdata->gph_config__stream_count_update_value;
 800d35e:	68fb      	ldr	r3, [r7, #12]
 800d360:	781a      	ldrb	r2, [r3, #0]
	*(pbuffer +   0) =
 800d362:	687b      	ldr	r3, [r7, #4]
 800d364:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   1) =
 800d366:	687b      	ldr	r3, [r7, #4]
 800d368:	3301      	adds	r3, #1
		pdata->global_config__stream_divider;
 800d36a:	68fa      	ldr	r2, [r7, #12]
 800d36c:	7852      	ldrb	r2, [r2, #1]
	*(pbuffer +   1) =
 800d36e:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   2) =
 800d370:	687b      	ldr	r3, [r7, #4]
 800d372:	3302      	adds	r3, #2
		pdata->system__interrupt_config_gpio;
 800d374:	68fa      	ldr	r2, [r7, #12]
 800d376:	7892      	ldrb	r2, [r2, #2]
	*(pbuffer +   2) =
 800d378:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   3) =
		pdata->cal_config__vcsel_start & 0x7F;
 800d37a:	68fb      	ldr	r3, [r7, #12]
 800d37c:	78da      	ldrb	r2, [r3, #3]
	*(pbuffer +   3) =
 800d37e:	687b      	ldr	r3, [r7, #4]
 800d380:	3303      	adds	r3, #3
		pdata->cal_config__vcsel_start & 0x7F;
 800d382:	217f      	movs	r1, #127	; 0x7f
 800d384:	400a      	ands	r2, r1
 800d386:	b2d2      	uxtb	r2, r2
	*(pbuffer +   3) =
 800d388:	701a      	strb	r2, [r3, #0]
	VL53L1_i2c_encode_uint16_t(
		pdata->cal_config__repeat_rate & 0xFFF,
 800d38a:	68fb      	ldr	r3, [r7, #12]
 800d38c:	889b      	ldrh	r3, [r3, #4]
	VL53L1_i2c_encode_uint16_t(
 800d38e:	051b      	lsls	r3, r3, #20
 800d390:	0d1b      	lsrs	r3, r3, #20
 800d392:	b298      	uxth	r0, r3
 800d394:	687b      	ldr	r3, [r7, #4]
 800d396:	3304      	adds	r3, #4
 800d398:	001a      	movs	r2, r3
 800d39a:	2102      	movs	r1, #2
 800d39c:	f7fe feaf 	bl	800c0fe <VL53L1_i2c_encode_uint16_t>
		2,
		pbuffer +   4);
	*(pbuffer +   6) =
		pdata->global_config__vcsel_width & 0x7F;
 800d3a0:	68fb      	ldr	r3, [r7, #12]
 800d3a2:	799a      	ldrb	r2, [r3, #6]
	*(pbuffer +   6) =
 800d3a4:	687b      	ldr	r3, [r7, #4]
 800d3a6:	3306      	adds	r3, #6
		pdata->global_config__vcsel_width & 0x7F;
 800d3a8:	217f      	movs	r1, #127	; 0x7f
 800d3aa:	400a      	ands	r2, r1
 800d3ac:	b2d2      	uxtb	r2, r2
	*(pbuffer +   6) =
 800d3ae:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   7) =
 800d3b0:	687b      	ldr	r3, [r7, #4]
 800d3b2:	3307      	adds	r3, #7
		pdata->phasecal_config__timeout_macrop;
 800d3b4:	68fa      	ldr	r2, [r7, #12]
 800d3b6:	79d2      	ldrb	r2, [r2, #7]
	*(pbuffer +   7) =
 800d3b8:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   8) =
 800d3ba:	687b      	ldr	r3, [r7, #4]
 800d3bc:	3308      	adds	r3, #8
		pdata->phasecal_config__target;
 800d3be:	68fa      	ldr	r2, [r7, #12]
 800d3c0:	7a12      	ldrb	r2, [r2, #8]
	*(pbuffer +   8) =
 800d3c2:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   9) =
		pdata->phasecal_config__override & 0x1;
 800d3c4:	68fb      	ldr	r3, [r7, #12]
 800d3c6:	7a5a      	ldrb	r2, [r3, #9]
	*(pbuffer +   9) =
 800d3c8:	687b      	ldr	r3, [r7, #4]
 800d3ca:	3309      	adds	r3, #9
		pdata->phasecal_config__override & 0x1;
 800d3cc:	2101      	movs	r1, #1
 800d3ce:	400a      	ands	r2, r1
 800d3d0:	b2d2      	uxtb	r2, r2
	*(pbuffer +   9) =
 800d3d2:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  11) =
		pdata->dss_config__roi_mode_control & 0x7;
 800d3d4:	68fb      	ldr	r3, [r7, #12]
 800d3d6:	7a9a      	ldrb	r2, [r3, #10]
	*(pbuffer +  11) =
 800d3d8:	687b      	ldr	r3, [r7, #4]
 800d3da:	330b      	adds	r3, #11
		pdata->dss_config__roi_mode_control & 0x7;
 800d3dc:	2107      	movs	r1, #7
 800d3de:	400a      	ands	r2, r1
 800d3e0:	b2d2      	uxtb	r2, r2
	*(pbuffer +  11) =
 800d3e2:	701a      	strb	r2, [r3, #0]
	VL53L1_i2c_encode_uint16_t(
 800d3e4:	68fb      	ldr	r3, [r7, #12]
 800d3e6:	8998      	ldrh	r0, [r3, #12]
 800d3e8:	687b      	ldr	r3, [r7, #4]
 800d3ea:	330c      	adds	r3, #12
 800d3ec:	001a      	movs	r2, r3
 800d3ee:	2102      	movs	r1, #2
 800d3f0:	f7fe fe85 	bl	800c0fe <VL53L1_i2c_encode_uint16_t>
		pdata->system__thresh_rate_high,
		2,
		pbuffer +  12);
	VL53L1_i2c_encode_uint16_t(
 800d3f4:	68fb      	ldr	r3, [r7, #12]
 800d3f6:	89d8      	ldrh	r0, [r3, #14]
 800d3f8:	687b      	ldr	r3, [r7, #4]
 800d3fa:	330e      	adds	r3, #14
 800d3fc:	001a      	movs	r2, r3
 800d3fe:	2102      	movs	r1, #2
 800d400:	f7fe fe7d 	bl	800c0fe <VL53L1_i2c_encode_uint16_t>
		pdata->system__thresh_rate_low,
		2,
		pbuffer +  14);
	VL53L1_i2c_encode_uint16_t(
 800d404:	68fb      	ldr	r3, [r7, #12]
 800d406:	8a18      	ldrh	r0, [r3, #16]
 800d408:	687b      	ldr	r3, [r7, #4]
 800d40a:	3310      	adds	r3, #16
 800d40c:	001a      	movs	r2, r3
 800d40e:	2102      	movs	r1, #2
 800d410:	f7fe fe75 	bl	800c0fe <VL53L1_i2c_encode_uint16_t>
		pdata->dss_config__manual_effective_spads_select,
		2,
		pbuffer +  16);
	*(pbuffer +  18) =
 800d414:	687b      	ldr	r3, [r7, #4]
 800d416:	3312      	adds	r3, #18
		pdata->dss_config__manual_block_select;
 800d418:	68fa      	ldr	r2, [r7, #12]
 800d41a:	7c92      	ldrb	r2, [r2, #18]
	*(pbuffer +  18) =
 800d41c:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  19) =
 800d41e:	687b      	ldr	r3, [r7, #4]
 800d420:	3313      	adds	r3, #19
		pdata->dss_config__aperture_attenuation;
 800d422:	68fa      	ldr	r2, [r7, #12]
 800d424:	7cd2      	ldrb	r2, [r2, #19]
	*(pbuffer +  19) =
 800d426:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  20) =
 800d428:	687b      	ldr	r3, [r7, #4]
 800d42a:	3314      	adds	r3, #20
		pdata->dss_config__max_spads_limit;
 800d42c:	68fa      	ldr	r2, [r7, #12]
 800d42e:	7d12      	ldrb	r2, [r2, #20]
	*(pbuffer +  20) =
 800d430:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  21) =
 800d432:	687b      	ldr	r3, [r7, #4]
 800d434:	3315      	adds	r3, #21
		pdata->dss_config__min_spads_limit;
 800d436:	68fa      	ldr	r2, [r7, #12]
 800d438:	7d52      	ldrb	r2, [r2, #21]
	*(pbuffer +  21) =
 800d43a:	701a      	strb	r2, [r3, #0]
	LOG_FUNCTION_END(status);


	return status;
 800d43c:	2317      	movs	r3, #23
 800d43e:	18fb      	adds	r3, r7, r3
 800d440:	781b      	ldrb	r3, [r3, #0]
 800d442:	b25b      	sxtb	r3, r3
}
 800d444:	0018      	movs	r0, r3
 800d446:	46bd      	mov	sp, r7
 800d448:	b006      	add	sp, #24
 800d44a:	bd80      	pop	{r7, pc}

0800d44c <VL53L1_i2c_encode_timing_config>:

VL53L1_Error VL53L1_i2c_encode_timing_config(
	VL53L1_timing_config_t   *pdata,
	uint16_t                  buf_size,
	uint8_t                  *pbuffer)
{
 800d44c:	b580      	push	{r7, lr}
 800d44e:	b086      	sub	sp, #24
 800d450:	af00      	add	r7, sp, #0
 800d452:	60f8      	str	r0, [r7, #12]
 800d454:	607a      	str	r2, [r7, #4]
 800d456:	200a      	movs	r0, #10
 800d458:	183b      	adds	r3, r7, r0
 800d45a:	1c0a      	adds	r2, r1, #0
 800d45c:	801a      	strh	r2, [r3, #0]
	/**
	 * Encodes data structure VL53L1_timing_config_t into a I2C write buffer
	 * Buffer must be at least 23 bytes
	*/

	VL53L1_Error status = VL53L1_ERROR_NONE;
 800d45e:	2317      	movs	r3, #23
 800d460:	18fb      	adds	r3, r7, r3
 800d462:	2200      	movs	r2, #0
 800d464:	701a      	strb	r2, [r3, #0]

	LOG_FUNCTION_START("");

	if (VL53L1_TIMING_CONFIG_I2C_SIZE_BYTES > buf_size)
 800d466:	183b      	adds	r3, r7, r0
 800d468:	881b      	ldrh	r3, [r3, #0]
 800d46a:	2b16      	cmp	r3, #22
 800d46c:	d802      	bhi.n	800d474 <VL53L1_i2c_encode_timing_config+0x28>
		return VL53L1_ERROR_COMMS_BUFFER_TOO_SMALL;
 800d46e:	230a      	movs	r3, #10
 800d470:	425b      	negs	r3, r3
 800d472:	e070      	b.n	800d556 <VL53L1_i2c_encode_timing_config+0x10a>

	*(pbuffer +   0) =
		pdata->mm_config__timeout_macrop_a_hi & 0xF;
 800d474:	68fb      	ldr	r3, [r7, #12]
 800d476:	781b      	ldrb	r3, [r3, #0]
 800d478:	220f      	movs	r2, #15
 800d47a:	4013      	ands	r3, r2
 800d47c:	b2da      	uxtb	r2, r3
	*(pbuffer +   0) =
 800d47e:	687b      	ldr	r3, [r7, #4]
 800d480:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   1) =
 800d482:	687b      	ldr	r3, [r7, #4]
 800d484:	3301      	adds	r3, #1
		pdata->mm_config__timeout_macrop_a_lo;
 800d486:	68fa      	ldr	r2, [r7, #12]
 800d488:	7852      	ldrb	r2, [r2, #1]
	*(pbuffer +   1) =
 800d48a:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   2) =
		pdata->mm_config__timeout_macrop_b_hi & 0xF;
 800d48c:	68fb      	ldr	r3, [r7, #12]
 800d48e:	789a      	ldrb	r2, [r3, #2]
	*(pbuffer +   2) =
 800d490:	687b      	ldr	r3, [r7, #4]
 800d492:	3302      	adds	r3, #2
		pdata->mm_config__timeout_macrop_b_hi & 0xF;
 800d494:	210f      	movs	r1, #15
 800d496:	400a      	ands	r2, r1
 800d498:	b2d2      	uxtb	r2, r2
	*(pbuffer +   2) =
 800d49a:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   3) =
 800d49c:	687b      	ldr	r3, [r7, #4]
 800d49e:	3303      	adds	r3, #3
		pdata->mm_config__timeout_macrop_b_lo;
 800d4a0:	68fa      	ldr	r2, [r7, #12]
 800d4a2:	78d2      	ldrb	r2, [r2, #3]
	*(pbuffer +   3) =
 800d4a4:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   4) =
		pdata->range_config__timeout_macrop_a_hi & 0xF;
 800d4a6:	68fb      	ldr	r3, [r7, #12]
 800d4a8:	791a      	ldrb	r2, [r3, #4]
	*(pbuffer +   4) =
 800d4aa:	687b      	ldr	r3, [r7, #4]
 800d4ac:	3304      	adds	r3, #4
		pdata->range_config__timeout_macrop_a_hi & 0xF;
 800d4ae:	210f      	movs	r1, #15
 800d4b0:	400a      	ands	r2, r1
 800d4b2:	b2d2      	uxtb	r2, r2
	*(pbuffer +   4) =
 800d4b4:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   5) =
 800d4b6:	687b      	ldr	r3, [r7, #4]
 800d4b8:	3305      	adds	r3, #5
		pdata->range_config__timeout_macrop_a_lo;
 800d4ba:	68fa      	ldr	r2, [r7, #12]
 800d4bc:	7952      	ldrb	r2, [r2, #5]
	*(pbuffer +   5) =
 800d4be:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   6) =
		pdata->range_config__vcsel_period_a & 0x3F;
 800d4c0:	68fb      	ldr	r3, [r7, #12]
 800d4c2:	799a      	ldrb	r2, [r3, #6]
	*(pbuffer +   6) =
 800d4c4:	687b      	ldr	r3, [r7, #4]
 800d4c6:	3306      	adds	r3, #6
		pdata->range_config__vcsel_period_a & 0x3F;
 800d4c8:	213f      	movs	r1, #63	; 0x3f
 800d4ca:	400a      	ands	r2, r1
 800d4cc:	b2d2      	uxtb	r2, r2
	*(pbuffer +   6) =
 800d4ce:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   7) =
		pdata->range_config__timeout_macrop_b_hi & 0xF;
 800d4d0:	68fb      	ldr	r3, [r7, #12]
 800d4d2:	79da      	ldrb	r2, [r3, #7]
	*(pbuffer +   7) =
 800d4d4:	687b      	ldr	r3, [r7, #4]
 800d4d6:	3307      	adds	r3, #7
		pdata->range_config__timeout_macrop_b_hi & 0xF;
 800d4d8:	210f      	movs	r1, #15
 800d4da:	400a      	ands	r2, r1
 800d4dc:	b2d2      	uxtb	r2, r2
	*(pbuffer +   7) =
 800d4de:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   8) =
 800d4e0:	687b      	ldr	r3, [r7, #4]
 800d4e2:	3308      	adds	r3, #8
		pdata->range_config__timeout_macrop_b_lo;
 800d4e4:	68fa      	ldr	r2, [r7, #12]
 800d4e6:	7a12      	ldrb	r2, [r2, #8]
	*(pbuffer +   8) =
 800d4e8:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   9) =
		pdata->range_config__vcsel_period_b & 0x3F;
 800d4ea:	68fb      	ldr	r3, [r7, #12]
 800d4ec:	7a5a      	ldrb	r2, [r3, #9]
	*(pbuffer +   9) =
 800d4ee:	687b      	ldr	r3, [r7, #4]
 800d4f0:	3309      	adds	r3, #9
		pdata->range_config__vcsel_period_b & 0x3F;
 800d4f2:	213f      	movs	r1, #63	; 0x3f
 800d4f4:	400a      	ands	r2, r1
 800d4f6:	b2d2      	uxtb	r2, r2
	*(pbuffer +   9) =
 800d4f8:	701a      	strb	r2, [r3, #0]
	VL53L1_i2c_encode_uint16_t(
 800d4fa:	68fb      	ldr	r3, [r7, #12]
 800d4fc:	8958      	ldrh	r0, [r3, #10]
 800d4fe:	687b      	ldr	r3, [r7, #4]
 800d500:	330a      	adds	r3, #10
 800d502:	001a      	movs	r2, r3
 800d504:	2102      	movs	r1, #2
 800d506:	f7fe fdfa 	bl	800c0fe <VL53L1_i2c_encode_uint16_t>
		pdata->range_config__sigma_thresh,
		2,
		pbuffer +  10);
	VL53L1_i2c_encode_uint16_t(
 800d50a:	68fb      	ldr	r3, [r7, #12]
 800d50c:	8998      	ldrh	r0, [r3, #12]
 800d50e:	687b      	ldr	r3, [r7, #4]
 800d510:	330c      	adds	r3, #12
 800d512:	001a      	movs	r2, r3
 800d514:	2102      	movs	r1, #2
 800d516:	f7fe fdf2 	bl	800c0fe <VL53L1_i2c_encode_uint16_t>
		pdata->range_config__min_count_rate_rtn_limit_mcps,
		2,
		pbuffer +  12);
	*(pbuffer +  14) =
 800d51a:	687b      	ldr	r3, [r7, #4]
 800d51c:	330e      	adds	r3, #14
		pdata->range_config__valid_phase_low;
 800d51e:	68fa      	ldr	r2, [r7, #12]
 800d520:	7b92      	ldrb	r2, [r2, #14]
	*(pbuffer +  14) =
 800d522:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  15) =
 800d524:	687b      	ldr	r3, [r7, #4]
 800d526:	330f      	adds	r3, #15
		pdata->range_config__valid_phase_high;
 800d528:	68fa      	ldr	r2, [r7, #12]
 800d52a:	7bd2      	ldrb	r2, [r2, #15]
	*(pbuffer +  15) =
 800d52c:	701a      	strb	r2, [r3, #0]
	VL53L1_i2c_encode_uint32_t(
 800d52e:	68fb      	ldr	r3, [r7, #12]
 800d530:	6918      	ldr	r0, [r3, #16]
 800d532:	687b      	ldr	r3, [r7, #4]
 800d534:	3312      	adds	r3, #18
 800d536:	001a      	movs	r2, r3
 800d538:	2104      	movs	r1, #4
 800d53a:	f7fe feb6 	bl	800c2aa <VL53L1_i2c_encode_uint32_t>
		pdata->system__intermeasurement_period,
		4,
		pbuffer +  18);
	*(pbuffer +  22) =
		pdata->system__fractional_enable & 0x1;
 800d53e:	68fb      	ldr	r3, [r7, #12]
 800d540:	7d1a      	ldrb	r2, [r3, #20]
	*(pbuffer +  22) =
 800d542:	687b      	ldr	r3, [r7, #4]
 800d544:	3316      	adds	r3, #22
		pdata->system__fractional_enable & 0x1;
 800d546:	2101      	movs	r1, #1
 800d548:	400a      	ands	r2, r1
 800d54a:	b2d2      	uxtb	r2, r2
	*(pbuffer +  22) =
 800d54c:	701a      	strb	r2, [r3, #0]
	LOG_FUNCTION_END(status);


	return status;
 800d54e:	2317      	movs	r3, #23
 800d550:	18fb      	adds	r3, r7, r3
 800d552:	781b      	ldrb	r3, [r3, #0]
 800d554:	b25b      	sxtb	r3, r3
}
 800d556:	0018      	movs	r0, r3
 800d558:	46bd      	mov	sp, r7
 800d55a:	b006      	add	sp, #24
 800d55c:	bd80      	pop	{r7, pc}

0800d55e <VL53L1_i2c_encode_dynamic_config>:

VL53L1_Error VL53L1_i2c_encode_dynamic_config(
	VL53L1_dynamic_config_t  *pdata,
	uint16_t                  buf_size,
	uint8_t                  *pbuffer)
{
 800d55e:	b580      	push	{r7, lr}
 800d560:	b086      	sub	sp, #24
 800d562:	af00      	add	r7, sp, #0
 800d564:	60f8      	str	r0, [r7, #12]
 800d566:	607a      	str	r2, [r7, #4]
 800d568:	200a      	movs	r0, #10
 800d56a:	183b      	adds	r3, r7, r0
 800d56c:	1c0a      	adds	r2, r1, #0
 800d56e:	801a      	strh	r2, [r3, #0]
	/**
	 * Encodes data structure VL53L1_dynamic_config_t into a I2C write buffer
	 * Buffer must be at least 18 bytes
	*/

	VL53L1_Error status = VL53L1_ERROR_NONE;
 800d570:	2317      	movs	r3, #23
 800d572:	18fb      	adds	r3, r7, r3
 800d574:	2200      	movs	r2, #0
 800d576:	701a      	strb	r2, [r3, #0]

	LOG_FUNCTION_START("");

	if (VL53L1_DYNAMIC_CONFIG_I2C_SIZE_BYTES > buf_size)
 800d578:	183b      	adds	r3, r7, r0
 800d57a:	881b      	ldrh	r3, [r3, #0]
 800d57c:	2b11      	cmp	r3, #17
 800d57e:	d802      	bhi.n	800d586 <VL53L1_i2c_encode_dynamic_config+0x28>
		return VL53L1_ERROR_COMMS_BUFFER_TOO_SMALL;
 800d580:	230a      	movs	r3, #10
 800d582:	425b      	negs	r3, r3
 800d584:	e073      	b.n	800d66e <VL53L1_i2c_encode_dynamic_config+0x110>

	*(pbuffer +   0) =
		pdata->system__grouped_parameter_hold_0 & 0x3;
 800d586:	68fb      	ldr	r3, [r7, #12]
 800d588:	781b      	ldrb	r3, [r3, #0]
 800d58a:	2203      	movs	r2, #3
 800d58c:	4013      	ands	r3, r2
 800d58e:	b2da      	uxtb	r2, r3
	*(pbuffer +   0) =
 800d590:	687b      	ldr	r3, [r7, #4]
 800d592:	701a      	strb	r2, [r3, #0]
	VL53L1_i2c_encode_uint16_t(
 800d594:	68fb      	ldr	r3, [r7, #12]
 800d596:	8858      	ldrh	r0, [r3, #2]
 800d598:	687b      	ldr	r3, [r7, #4]
 800d59a:	3301      	adds	r3, #1
 800d59c:	001a      	movs	r2, r3
 800d59e:	2102      	movs	r1, #2
 800d5a0:	f7fe fdad 	bl	800c0fe <VL53L1_i2c_encode_uint16_t>
		pdata->system__thresh_high,
		2,
		pbuffer +   1);
	VL53L1_i2c_encode_uint16_t(
 800d5a4:	68fb      	ldr	r3, [r7, #12]
 800d5a6:	8898      	ldrh	r0, [r3, #4]
 800d5a8:	687b      	ldr	r3, [r7, #4]
 800d5aa:	3303      	adds	r3, #3
 800d5ac:	001a      	movs	r2, r3
 800d5ae:	2102      	movs	r1, #2
 800d5b0:	f7fe fda5 	bl	800c0fe <VL53L1_i2c_encode_uint16_t>
		pdata->system__thresh_low,
		2,
		pbuffer +   3);
	*(pbuffer +   5) =
		pdata->system__enable_xtalk_per_quadrant & 0x1;
 800d5b4:	68fb      	ldr	r3, [r7, #12]
 800d5b6:	799a      	ldrb	r2, [r3, #6]
	*(pbuffer +   5) =
 800d5b8:	687b      	ldr	r3, [r7, #4]
 800d5ba:	3305      	adds	r3, #5
		pdata->system__enable_xtalk_per_quadrant & 0x1;
 800d5bc:	2101      	movs	r1, #1
 800d5be:	400a      	ands	r2, r1
 800d5c0:	b2d2      	uxtb	r2, r2
	*(pbuffer +   5) =
 800d5c2:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   6) =
		pdata->system__seed_config & 0x7;
 800d5c4:	68fb      	ldr	r3, [r7, #12]
 800d5c6:	79da      	ldrb	r2, [r3, #7]
	*(pbuffer +   6) =
 800d5c8:	687b      	ldr	r3, [r7, #4]
 800d5ca:	3306      	adds	r3, #6
		pdata->system__seed_config & 0x7;
 800d5cc:	2107      	movs	r1, #7
 800d5ce:	400a      	ands	r2, r1
 800d5d0:	b2d2      	uxtb	r2, r2
	*(pbuffer +   6) =
 800d5d2:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   7) =
 800d5d4:	687b      	ldr	r3, [r7, #4]
 800d5d6:	3307      	adds	r3, #7
		pdata->sd_config__woi_sd0;
 800d5d8:	68fa      	ldr	r2, [r7, #12]
 800d5da:	7a12      	ldrb	r2, [r2, #8]
	*(pbuffer +   7) =
 800d5dc:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   8) =
 800d5de:	687b      	ldr	r3, [r7, #4]
 800d5e0:	3308      	adds	r3, #8
		pdata->sd_config__woi_sd1;
 800d5e2:	68fa      	ldr	r2, [r7, #12]
 800d5e4:	7a52      	ldrb	r2, [r2, #9]
	*(pbuffer +   8) =
 800d5e6:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   9) =
		pdata->sd_config__initial_phase_sd0 & 0x7F;
 800d5e8:	68fb      	ldr	r3, [r7, #12]
 800d5ea:	7a9a      	ldrb	r2, [r3, #10]
	*(pbuffer +   9) =
 800d5ec:	687b      	ldr	r3, [r7, #4]
 800d5ee:	3309      	adds	r3, #9
		pdata->sd_config__initial_phase_sd0 & 0x7F;
 800d5f0:	217f      	movs	r1, #127	; 0x7f
 800d5f2:	400a      	ands	r2, r1
 800d5f4:	b2d2      	uxtb	r2, r2
	*(pbuffer +   9) =
 800d5f6:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  10) =
		pdata->sd_config__initial_phase_sd1 & 0x7F;
 800d5f8:	68fb      	ldr	r3, [r7, #12]
 800d5fa:	7ada      	ldrb	r2, [r3, #11]
	*(pbuffer +  10) =
 800d5fc:	687b      	ldr	r3, [r7, #4]
 800d5fe:	330a      	adds	r3, #10
		pdata->sd_config__initial_phase_sd1 & 0x7F;
 800d600:	217f      	movs	r1, #127	; 0x7f
 800d602:	400a      	ands	r2, r1
 800d604:	b2d2      	uxtb	r2, r2
	*(pbuffer +  10) =
 800d606:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  11) =
		pdata->system__grouped_parameter_hold_1 & 0x3;
 800d608:	68fb      	ldr	r3, [r7, #12]
 800d60a:	7b1a      	ldrb	r2, [r3, #12]
	*(pbuffer +  11) =
 800d60c:	687b      	ldr	r3, [r7, #4]
 800d60e:	330b      	adds	r3, #11
		pdata->system__grouped_parameter_hold_1 & 0x3;
 800d610:	2103      	movs	r1, #3
 800d612:	400a      	ands	r2, r1
 800d614:	b2d2      	uxtb	r2, r2
	*(pbuffer +  11) =
 800d616:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  12) =
		pdata->sd_config__first_order_select & 0x3;
 800d618:	68fb      	ldr	r3, [r7, #12]
 800d61a:	7b5a      	ldrb	r2, [r3, #13]
	*(pbuffer +  12) =
 800d61c:	687b      	ldr	r3, [r7, #4]
 800d61e:	330c      	adds	r3, #12
		pdata->sd_config__first_order_select & 0x3;
 800d620:	2103      	movs	r1, #3
 800d622:	400a      	ands	r2, r1
 800d624:	b2d2      	uxtb	r2, r2
	*(pbuffer +  12) =
 800d626:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  13) =
		pdata->sd_config__quantifier & 0xF;
 800d628:	68fb      	ldr	r3, [r7, #12]
 800d62a:	7b9a      	ldrb	r2, [r3, #14]
	*(pbuffer +  13) =
 800d62c:	687b      	ldr	r3, [r7, #4]
 800d62e:	330d      	adds	r3, #13
		pdata->sd_config__quantifier & 0xF;
 800d630:	210f      	movs	r1, #15
 800d632:	400a      	ands	r2, r1
 800d634:	b2d2      	uxtb	r2, r2
	*(pbuffer +  13) =
 800d636:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  14) =
 800d638:	687b      	ldr	r3, [r7, #4]
 800d63a:	330e      	adds	r3, #14
		pdata->roi_config__user_roi_centre_spad;
 800d63c:	68fa      	ldr	r2, [r7, #12]
 800d63e:	7bd2      	ldrb	r2, [r2, #15]
	*(pbuffer +  14) =
 800d640:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  15) =
 800d642:	687b      	ldr	r3, [r7, #4]
 800d644:	330f      	adds	r3, #15
		pdata->roi_config__user_roi_requested_global_xy_size;
 800d646:	68fa      	ldr	r2, [r7, #12]
 800d648:	7c12      	ldrb	r2, [r2, #16]
	*(pbuffer +  15) =
 800d64a:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  16) =
 800d64c:	687b      	ldr	r3, [r7, #4]
 800d64e:	3310      	adds	r3, #16
		pdata->system__sequence_config;
 800d650:	68fa      	ldr	r2, [r7, #12]
 800d652:	7c52      	ldrb	r2, [r2, #17]
	*(pbuffer +  16) =
 800d654:	701a      	strb	r2, [r3, #0]
	*(pbuffer +  17) =
		pdata->system__grouped_parameter_hold & 0x3;
 800d656:	68fb      	ldr	r3, [r7, #12]
 800d658:	7c9a      	ldrb	r2, [r3, #18]
	*(pbuffer +  17) =
 800d65a:	687b      	ldr	r3, [r7, #4]
 800d65c:	3311      	adds	r3, #17
		pdata->system__grouped_parameter_hold & 0x3;
 800d65e:	2103      	movs	r1, #3
 800d660:	400a      	ands	r2, r1
 800d662:	b2d2      	uxtb	r2, r2
	*(pbuffer +  17) =
 800d664:	701a      	strb	r2, [r3, #0]
	LOG_FUNCTION_END(status);


	return status;
 800d666:	2317      	movs	r3, #23
 800d668:	18fb      	adds	r3, r7, r3
 800d66a:	781b      	ldrb	r3, [r3, #0]
 800d66c:	b25b      	sxtb	r3, r3
}
 800d66e:	0018      	movs	r0, r3
 800d670:	46bd      	mov	sp, r7
 800d672:	b006      	add	sp, #24
 800d674:	bd80      	pop	{r7, pc}

0800d676 <VL53L1_i2c_encode_system_control>:

VL53L1_Error VL53L1_i2c_encode_system_control(
	VL53L1_system_control_t  *pdata,
	uint16_t                  buf_size,
	uint8_t                  *pbuffer)
{
 800d676:	b580      	push	{r7, lr}
 800d678:	b086      	sub	sp, #24
 800d67a:	af00      	add	r7, sp, #0
 800d67c:	60f8      	str	r0, [r7, #12]
 800d67e:	607a      	str	r2, [r7, #4]
 800d680:	200a      	movs	r0, #10
 800d682:	183b      	adds	r3, r7, r0
 800d684:	1c0a      	adds	r2, r1, #0
 800d686:	801a      	strh	r2, [r3, #0]
	/**
	 * Encodes data structure VL53L1_system_control_t into a I2C write buffer
	 * Buffer must be at least 5 bytes
	*/

	VL53L1_Error status = VL53L1_ERROR_NONE;
 800d688:	2317      	movs	r3, #23
 800d68a:	18fb      	adds	r3, r7, r3
 800d68c:	2200      	movs	r2, #0
 800d68e:	701a      	strb	r2, [r3, #0]

	LOG_FUNCTION_START("");

	if (VL53L1_SYSTEM_CONTROL_I2C_SIZE_BYTES > buf_size)
 800d690:	183b      	adds	r3, r7, r0
 800d692:	881b      	ldrh	r3, [r3, #0]
 800d694:	2b04      	cmp	r3, #4
 800d696:	d802      	bhi.n	800d69e <VL53L1_i2c_encode_system_control+0x28>
		return VL53L1_ERROR_COMMS_BUFFER_TOO_SMALL;
 800d698:	230a      	movs	r3, #10
 800d69a:	425b      	negs	r3, r3
 800d69c:	e027      	b.n	800d6ee <VL53L1_i2c_encode_system_control+0x78>

	*(pbuffer +   0) =
		pdata->power_management__go1_power_force & 0x1;
 800d69e:	68fb      	ldr	r3, [r7, #12]
 800d6a0:	781b      	ldrb	r3, [r3, #0]
 800d6a2:	2201      	movs	r2, #1
 800d6a4:	4013      	ands	r3, r2
 800d6a6:	b2da      	uxtb	r2, r3
	*(pbuffer +   0) =
 800d6a8:	687b      	ldr	r3, [r7, #4]
 800d6aa:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   1) =
		pdata->system__stream_count_ctrl & 0x1;
 800d6ac:	68fb      	ldr	r3, [r7, #12]
 800d6ae:	785a      	ldrb	r2, [r3, #1]
	*(pbuffer +   1) =
 800d6b0:	687b      	ldr	r3, [r7, #4]
 800d6b2:	3301      	adds	r3, #1
		pdata->system__stream_count_ctrl & 0x1;
 800d6b4:	2101      	movs	r1, #1
 800d6b6:	400a      	ands	r2, r1
 800d6b8:	b2d2      	uxtb	r2, r2
	*(pbuffer +   1) =
 800d6ba:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   2) =
		pdata->firmware__enable & 0x1;
 800d6bc:	68fb      	ldr	r3, [r7, #12]
 800d6be:	789a      	ldrb	r2, [r3, #2]
	*(pbuffer +   2) =
 800d6c0:	687b      	ldr	r3, [r7, #4]
 800d6c2:	3302      	adds	r3, #2
		pdata->firmware__enable & 0x1;
 800d6c4:	2101      	movs	r1, #1
 800d6c6:	400a      	ands	r2, r1
 800d6c8:	b2d2      	uxtb	r2, r2
	*(pbuffer +   2) =
 800d6ca:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   3) =
		pdata->system__interrupt_clear & 0x3;
 800d6cc:	68fb      	ldr	r3, [r7, #12]
 800d6ce:	78da      	ldrb	r2, [r3, #3]
	*(pbuffer +   3) =
 800d6d0:	687b      	ldr	r3, [r7, #4]
 800d6d2:	3303      	adds	r3, #3
		pdata->system__interrupt_clear & 0x3;
 800d6d4:	2103      	movs	r1, #3
 800d6d6:	400a      	ands	r2, r1
 800d6d8:	b2d2      	uxtb	r2, r2
	*(pbuffer +   3) =
 800d6da:	701a      	strb	r2, [r3, #0]
	*(pbuffer +   4) =
 800d6dc:	687b      	ldr	r3, [r7, #4]
 800d6de:	3304      	adds	r3, #4
		pdata->system__mode_start;
 800d6e0:	68fa      	ldr	r2, [r7, #12]
 800d6e2:	7912      	ldrb	r2, [r2, #4]
	*(pbuffer +   4) =
 800d6e4:	701a      	strb	r2, [r3, #0]
	LOG_FUNCTION_END(status);


	return status;
 800d6e6:	2317      	movs	r3, #23
 800d6e8:	18fb      	adds	r3, r7, r3
 800d6ea:	781b      	ldrb	r3, [r3, #0]
 800d6ec:	b25b      	sxtb	r3, r3
}
 800d6ee:	0018      	movs	r0, r3
 800d6f0:	46bd      	mov	sp, r7
 800d6f2:	b006      	add	sp, #24
 800d6f4:	bd80      	pop	{r7, pc}

0800d6f6 <VL53L1_set_system_control>:


VL53L1_Error VL53L1_set_system_control(
	VL53L1_DEV                 Dev,
	VL53L1_system_control_t   *pdata)
{
 800d6f6:	b590      	push	{r4, r7, lr}
 800d6f8:	b085      	sub	sp, #20
 800d6fa:	af00      	add	r7, sp, #0
 800d6fc:	6078      	str	r0, [r7, #4]
 800d6fe:	6039      	str	r1, [r7, #0]
	/**
	 * Serialises and sends the contents of VL53L1_system_control_t
	 * data structure to the device
	 */

	VL53L1_Error status = VL53L1_ERROR_NONE;
 800d700:	210f      	movs	r1, #15
 800d702:	187b      	adds	r3, r7, r1
 800d704:	2200      	movs	r2, #0
 800d706:	701a      	strb	r2, [r3, #0]
	uint8_t comms_buffer[VL53L1_SYSTEM_CONTROL_I2C_SIZE_BYTES];

	LOG_FUNCTION_START("");

	if (status == VL53L1_ERROR_NONE) /*lint !e774 always true*/
 800d708:	187b      	adds	r3, r7, r1
 800d70a:	781b      	ldrb	r3, [r3, #0]
 800d70c:	b25b      	sxtb	r3, r3
 800d70e:	2b00      	cmp	r3, #0
 800d710:	d10a      	bne.n	800d728 <VL53L1_set_system_control+0x32>
		status = VL53L1_i2c_encode_system_control(
 800d712:	230f      	movs	r3, #15
 800d714:	18fc      	adds	r4, r7, r3
 800d716:	2308      	movs	r3, #8
 800d718:	18fa      	adds	r2, r7, r3
 800d71a:	683b      	ldr	r3, [r7, #0]
 800d71c:	2105      	movs	r1, #5
 800d71e:	0018      	movs	r0, r3
 800d720:	f7ff ffa9 	bl	800d676 <VL53L1_i2c_encode_system_control>
 800d724:	0003      	movs	r3, r0
 800d726:	7023      	strb	r3, [r4, #0]
			pdata,
			VL53L1_SYSTEM_CONTROL_I2C_SIZE_BYTES,
			comms_buffer);

	if (status == VL53L1_ERROR_NONE)
 800d728:	230f      	movs	r3, #15
 800d72a:	18fb      	adds	r3, r7, r3
 800d72c:	781b      	ldrb	r3, [r3, #0]
 800d72e:	b25b      	sxtb	r3, r3
 800d730:	2b00      	cmp	r3, #0
 800d732:	d10a      	bne.n	800d74a <VL53L1_set_system_control+0x54>
		status = VL53L1_WriteMulti(
 800d734:	230f      	movs	r3, #15
 800d736:	18fc      	adds	r4, r7, r3
 800d738:	2308      	movs	r3, #8
 800d73a:	18fa      	adds	r2, r7, r3
 800d73c:	6878      	ldr	r0, [r7, #4]
 800d73e:	2305      	movs	r3, #5
 800d740:	2183      	movs	r1, #131	; 0x83
 800d742:	f000 fd0b 	bl	800e15c <VL53L1_WriteMulti>
 800d746:	0003      	movs	r3, r0
 800d748:	7023      	strb	r3, [r4, #0]
			comms_buffer,
			VL53L1_SYSTEM_CONTROL_I2C_SIZE_BYTES);

	LOG_FUNCTION_END(status);

	return status;
 800d74a:	230f      	movs	r3, #15
 800d74c:	18fb      	adds	r3, r7, r3
 800d74e:	781b      	ldrb	r3, [r3, #0]
 800d750:	b25b      	sxtb	r3, r3
}
 800d752:	0018      	movs	r0, r3
 800d754:	46bd      	mov	sp, r7
 800d756:	b005      	add	sp, #20
 800d758:	bd90      	pop	{r4, r7, pc}

0800d75a <VL53L1_i2c_decode_system_results>:

VL53L1_Error VL53L1_i2c_decode_system_results(
	uint16_t                   buf_size,
	uint8_t                   *pbuffer,
	VL53L1_system_results_t   *pdata)
{
 800d75a:	b580      	push	{r7, lr}
 800d75c:	b086      	sub	sp, #24
 800d75e:	af00      	add	r7, sp, #0
 800d760:	60b9      	str	r1, [r7, #8]
 800d762:	607a      	str	r2, [r7, #4]
 800d764:	210e      	movs	r1, #14
 800d766:	187b      	adds	r3, r7, r1
 800d768:	1c02      	adds	r2, r0, #0
 800d76a:	801a      	strh	r2, [r3, #0]
	/**
	 * Decodes data structure VL53L1_system_results_t from the input I2C read buffer
	 * Buffer must be at least 44 bytes
	*/

	VL53L1_Error status = VL53L1_ERROR_NONE;
 800d76c:	2317      	movs	r3, #23
 800d76e:	18fb      	adds	r3, r7, r3
 800d770:	2200      	movs	r2, #0
 800d772:	701a      	strb	r2, [r3, #0]

	LOG_FUNCTION_START("");

	if (VL53L1_SYSTEM_RESULTS_I2C_SIZE_BYTES > buf_size)
 800d774:	187b      	adds	r3, r7, r1
 800d776:	881b      	ldrh	r3, [r3, #0]
 800d778:	2b2b      	cmp	r3, #43	; 0x2b
 800d77a:	d802      	bhi.n	800d782 <VL53L1_i2c_decode_system_results+0x28>
		return VL53L1_ERROR_COMMS_BUFFER_TOO_SMALL;
 800d77c:	230a      	movs	r3, #10
 800d77e:	425b      	negs	r3, r3
 800d780:	e0e4      	b.n	800d94c <VL53L1_i2c_decode_system_results+0x1f2>

	pdata->result__interrupt_status =
		(*(pbuffer +   0)) & 0x3F;
 800d782:	68bb      	ldr	r3, [r7, #8]
 800d784:	781b      	ldrb	r3, [r3, #0]
 800d786:	223f      	movs	r2, #63	; 0x3f
 800d788:	4013      	ands	r3, r2
 800d78a:	b2da      	uxtb	r2, r3
	pdata->result__interrupt_status =
 800d78c:	687b      	ldr	r3, [r7, #4]
 800d78e:	701a      	strb	r2, [r3, #0]
	pdata->result__range_status =
 800d790:	68bb      	ldr	r3, [r7, #8]
 800d792:	785a      	ldrb	r2, [r3, #1]
 800d794:	687b      	ldr	r3, [r7, #4]
 800d796:	705a      	strb	r2, [r3, #1]
		(*(pbuffer +   1));
	pdata->result__report_status =
		(*(pbuffer +   2)) & 0xF;
 800d798:	68bb      	ldr	r3, [r7, #8]
 800d79a:	3302      	adds	r3, #2
 800d79c:	781b      	ldrb	r3, [r3, #0]
 800d79e:	220f      	movs	r2, #15
 800d7a0:	4013      	ands	r3, r2
 800d7a2:	b2da      	uxtb	r2, r3
	pdata->result__report_status =
 800d7a4:	687b      	ldr	r3, [r7, #4]
 800d7a6:	709a      	strb	r2, [r3, #2]
	pdata->result__stream_count =
 800d7a8:	68bb      	ldr	r3, [r7, #8]
 800d7aa:	78da      	ldrb	r2, [r3, #3]
 800d7ac:	687b      	ldr	r3, [r7, #4]
 800d7ae:	70da      	strb	r2, [r3, #3]
		(*(pbuffer +   3));
	pdata->result__dss_actual_effective_spads_sd0 =
		(VL53L1_i2c_decode_uint16_t(2, pbuffer +   4));
 800d7b0:	68bb      	ldr	r3, [r7, #8]
 800d7b2:	3304      	adds	r3, #4
 800d7b4:	0019      	movs	r1, r3
 800d7b6:	2002      	movs	r0, #2
 800d7b8:	f7fe fcde 	bl	800c178 <VL53L1_i2c_decode_uint16_t>
 800d7bc:	0003      	movs	r3, r0
 800d7be:	001a      	movs	r2, r3
	pdata->result__dss_actual_effective_spads_sd0 =
 800d7c0:	687b      	ldr	r3, [r7, #4]
 800d7c2:	809a      	strh	r2, [r3, #4]
	pdata->result__peak_signal_count_rate_mcps_sd0 =
		(VL53L1_i2c_decode_uint16_t(2, pbuffer +   6));
 800d7c4:	68bb      	ldr	r3, [r7, #8]
 800d7c6:	3306      	adds	r3, #6
 800d7c8:	0019      	movs	r1, r3
 800d7ca:	2002      	movs	r0, #2
 800d7cc:	f7fe fcd4 	bl	800c178 <VL53L1_i2c_decode_uint16_t>
 800d7d0:	0003      	movs	r3, r0
 800d7d2:	001a      	movs	r2, r3
	pdata->result__peak_signal_count_rate_mcps_sd0 =
 800d7d4:	687b      	ldr	r3, [r7, #4]
 800d7d6:	80da      	strh	r2, [r3, #6]
	pdata->result__ambient_count_rate_mcps_sd0 =
		(VL53L1_i2c_decode_uint16_t(2, pbuffer +   8));
 800d7d8:	68bb      	ldr	r3, [r7, #8]
 800d7da:	3308      	adds	r3, #8
 800d7dc:	0019      	movs	r1, r3
 800d7de:	2002      	movs	r0, #2
 800d7e0:	f7fe fcca 	bl	800c178 <VL53L1_i2c_decode_uint16_t>
 800d7e4:	0003      	movs	r3, r0
 800d7e6:	001a      	movs	r2, r3
	pdata->result__ambient_count_rate_mcps_sd0 =
 800d7e8:	687b      	ldr	r3, [r7, #4]
 800d7ea:	811a      	strh	r2, [r3, #8]
	pdata->result__sigma_sd0 =
		(VL53L1_i2c_decode_uint16_t(2, pbuffer +  10));
 800d7ec:	68bb      	ldr	r3, [r7, #8]
 800d7ee:	330a      	adds	r3, #10
 800d7f0:	0019      	movs	r1, r3
 800d7f2:	2002      	movs	r0, #2
 800d7f4:	f7fe fcc0 	bl	800c178 <VL53L1_i2c_decode_uint16_t>
 800d7f8:	0003      	movs	r3, r0
 800d7fa:	001a      	movs	r2, r3
	pdata->result__sigma_sd0 =
 800d7fc:	687b      	ldr	r3, [r7, #4]
 800d7fe:	815a      	strh	r2, [r3, #10]
	pdata->result__phase_sd0 =
		(VL53L1_i2c_decode_uint16_t(2, pbuffer +  12));
 800d800:	68bb      	ldr	r3, [r7, #8]
 800d802:	330c      	adds	r3, #12
 800d804:	0019      	movs	r1, r3
 800d806:	2002      	movs	r0, #2
 800d808:	f7fe fcb6 	bl	800c178 <VL53L1_i2c_decode_uint16_t>
 800d80c:	0003      	movs	r3, r0
 800d80e:	001a      	movs	r2, r3
	pdata->result__phase_sd0 =
 800d810:	687b      	ldr	r3, [r7, #4]
 800d812:	819a      	strh	r2, [r3, #12]
	pdata->result__final_crosstalk_corrected_range_mm_sd0 =
		(VL53L1_i2c_decode_uint16_t(2, pbuffer +  14));
 800d814:	68bb      	ldr	r3, [r7, #8]
 800d816:	330e      	adds	r3, #14
 800d818:	0019      	movs	r1, r3
 800d81a:	2002      	movs	r0, #2
 800d81c:	f7fe fcac 	bl	800c178 <VL53L1_i2c_decode_uint16_t>
 800d820:	0003      	movs	r3, r0
 800d822:	001a      	movs	r2, r3
	pdata->result__final_crosstalk_corrected_range_mm_sd0 =
 800d824:	687b      	ldr	r3, [r7, #4]
 800d826:	81da      	strh	r2, [r3, #14]
	pdata->result__peak_signal_count_rate_crosstalk_corrected_mcps_sd0 =
		(VL53L1_i2c_decode_uint16_t(2, pbuffer +  16));
 800d828:	68bb      	ldr	r3, [r7, #8]
 800d82a:	3310      	adds	r3, #16
 800d82c:	0019      	movs	r1, r3
 800d82e:	2002      	movs	r0, #2
 800d830:	f7fe fca2 	bl	800c178 <VL53L1_i2c_decode_uint16_t>
 800d834:	0003      	movs	r3, r0
 800d836:	001a      	movs	r2, r3
	pdata->result__peak_signal_count_rate_crosstalk_corrected_mcps_sd0 =
 800d838:	687b      	ldr	r3, [r7, #4]
 800d83a:	821a      	strh	r2, [r3, #16]
	pdata->result__mm_inner_actual_effective_spads_sd0 =
		(VL53L1_i2c_decode_uint16_t(2, pbuffer +  18));
 800d83c:	68bb      	ldr	r3, [r7, #8]
 800d83e:	3312      	adds	r3, #18
 800d840:	0019      	movs	r1, r3
 800d842:	2002      	movs	r0, #2
 800d844:	f7fe fc98 	bl	800c178 <VL53L1_i2c_decode_uint16_t>
 800d848:	0003      	movs	r3, r0
 800d84a:	001a      	movs	r2, r3
	pdata->result__mm_inner_actual_effective_spads_sd0 =
 800d84c:	687b      	ldr	r3, [r7, #4]
 800d84e:	825a      	strh	r2, [r3, #18]
	pdata->result__mm_outer_actual_effective_spads_sd0 =
		(VL53L1_i2c_decode_uint16_t(2, pbuffer +  20));
 800d850:	68bb      	ldr	r3, [r7, #8]
 800d852:	3314      	adds	r3, #20
 800d854:	0019      	movs	r1, r3
 800d856:	2002      	movs	r0, #2
 800d858:	f7fe fc8e 	bl	800c178 <VL53L1_i2c_decode_uint16_t>
 800d85c:	0003      	movs	r3, r0
 800d85e:	001a      	movs	r2, r3
	pdata->result__mm_outer_actual_effective_spads_sd0 =
 800d860:	687b      	ldr	r3, [r7, #4]
 800d862:	829a      	strh	r2, [r3, #20]
	pdata->result__avg_signal_count_rate_mcps_sd0 =
		(VL53L1_i2c_decode_uint16_t(2, pbuffer +  22));
 800d864:	68bb      	ldr	r3, [r7, #8]
 800d866:	3316      	adds	r3, #22
 800d868:	0019      	movs	r1, r3
 800d86a:	2002      	movs	r0, #2
 800d86c:	f7fe fc84 	bl	800c178 <VL53L1_i2c_decode_uint16_t>
 800d870:	0003      	movs	r3, r0
 800d872:	001a      	movs	r2, r3
	pdata->result__avg_signal_count_rate_mcps_sd0 =
 800d874:	687b      	ldr	r3, [r7, #4]
 800d876:	82da      	strh	r2, [r3, #22]
	pdata->result__dss_actual_effective_spads_sd1 =
		(VL53L1_i2c_decode_uint16_t(2, pbuffer +  24));
 800d878:	68bb      	ldr	r3, [r7, #8]
 800d87a:	3318      	adds	r3, #24
 800d87c:	0019      	movs	r1, r3
 800d87e:	2002      	movs	r0, #2
 800d880:	f7fe fc7a 	bl	800c178 <VL53L1_i2c_decode_uint16_t>
 800d884:	0003      	movs	r3, r0
 800d886:	001a      	movs	r2, r3
	pdata->result__dss_actual_effective_spads_sd1 =
 800d888:	687b      	ldr	r3, [r7, #4]
 800d88a:	831a      	strh	r2, [r3, #24]
	pdata->result__peak_signal_count_rate_mcps_sd1 =
		(VL53L1_i2c_decode_uint16_t(2, pbuffer +  26));
 800d88c:	68bb      	ldr	r3, [r7, #8]
 800d88e:	331a      	adds	r3, #26
 800d890:	0019      	movs	r1, r3
 800d892:	2002      	movs	r0, #2
 800d894:	f7fe fc70 	bl	800c178 <VL53L1_i2c_decode_uint16_t>
 800d898:	0003      	movs	r3, r0
 800d89a:	001a      	movs	r2, r3
	pdata->result__peak_signal_count_rate_mcps_sd1 =
 800d89c:	687b      	ldr	r3, [r7, #4]
 800d89e:	835a      	strh	r2, [r3, #26]
	pdata->result__ambient_count_rate_mcps_sd1 =
		(VL53L1_i2c_decode_uint16_t(2, pbuffer +  28));
 800d8a0:	68bb      	ldr	r3, [r7, #8]
 800d8a2:	331c      	adds	r3, #28
 800d8a4:	0019      	movs	r1, r3
 800d8a6:	2002      	movs	r0, #2
 800d8a8:	f7fe fc66 	bl	800c178 <VL53L1_i2c_decode_uint16_t>
 800d8ac:	0003      	movs	r3, r0
 800d8ae:	001a      	movs	r2, r3
	pdata->result__ambient_count_rate_mcps_sd1 =
 800d8b0:	687b      	ldr	r3, [r7, #4]
 800d8b2:	839a      	strh	r2, [r3, #28]
	pdata->result__sigma_sd1 =
		(VL53L1_i2c_decode_uint16_t(2, pbuffer +  30));
 800d8b4:	68bb      	ldr	r3, [r7, #8]
 800d8b6:	331e      	adds	r3, #30
 800d8b8:	0019      	movs	r1, r3
 800d8ba:	2002      	movs	r0, #2
 800d8bc:	f7fe fc5c 	bl	800c178 <VL53L1_i2c_decode_uint16_t>
 800d8c0:	0003      	movs	r3, r0
 800d8c2:	001a      	movs	r2, r3
	pdata->result__sigma_sd1 =
 800d8c4:	687b      	ldr	r3, [r7, #4]
 800d8c6:	83da      	strh	r2, [r3, #30]
	pdata->result__phase_sd1 =
		(VL53L1_i2c_decode_uint16_t(2, pbuffer +  32));
 800d8c8:	68bb      	ldr	r3, [r7, #8]
 800d8ca:	3320      	adds	r3, #32
 800d8cc:	0019      	movs	r1, r3
 800d8ce:	2002      	movs	r0, #2
 800d8d0:	f7fe fc52 	bl	800c178 <VL53L1_i2c_decode_uint16_t>
 800d8d4:	0003      	movs	r3, r0
 800d8d6:	001a      	movs	r2, r3
	pdata->result__phase_sd1 =
 800d8d8:	687b      	ldr	r3, [r7, #4]
 800d8da:	841a      	strh	r2, [r3, #32]
	pdata->result__final_crosstalk_corrected_range_mm_sd1 =
		(VL53L1_i2c_decode_uint16_t(2, pbuffer +  34));
 800d8dc:	68bb      	ldr	r3, [r7, #8]
 800d8de:	3322      	adds	r3, #34	; 0x22
 800d8e0:	0019      	movs	r1, r3
 800d8e2:	2002      	movs	r0, #2
 800d8e4:	f7fe fc48 	bl	800c178 <VL53L1_i2c_decode_uint16_t>
 800d8e8:	0003      	movs	r3, r0
 800d8ea:	001a      	movs	r2, r3
	pdata->result__final_crosstalk_corrected_range_mm_sd1 =
 800d8ec:	687b      	ldr	r3, [r7, #4]
 800d8ee:	845a      	strh	r2, [r3, #34]	; 0x22
	pdata->result__spare_0_sd1 =
		(VL53L1_i2c_decode_uint16_t(2, pbuffer +  36));
 800d8f0:	68bb      	ldr	r3, [r7, #8]
 800d8f2:	3324      	adds	r3, #36	; 0x24
 800d8f4:	0019      	movs	r1, r3
 800d8f6:	2002      	movs	r0, #2
 800d8f8:	f7fe fc3e 	bl	800c178 <VL53L1_i2c_decode_uint16_t>
 800d8fc:	0003      	movs	r3, r0
 800d8fe:	001a      	movs	r2, r3
	pdata->result__spare_0_sd1 =
 800d900:	687b      	ldr	r3, [r7, #4]
 800d902:	849a      	strh	r2, [r3, #36]	; 0x24
	pdata->result__spare_1_sd1 =
		(VL53L1_i2c_decode_uint16_t(2, pbuffer +  38));
 800d904:	68bb      	ldr	r3, [r7, #8]
 800d906:	3326      	adds	r3, #38	; 0x26
 800d908:	0019      	movs	r1, r3
 800d90a:	2002      	movs	r0, #2
 800d90c:	f7fe fc34 	bl	800c178 <VL53L1_i2c_decode_uint16_t>
 800d910:	0003      	movs	r3, r0
 800d912:	001a      	movs	r2, r3
	pdata->result__spare_1_sd1 =
 800d914:	687b      	ldr	r3, [r7, #4]
 800d916:	84da      	strh	r2, [r3, #38]	; 0x26
	pdata->result__spare_2_sd1 =
		(VL53L1_i2c_decode_uint16_t(2, pbuffer +  40));
 800d918:	68bb      	ldr	r3, [r7, #8]
 800d91a:	3328      	adds	r3, #40	; 0x28
 800d91c:	0019      	movs	r1, r3
 800d91e:	2002      	movs	r0, #2
 800d920:	f7fe fc2a 	bl	800c178 <VL53L1_i2c_decode_uint16_t>
 800d924:	0003      	movs	r3, r0
 800d926:	001a      	movs	r2, r3
	pdata->result__spare_2_sd1 =
 800d928:	687b      	ldr	r3, [r7, #4]
 800d92a:	851a      	strh	r2, [r3, #40]	; 0x28
	pdata->result__spare_3_sd1 =
 800d92c:	68bb      	ldr	r3, [r7, #8]
 800d92e:	222a      	movs	r2, #42	; 0x2a
 800d930:	5c99      	ldrb	r1, [r3, r2]
 800d932:	687b      	ldr	r3, [r7, #4]
 800d934:	222a      	movs	r2, #42	; 0x2a
 800d936:	5499      	strb	r1, [r3, r2]
		(*(pbuffer +  42));
	pdata->result__thresh_info =
 800d938:	68bb      	ldr	r3, [r7, #8]
 800d93a:	222b      	movs	r2, #43	; 0x2b
 800d93c:	5c99      	ldrb	r1, [r3, r2]
 800d93e:	687b      	ldr	r3, [r7, #4]
 800d940:	222b      	movs	r2, #43	; 0x2b
 800d942:	5499      	strb	r1, [r3, r2]
		(*(pbuffer +  43));

	LOG_FUNCTION_END(status);

	return status;
 800d944:	2317      	movs	r3, #23
 800d946:	18fb      	adds	r3, r7, r3
 800d948:	781b      	ldrb	r3, [r3, #0]
 800d94a:	b25b      	sxtb	r3, r3
}
 800d94c:	0018      	movs	r0, r3
 800d94e:	46bd      	mov	sp, r7
 800d950:	b006      	add	sp, #24
 800d952:	bd80      	pop	{r7, pc}

0800d954 <VL53L1_i2c_decode_core_results>:

VL53L1_Error VL53L1_i2c_decode_core_results(
	uint16_t                   buf_size,
	uint8_t                   *pbuffer,
	VL53L1_core_results_t     *pdata)
{
 800d954:	b580      	push	{r7, lr}
 800d956:	b086      	sub	sp, #24
 800d958:	af00      	add	r7, sp, #0
 800d95a:	60b9      	str	r1, [r7, #8]
 800d95c:	607a      	str	r2, [r7, #4]
 800d95e:	210e      	movs	r1, #14
 800d960:	187b      	adds	r3, r7, r1
 800d962:	1c02      	adds	r2, r0, #0
 800d964:	801a      	strh	r2, [r3, #0]
	/**
	 * Decodes data structure VL53L1_core_results_t from the input I2C read buffer
	 * Buffer must be at least 33 bytes
	*/

	VL53L1_Error status = VL53L1_ERROR_NONE;
 800d966:	2317      	movs	r3, #23
 800d968:	18fb      	adds	r3, r7, r3
 800d96a:	2200      	movs	r2, #0
 800d96c:	701a      	strb	r2, [r3, #0]

	LOG_FUNCTION_START("");

	if (VL53L1_CORE_RESULTS_I2C_SIZE_BYTES > buf_size)
 800d96e:	187b      	adds	r3, r7, r1
 800d970:	881b      	ldrh	r3, [r3, #0]
 800d972:	2b20      	cmp	r3, #32
 800d974:	d802      	bhi.n	800d97c <VL53L1_i2c_decode_core_results+0x28>
		return VL53L1_ERROR_COMMS_BUFFER_TOO_SMALL;
 800d976:	230a      	movs	r3, #10
 800d978:	425b      	negs	r3, r3
 800d97a:	e050      	b.n	800da1e <VL53L1_i2c_decode_core_results+0xca>

	pdata->result_core__ambient_window_events_sd0 =
		(VL53L1_i2c_decode_uint32_t(4, pbuffer +   0));
 800d97c:	68bb      	ldr	r3, [r7, #8]
 800d97e:	0019      	movs	r1, r3
 800d980:	2004      	movs	r0, #4
 800d982:	f7fe fcc8 	bl	800c316 <VL53L1_i2c_decode_uint32_t>
 800d986:	0002      	movs	r2, r0
	pdata->result_core__ambient_window_events_sd0 =
 800d988:	687b      	ldr	r3, [r7, #4]
 800d98a:	601a      	str	r2, [r3, #0]
	pdata->result_core__ranging_total_events_sd0 =
		(VL53L1_i2c_decode_uint32_t(4, pbuffer +   4));
 800d98c:	68bb      	ldr	r3, [r7, #8]
 800d98e:	3304      	adds	r3, #4
 800d990:	0019      	movs	r1, r3
 800d992:	2004      	movs	r0, #4
 800d994:	f7fe fcbf 	bl	800c316 <VL53L1_i2c_decode_uint32_t>
 800d998:	0002      	movs	r2, r0
	pdata->result_core__ranging_total_events_sd0 =
 800d99a:	687b      	ldr	r3, [r7, #4]
 800d99c:	605a      	str	r2, [r3, #4]
	pdata->result_core__signal_total_events_sd0 =
		(VL53L1_i2c_decode_int32_t(4, pbuffer +   8));
 800d99e:	68bb      	ldr	r3, [r7, #8]
 800d9a0:	3308      	adds	r3, #8
 800d9a2:	0019      	movs	r1, r3
 800d9a4:	2004      	movs	r0, #4
 800d9a6:	f7fe fcd4 	bl	800c352 <VL53L1_i2c_decode_int32_t>
 800d9aa:	0002      	movs	r2, r0
	pdata->result_core__signal_total_events_sd0 =
 800d9ac:	687b      	ldr	r3, [r7, #4]
 800d9ae:	609a      	str	r2, [r3, #8]
	pdata->result_core__total_periods_elapsed_sd0 =
		(VL53L1_i2c_decode_uint32_t(4, pbuffer +  12));
 800d9b0:	68bb      	ldr	r3, [r7, #8]
 800d9b2:	330c      	adds	r3, #12
 800d9b4:	0019      	movs	r1, r3
 800d9b6:	2004      	movs	r0, #4
 800d9b8:	f7fe fcad 	bl	800c316 <VL53L1_i2c_decode_uint32_t>
 800d9bc:	0002      	movs	r2, r0
	pdata->result_core__total_periods_elapsed_sd0 =
 800d9be:	687b      	ldr	r3, [r7, #4]
 800d9c0:	60da      	str	r2, [r3, #12]
	pdata->result_core__ambient_window_events_sd1 =
		(VL53L1_i2c_decode_uint32_t(4, pbuffer +  16));
 800d9c2:	68bb      	ldr	r3, [r7, #8]
 800d9c4:	3310      	adds	r3, #16
 800d9c6:	0019      	movs	r1, r3
 800d9c8:	2004      	movs	r0, #4
 800d9ca:	f7fe fca4 	bl	800c316 <VL53L1_i2c_decode_uint32_t>
 800d9ce:	0002      	movs	r2, r0
	pdata->result_core__ambient_window_events_sd1 =
 800d9d0:	687b      	ldr	r3, [r7, #4]
 800d9d2:	611a      	str	r2, [r3, #16]
	pdata->result_core__ranging_total_events_sd1 =
		(VL53L1_i2c_decode_uint32_t(4, pbuffer +  20));
 800d9d4:	68bb      	ldr	r3, [r7, #8]
 800d9d6:	3314      	adds	r3, #20
 800d9d8:	0019      	movs	r1, r3
 800d9da:	2004      	movs	r0, #4
 800d9dc:	f7fe fc9b 	bl	800c316 <VL53L1_i2c_decode_uint32_t>
 800d9e0:	0002      	movs	r2, r0
	pdata->result_core__ranging_total_events_sd1 =
 800d9e2:	687b      	ldr	r3, [r7, #4]
 800d9e4:	615a      	str	r2, [r3, #20]
	pdata->result_core__signal_total_events_sd1 =
		(VL53L1_i2c_decode_int32_t(4, pbuffer +  24));
 800d9e6:	68bb      	ldr	r3, [r7, #8]
 800d9e8:	3318      	adds	r3, #24
 800d9ea:	0019      	movs	r1, r3
 800d9ec:	2004      	movs	r0, #4
 800d9ee:	f7fe fcb0 	bl	800c352 <VL53L1_i2c_decode_int32_t>
 800d9f2:	0002      	movs	r2, r0
	pdata->result_core__signal_total_events_sd1 =
 800d9f4:	687b      	ldr	r3, [r7, #4]
 800d9f6:	619a      	str	r2, [r3, #24]
	pdata->result_core__total_periods_elapsed_sd1 =
		(VL53L1_i2c_decode_uint32_t(4, pbuffer +  28));
 800d9f8:	68bb      	ldr	r3, [r7, #8]
 800d9fa:	331c      	adds	r3, #28
 800d9fc:	0019      	movs	r1, r3
 800d9fe:	2004      	movs	r0, #4
 800da00:	f7fe fc89 	bl	800c316 <VL53L1_i2c_decode_uint32_t>
 800da04:	0002      	movs	r2, r0
	pdata->result_core__total_periods_elapsed_sd1 =
 800da06:	687b      	ldr	r3, [r7, #4]
 800da08:	61da      	str	r2, [r3, #28]
	pdata->result_core__spare_0 =
 800da0a:	68bb      	ldr	r3, [r7, #8]
 800da0c:	2220      	movs	r2, #32
 800da0e:	5c99      	ldrb	r1, [r3, r2]
 800da10:	687b      	ldr	r3, [r7, #4]
 800da12:	2220      	movs	r2, #32
 800da14:	5499      	strb	r1, [r3, r2]
		(*(pbuffer +  32));

	LOG_FUNCTION_END(status);

	return status;
 800da16:	2317      	movs	r3, #23
 800da18:	18fb      	adds	r3, r7, r3
 800da1a:	781b      	ldrb	r3, [r3, #0]
 800da1c:	b25b      	sxtb	r3, r3
}
 800da1e:	0018      	movs	r0, r3
 800da20:	46bd      	mov	sp, r7
 800da22:	b006      	add	sp, #24
 800da24:	bd80      	pop	{r7, pc}

0800da26 <VL53L1_i2c_decode_debug_results>:

VL53L1_Error VL53L1_i2c_decode_debug_results(
	uint16_t                   buf_size,
	uint8_t                   *pbuffer,
	VL53L1_debug_results_t    *pdata)
{
 800da26:	b580      	push	{r7, lr}
 800da28:	b086      	sub	sp, #24
 800da2a:	af00      	add	r7, sp, #0
 800da2c:	60b9      	str	r1, [r7, #8]
 800da2e:	607a      	str	r2, [r7, #4]
 800da30:	210e      	movs	r1, #14
 800da32:	187b      	adds	r3, r7, r1
 800da34:	1c02      	adds	r2, r0, #0
 800da36:	801a      	strh	r2, [r3, #0]
	/**
	 * Decodes data structure VL53L1_debug_results_t from the input I2C read buffer
	 * Buffer must be at least 56 bytes
	*/

	VL53L1_Error status = VL53L1_ERROR_NONE;
 800da38:	2317      	movs	r3, #23
 800da3a:	18fb      	adds	r3, r7, r3
 800da3c:	2200      	movs	r2, #0
 800da3e:	701a      	strb	r2, [r3, #0]

	LOG_FUNCTION_START("");

	if (VL53L1_DEBUG_RESULTS_I2C_SIZE_BYTES > buf_size)
 800da40:	187b      	adds	r3, r7, r1
 800da42:	881b      	ldrh	r3, [r3, #0]
 800da44:	2b37      	cmp	r3, #55	; 0x37
 800da46:	d802      	bhi.n	800da4e <VL53L1_i2c_decode_debug_results+0x28>
		return VL53L1_ERROR_COMMS_BUFFER_TOO_SMALL;
 800da48:	230a      	movs	r3, #10
 800da4a:	425b      	negs	r3, r3
 800da4c:	e161      	b.n	800dd12 <VL53L1_i2c_decode_debug_results+0x2ec>

	pdata->phasecal_result__reference_phase =
		(VL53L1_i2c_decode_uint16_t(2, pbuffer +   0));
 800da4e:	68bb      	ldr	r3, [r7, #8]
 800da50:	0019      	movs	r1, r3
 800da52:	2002      	movs	r0, #2
 800da54:	f7fe fb90 	bl	800c178 <VL53L1_i2c_decode_uint16_t>
 800da58:	0003      	movs	r3, r0
 800da5a:	001a      	movs	r2, r3
	pdata->phasecal_result__reference_phase =
 800da5c:	687b      	ldr	r3, [r7, #4]
 800da5e:	801a      	strh	r2, [r3, #0]
	pdata->phasecal_result__vcsel_start =
		(*(pbuffer +   2)) & 0x7F;
 800da60:	68bb      	ldr	r3, [r7, #8]
 800da62:	3302      	adds	r3, #2
 800da64:	781b      	ldrb	r3, [r3, #0]
 800da66:	227f      	movs	r2, #127	; 0x7f
 800da68:	4013      	ands	r3, r2
 800da6a:	b2da      	uxtb	r2, r3
	pdata->phasecal_result__vcsel_start =
 800da6c:	687b      	ldr	r3, [r7, #4]
 800da6e:	709a      	strb	r2, [r3, #2]
	pdata->ref_spad_char_result__num_actual_ref_spads =
		(*(pbuffer +   3)) & 0x3F;
 800da70:	68bb      	ldr	r3, [r7, #8]
 800da72:	3303      	adds	r3, #3
 800da74:	781b      	ldrb	r3, [r3, #0]
 800da76:	223f      	movs	r2, #63	; 0x3f
 800da78:	4013      	ands	r3, r2
 800da7a:	b2da      	uxtb	r2, r3
	pdata->ref_spad_char_result__num_actual_ref_spads =
 800da7c:	687b      	ldr	r3, [r7, #4]
 800da7e:	70da      	strb	r2, [r3, #3]
	pdata->ref_spad_char_result__ref_location =
		(*(pbuffer +   4)) & 0x3;
 800da80:	68bb      	ldr	r3, [r7, #8]
 800da82:	3304      	adds	r3, #4
 800da84:	781b      	ldrb	r3, [r3, #0]
 800da86:	2203      	movs	r2, #3
 800da88:	4013      	ands	r3, r2
 800da8a:	b2da      	uxtb	r2, r3
	pdata->ref_spad_char_result__ref_location =
 800da8c:	687b      	ldr	r3, [r7, #4]
 800da8e:	711a      	strb	r2, [r3, #4]
	pdata->vhv_result__coldboot_status =
		(*(pbuffer +   5)) & 0x1;
 800da90:	68bb      	ldr	r3, [r7, #8]
 800da92:	3305      	adds	r3, #5
 800da94:	781b      	ldrb	r3, [r3, #0]
 800da96:	2201      	movs	r2, #1
 800da98:	4013      	ands	r3, r2
 800da9a:	b2da      	uxtb	r2, r3
	pdata->vhv_result__coldboot_status =
 800da9c:	687b      	ldr	r3, [r7, #4]
 800da9e:	715a      	strb	r2, [r3, #5]
	pdata->vhv_result__search_result =
		(*(pbuffer +   6)) & 0x3F;
 800daa0:	68bb      	ldr	r3, [r7, #8]
 800daa2:	3306      	adds	r3, #6
 800daa4:	781b      	ldrb	r3, [r3, #0]
 800daa6:	223f      	movs	r2, #63	; 0x3f
 800daa8:	4013      	ands	r3, r2
 800daaa:	b2da      	uxtb	r2, r3
	pdata->vhv_result__search_result =
 800daac:	687b      	ldr	r3, [r7, #4]
 800daae:	719a      	strb	r2, [r3, #6]
	pdata->vhv_result__latest_setting =
		(*(pbuffer +   7)) & 0x3F;
 800dab0:	68bb      	ldr	r3, [r7, #8]
 800dab2:	3307      	adds	r3, #7
 800dab4:	781b      	ldrb	r3, [r3, #0]
 800dab6:	223f      	movs	r2, #63	; 0x3f
 800dab8:	4013      	ands	r3, r2
 800daba:	b2da      	uxtb	r2, r3
	pdata->vhv_result__latest_setting =
 800dabc:	687b      	ldr	r3, [r7, #4]
 800dabe:	71da      	strb	r2, [r3, #7]
	pdata->result__osc_calibrate_val =
		(VL53L1_i2c_decode_uint16_t(2, pbuffer +   8)) & 0x3FF;
 800dac0:	68bb      	ldr	r3, [r7, #8]
 800dac2:	3308      	adds	r3, #8
 800dac4:	0019      	movs	r1, r3
 800dac6:	2002      	movs	r0, #2
 800dac8:	f7fe fb56 	bl	800c178 <VL53L1_i2c_decode_uint16_t>
 800dacc:	0003      	movs	r3, r0
 800dace:	059b      	lsls	r3, r3, #22
 800dad0:	0d9b      	lsrs	r3, r3, #22
 800dad2:	b29a      	uxth	r2, r3
	pdata->result__osc_calibrate_val =
 800dad4:	687b      	ldr	r3, [r7, #4]
 800dad6:	811a      	strh	r2, [r3, #8]
	pdata->ana_config__powerdown_go1 =
		(*(pbuffer +  10)) & 0x3;
 800dad8:	68bb      	ldr	r3, [r7, #8]
 800dada:	330a      	adds	r3, #10
 800dadc:	781b      	ldrb	r3, [r3, #0]
 800dade:	2203      	movs	r2, #3
 800dae0:	4013      	ands	r3, r2
 800dae2:	b2da      	uxtb	r2, r3
	pdata->ana_config__powerdown_go1 =
 800dae4:	687b      	ldr	r3, [r7, #4]
 800dae6:	729a      	strb	r2, [r3, #10]
	pdata->ana_config__ref_bg_ctrl =
		(*(pbuffer +  11)) & 0x3;
 800dae8:	68bb      	ldr	r3, [r7, #8]
 800daea:	330b      	adds	r3, #11
 800daec:	781b      	ldrb	r3, [r3, #0]
 800daee:	2203      	movs	r2, #3
 800daf0:	4013      	ands	r3, r2
 800daf2:	b2da      	uxtb	r2, r3
	pdata->ana_config__ref_bg_ctrl =
 800daf4:	687b      	ldr	r3, [r7, #4]
 800daf6:	72da      	strb	r2, [r3, #11]
	pdata->ana_config__regdvdd1v2_ctrl =
		(*(pbuffer +  12)) & 0xF;
 800daf8:	68bb      	ldr	r3, [r7, #8]
 800dafa:	330c      	adds	r3, #12
 800dafc:	781b      	ldrb	r3, [r3, #0]
 800dafe:	220f      	movs	r2, #15
 800db00:	4013      	ands	r3, r2
 800db02:	b2da      	uxtb	r2, r3
	pdata->ana_config__regdvdd1v2_ctrl =
 800db04:	687b      	ldr	r3, [r7, #4]
 800db06:	731a      	strb	r2, [r3, #12]
	pdata->ana_config__osc_slow_ctrl =
		(*(pbuffer +  13)) & 0x7;
 800db08:	68bb      	ldr	r3, [r7, #8]
 800db0a:	330d      	adds	r3, #13
 800db0c:	781b      	ldrb	r3, [r3, #0]
 800db0e:	2207      	movs	r2, #7
 800db10:	4013      	ands	r3, r2
 800db12:	b2da      	uxtb	r2, r3
	pdata->ana_config__osc_slow_ctrl =
 800db14:	687b      	ldr	r3, [r7, #4]
 800db16:	735a      	strb	r2, [r3, #13]
	pdata->test_mode__status =
		(*(pbuffer +  14)) & 0x1;
 800db18:	68bb      	ldr	r3, [r7, #8]
 800db1a:	330e      	adds	r3, #14
 800db1c:	781b      	ldrb	r3, [r3, #0]
 800db1e:	2201      	movs	r2, #1
 800db20:	4013      	ands	r3, r2
 800db22:	b2da      	uxtb	r2, r3
	pdata->test_mode__status =
 800db24:	687b      	ldr	r3, [r7, #4]
 800db26:	739a      	strb	r2, [r3, #14]
	pdata->firmware__system_status =
		(*(pbuffer +  15)) & 0x3;
 800db28:	68bb      	ldr	r3, [r7, #8]
 800db2a:	330f      	adds	r3, #15
 800db2c:	781b      	ldrb	r3, [r3, #0]
 800db2e:	2203      	movs	r2, #3
 800db30:	4013      	ands	r3, r2
 800db32:	b2da      	uxtb	r2, r3
	pdata->firmware__system_status =
 800db34:	687b      	ldr	r3, [r7, #4]
 800db36:	73da      	strb	r2, [r3, #15]
	pdata->firmware__mode_status =
 800db38:	68bb      	ldr	r3, [r7, #8]
 800db3a:	7c1a      	ldrb	r2, [r3, #16]
 800db3c:	687b      	ldr	r3, [r7, #4]
 800db3e:	741a      	strb	r2, [r3, #16]
		(*(pbuffer +  16));
	pdata->firmware__secondary_mode_status =
 800db40:	68bb      	ldr	r3, [r7, #8]
 800db42:	7c5a      	ldrb	r2, [r3, #17]
 800db44:	687b      	ldr	r3, [r7, #4]
 800db46:	745a      	strb	r2, [r3, #17]
		(*(pbuffer +  17));
	pdata->firmware__cal_repeat_rate_counter =
		(VL53L1_i2c_decode_uint16_t(2, pbuffer +  18)) & 0xFFF;
 800db48:	68bb      	ldr	r3, [r7, #8]
 800db4a:	3312      	adds	r3, #18
 800db4c:	0019      	movs	r1, r3
 800db4e:	2002      	movs	r0, #2
 800db50:	f7fe fb12 	bl	800c178 <VL53L1_i2c_decode_uint16_t>
 800db54:	0003      	movs	r3, r0
 800db56:	051b      	lsls	r3, r3, #20
 800db58:	0d1b      	lsrs	r3, r3, #20
 800db5a:	b29a      	uxth	r2, r3
	pdata->firmware__cal_repeat_rate_counter =
 800db5c:	687b      	ldr	r3, [r7, #4]
 800db5e:	825a      	strh	r2, [r3, #18]
	pdata->gph__system__thresh_high =
		(VL53L1_i2c_decode_uint16_t(2, pbuffer +  22));
 800db60:	68bb      	ldr	r3, [r7, #8]
 800db62:	3316      	adds	r3, #22
 800db64:	0019      	movs	r1, r3
 800db66:	2002      	movs	r0, #2
 800db68:	f7fe fb06 	bl	800c178 <VL53L1_i2c_decode_uint16_t>
 800db6c:	0003      	movs	r3, r0
 800db6e:	001a      	movs	r2, r3
	pdata->gph__system__thresh_high =
 800db70:	687b      	ldr	r3, [r7, #4]
 800db72:	829a      	strh	r2, [r3, #20]
	pdata->gph__system__thresh_low =
		(VL53L1_i2c_decode_uint16_t(2, pbuffer +  24));
 800db74:	68bb      	ldr	r3, [r7, #8]
 800db76:	3318      	adds	r3, #24
 800db78:	0019      	movs	r1, r3
 800db7a:	2002      	movs	r0, #2
 800db7c:	f7fe fafc 	bl	800c178 <VL53L1_i2c_decode_uint16_t>
 800db80:	0003      	movs	r3, r0
 800db82:	001a      	movs	r2, r3
	pdata->gph__system__thresh_low =
 800db84:	687b      	ldr	r3, [r7, #4]
 800db86:	82da      	strh	r2, [r3, #22]
	pdata->gph__system__enable_xtalk_per_quadrant =
		(*(pbuffer +  26)) & 0x1;
 800db88:	68bb      	ldr	r3, [r7, #8]
 800db8a:	331a      	adds	r3, #26
 800db8c:	781b      	ldrb	r3, [r3, #0]
 800db8e:	2201      	movs	r2, #1
 800db90:	4013      	ands	r3, r2
 800db92:	b2da      	uxtb	r2, r3
	pdata->gph__system__enable_xtalk_per_quadrant =
 800db94:	687b      	ldr	r3, [r7, #4]
 800db96:	761a      	strb	r2, [r3, #24]
	pdata->gph__spare_0 =
		(*(pbuffer +  27)) & 0x7;
 800db98:	68bb      	ldr	r3, [r7, #8]
 800db9a:	331b      	adds	r3, #27
 800db9c:	781b      	ldrb	r3, [r3, #0]
 800db9e:	2207      	movs	r2, #7
 800dba0:	4013      	ands	r3, r2
 800dba2:	b2da      	uxtb	r2, r3
	pdata->gph__spare_0 =
 800dba4:	687b      	ldr	r3, [r7, #4]
 800dba6:	765a      	strb	r2, [r3, #25]
	pdata->gph__sd_config__woi_sd0 =
 800dba8:	68bb      	ldr	r3, [r7, #8]
 800dbaa:	7f1a      	ldrb	r2, [r3, #28]
 800dbac:	687b      	ldr	r3, [r7, #4]
 800dbae:	769a      	strb	r2, [r3, #26]
		(*(pbuffer +  28));
	pdata->gph__sd_config__woi_sd1 =
 800dbb0:	68bb      	ldr	r3, [r7, #8]
 800dbb2:	7f5a      	ldrb	r2, [r3, #29]
 800dbb4:	687b      	ldr	r3, [r7, #4]
 800dbb6:	76da      	strb	r2, [r3, #27]
		(*(pbuffer +  29));
	pdata->gph__sd_config__initial_phase_sd0 =
		(*(pbuffer +  30)) & 0x7F;
 800dbb8:	68bb      	ldr	r3, [r7, #8]
 800dbba:	331e      	adds	r3, #30
 800dbbc:	781b      	ldrb	r3, [r3, #0]
 800dbbe:	227f      	movs	r2, #127	; 0x7f
 800dbc0:	4013      	ands	r3, r2
 800dbc2:	b2da      	uxtb	r2, r3
	pdata->gph__sd_config__initial_phase_sd0 =
 800dbc4:	687b      	ldr	r3, [r7, #4]
 800dbc6:	771a      	strb	r2, [r3, #28]
	pdata->gph__sd_config__initial_phase_sd1 =
		(*(pbuffer +  31)) & 0x7F;
 800dbc8:	68bb      	ldr	r3, [r7, #8]
 800dbca:	331f      	adds	r3, #31
 800dbcc:	781b      	ldrb	r3, [r3, #0]
 800dbce:	227f      	movs	r2, #127	; 0x7f
 800dbd0:	4013      	ands	r3, r2
 800dbd2:	b2da      	uxtb	r2, r3
	pdata->gph__sd_config__initial_phase_sd1 =
 800dbd4:	687b      	ldr	r3, [r7, #4]
 800dbd6:	775a      	strb	r2, [r3, #29]
	pdata->gph__sd_config__first_order_select =
		(*(pbuffer +  32)) & 0x3;
 800dbd8:	68bb      	ldr	r3, [r7, #8]
 800dbda:	3320      	adds	r3, #32
 800dbdc:	781b      	ldrb	r3, [r3, #0]
 800dbde:	2203      	movs	r2, #3
 800dbe0:	4013      	ands	r3, r2
 800dbe2:	b2da      	uxtb	r2, r3
	pdata->gph__sd_config__first_order_select =
 800dbe4:	687b      	ldr	r3, [r7, #4]
 800dbe6:	779a      	strb	r2, [r3, #30]
	pdata->gph__sd_config__quantifier =
		(*(pbuffer +  33)) & 0xF;
 800dbe8:	68bb      	ldr	r3, [r7, #8]
 800dbea:	3321      	adds	r3, #33	; 0x21
 800dbec:	781b      	ldrb	r3, [r3, #0]
 800dbee:	220f      	movs	r2, #15
 800dbf0:	4013      	ands	r3, r2
 800dbf2:	b2da      	uxtb	r2, r3
	pdata->gph__sd_config__quantifier =
 800dbf4:	687b      	ldr	r3, [r7, #4]
 800dbf6:	77da      	strb	r2, [r3, #31]
	pdata->gph__roi_config__user_roi_centre_spad =
 800dbf8:	68bb      	ldr	r3, [r7, #8]
 800dbfa:	2222      	movs	r2, #34	; 0x22
 800dbfc:	5c99      	ldrb	r1, [r3, r2]
 800dbfe:	687b      	ldr	r3, [r7, #4]
 800dc00:	2220      	movs	r2, #32
 800dc02:	5499      	strb	r1, [r3, r2]
		(*(pbuffer +  34));
	pdata->gph__roi_config__user_roi_requested_global_xy_size =
 800dc04:	68bb      	ldr	r3, [r7, #8]
 800dc06:	2223      	movs	r2, #35	; 0x23
 800dc08:	5c99      	ldrb	r1, [r3, r2]
 800dc0a:	687b      	ldr	r3, [r7, #4]
 800dc0c:	2221      	movs	r2, #33	; 0x21
 800dc0e:	5499      	strb	r1, [r3, r2]
		(*(pbuffer +  35));
	pdata->gph__system__sequence_config =
 800dc10:	68bb      	ldr	r3, [r7, #8]
 800dc12:	2224      	movs	r2, #36	; 0x24
 800dc14:	5c99      	ldrb	r1, [r3, r2]
 800dc16:	687b      	ldr	r3, [r7, #4]
 800dc18:	2222      	movs	r2, #34	; 0x22
 800dc1a:	5499      	strb	r1, [r3, r2]
		(*(pbuffer +  36));
	pdata->gph__gph_id =
		(*(pbuffer +  37)) & 0x1;
 800dc1c:	68bb      	ldr	r3, [r7, #8]
 800dc1e:	3325      	adds	r3, #37	; 0x25
 800dc20:	781b      	ldrb	r3, [r3, #0]
 800dc22:	2201      	movs	r2, #1
 800dc24:	4013      	ands	r3, r2
 800dc26:	b2d9      	uxtb	r1, r3
	pdata->gph__gph_id =
 800dc28:	687b      	ldr	r3, [r7, #4]
 800dc2a:	2223      	movs	r2, #35	; 0x23
 800dc2c:	5499      	strb	r1, [r3, r2]
	pdata->system__interrupt_set =
		(*(pbuffer +  38)) & 0x3;
 800dc2e:	68bb      	ldr	r3, [r7, #8]
 800dc30:	3326      	adds	r3, #38	; 0x26
 800dc32:	781b      	ldrb	r3, [r3, #0]
 800dc34:	2203      	movs	r2, #3
 800dc36:	4013      	ands	r3, r2
 800dc38:	b2d9      	uxtb	r1, r3
	pdata->system__interrupt_set =
 800dc3a:	687b      	ldr	r3, [r7, #4]
 800dc3c:	2224      	movs	r2, #36	; 0x24
 800dc3e:	5499      	strb	r1, [r3, r2]
	pdata->interrupt_manager__enables =
		(*(pbuffer +  39)) & 0x1F;
 800dc40:	68bb      	ldr	r3, [r7, #8]
 800dc42:	3327      	adds	r3, #39	; 0x27
 800dc44:	781b      	ldrb	r3, [r3, #0]
 800dc46:	221f      	movs	r2, #31
 800dc48:	4013      	ands	r3, r2
 800dc4a:	b2d9      	uxtb	r1, r3
	pdata->interrupt_manager__enables =
 800dc4c:	687b      	ldr	r3, [r7, #4]
 800dc4e:	2225      	movs	r2, #37	; 0x25
 800dc50:	5499      	strb	r1, [r3, r2]
	pdata->interrupt_manager__clear =
		(*(pbuffer +  40)) & 0x1F;
 800dc52:	68bb      	ldr	r3, [r7, #8]
 800dc54:	3328      	adds	r3, #40	; 0x28
 800dc56:	781b      	ldrb	r3, [r3, #0]
 800dc58:	221f      	movs	r2, #31
 800dc5a:	4013      	ands	r3, r2
 800dc5c:	b2d9      	uxtb	r1, r3
	pdata->interrupt_manager__clear =
 800dc5e:	687b      	ldr	r3, [r7, #4]
 800dc60:	2226      	movs	r2, #38	; 0x26
 800dc62:	5499      	strb	r1, [r3, r2]
	pdata->interrupt_manager__status =
		(*(pbuffer +  41)) & 0x1F;
 800dc64:	68bb      	ldr	r3, [r7, #8]
 800dc66:	3329      	adds	r3, #41	; 0x29
 800dc68:	781b      	ldrb	r3, [r3, #0]
 800dc6a:	221f      	movs	r2, #31
 800dc6c:	4013      	ands	r3, r2
 800dc6e:	b2d9      	uxtb	r1, r3
	pdata->interrupt_manager__status =
 800dc70:	687b      	ldr	r3, [r7, #4]
 800dc72:	2227      	movs	r2, #39	; 0x27
 800dc74:	5499      	strb	r1, [r3, r2]
	pdata->mcu_to_host_bank__wr_access_en =
		(*(pbuffer +  42)) & 0x1;
 800dc76:	68bb      	ldr	r3, [r7, #8]
 800dc78:	332a      	adds	r3, #42	; 0x2a
 800dc7a:	781b      	ldrb	r3, [r3, #0]
 800dc7c:	2201      	movs	r2, #1
 800dc7e:	4013      	ands	r3, r2
 800dc80:	b2d9      	uxtb	r1, r3
	pdata->mcu_to_host_bank__wr_access_en =
 800dc82:	687b      	ldr	r3, [r7, #4]
 800dc84:	2228      	movs	r2, #40	; 0x28
 800dc86:	5499      	strb	r1, [r3, r2]
	pdata->power_management__go1_reset_status =
		(*(pbuffer +  43)) & 0x1;
 800dc88:	68bb      	ldr	r3, [r7, #8]
 800dc8a:	332b      	adds	r3, #43	; 0x2b
 800dc8c:	781b      	ldrb	r3, [r3, #0]
 800dc8e:	2201      	movs	r2, #1
 800dc90:	4013      	ands	r3, r2
 800dc92:	b2d9      	uxtb	r1, r3
	pdata->power_management__go1_reset_status =
 800dc94:	687b      	ldr	r3, [r7, #4]
 800dc96:	2229      	movs	r2, #41	; 0x29
 800dc98:	5499      	strb	r1, [r3, r2]
	pdata->pad_startup_mode__value_ro =
		(*(pbuffer +  44)) & 0x3;
 800dc9a:	68bb      	ldr	r3, [r7, #8]
 800dc9c:	332c      	adds	r3, #44	; 0x2c
 800dc9e:	781b      	ldrb	r3, [r3, #0]
 800dca0:	2203      	movs	r2, #3
 800dca2:	4013      	ands	r3, r2
 800dca4:	b2d9      	uxtb	r1, r3
	pdata->pad_startup_mode__value_ro =
 800dca6:	687b      	ldr	r3, [r7, #4]
 800dca8:	222a      	movs	r2, #42	; 0x2a
 800dcaa:	5499      	strb	r1, [r3, r2]
	pdata->pad_startup_mode__value_ctrl =
		(*(pbuffer +  45)) & 0x3F;
 800dcac:	68bb      	ldr	r3, [r7, #8]
 800dcae:	332d      	adds	r3, #45	; 0x2d
 800dcb0:	781b      	ldrb	r3, [r3, #0]
 800dcb2:	223f      	movs	r2, #63	; 0x3f
 800dcb4:	4013      	ands	r3, r2
 800dcb6:	b2d9      	uxtb	r1, r3
	pdata->pad_startup_mode__value_ctrl =
 800dcb8:	687b      	ldr	r3, [r7, #4]
 800dcba:	222b      	movs	r2, #43	; 0x2b
 800dcbc:	5499      	strb	r1, [r3, r2]
	pdata->pll_period_us =
		(VL53L1_i2c_decode_uint32_t(4, pbuffer +  46)) & 0x3FFFF;
 800dcbe:	68bb      	ldr	r3, [r7, #8]
 800dcc0:	332e      	adds	r3, #46	; 0x2e
 800dcc2:	0019      	movs	r1, r3
 800dcc4:	2004      	movs	r0, #4
 800dcc6:	f7fe fb26 	bl	800c316 <VL53L1_i2c_decode_uint32_t>
 800dcca:	0003      	movs	r3, r0
 800dccc:	039b      	lsls	r3, r3, #14
 800dcce:	0b9a      	lsrs	r2, r3, #14
	pdata->pll_period_us =
 800dcd0:	687b      	ldr	r3, [r7, #4]
 800dcd2:	62da      	str	r2, [r3, #44]	; 0x2c
	pdata->interrupt_scheduler__data_out =
		(VL53L1_i2c_decode_uint32_t(4, pbuffer +  50));
 800dcd4:	68bb      	ldr	r3, [r7, #8]
 800dcd6:	3332      	adds	r3, #50	; 0x32
 800dcd8:	0019      	movs	r1, r3
 800dcda:	2004      	movs	r0, #4
 800dcdc:	f7fe fb1b 	bl	800c316 <VL53L1_i2c_decode_uint32_t>
 800dce0:	0002      	movs	r2, r0
	pdata->interrupt_scheduler__data_out =
 800dce2:	687b      	ldr	r3, [r7, #4]
 800dce4:	631a      	str	r2, [r3, #48]	; 0x30
	pdata->nvm_bist__complete =
		(*(pbuffer +  54)) & 0x1;
 800dce6:	68bb      	ldr	r3, [r7, #8]
 800dce8:	3336      	adds	r3, #54	; 0x36
 800dcea:	781b      	ldrb	r3, [r3, #0]
 800dcec:	2201      	movs	r2, #1
 800dcee:	4013      	ands	r3, r2
 800dcf0:	b2d9      	uxtb	r1, r3
	pdata->nvm_bist__complete =
 800dcf2:	687b      	ldr	r3, [r7, #4]
 800dcf4:	2234      	movs	r2, #52	; 0x34
 800dcf6:	5499      	strb	r1, [r3, r2]
	pdata->nvm_bist__status =
		(*(pbuffer +  55)) & 0x1;
 800dcf8:	68bb      	ldr	r3, [r7, #8]
 800dcfa:	3337      	adds	r3, #55	; 0x37
 800dcfc:	781b      	ldrb	r3, [r3, #0]
 800dcfe:	2201      	movs	r2, #1
 800dd00:	4013      	ands	r3, r2
 800dd02:	b2d9      	uxtb	r1, r3
	pdata->nvm_bist__status =
 800dd04:	687b      	ldr	r3, [r7, #4]
 800dd06:	2235      	movs	r2, #53	; 0x35
 800dd08:	5499      	strb	r1, [r3, r2]

	LOG_FUNCTION_END(status);

	return status;
 800dd0a:	2317      	movs	r3, #23
 800dd0c:	18fb      	adds	r3, r7, r3
 800dd0e:	781b      	ldrb	r3, [r3, #0]
 800dd10:	b25b      	sxtb	r3, r3
}
 800dd12:	0018      	movs	r0, r3
 800dd14:	46bd      	mov	sp, r7
 800dd16:	b006      	add	sp, #24
 800dd18:	bd80      	pop	{r7, pc}

0800dd1a <VL53L1_i2c_decode_nvm_copy_data>:

VL53L1_Error VL53L1_i2c_decode_nvm_copy_data(
	uint16_t                   buf_size,
	uint8_t                   *pbuffer,
	VL53L1_nvm_copy_data_t    *pdata)
{
 800dd1a:	b580      	push	{r7, lr}
 800dd1c:	b086      	sub	sp, #24
 800dd1e:	af00      	add	r7, sp, #0
 800dd20:	60b9      	str	r1, [r7, #8]
 800dd22:	607a      	str	r2, [r7, #4]
 800dd24:	210e      	movs	r1, #14
 800dd26:	187b      	adds	r3, r7, r1
 800dd28:	1c02      	adds	r2, r0, #0
 800dd2a:	801a      	strh	r2, [r3, #0]
	/**
	 * Decodes data structure VL53L1_nvm_copy_data_t from the input I2C read buffer
	 * Buffer must be at least 49 bytes
	*/

	VL53L1_Error status = VL53L1_ERROR_NONE;
 800dd2c:	2317      	movs	r3, #23
 800dd2e:	18fb      	adds	r3, r7, r3
 800dd30:	2200      	movs	r2, #0
 800dd32:	701a      	strb	r2, [r3, #0]

	LOG_FUNCTION_START("");

	if (VL53L1_NVM_COPY_DATA_I2C_SIZE_BYTES > buf_size)
 800dd34:	187b      	adds	r3, r7, r1
 800dd36:	881b      	ldrh	r3, [r3, #0]
 800dd38:	2b30      	cmp	r3, #48	; 0x30
 800dd3a:	d802      	bhi.n	800dd42 <VL53L1_i2c_decode_nvm_copy_data+0x28>
		return VL53L1_ERROR_COMMS_BUFFER_TOO_SMALL;
 800dd3c:	230a      	movs	r3, #10
 800dd3e:	425b      	negs	r3, r3
 800dd40:	e114      	b.n	800df6c <VL53L1_i2c_decode_nvm_copy_data+0x252>

	pdata->identification__model_id =
		(*(pbuffer +   0));
 800dd42:	68bb      	ldr	r3, [r7, #8]
 800dd44:	781a      	ldrb	r2, [r3, #0]
	pdata->identification__model_id =
 800dd46:	687b      	ldr	r3, [r7, #4]
 800dd48:	701a      	strb	r2, [r3, #0]
	pdata->identification__module_type =
 800dd4a:	68bb      	ldr	r3, [r7, #8]
 800dd4c:	785a      	ldrb	r2, [r3, #1]
 800dd4e:	687b      	ldr	r3, [r7, #4]
 800dd50:	705a      	strb	r2, [r3, #1]
		(*(pbuffer +   1));
	pdata->identification__revision_id =
 800dd52:	68bb      	ldr	r3, [r7, #8]
 800dd54:	789a      	ldrb	r2, [r3, #2]
 800dd56:	687b      	ldr	r3, [r7, #4]
 800dd58:	709a      	strb	r2, [r3, #2]
		(*(pbuffer +   2));
	pdata->identification__module_id =
		(VL53L1_i2c_decode_uint16_t(2, pbuffer +   3));
 800dd5a:	68bb      	ldr	r3, [r7, #8]
 800dd5c:	3303      	adds	r3, #3
 800dd5e:	0019      	movs	r1, r3
 800dd60:	2002      	movs	r0, #2
 800dd62:	f7fe fa09 	bl	800c178 <VL53L1_i2c_decode_uint16_t>
 800dd66:	0003      	movs	r3, r0
 800dd68:	001a      	movs	r2, r3
	pdata->identification__module_id =
 800dd6a:	687b      	ldr	r3, [r7, #4]
 800dd6c:	809a      	strh	r2, [r3, #4]
	pdata->ana_config__fast_osc__trim_max =
		(*(pbuffer +   5)) & 0x7F;
 800dd6e:	68bb      	ldr	r3, [r7, #8]
 800dd70:	3305      	adds	r3, #5
 800dd72:	781b      	ldrb	r3, [r3, #0]
 800dd74:	227f      	movs	r2, #127	; 0x7f
 800dd76:	4013      	ands	r3, r2
 800dd78:	b2da      	uxtb	r2, r3
	pdata->ana_config__fast_osc__trim_max =
 800dd7a:	687b      	ldr	r3, [r7, #4]
 800dd7c:	719a      	strb	r2, [r3, #6]
	pdata->ana_config__fast_osc__freq_set =
		(*(pbuffer +   6)) & 0x7;
 800dd7e:	68bb      	ldr	r3, [r7, #8]
 800dd80:	3306      	adds	r3, #6
 800dd82:	781b      	ldrb	r3, [r3, #0]
 800dd84:	2207      	movs	r2, #7
 800dd86:	4013      	ands	r3, r2
 800dd88:	b2da      	uxtb	r2, r3
	pdata->ana_config__fast_osc__freq_set =
 800dd8a:	687b      	ldr	r3, [r7, #4]
 800dd8c:	71da      	strb	r2, [r3, #7]
	pdata->ana_config__vcsel_trim =
		(*(pbuffer +   7)) & 0x7;
 800dd8e:	68bb      	ldr	r3, [r7, #8]
 800dd90:	3307      	adds	r3, #7
 800dd92:	781b      	ldrb	r3, [r3, #0]
 800dd94:	2207      	movs	r2, #7
 800dd96:	4013      	ands	r3, r2
 800dd98:	b2da      	uxtb	r2, r3
	pdata->ana_config__vcsel_trim =
 800dd9a:	687b      	ldr	r3, [r7, #4]
 800dd9c:	721a      	strb	r2, [r3, #8]
	pdata->ana_config__vcsel_selion =
		(*(pbuffer +   8)) & 0x3F;
 800dd9e:	68bb      	ldr	r3, [r7, #8]
 800dda0:	3308      	adds	r3, #8
 800dda2:	781b      	ldrb	r3, [r3, #0]
 800dda4:	223f      	movs	r2, #63	; 0x3f
 800dda6:	4013      	ands	r3, r2
 800dda8:	b2da      	uxtb	r2, r3
	pdata->ana_config__vcsel_selion =
 800ddaa:	687b      	ldr	r3, [r7, #4]
 800ddac:	725a      	strb	r2, [r3, #9]
	pdata->ana_config__vcsel_selion_max =
		(*(pbuffer +   9)) & 0x3F;
 800ddae:	68bb      	ldr	r3, [r7, #8]
 800ddb0:	3309      	adds	r3, #9
 800ddb2:	781b      	ldrb	r3, [r3, #0]
 800ddb4:	223f      	movs	r2, #63	; 0x3f
 800ddb6:	4013      	ands	r3, r2
 800ddb8:	b2da      	uxtb	r2, r3
	pdata->ana_config__vcsel_selion_max =
 800ddba:	687b      	ldr	r3, [r7, #4]
 800ddbc:	729a      	strb	r2, [r3, #10]
	pdata->protected_laser_safety__lock_bit =
		(*(pbuffer +  10)) & 0x1;
 800ddbe:	68bb      	ldr	r3, [r7, #8]
 800ddc0:	330a      	adds	r3, #10
 800ddc2:	781b      	ldrb	r3, [r3, #0]
 800ddc4:	2201      	movs	r2, #1
 800ddc6:	4013      	ands	r3, r2
 800ddc8:	b2da      	uxtb	r2, r3
	pdata->protected_laser_safety__lock_bit =
 800ddca:	687b      	ldr	r3, [r7, #4]
 800ddcc:	72da      	strb	r2, [r3, #11]
	pdata->laser_safety__key =
		(*(pbuffer +  11)) & 0x7F;
 800ddce:	68bb      	ldr	r3, [r7, #8]
 800ddd0:	330b      	adds	r3, #11
 800ddd2:	781b      	ldrb	r3, [r3, #0]
 800ddd4:	227f      	movs	r2, #127	; 0x7f
 800ddd6:	4013      	ands	r3, r2
 800ddd8:	b2da      	uxtb	r2, r3
	pdata->laser_safety__key =
 800ddda:	687b      	ldr	r3, [r7, #4]
 800dddc:	731a      	strb	r2, [r3, #12]
	pdata->laser_safety__key_ro =
		(*(pbuffer +  12)) & 0x1;
 800ddde:	68bb      	ldr	r3, [r7, #8]
 800dde0:	330c      	adds	r3, #12
 800dde2:	781b      	ldrb	r3, [r3, #0]
 800dde4:	2201      	movs	r2, #1
 800dde6:	4013      	ands	r3, r2
 800dde8:	b2da      	uxtb	r2, r3
	pdata->laser_safety__key_ro =
 800ddea:	687b      	ldr	r3, [r7, #4]
 800ddec:	735a      	strb	r2, [r3, #13]
	pdata->laser_safety__clip =
		(*(pbuffer +  13)) & 0x3F;
 800ddee:	68bb      	ldr	r3, [r7, #8]
 800ddf0:	330d      	adds	r3, #13
 800ddf2:	781b      	ldrb	r3, [r3, #0]
 800ddf4:	223f      	movs	r2, #63	; 0x3f
 800ddf6:	4013      	ands	r3, r2
 800ddf8:	b2da      	uxtb	r2, r3
	pdata->laser_safety__clip =
 800ddfa:	687b      	ldr	r3, [r7, #4]
 800ddfc:	739a      	strb	r2, [r3, #14]
	pdata->laser_safety__mult =
		(*(pbuffer +  14)) & 0x3F;
 800ddfe:	68bb      	ldr	r3, [r7, #8]
 800de00:	330e      	adds	r3, #14
 800de02:	781b      	ldrb	r3, [r3, #0]
 800de04:	223f      	movs	r2, #63	; 0x3f
 800de06:	4013      	ands	r3, r2
 800de08:	b2da      	uxtb	r2, r3
	pdata->laser_safety__mult =
 800de0a:	687b      	ldr	r3, [r7, #4]
 800de0c:	73da      	strb	r2, [r3, #15]
	pdata->global_config__spad_enables_rtn_0 =
 800de0e:	68bb      	ldr	r3, [r7, #8]
 800de10:	7bda      	ldrb	r2, [r3, #15]
 800de12:	687b      	ldr	r3, [r7, #4]
 800de14:	741a      	strb	r2, [r3, #16]
		(*(pbuffer +  15));
	pdata->global_config__spad_enables_rtn_1 =
 800de16:	68bb      	ldr	r3, [r7, #8]
 800de18:	7c1a      	ldrb	r2, [r3, #16]
 800de1a:	687b      	ldr	r3, [r7, #4]
 800de1c:	745a      	strb	r2, [r3, #17]
		(*(pbuffer +  16));
	pdata->global_config__spad_enables_rtn_2 =
 800de1e:	68bb      	ldr	r3, [r7, #8]
 800de20:	7c5a      	ldrb	r2, [r3, #17]
 800de22:	687b      	ldr	r3, [r7, #4]
 800de24:	749a      	strb	r2, [r3, #18]
		(*(pbuffer +  17));
	pdata->global_config__spad_enables_rtn_3 =
 800de26:	68bb      	ldr	r3, [r7, #8]
 800de28:	7c9a      	ldrb	r2, [r3, #18]
 800de2a:	687b      	ldr	r3, [r7, #4]
 800de2c:	74da      	strb	r2, [r3, #19]
		(*(pbuffer +  18));
	pdata->global_config__spad_enables_rtn_4 =
 800de2e:	68bb      	ldr	r3, [r7, #8]
 800de30:	7cda      	ldrb	r2, [r3, #19]
 800de32:	687b      	ldr	r3, [r7, #4]
 800de34:	751a      	strb	r2, [r3, #20]
		(*(pbuffer +  19));
	pdata->global_config__spad_enables_rtn_5 =
 800de36:	68bb      	ldr	r3, [r7, #8]
 800de38:	7d1a      	ldrb	r2, [r3, #20]
 800de3a:	687b      	ldr	r3, [r7, #4]
 800de3c:	755a      	strb	r2, [r3, #21]
		(*(pbuffer +  20));
	pdata->global_config__spad_enables_rtn_6 =
 800de3e:	68bb      	ldr	r3, [r7, #8]
 800de40:	7d5a      	ldrb	r2, [r3, #21]
 800de42:	687b      	ldr	r3, [r7, #4]
 800de44:	759a      	strb	r2, [r3, #22]
		(*(pbuffer +  21));
	pdata->global_config__spad_enables_rtn_7 =
 800de46:	68bb      	ldr	r3, [r7, #8]
 800de48:	7d9a      	ldrb	r2, [r3, #22]
 800de4a:	687b      	ldr	r3, [r7, #4]
 800de4c:	75da      	strb	r2, [r3, #23]
		(*(pbuffer +  22));
	pdata->global_config__spad_enables_rtn_8 =
 800de4e:	68bb      	ldr	r3, [r7, #8]
 800de50:	7dda      	ldrb	r2, [r3, #23]
 800de52:	687b      	ldr	r3, [r7, #4]
 800de54:	761a      	strb	r2, [r3, #24]
		(*(pbuffer +  23));
	pdata->global_config__spad_enables_rtn_9 =
 800de56:	68bb      	ldr	r3, [r7, #8]
 800de58:	7e1a      	ldrb	r2, [r3, #24]
 800de5a:	687b      	ldr	r3, [r7, #4]
 800de5c:	765a      	strb	r2, [r3, #25]
		(*(pbuffer +  24));
	pdata->global_config__spad_enables_rtn_10 =
 800de5e:	68bb      	ldr	r3, [r7, #8]
 800de60:	7e5a      	ldrb	r2, [r3, #25]
 800de62:	687b      	ldr	r3, [r7, #4]
 800de64:	769a      	strb	r2, [r3, #26]
		(*(pbuffer +  25));
	pdata->global_config__spad_enables_rtn_11 =
 800de66:	68bb      	ldr	r3, [r7, #8]
 800de68:	7e9a      	ldrb	r2, [r3, #26]
 800de6a:	687b      	ldr	r3, [r7, #4]
 800de6c:	76da      	strb	r2, [r3, #27]
		(*(pbuffer +  26));
	pdata->global_config__spad_enables_rtn_12 =
 800de6e:	68bb      	ldr	r3, [r7, #8]
 800de70:	7eda      	ldrb	r2, [r3, #27]
 800de72:	687b      	ldr	r3, [r7, #4]
 800de74:	771a      	strb	r2, [r3, #28]
		(*(pbuffer +  27));
	pdata->global_config__spad_enables_rtn_13 =
 800de76:	68bb      	ldr	r3, [r7, #8]
 800de78:	7f1a      	ldrb	r2, [r3, #28]
 800de7a:	687b      	ldr	r3, [r7, #4]
 800de7c:	775a      	strb	r2, [r3, #29]
		(*(pbuffer +  28));
	pdata->global_config__spad_enables_rtn_14 =
 800de7e:	68bb      	ldr	r3, [r7, #8]
 800de80:	7f5a      	ldrb	r2, [r3, #29]
 800de82:	687b      	ldr	r3, [r7, #4]
 800de84:	779a      	strb	r2, [r3, #30]
		(*(pbuffer +  29));
	pdata->global_config__spad_enables_rtn_15 =
 800de86:	68bb      	ldr	r3, [r7, #8]
 800de88:	7f9a      	ldrb	r2, [r3, #30]
 800de8a:	687b      	ldr	r3, [r7, #4]
 800de8c:	77da      	strb	r2, [r3, #31]
		(*(pbuffer +  30));
	pdata->global_config__spad_enables_rtn_16 =
 800de8e:	68bb      	ldr	r3, [r7, #8]
 800de90:	7fd9      	ldrb	r1, [r3, #31]
 800de92:	687b      	ldr	r3, [r7, #4]
 800de94:	2220      	movs	r2, #32
 800de96:	5499      	strb	r1, [r3, r2]
		(*(pbuffer +  31));
	pdata->global_config__spad_enables_rtn_17 =
 800de98:	68bb      	ldr	r3, [r7, #8]
 800de9a:	2220      	movs	r2, #32
 800de9c:	5c99      	ldrb	r1, [r3, r2]
 800de9e:	687b      	ldr	r3, [r7, #4]
 800dea0:	2221      	movs	r2, #33	; 0x21
 800dea2:	5499      	strb	r1, [r3, r2]
		(*(pbuffer +  32));
	pdata->global_config__spad_enables_rtn_18 =
 800dea4:	68bb      	ldr	r3, [r7, #8]
 800dea6:	2221      	movs	r2, #33	; 0x21
 800dea8:	5c99      	ldrb	r1, [r3, r2]
 800deaa:	687b      	ldr	r3, [r7, #4]
 800deac:	2222      	movs	r2, #34	; 0x22
 800deae:	5499      	strb	r1, [r3, r2]
		(*(pbuffer +  33));
	pdata->global_config__spad_enables_rtn_19 =
 800deb0:	68bb      	ldr	r3, [r7, #8]
 800deb2:	2222      	movs	r2, #34	; 0x22
 800deb4:	5c99      	ldrb	r1, [r3, r2]
 800deb6:	687b      	ldr	r3, [r7, #4]
 800deb8:	2223      	movs	r2, #35	; 0x23
 800deba:	5499      	strb	r1, [r3, r2]
		(*(pbuffer +  34));
	pdata->global_config__spad_enables_rtn_20 =
 800debc:	68bb      	ldr	r3, [r7, #8]
 800debe:	2223      	movs	r2, #35	; 0x23
 800dec0:	5c99      	ldrb	r1, [r3, r2]
 800dec2:	687b      	ldr	r3, [r7, #4]
 800dec4:	2224      	movs	r2, #36	; 0x24
 800dec6:	5499      	strb	r1, [r3, r2]
		(*(pbuffer +  35));
	pdata->global_config__spad_enables_rtn_21 =
 800dec8:	68bb      	ldr	r3, [r7, #8]
 800deca:	2224      	movs	r2, #36	; 0x24
 800decc:	5c99      	ldrb	r1, [r3, r2]
 800dece:	687b      	ldr	r3, [r7, #4]
 800ded0:	2225      	movs	r2, #37	; 0x25
 800ded2:	5499      	strb	r1, [r3, r2]
		(*(pbuffer +  36));
	pdata->global_config__spad_enables_rtn_22 =
 800ded4:	68bb      	ldr	r3, [r7, #8]
 800ded6:	2225      	movs	r2, #37	; 0x25
 800ded8:	5c99      	ldrb	r1, [r3, r2]
 800deda:	687b      	ldr	r3, [r7, #4]
 800dedc:	2226      	movs	r2, #38	; 0x26
 800dede:	5499      	strb	r1, [r3, r2]
		(*(pbuffer +  37));
	pdata->global_config__spad_enables_rtn_23 =
 800dee0:	68bb      	ldr	r3, [r7, #8]
 800dee2:	2226      	movs	r2, #38	; 0x26
 800dee4:	5c99      	ldrb	r1, [r3, r2]
 800dee6:	687b      	ldr	r3, [r7, #4]
 800dee8:	2227      	movs	r2, #39	; 0x27
 800deea:	5499      	strb	r1, [r3, r2]
		(*(pbuffer +  38));
	pdata->global_config__spad_enables_rtn_24 =
 800deec:	68bb      	ldr	r3, [r7, #8]
 800deee:	2227      	movs	r2, #39	; 0x27
 800def0:	5c99      	ldrb	r1, [r3, r2]
 800def2:	687b      	ldr	r3, [r7, #4]
 800def4:	2228      	movs	r2, #40	; 0x28
 800def6:	5499      	strb	r1, [r3, r2]
		(*(pbuffer +  39));
	pdata->global_config__spad_enables_rtn_25 =
 800def8:	68bb      	ldr	r3, [r7, #8]
 800defa:	2228      	movs	r2, #40	; 0x28
 800defc:	5c99      	ldrb	r1, [r3, r2]
 800defe:	687b      	ldr	r3, [r7, #4]
 800df00:	2229      	movs	r2, #41	; 0x29
 800df02:	5499      	strb	r1, [r3, r2]
		(*(pbuffer +  40));
	pdata->global_config__spad_enables_rtn_26 =
 800df04:	68bb      	ldr	r3, [r7, #8]
 800df06:	2229      	movs	r2, #41	; 0x29
 800df08:	5c99      	ldrb	r1, [r3, r2]
 800df0a:	687b      	ldr	r3, [r7, #4]
 800df0c:	222a      	movs	r2, #42	; 0x2a
 800df0e:	5499      	strb	r1, [r3, r2]
		(*(pbuffer +  41));
	pdata->global_config__spad_enables_rtn_27 =
 800df10:	68bb      	ldr	r3, [r7, #8]
 800df12:	222a      	movs	r2, #42	; 0x2a
 800df14:	5c99      	ldrb	r1, [r3, r2]
 800df16:	687b      	ldr	r3, [r7, #4]
 800df18:	222b      	movs	r2, #43	; 0x2b
 800df1a:	5499      	strb	r1, [r3, r2]
		(*(pbuffer +  42));
	pdata->global_config__spad_enables_rtn_28 =
 800df1c:	68bb      	ldr	r3, [r7, #8]
 800df1e:	222b      	movs	r2, #43	; 0x2b
 800df20:	5c99      	ldrb	r1, [r3, r2]
 800df22:	687b      	ldr	r3, [r7, #4]
 800df24:	222c      	movs	r2, #44	; 0x2c
 800df26:	5499      	strb	r1, [r3, r2]
		(*(pbuffer +  43));
	pdata->global_config__spad_enables_rtn_29 =
 800df28:	68bb      	ldr	r3, [r7, #8]
 800df2a:	222c      	movs	r2, #44	; 0x2c
 800df2c:	5c99      	ldrb	r1, [r3, r2]
 800df2e:	687b      	ldr	r3, [r7, #4]
 800df30:	222d      	movs	r2, #45	; 0x2d
 800df32:	5499      	strb	r1, [r3, r2]
		(*(pbuffer +  44));
	pdata->global_config__spad_enables_rtn_30 =
 800df34:	68bb      	ldr	r3, [r7, #8]
 800df36:	222d      	movs	r2, #45	; 0x2d
 800df38:	5c99      	ldrb	r1, [r3, r2]
 800df3a:	687b      	ldr	r3, [r7, #4]
 800df3c:	222e      	movs	r2, #46	; 0x2e
 800df3e:	5499      	strb	r1, [r3, r2]
		(*(pbuffer +  45));
	pdata->global_config__spad_enables_rtn_31 =
 800df40:	68bb      	ldr	r3, [r7, #8]
 800df42:	222e      	movs	r2, #46	; 0x2e
 800df44:	5c99      	ldrb	r1, [r3, r2]
 800df46:	687b      	ldr	r3, [r7, #4]
 800df48:	222f      	movs	r2, #47	; 0x2f
 800df4a:	5499      	strb	r1, [r3, r2]
		(*(pbuffer +  46));
	pdata->roi_config__mode_roi_centre_spad =
 800df4c:	68bb      	ldr	r3, [r7, #8]
 800df4e:	222f      	movs	r2, #47	; 0x2f
 800df50:	5c99      	ldrb	r1, [r3, r2]
 800df52:	687b      	ldr	r3, [r7, #4]
 800df54:	2230      	movs	r2, #48	; 0x30
 800df56:	5499      	strb	r1, [r3, r2]
		(*(pbuffer +  47));
	pdata->roi_config__mode_roi_xy_size =
 800df58:	68bb      	ldr	r3, [r7, #8]
 800df5a:	2230      	movs	r2, #48	; 0x30
 800df5c:	5c99      	ldrb	r1, [r3, r2]
 800df5e:	687b      	ldr	r3, [r7, #4]
 800df60:	2231      	movs	r2, #49	; 0x31
 800df62:	5499      	strb	r1, [r3, r2]
		(*(pbuffer +  48));

	LOG_FUNCTION_END(status);

	return status;
 800df64:	2317      	movs	r3, #23
 800df66:	18fb      	adds	r3, r7, r3
 800df68:	781b      	ldrb	r3, [r3, #0]
 800df6a:	b25b      	sxtb	r3, r3
}
 800df6c:	0018      	movs	r0, r3
 800df6e:	46bd      	mov	sp, r7
 800df70:	b006      	add	sp, #24
 800df72:	bd80      	pop	{r7, pc}

0800df74 <VL53L1_get_nvm_copy_data>:


VL53L1_Error VL53L1_get_nvm_copy_data(
	VL53L1_DEV                 Dev,
	VL53L1_nvm_copy_data_t    *pdata)
{
 800df74:	b590      	push	{r4, r7, lr}
 800df76:	b091      	sub	sp, #68	; 0x44
 800df78:	af00      	add	r7, sp, #0
 800df7a:	6078      	str	r0, [r7, #4]
 800df7c:	6039      	str	r1, [r7, #0]
	/**
	 * Reads and de-serialises the contents of VL53L1_nvm_copy_data_t
	 * data structure from the device
	 */

	VL53L1_Error status = VL53L1_ERROR_NONE;
 800df7e:	213f      	movs	r1, #63	; 0x3f
 800df80:	187b      	adds	r3, r7, r1
 800df82:	2200      	movs	r2, #0
 800df84:	701a      	strb	r2, [r3, #0]
	uint8_t comms_buffer[VL53L1_NVM_COPY_DATA_I2C_SIZE_BYTES];

	LOG_FUNCTION_START("");

	if (status == VL53L1_ERROR_NONE) /*lint !e774 always true*/
 800df86:	187b      	adds	r3, r7, r1
 800df88:	781b      	ldrb	r3, [r3, #0]
 800df8a:	b25b      	sxtb	r3, r3
 800df8c:	2b00      	cmp	r3, #0
 800df8e:	d10c      	bne.n	800dfaa <VL53L1_get_nvm_copy_data+0x36>
		status = VL53L1_ReadMulti(
 800df90:	233f      	movs	r3, #63	; 0x3f
 800df92:	18fc      	adds	r4, r7, r3
 800df94:	230c      	movs	r3, #12
 800df96:	18fa      	adds	r2, r7, r3
 800df98:	2310      	movs	r3, #16
 800df9a:	33ff      	adds	r3, #255	; 0xff
 800df9c:	0019      	movs	r1, r3
 800df9e:	6878      	ldr	r0, [r7, #4]
 800dfa0:	2331      	movs	r3, #49	; 0x31
 800dfa2:	f000 f91f 	bl	800e1e4 <VL53L1_ReadMulti>
 800dfa6:	0003      	movs	r3, r0
 800dfa8:	7023      	strb	r3, [r4, #0]
			Dev,
			VL53L1_IDENTIFICATION__MODEL_ID,
			comms_buffer,
			VL53L1_NVM_COPY_DATA_I2C_SIZE_BYTES);

	if (status == VL53L1_ERROR_NONE)
 800dfaa:	233f      	movs	r3, #63	; 0x3f
 800dfac:	18fb      	adds	r3, r7, r3
 800dfae:	781b      	ldrb	r3, [r3, #0]
 800dfb0:	b25b      	sxtb	r3, r3
 800dfb2:	2b00      	cmp	r3, #0
 800dfb4:	d10a      	bne.n	800dfcc <VL53L1_get_nvm_copy_data+0x58>
		status = VL53L1_i2c_decode_nvm_copy_data(
 800dfb6:	233f      	movs	r3, #63	; 0x3f
 800dfb8:	18fc      	adds	r4, r7, r3
 800dfba:	683a      	ldr	r2, [r7, #0]
 800dfbc:	230c      	movs	r3, #12
 800dfbe:	18fb      	adds	r3, r7, r3
 800dfc0:	0019      	movs	r1, r3
 800dfc2:	2031      	movs	r0, #49	; 0x31
 800dfc4:	f7ff fea9 	bl	800dd1a <VL53L1_i2c_decode_nvm_copy_data>
 800dfc8:	0003      	movs	r3, r0
 800dfca:	7023      	strb	r3, [r4, #0]
			comms_buffer,
			pdata);

	LOG_FUNCTION_END(status);

	return status;
 800dfcc:	233f      	movs	r3, #63	; 0x3f
 800dfce:	18fb      	adds	r3, r7, r3
 800dfd0:	781b      	ldrb	r3, [r3, #0]
 800dfd2:	b25b      	sxtb	r3, r3
}
 800dfd4:	0018      	movs	r0, r3
 800dfd6:	46bd      	mov	sp, r7
 800dfd8:	b011      	add	sp, #68	; 0x44
 800dfda:	bd90      	pop	{r4, r7, pc}

0800dfdc <VL53L1_poll_for_boot_completion>:


VL53L1_Error VL53L1_poll_for_boot_completion(
	VL53L1_DEV    Dev,
	uint32_t      timeout_ms)
{
 800dfdc:	b5b0      	push	{r4, r5, r7, lr}
 800dfde:	b086      	sub	sp, #24
 800dfe0:	af02      	add	r7, sp, #8
 800dfe2:	6078      	str	r0, [r7, #4]
 800dfe4:	6039      	str	r1, [r7, #0]
	/**
	 * Polls the bit 0 of the FIRMWARE__SYSTEM_STATUS register to see if
	 * the firmware is ready.
	 */

	VL53L1_Error status       = VL53L1_ERROR_NONE;
 800dfe6:	250f      	movs	r5, #15
 800dfe8:	197b      	adds	r3, r7, r5
 800dfea:	2200      	movs	r2, #0
 800dfec:	701a      	strb	r2, [r3, #0]
	 * it copies the NVM data into the G02 host register banks
	 * The host must wait the required time to allow the copy
	 * to complete before attempting to read the firmware status
	 */

	status = VL53L1_WaitUs(
 800dfee:	197c      	adds	r4, r7, r5
 800dff0:	2396      	movs	r3, #150	; 0x96
 800dff2:	00da      	lsls	r2, r3, #3
 800dff4:	687b      	ldr	r3, [r7, #4]
 800dff6:	0011      	movs	r1, r2
 800dff8:	0018      	movs	r0, r3
 800dffa:	f000 fa29 	bl	800e450 <VL53L1_WaitUs>
 800dffe:	0003      	movs	r3, r0
 800e000:	7023      	strb	r3, [r4, #0]
			Dev,
			VL53L1_FIRMWARE_BOOT_TIME_US);

	if (status == VL53L1_ERROR_NONE)
 800e002:	197b      	adds	r3, r7, r5
 800e004:	781b      	ldrb	r3, [r3, #0]
 800e006:	b25b      	sxtb	r3, r3
 800e008:	2b00      	cmp	r3, #0
 800e00a:	d10d      	bne.n	800e028 <VL53L1_poll_for_boot_completion+0x4c>
		status =
 800e00c:	230f      	movs	r3, #15
 800e00e:	18fc      	adds	r4, r7, r3
 800e010:	6839      	ldr	r1, [r7, #0]
 800e012:	6878      	ldr	r0, [r7, #4]
 800e014:	2301      	movs	r3, #1
 800e016:	9301      	str	r3, [sp, #4]
 800e018:	2301      	movs	r3, #1
 800e01a:	9300      	str	r3, [sp, #0]
 800e01c:	2301      	movs	r3, #1
 800e01e:	22e5      	movs	r2, #229	; 0xe5
 800e020:	f000 fa2a 	bl	800e478 <VL53L1_WaitValueMaskEx>
 800e024:	0003      	movs	r3, r0
 800e026:	7023      	strb	r3, [r4, #0]
				VL53L1_FIRMWARE__SYSTEM_STATUS,
				0x01,
				0x01,
				VL53L1_POLLING_DELAY_MS);

	if (status == VL53L1_ERROR_NONE)
 800e028:	230f      	movs	r3, #15
 800e02a:	18fb      	adds	r3, r7, r3
 800e02c:	781b      	ldrb	r3, [r3, #0]
 800e02e:	b25b      	sxtb	r3, r3
 800e030:	2b00      	cmp	r3, #0
 800e032:	d104      	bne.n	800e03e <VL53L1_poll_for_boot_completion+0x62>
		VL53L1_init_ll_driver_state(Dev, VL53L1_DEVICESTATE_SW_STANDBY);
 800e034:	687b      	ldr	r3, [r7, #4]
 800e036:	2103      	movs	r1, #3
 800e038:	0018      	movs	r0, r3
 800e03a:	f7fd fe2c 	bl	800bc96 <VL53L1_init_ll_driver_state>

	LOG_FUNCTION_END(status);

	return status;
 800e03e:	230f      	movs	r3, #15
 800e040:	18fb      	adds	r3, r7, r3
 800e042:	781b      	ldrb	r3, [r3, #0]
 800e044:	b25b      	sxtb	r3, r3
}
 800e046:	0018      	movs	r0, r3
 800e048:	46bd      	mov	sp, r7
 800e04a:	b004      	add	sp, #16
 800e04c:	bdb0      	pop	{r4, r5, r7, pc}

0800e04e <VL53L1_poll_for_range_completion>:


VL53L1_Error VL53L1_poll_for_range_completion(
	VL53L1_DEV     Dev,
	uint32_t       timeout_ms)
{
 800e04e:	b5b0      	push	{r4, r5, r7, lr}
 800e050:	b088      	sub	sp, #32
 800e052:	af02      	add	r7, sp, #8
 800e054:	6078      	str	r0, [r7, #4]
 800e056:	6039      	str	r1, [r7, #0]
	 *
	 * Interrupt may be either active high or active low. Use active_high to
	 * select the required level check
	 */

	VL53L1_Error status = VL53L1_ERROR_NONE;
 800e058:	2316      	movs	r3, #22
 800e05a:	18fb      	adds	r3, r7, r3
 800e05c:	2200      	movs	r2, #0
 800e05e:	701a      	strb	r2, [r3, #0]
	VL53L1_LLDriverData_t *pdev = VL53L1DevStructGetLLDriverHandle(Dev);
 800e060:	687b      	ldr	r3, [r7, #4]
 800e062:	613b      	str	r3, [r7, #16]

	uint8_t  gpio__mux_active_high_hv = 0;
 800e064:	210f      	movs	r1, #15
 800e066:	187b      	adds	r3, r7, r1
 800e068:	2200      	movs	r2, #0
 800e06a:	701a      	strb	r2, [r3, #0]
	uint8_t  interrupt_ready          = 0;
 800e06c:	2317      	movs	r3, #23
 800e06e:	18fb      	adds	r3, r7, r3
 800e070:	2200      	movs	r2, #0
 800e072:	701a      	strb	r2, [r3, #0]

	LOG_FUNCTION_START("");

	gpio__mux_active_high_hv =
			pdev->stat_cfg.gpio_hv_mux__ctrl &
 800e074:	693a      	ldr	r2, [r7, #16]
 800e076:	23b8      	movs	r3, #184	; 0xb8
 800e078:	005b      	lsls	r3, r3, #1
 800e07a:	5cd2      	ldrb	r2, [r2, r3]
	gpio__mux_active_high_hv =
 800e07c:	0008      	movs	r0, r1
 800e07e:	187b      	adds	r3, r7, r1
 800e080:	2110      	movs	r1, #16
 800e082:	400a      	ands	r2, r1
 800e084:	701a      	strb	r2, [r3, #0]
			VL53L1_DEVICEINTERRUPTLEVEL_ACTIVE_MASK;

	if (gpio__mux_active_high_hv == VL53L1_DEVICEINTERRUPTLEVEL_ACTIVE_HIGH)
 800e086:	0001      	movs	r1, r0
 800e088:	187b      	adds	r3, r7, r1
 800e08a:	781b      	ldrb	r3, [r3, #0]
 800e08c:	2b00      	cmp	r3, #0
 800e08e:	d104      	bne.n	800e09a <VL53L1_poll_for_range_completion+0x4c>
		interrupt_ready = 0x01;
 800e090:	2317      	movs	r3, #23
 800e092:	18fb      	adds	r3, r7, r3
 800e094:	2201      	movs	r2, #1
 800e096:	701a      	strb	r2, [r3, #0]
 800e098:	e003      	b.n	800e0a2 <VL53L1_poll_for_range_completion+0x54>
	else
		interrupt_ready = 0x00;
 800e09a:	2317      	movs	r3, #23
 800e09c:	18fb      	adds	r3, r7, r3
 800e09e:	2200      	movs	r2, #0
 800e0a0:	701a      	strb	r2, [r3, #0]

	status =
 800e0a2:	2516      	movs	r5, #22
 800e0a4:	197c      	adds	r4, r7, r5
 800e0a6:	2317      	movs	r3, #23
 800e0a8:	18fb      	adds	r3, r7, r3
 800e0aa:	781a      	ldrb	r2, [r3, #0]
 800e0ac:	6839      	ldr	r1, [r7, #0]
 800e0ae:	6878      	ldr	r0, [r7, #4]
 800e0b0:	2301      	movs	r3, #1
 800e0b2:	9301      	str	r3, [sp, #4]
 800e0b4:	2301      	movs	r3, #1
 800e0b6:	9300      	str	r3, [sp, #0]
 800e0b8:	0013      	movs	r3, r2
 800e0ba:	2231      	movs	r2, #49	; 0x31
 800e0bc:	f000 f9dc 	bl	800e478 <VL53L1_WaitValueMaskEx>
 800e0c0:	0003      	movs	r3, r0
 800e0c2:	7023      	strb	r3, [r4, #0]
			0x01,
			VL53L1_POLLING_DELAY_MS);

	LOG_FUNCTION_END(status);

	return status;
 800e0c4:	197b      	adds	r3, r7, r5
 800e0c6:	781b      	ldrb	r3, [r3, #0]
 800e0c8:	b25b      	sxtb	r3, r3
}
 800e0ca:	0018      	movs	r0, r3
 800e0cc:	46bd      	mov	sp, r7
 800e0ce:	b006      	add	sp, #24
 800e0d0:	bdb0      	pop	{r4, r5, r7, pc}

0800e0d2 <_I2CWrite>:
#   define VL53L1_PutI2cBus(...) (void)0
#endif

uint8_t _I2CBuffer[256];

int _I2CWrite(VL53L1_DEV Dev, uint8_t *pdata, uint32_t count) {
 800e0d2:	b590      	push	{r4, r7, lr}
 800e0d4:	b089      	sub	sp, #36	; 0x24
 800e0d6:	af02      	add	r7, sp, #8
 800e0d8:	60f8      	str	r0, [r7, #12]
 800e0da:	60b9      	str	r1, [r7, #8]
 800e0dc:	607a      	str	r2, [r7, #4]
    int status;
    int i2c_time_out = I2C_TIME_OUT_BASE+ count* I2C_TIME_OUT_BYTE;
 800e0de:	687b      	ldr	r3, [r7, #4]
 800e0e0:	330a      	adds	r3, #10
 800e0e2:	617b      	str	r3, [r7, #20]

    status = HAL_I2C_Master_Transmit(Dev->I2cHandle, Dev->I2cDevAddr, pdata, count, i2c_time_out);
 800e0e4:	68fa      	ldr	r2, [r7, #12]
 800e0e6:	23e8      	movs	r3, #232	; 0xe8
 800e0e8:	009b      	lsls	r3, r3, #2
 800e0ea:	58d0      	ldr	r0, [r2, r3]
 800e0ec:	68fa      	ldr	r2, [r7, #12]
 800e0ee:	23e6      	movs	r3, #230	; 0xe6
 800e0f0:	009b      	lsls	r3, r3, #2
 800e0f2:	5cd3      	ldrb	r3, [r2, r3]
 800e0f4:	b299      	uxth	r1, r3
 800e0f6:	687b      	ldr	r3, [r7, #4]
 800e0f8:	b29c      	uxth	r4, r3
 800e0fa:	697b      	ldr	r3, [r7, #20]
 800e0fc:	68ba      	ldr	r2, [r7, #8]
 800e0fe:	9300      	str	r3, [sp, #0]
 800e100:	0023      	movs	r3, r4
 800e102:	f001 febb 	bl	800fe7c <HAL_I2C_Master_Transmit>
 800e106:	0003      	movs	r3, r0
 800e108:	613b      	str	r3, [r7, #16]
    if (status) {
        //VL6180x_ErrLog("I2C error 0x%x %d len", dev->I2cAddr, len);
        //XNUCLEO6180XA1_I2C1_Init(&hi2c1);
    }
    return status;
 800e10a:	693b      	ldr	r3, [r7, #16]
}
 800e10c:	0018      	movs	r0, r3
 800e10e:	46bd      	mov	sp, r7
 800e110:	b007      	add	sp, #28
 800e112:	bd90      	pop	{r4, r7, pc}

0800e114 <_I2CRead>:

int _I2CRead(VL53L1_DEV Dev, uint8_t *pdata, uint32_t count) {
 800e114:	b590      	push	{r4, r7, lr}
 800e116:	b089      	sub	sp, #36	; 0x24
 800e118:	af02      	add	r7, sp, #8
 800e11a:	60f8      	str	r0, [r7, #12]
 800e11c:	60b9      	str	r1, [r7, #8]
 800e11e:	607a      	str	r2, [r7, #4]
    int status;
    int i2c_time_out = I2C_TIME_OUT_BASE+ count* I2C_TIME_OUT_BYTE;
 800e120:	687b      	ldr	r3, [r7, #4]
 800e122:	330a      	adds	r3, #10
 800e124:	617b      	str	r3, [r7, #20]

    status = HAL_I2C_Master_Receive(Dev->I2cHandle, Dev->I2cDevAddr|1, pdata, count, i2c_time_out);
 800e126:	68fa      	ldr	r2, [r7, #12]
 800e128:	23e8      	movs	r3, #232	; 0xe8
 800e12a:	009b      	lsls	r3, r3, #2
 800e12c:	58d0      	ldr	r0, [r2, r3]
 800e12e:	68fa      	ldr	r2, [r7, #12]
 800e130:	23e6      	movs	r3, #230	; 0xe6
 800e132:	009b      	lsls	r3, r3, #2
 800e134:	5cd3      	ldrb	r3, [r2, r3]
 800e136:	2201      	movs	r2, #1
 800e138:	4313      	orrs	r3, r2
 800e13a:	b2db      	uxtb	r3, r3
 800e13c:	b299      	uxth	r1, r3
 800e13e:	687b      	ldr	r3, [r7, #4]
 800e140:	b29c      	uxth	r4, r3
 800e142:	697b      	ldr	r3, [r7, #20]
 800e144:	68ba      	ldr	r2, [r7, #8]
 800e146:	9300      	str	r3, [sp, #0]
 800e148:	0023      	movs	r3, r4
 800e14a:	f001 ff9f 	bl	801008c <HAL_I2C_Master_Receive>
 800e14e:	0003      	movs	r3, r0
 800e150:	613b      	str	r3, [r7, #16]
    if (status) {
        //VL6180x_ErrLog("I2C error 0x%x %d len", dev->I2cAddr, len);
        //XNUCLEO6180XA1_I2C1_Init(&hi2c1);
    }
    return status;
 800e152:	693b      	ldr	r3, [r7, #16]
}
 800e154:	0018      	movs	r0, r3
 800e156:	46bd      	mov	sp, r7
 800e158:	b007      	add	sp, #28
 800e15a:	bd90      	pop	{r4, r7, pc}

0800e15c <VL53L1_WriteMulti>:

VL53L1_Error VL53L1_WriteMulti(VL53L1_DEV Dev, uint16_t index, uint8_t *pdata, uint32_t count) {
 800e15c:	b580      	push	{r7, lr}
 800e15e:	b086      	sub	sp, #24
 800e160:	af00      	add	r7, sp, #0
 800e162:	60f8      	str	r0, [r7, #12]
 800e164:	607a      	str	r2, [r7, #4]
 800e166:	603b      	str	r3, [r7, #0]
 800e168:	230a      	movs	r3, #10
 800e16a:	18fb      	adds	r3, r7, r3
 800e16c:	1c0a      	adds	r2, r1, #0
 800e16e:	801a      	strh	r2, [r3, #0]
    int status_int;
    VL53L1_Error Status = VL53L1_ERROR_NONE;
 800e170:	2317      	movs	r3, #23
 800e172:	18fb      	adds	r3, r7, r3
 800e174:	2200      	movs	r2, #0
 800e176:	701a      	strb	r2, [r3, #0]
    if (count > sizeof(_I2CBuffer) - 1) {
 800e178:	683b      	ldr	r3, [r7, #0]
 800e17a:	2bff      	cmp	r3, #255	; 0xff
 800e17c:	d902      	bls.n	800e184 <VL53L1_WriteMulti+0x28>
        return VL53L1_ERROR_INVALID_PARAMS;
 800e17e:	2304      	movs	r3, #4
 800e180:	425b      	negs	r3, r3
 800e182:	e026      	b.n	800e1d2 <VL53L1_WriteMulti+0x76>
    }
    _I2CBuffer[0] = index>>8;
 800e184:	210a      	movs	r1, #10
 800e186:	187b      	adds	r3, r7, r1
 800e188:	881b      	ldrh	r3, [r3, #0]
 800e18a:	0a1b      	lsrs	r3, r3, #8
 800e18c:	b29b      	uxth	r3, r3
 800e18e:	b2da      	uxtb	r2, r3
 800e190:	4b12      	ldr	r3, [pc, #72]	; (800e1dc <VL53L1_WriteMulti+0x80>)
 800e192:	701a      	strb	r2, [r3, #0]
    _I2CBuffer[1] = index&0xFF;
 800e194:	187b      	adds	r3, r7, r1
 800e196:	881b      	ldrh	r3, [r3, #0]
 800e198:	b2da      	uxtb	r2, r3
 800e19a:	4b10      	ldr	r3, [pc, #64]	; (800e1dc <VL53L1_WriteMulti+0x80>)
 800e19c:	705a      	strb	r2, [r3, #1]
    memcpy(&_I2CBuffer[2], pdata, count);
 800e19e:	683a      	ldr	r2, [r7, #0]
 800e1a0:	6879      	ldr	r1, [r7, #4]
 800e1a2:	4b0f      	ldr	r3, [pc, #60]	; (800e1e0 <VL53L1_WriteMulti+0x84>)
 800e1a4:	0018      	movs	r0, r3
 800e1a6:	f005 f80d 	bl	80131c4 <memcpy>
    VL53L1_GetI2cBus();
    status_int = _I2CWrite(Dev, _I2CBuffer, count + 2);
 800e1aa:	683b      	ldr	r3, [r7, #0]
 800e1ac:	1c9a      	adds	r2, r3, #2
 800e1ae:	490b      	ldr	r1, [pc, #44]	; (800e1dc <VL53L1_WriteMulti+0x80>)
 800e1b0:	68fb      	ldr	r3, [r7, #12]
 800e1b2:	0018      	movs	r0, r3
 800e1b4:	f7ff ff8d 	bl	800e0d2 <_I2CWrite>
 800e1b8:	0003      	movs	r3, r0
 800e1ba:	613b      	str	r3, [r7, #16]
    if (status_int != 0) {
 800e1bc:	693b      	ldr	r3, [r7, #16]
 800e1be:	2b00      	cmp	r3, #0
 800e1c0:	d003      	beq.n	800e1ca <VL53L1_WriteMulti+0x6e>
        Status = VL53L1_ERROR_CONTROL_INTERFACE;
 800e1c2:	2317      	movs	r3, #23
 800e1c4:	18fb      	adds	r3, r7, r3
 800e1c6:	22f3      	movs	r2, #243	; 0xf3
 800e1c8:	701a      	strb	r2, [r3, #0]
    }
    VL53L1_PutI2cBus();
    return Status;
 800e1ca:	2317      	movs	r3, #23
 800e1cc:	18fb      	adds	r3, r7, r3
 800e1ce:	781b      	ldrb	r3, [r3, #0]
 800e1d0:	b25b      	sxtb	r3, r3
}
 800e1d2:	0018      	movs	r0, r3
 800e1d4:	46bd      	mov	sp, r7
 800e1d6:	b006      	add	sp, #24
 800e1d8:	bd80      	pop	{r7, pc}
 800e1da:	46c0      	nop			; (mov r8, r8)
 800e1dc:	200032c4 	.word	0x200032c4
 800e1e0:	200032c6 	.word	0x200032c6

0800e1e4 <VL53L1_ReadMulti>:

// the ranging_sensor_comms.dll will take care of the page selection
VL53L1_Error VL53L1_ReadMulti(VL53L1_DEV Dev, uint16_t index, uint8_t *pdata, uint32_t count) {
 800e1e4:	b580      	push	{r7, lr}
 800e1e6:	b086      	sub	sp, #24
 800e1e8:	af00      	add	r7, sp, #0
 800e1ea:	60f8      	str	r0, [r7, #12]
 800e1ec:	607a      	str	r2, [r7, #4]
 800e1ee:	603b      	str	r3, [r7, #0]
 800e1f0:	200a      	movs	r0, #10
 800e1f2:	183b      	adds	r3, r7, r0
 800e1f4:	1c0a      	adds	r2, r1, #0
 800e1f6:	801a      	strh	r2, [r3, #0]
    VL53L1_Error Status = VL53L1_ERROR_NONE;
 800e1f8:	2317      	movs	r3, #23
 800e1fa:	18fb      	adds	r3, r7, r3
 800e1fc:	2200      	movs	r2, #0
 800e1fe:	701a      	strb	r2, [r3, #0]
    int32_t status_int;

    _I2CBuffer[0] = index>>8;
 800e200:	0001      	movs	r1, r0
 800e202:	187b      	adds	r3, r7, r1
 800e204:	881b      	ldrh	r3, [r3, #0]
 800e206:	0a1b      	lsrs	r3, r3, #8
 800e208:	b29b      	uxth	r3, r3
 800e20a:	b2da      	uxtb	r2, r3
 800e20c:	4b17      	ldr	r3, [pc, #92]	; (800e26c <VL53L1_ReadMulti+0x88>)
 800e20e:	701a      	strb	r2, [r3, #0]
    _I2CBuffer[1] = index&0xFF;
 800e210:	187b      	adds	r3, r7, r1
 800e212:	881b      	ldrh	r3, [r3, #0]
 800e214:	b2da      	uxtb	r2, r3
 800e216:	4b15      	ldr	r3, [pc, #84]	; (800e26c <VL53L1_ReadMulti+0x88>)
 800e218:	705a      	strb	r2, [r3, #1]
    VL53L1_GetI2cBus();
    status_int = _I2CWrite(Dev, _I2CBuffer, 2);
 800e21a:	4914      	ldr	r1, [pc, #80]	; (800e26c <VL53L1_ReadMulti+0x88>)
 800e21c:	68fb      	ldr	r3, [r7, #12]
 800e21e:	2202      	movs	r2, #2
 800e220:	0018      	movs	r0, r3
 800e222:	f7ff ff56 	bl	800e0d2 <_I2CWrite>
 800e226:	0003      	movs	r3, r0
 800e228:	613b      	str	r3, [r7, #16]
    if (status_int != 0) {
 800e22a:	693b      	ldr	r3, [r7, #16]
 800e22c:	2b00      	cmp	r3, #0
 800e22e:	d004      	beq.n	800e23a <VL53L1_ReadMulti+0x56>
        Status = VL53L1_ERROR_CONTROL_INTERFACE;
 800e230:	2317      	movs	r3, #23
 800e232:	18fb      	adds	r3, r7, r3
 800e234:	22f3      	movs	r2, #243	; 0xf3
 800e236:	701a      	strb	r2, [r3, #0]
        goto done;
 800e238:	e010      	b.n	800e25c <VL53L1_ReadMulti+0x78>
    }
    status_int = _I2CRead(Dev, pdata, count);
 800e23a:	683a      	ldr	r2, [r7, #0]
 800e23c:	6879      	ldr	r1, [r7, #4]
 800e23e:	68fb      	ldr	r3, [r7, #12]
 800e240:	0018      	movs	r0, r3
 800e242:	f7ff ff67 	bl	800e114 <_I2CRead>
 800e246:	0003      	movs	r3, r0
 800e248:	613b      	str	r3, [r7, #16]
    if (status_int != 0) {
 800e24a:	693b      	ldr	r3, [r7, #16]
 800e24c:	2b00      	cmp	r3, #0
 800e24e:	d004      	beq.n	800e25a <VL53L1_ReadMulti+0x76>
        Status = VL53L1_ERROR_CONTROL_INTERFACE;
 800e250:	2317      	movs	r3, #23
 800e252:	18fb      	adds	r3, r7, r3
 800e254:	22f3      	movs	r2, #243	; 0xf3
 800e256:	701a      	strb	r2, [r3, #0]
 800e258:	e000      	b.n	800e25c <VL53L1_ReadMulti+0x78>
    }
done:
 800e25a:	46c0      	nop			; (mov r8, r8)
    VL53L1_PutI2cBus();
    return Status;
 800e25c:	2317      	movs	r3, #23
 800e25e:	18fb      	adds	r3, r7, r3
 800e260:	781b      	ldrb	r3, [r3, #0]
 800e262:	b25b      	sxtb	r3, r3
}
 800e264:	0018      	movs	r0, r3
 800e266:	46bd      	mov	sp, r7
 800e268:	b006      	add	sp, #24
 800e26a:	bd80      	pop	{r7, pc}
 800e26c:	200032c4 	.word	0x200032c4

0800e270 <VL53L1_WrByte>:

VL53L1_Error VL53L1_WrByte(VL53L1_DEV Dev, uint16_t index, uint8_t data) {
 800e270:	b580      	push	{r7, lr}
 800e272:	b084      	sub	sp, #16
 800e274:	af00      	add	r7, sp, #0
 800e276:	6078      	str	r0, [r7, #4]
 800e278:	0008      	movs	r0, r1
 800e27a:	0011      	movs	r1, r2
 800e27c:	1cbb      	adds	r3, r7, #2
 800e27e:	1c02      	adds	r2, r0, #0
 800e280:	801a      	strh	r2, [r3, #0]
 800e282:	1c7b      	adds	r3, r7, #1
 800e284:	1c0a      	adds	r2, r1, #0
 800e286:	701a      	strb	r2, [r3, #0]
    VL53L1_Error Status = VL53L1_ERROR_NONE;
 800e288:	230f      	movs	r3, #15
 800e28a:	18fb      	adds	r3, r7, r3
 800e28c:	2200      	movs	r2, #0
 800e28e:	701a      	strb	r2, [r3, #0]
    int32_t status_int;

    _I2CBuffer[0] = index>>8;
 800e290:	1cbb      	adds	r3, r7, #2
 800e292:	881b      	ldrh	r3, [r3, #0]
 800e294:	0a1b      	lsrs	r3, r3, #8
 800e296:	b29b      	uxth	r3, r3
 800e298:	b2da      	uxtb	r2, r3
 800e29a:	4b11      	ldr	r3, [pc, #68]	; (800e2e0 <VL53L1_WrByte+0x70>)
 800e29c:	701a      	strb	r2, [r3, #0]
    _I2CBuffer[1] = index&0xFF;
 800e29e:	1cbb      	adds	r3, r7, #2
 800e2a0:	881b      	ldrh	r3, [r3, #0]
 800e2a2:	b2da      	uxtb	r2, r3
 800e2a4:	4b0e      	ldr	r3, [pc, #56]	; (800e2e0 <VL53L1_WrByte+0x70>)
 800e2a6:	705a      	strb	r2, [r3, #1]
    _I2CBuffer[2] = data;
 800e2a8:	4b0d      	ldr	r3, [pc, #52]	; (800e2e0 <VL53L1_WrByte+0x70>)
 800e2aa:	1c7a      	adds	r2, r7, #1
 800e2ac:	7812      	ldrb	r2, [r2, #0]
 800e2ae:	709a      	strb	r2, [r3, #2]

    VL53L1_GetI2cBus();
    status_int = _I2CWrite(Dev, _I2CBuffer, 3);
 800e2b0:	490b      	ldr	r1, [pc, #44]	; (800e2e0 <VL53L1_WrByte+0x70>)
 800e2b2:	687b      	ldr	r3, [r7, #4]
 800e2b4:	2203      	movs	r2, #3
 800e2b6:	0018      	movs	r0, r3
 800e2b8:	f7ff ff0b 	bl	800e0d2 <_I2CWrite>
 800e2bc:	0003      	movs	r3, r0
 800e2be:	60bb      	str	r3, [r7, #8]
    if (status_int != 0) {
 800e2c0:	68bb      	ldr	r3, [r7, #8]
 800e2c2:	2b00      	cmp	r3, #0
 800e2c4:	d003      	beq.n	800e2ce <VL53L1_WrByte+0x5e>
        Status = VL53L1_ERROR_CONTROL_INTERFACE;
 800e2c6:	230f      	movs	r3, #15
 800e2c8:	18fb      	adds	r3, r7, r3
 800e2ca:	22f3      	movs	r2, #243	; 0xf3
 800e2cc:	701a      	strb	r2, [r3, #0]
    }
    VL53L1_PutI2cBus();
    return Status;
 800e2ce:	230f      	movs	r3, #15
 800e2d0:	18fb      	adds	r3, r7, r3
 800e2d2:	781b      	ldrb	r3, [r3, #0]
 800e2d4:	b25b      	sxtb	r3, r3
}
 800e2d6:	0018      	movs	r0, r3
 800e2d8:	46bd      	mov	sp, r7
 800e2da:	b004      	add	sp, #16
 800e2dc:	bd80      	pop	{r7, pc}
 800e2de:	46c0      	nop			; (mov r8, r8)
 800e2e0:	200032c4 	.word	0x200032c4

0800e2e4 <VL53L1_RdByte>:
    Status = VL53L1_WrByte(Dev, index, data);
done:
    return Status;
}

VL53L1_Error VL53L1_RdByte(VL53L1_DEV Dev, uint16_t index, uint8_t *data) {
 800e2e4:	b580      	push	{r7, lr}
 800e2e6:	b086      	sub	sp, #24
 800e2e8:	af00      	add	r7, sp, #0
 800e2ea:	60f8      	str	r0, [r7, #12]
 800e2ec:	607a      	str	r2, [r7, #4]
 800e2ee:	200a      	movs	r0, #10
 800e2f0:	183b      	adds	r3, r7, r0
 800e2f2:	1c0a      	adds	r2, r1, #0
 800e2f4:	801a      	strh	r2, [r3, #0]
    VL53L1_Error Status = VL53L1_ERROR_NONE;
 800e2f6:	2317      	movs	r3, #23
 800e2f8:	18fb      	adds	r3, r7, r3
 800e2fa:	2200      	movs	r2, #0
 800e2fc:	701a      	strb	r2, [r3, #0]
    int32_t status_int;

	_I2CBuffer[0] = index>>8;
 800e2fe:	0001      	movs	r1, r0
 800e300:	187b      	adds	r3, r7, r1
 800e302:	881b      	ldrh	r3, [r3, #0]
 800e304:	0a1b      	lsrs	r3, r3, #8
 800e306:	b29b      	uxth	r3, r3
 800e308:	b2da      	uxtb	r2, r3
 800e30a:	4b18      	ldr	r3, [pc, #96]	; (800e36c <VL53L1_RdByte+0x88>)
 800e30c:	701a      	strb	r2, [r3, #0]
	_I2CBuffer[1] = index&0xFF;
 800e30e:	187b      	adds	r3, r7, r1
 800e310:	881b      	ldrh	r3, [r3, #0]
 800e312:	b2da      	uxtb	r2, r3
 800e314:	4b15      	ldr	r3, [pc, #84]	; (800e36c <VL53L1_RdByte+0x88>)
 800e316:	705a      	strb	r2, [r3, #1]
    VL53L1_GetI2cBus();
    status_int = _I2CWrite(Dev, _I2CBuffer, 2);
 800e318:	4914      	ldr	r1, [pc, #80]	; (800e36c <VL53L1_RdByte+0x88>)
 800e31a:	68fb      	ldr	r3, [r7, #12]
 800e31c:	2202      	movs	r2, #2
 800e31e:	0018      	movs	r0, r3
 800e320:	f7ff fed7 	bl	800e0d2 <_I2CWrite>
 800e324:	0003      	movs	r3, r0
 800e326:	613b      	str	r3, [r7, #16]
    if( status_int ){
 800e328:	693b      	ldr	r3, [r7, #16]
 800e32a:	2b00      	cmp	r3, #0
 800e32c:	d004      	beq.n	800e338 <VL53L1_RdByte+0x54>
        Status = VL53L1_ERROR_CONTROL_INTERFACE;
 800e32e:	2317      	movs	r3, #23
 800e330:	18fb      	adds	r3, r7, r3
 800e332:	22f3      	movs	r2, #243	; 0xf3
 800e334:	701a      	strb	r2, [r3, #0]
        goto done;
 800e336:	e010      	b.n	800e35a <VL53L1_RdByte+0x76>
    }
    status_int = _I2CRead(Dev, data, 1);
 800e338:	6879      	ldr	r1, [r7, #4]
 800e33a:	68fb      	ldr	r3, [r7, #12]
 800e33c:	2201      	movs	r2, #1
 800e33e:	0018      	movs	r0, r3
 800e340:	f7ff fee8 	bl	800e114 <_I2CRead>
 800e344:	0003      	movs	r3, r0
 800e346:	613b      	str	r3, [r7, #16]
    if (status_int != 0) {
 800e348:	693b      	ldr	r3, [r7, #16]
 800e34a:	2b00      	cmp	r3, #0
 800e34c:	d004      	beq.n	800e358 <VL53L1_RdByte+0x74>
        Status = VL53L1_ERROR_CONTROL_INTERFACE;
 800e34e:	2317      	movs	r3, #23
 800e350:	18fb      	adds	r3, r7, r3
 800e352:	22f3      	movs	r2, #243	; 0xf3
 800e354:	701a      	strb	r2, [r3, #0]
 800e356:	e000      	b.n	800e35a <VL53L1_RdByte+0x76>
    }
done:
 800e358:	46c0      	nop			; (mov r8, r8)
    VL53L1_PutI2cBus();
    return Status;
 800e35a:	2317      	movs	r3, #23
 800e35c:	18fb      	adds	r3, r7, r3
 800e35e:	781b      	ldrb	r3, [r3, #0]
 800e360:	b25b      	sxtb	r3, r3
}
 800e362:	0018      	movs	r0, r3
 800e364:	46bd      	mov	sp, r7
 800e366:	b006      	add	sp, #24
 800e368:	bd80      	pop	{r7, pc}
 800e36a:	46c0      	nop			; (mov r8, r8)
 800e36c:	200032c4 	.word	0x200032c4

0800e370 <VL53L1_RdWord>:

VL53L1_Error VL53L1_RdWord(VL53L1_DEV Dev, uint16_t index, uint16_t *data) {
 800e370:	b580      	push	{r7, lr}
 800e372:	b086      	sub	sp, #24
 800e374:	af00      	add	r7, sp, #0
 800e376:	60f8      	str	r0, [r7, #12]
 800e378:	607a      	str	r2, [r7, #4]
 800e37a:	200a      	movs	r0, #10
 800e37c:	183b      	adds	r3, r7, r0
 800e37e:	1c0a      	adds	r2, r1, #0
 800e380:	801a      	strh	r2, [r3, #0]
    VL53L1_Error Status = VL53L1_ERROR_NONE;
 800e382:	2317      	movs	r3, #23
 800e384:	18fb      	adds	r3, r7, r3
 800e386:	2200      	movs	r2, #0
 800e388:	701a      	strb	r2, [r3, #0]
    int32_t status_int;

    _I2CBuffer[0] = index>>8;
 800e38a:	0001      	movs	r1, r0
 800e38c:	187b      	adds	r3, r7, r1
 800e38e:	881b      	ldrh	r3, [r3, #0]
 800e390:	0a1b      	lsrs	r3, r3, #8
 800e392:	b29b      	uxth	r3, r3
 800e394:	b2da      	uxtb	r2, r3
 800e396:	4b1d      	ldr	r3, [pc, #116]	; (800e40c <VL53L1_RdWord+0x9c>)
 800e398:	701a      	strb	r2, [r3, #0]
	_I2CBuffer[1] = index&0xFF;
 800e39a:	187b      	adds	r3, r7, r1
 800e39c:	881b      	ldrh	r3, [r3, #0]
 800e39e:	b2da      	uxtb	r2, r3
 800e3a0:	4b1a      	ldr	r3, [pc, #104]	; (800e40c <VL53L1_RdWord+0x9c>)
 800e3a2:	705a      	strb	r2, [r3, #1]
    VL53L1_GetI2cBus();
    status_int = _I2CWrite(Dev, _I2CBuffer, 2);
 800e3a4:	4919      	ldr	r1, [pc, #100]	; (800e40c <VL53L1_RdWord+0x9c>)
 800e3a6:	68fb      	ldr	r3, [r7, #12]
 800e3a8:	2202      	movs	r2, #2
 800e3aa:	0018      	movs	r0, r3
 800e3ac:	f7ff fe91 	bl	800e0d2 <_I2CWrite>
 800e3b0:	0003      	movs	r3, r0
 800e3b2:	613b      	str	r3, [r7, #16]

    if( status_int ){
 800e3b4:	693b      	ldr	r3, [r7, #16]
 800e3b6:	2b00      	cmp	r3, #0
 800e3b8:	d004      	beq.n	800e3c4 <VL53L1_RdWord+0x54>
        Status = VL53L1_ERROR_CONTROL_INTERFACE;
 800e3ba:	2317      	movs	r3, #23
 800e3bc:	18fb      	adds	r3, r7, r3
 800e3be:	22f3      	movs	r2, #243	; 0xf3
 800e3c0:	701a      	strb	r2, [r3, #0]
        goto done;
 800e3c2:	e01b      	b.n	800e3fc <VL53L1_RdWord+0x8c>
    }
    status_int = _I2CRead(Dev, _I2CBuffer, 2);
 800e3c4:	4911      	ldr	r1, [pc, #68]	; (800e40c <VL53L1_RdWord+0x9c>)
 800e3c6:	68fb      	ldr	r3, [r7, #12]
 800e3c8:	2202      	movs	r2, #2
 800e3ca:	0018      	movs	r0, r3
 800e3cc:	f7ff fea2 	bl	800e114 <_I2CRead>
 800e3d0:	0003      	movs	r3, r0
 800e3d2:	613b      	str	r3, [r7, #16]
    if (status_int != 0) {
 800e3d4:	693b      	ldr	r3, [r7, #16]
 800e3d6:	2b00      	cmp	r3, #0
 800e3d8:	d004      	beq.n	800e3e4 <VL53L1_RdWord+0x74>
        Status = VL53L1_ERROR_CONTROL_INTERFACE;
 800e3da:	2317      	movs	r3, #23
 800e3dc:	18fb      	adds	r3, r7, r3
 800e3de:	22f3      	movs	r2, #243	; 0xf3
 800e3e0:	701a      	strb	r2, [r3, #0]
        goto done;
 800e3e2:	e00b      	b.n	800e3fc <VL53L1_RdWord+0x8c>
    }

    *data = ((uint16_t)_I2CBuffer[0]<<8) + (uint16_t)_I2CBuffer[1];
 800e3e4:	4b09      	ldr	r3, [pc, #36]	; (800e40c <VL53L1_RdWord+0x9c>)
 800e3e6:	781b      	ldrb	r3, [r3, #0]
 800e3e8:	b29b      	uxth	r3, r3
 800e3ea:	021b      	lsls	r3, r3, #8
 800e3ec:	b29a      	uxth	r2, r3
 800e3ee:	4b07      	ldr	r3, [pc, #28]	; (800e40c <VL53L1_RdWord+0x9c>)
 800e3f0:	785b      	ldrb	r3, [r3, #1]
 800e3f2:	b29b      	uxth	r3, r3
 800e3f4:	18d3      	adds	r3, r2, r3
 800e3f6:	b29a      	uxth	r2, r3
 800e3f8:	687b      	ldr	r3, [r7, #4]
 800e3fa:	801a      	strh	r2, [r3, #0]
done:
    VL53L1_PutI2cBus();
    return Status;
 800e3fc:	2317      	movs	r3, #23
 800e3fe:	18fb      	adds	r3, r7, r3
 800e400:	781b      	ldrb	r3, [r3, #0]
 800e402:	b25b      	sxtb	r3, r3
}
 800e404:	0018      	movs	r0, r3
 800e406:	46bd      	mov	sp, r7
 800e408:	b006      	add	sp, #24
 800e40a:	bd80      	pop	{r7, pc}
 800e40c:	200032c4 	.word	0x200032c4

0800e410 <VL53L1_GetTickCount>:
    return Status;
}

VL53L1_Error VL53L1_GetTickCount(
	uint32_t *ptick_count_ms)
{
 800e410:	b580      	push	{r7, lr}
 800e412:	b084      	sub	sp, #16
 800e414:	af00      	add	r7, sp, #0
 800e416:	6078      	str	r0, [r7, #4]

    /* Returns current tick count in [ms] */

	VL53L1_Error status  = VL53L1_ERROR_NONE;
 800e418:	210f      	movs	r1, #15
 800e41a:	187b      	adds	r3, r7, r1
 800e41c:	2200      	movs	r2, #0
 800e41e:	701a      	strb	r2, [r3, #0]

	//*ptick_count_ms = timeGetTime();
	*ptick_count_ms = 0;
 800e420:	687b      	ldr	r3, [r7, #4]
 800e422:	2200      	movs	r2, #0
 800e424:	601a      	str	r2, [r3, #0]
		VL53L1_TRACE_LEVEL_DEBUG,
		"VL53L1_GetTickCount() = %5u ms;\n",
	*ptick_count_ms);
#endif

	return status;
 800e426:	187b      	adds	r3, r7, r1
 800e428:	781b      	ldrb	r3, [r3, #0]
 800e42a:	b25b      	sxtb	r3, r3
}
 800e42c:	0018      	movs	r0, r3
 800e42e:	46bd      	mov	sp, r7
 800e430:	b004      	add	sp, #16
 800e432:	bd80      	pop	{r7, pc}

0800e434 <VL53L1_WaitMs>:
	trace_print(VL53L1_TRACE_LEVEL_INFO, "VL53L1_GetTimerFrequency: Freq : %dHz\n", *ptimer_freq_hz);
	return VL53L1_ERROR_NONE;
}


VL53L1_Error VL53L1_WaitMs(VL53L1_Dev_t *pdev, int32_t wait_ms){
 800e434:	b580      	push	{r7, lr}
 800e436:	b082      	sub	sp, #8
 800e438:	af00      	add	r7, sp, #0
 800e43a:	6078      	str	r0, [r7, #4]
 800e43c:	6039      	str	r1, [r7, #0]
	(void)pdev;
	HAL_Delay(wait_ms);
 800e43e:	683b      	ldr	r3, [r7, #0]
 800e440:	0018      	movs	r0, r3
 800e442:	f001 f857 	bl	800f4f4 <HAL_Delay>
    return VL53L1_ERROR_NONE;
 800e446:	2300      	movs	r3, #0
}
 800e448:	0018      	movs	r0, r3
 800e44a:	46bd      	mov	sp, r7
 800e44c:	b002      	add	sp, #8
 800e44e:	bd80      	pop	{r7, pc}

0800e450 <VL53L1_WaitUs>:

VL53L1_Error VL53L1_WaitUs(VL53L1_Dev_t *pdev, int32_t wait_us){
 800e450:	b580      	push	{r7, lr}
 800e452:	b082      	sub	sp, #8
 800e454:	af00      	add	r7, sp, #0
 800e456:	6078      	str	r0, [r7, #4]
 800e458:	6039      	str	r1, [r7, #0]
	(void)pdev;
	HAL_Delay(wait_us/1000);
 800e45a:	683a      	ldr	r2, [r7, #0]
 800e45c:	23fa      	movs	r3, #250	; 0xfa
 800e45e:	0099      	lsls	r1, r3, #2
 800e460:	0010      	movs	r0, r2
 800e462:	f7f1 feed 	bl	8000240 <__divsi3>
 800e466:	0003      	movs	r3, r0
 800e468:	0018      	movs	r0, r3
 800e46a:	f001 f843 	bl	800f4f4 <HAL_Delay>
    return VL53L1_ERROR_NONE;
 800e46e:	2300      	movs	r3, #0
}
 800e470:	0018      	movs	r0, r3
 800e472:	46bd      	mov	sp, r7
 800e474:	b002      	add	sp, #8
 800e476:	bd80      	pop	{r7, pc}

0800e478 <VL53L1_WaitValueMaskEx>:
	uint32_t      timeout_ms,
	uint16_t      index,
	uint8_t       value,
	uint8_t       mask,
	uint32_t      poll_delay_ms)
{
 800e478:	b590      	push	{r4, r7, lr}
 800e47a:	4c61      	ldr	r4, [pc, #388]	; (800e600 <VL53L1_WaitValueMaskEx+0x188>)
 800e47c:	44a5      	add	sp, r4
 800e47e:	af00      	add	r7, sp, #0
 800e480:	60f8      	str	r0, [r7, #12]
 800e482:	60b9      	str	r1, [r7, #8]
 800e484:	0019      	movs	r1, r3
 800e486:	4b5f      	ldr	r3, [pc, #380]	; (800e604 <VL53L1_WaitValueMaskEx+0x18c>)
 800e488:	208a      	movs	r0, #138	; 0x8a
 800e48a:	0080      	lsls	r0, r0, #2
 800e48c:	4684      	mov	ip, r0
 800e48e:	44bc      	add	ip, r7
 800e490:	4463      	add	r3, ip
 800e492:	801a      	strh	r2, [r3, #0]
 800e494:	4b5c      	ldr	r3, [pc, #368]	; (800e608 <VL53L1_WaitValueMaskEx+0x190>)
 800e496:	228a      	movs	r2, #138	; 0x8a
 800e498:	0092      	lsls	r2, r2, #2
 800e49a:	4694      	mov	ip, r2
 800e49c:	44bc      	add	ip, r7
 800e49e:	4463      	add	r3, ip
 800e4a0:	1c0a      	adds	r2, r1, #0
 800e4a2:	701a      	strb	r2, [r3, #0]
	 *          value,
	 *          mask,
	 *          poll_delay_ms);
	 */

	VL53L1_Error status         = VL53L1_ERROR_NONE;
 800e4a4:	4b59      	ldr	r3, [pc, #356]	; (800e60c <VL53L1_WaitValueMaskEx+0x194>)
 800e4a6:	18fb      	adds	r3, r7, r3
 800e4a8:	2200      	movs	r2, #0
 800e4aa:	701a      	strb	r2, [r3, #0]
	uint32_t     start_time_ms = 0;
 800e4ac:	2300      	movs	r3, #0
 800e4ae:	2486      	movs	r4, #134	; 0x86
 800e4b0:	00a4      	lsls	r4, r4, #2
 800e4b2:	193a      	adds	r2, r7, r4
 800e4b4:	6013      	str	r3, [r2, #0]
	uint32_t     current_time_ms = 0;
 800e4b6:	2300      	movs	r3, #0
 800e4b8:	2285      	movs	r2, #133	; 0x85
 800e4ba:	0092      	lsls	r2, r2, #2
 800e4bc:	18ba      	adds	r2, r7, r2
 800e4be:	6013      	str	r3, [r2, #0]
	uint32_t     polling_time_ms = 0;
 800e4c0:	2300      	movs	r3, #0
 800e4c2:	2288      	movs	r2, #136	; 0x88
 800e4c4:	0092      	lsls	r2, r2, #2
 800e4c6:	18ba      	adds	r2, r7, r2
 800e4c8:	6013      	str	r3, [r2, #0]
	uint8_t      byte_value      = 0;
 800e4ca:	4b51      	ldr	r3, [pc, #324]	; (800e610 <VL53L1_WaitValueMaskEx+0x198>)
 800e4cc:	18fb      	adds	r3, r7, r3
 800e4ce:	2200      	movs	r2, #0
 800e4d0:	701a      	strb	r2, [r3, #0]
	uint8_t      found           = 0;
 800e4d2:	4b50      	ldr	r3, [pc, #320]	; (800e614 <VL53L1_WaitValueMaskEx+0x19c>)
 800e4d4:	18fb      	adds	r3, r7, r3
 800e4d6:	2200      	movs	r2, #0
 800e4d8:	701a      	strb	r2, [r3, #0]
#ifdef PAL_EXTENDED
	VL53L1_get_register_name(
			index,
			register_name);
#else
	VL53L1_COPYSTRING(register_name, "");
 800e4da:	4a4f      	ldr	r2, [pc, #316]	; (800e618 <VL53L1_WaitValueMaskEx+0x1a0>)
 800e4dc:	494f      	ldr	r1, [pc, #316]	; (800e61c <VL53L1_WaitValueMaskEx+0x1a4>)
 800e4de:	2310      	movs	r3, #16
 800e4e0:	18fb      	adds	r3, r7, r3
 800e4e2:	0018      	movs	r0, r3
 800e4e4:	f005 f9d5 	bl	8013892 <strncpy>
    trace_i2c("WaitValueMaskEx(%5d, %s, 0x%02X, 0x%02X, %5d);\n",
    		     timeout_ms, register_name, value, mask, poll_delay_ms);

	/* calculate time limit in absolute time */

	 VL53L1_GetTickCount(&start_time_ms);
 800e4e8:	193b      	adds	r3, r7, r4
 800e4ea:	0018      	movs	r0, r3
 800e4ec:	f7ff ff90 	bl	800e410 <VL53L1_GetTickCount>
	VL53L1_set_trace_functions(VL53L1_TRACE_FUNCTION_NONE);
#endif

	/* wait until value is found, timeout reached on error occurred */

	while ((status == VL53L1_ERROR_NONE) &&
 800e4f0:	e05b      	b.n	800e5aa <VL53L1_WaitValueMaskEx+0x132>
		   (polling_time_ms < timeout_ms) &&
		   (found == 0)) {

		if (status == VL53L1_ERROR_NONE)
 800e4f2:	4b46      	ldr	r3, [pc, #280]	; (800e60c <VL53L1_WaitValueMaskEx+0x194>)
 800e4f4:	18fb      	adds	r3, r7, r3
 800e4f6:	781b      	ldrb	r3, [r3, #0]
 800e4f8:	b25b      	sxtb	r3, r3
 800e4fa:	2b00      	cmp	r3, #0
 800e4fc:	d110      	bne.n	800e520 <VL53L1_WaitValueMaskEx+0xa8>
			status = VL53L1_RdByte(
 800e4fe:	4b43      	ldr	r3, [pc, #268]	; (800e60c <VL53L1_WaitValueMaskEx+0x194>)
 800e500:	18fc      	adds	r4, r7, r3
 800e502:	4b43      	ldr	r3, [pc, #268]	; (800e610 <VL53L1_WaitValueMaskEx+0x198>)
 800e504:	18fa      	adds	r2, r7, r3
 800e506:	4b3f      	ldr	r3, [pc, #252]	; (800e604 <VL53L1_WaitValueMaskEx+0x18c>)
 800e508:	218a      	movs	r1, #138	; 0x8a
 800e50a:	0089      	lsls	r1, r1, #2
 800e50c:	468c      	mov	ip, r1
 800e50e:	44bc      	add	ip, r7
 800e510:	4463      	add	r3, ip
 800e512:	8819      	ldrh	r1, [r3, #0]
 800e514:	68fb      	ldr	r3, [r7, #12]
 800e516:	0018      	movs	r0, r3
 800e518:	f7ff fee4 	bl	800e2e4 <VL53L1_RdByte>
 800e51c:	0003      	movs	r3, r0
 800e51e:	7023      	strb	r3, [r4, #0]
							pdev,
							index,
							&byte_value);

		if ((byte_value & mask) == value)
 800e520:	4b3b      	ldr	r3, [pc, #236]	; (800e610 <VL53L1_WaitValueMaskEx+0x198>)
 800e522:	18fb      	adds	r3, r7, r3
 800e524:	781b      	ldrb	r3, [r3, #0]
 800e526:	228e      	movs	r2, #142	; 0x8e
 800e528:	0092      	lsls	r2, r2, #2
 800e52a:	18ba      	adds	r2, r7, r2
 800e52c:	7812      	ldrb	r2, [r2, #0]
 800e52e:	4013      	ands	r3, r2
 800e530:	b2db      	uxtb	r3, r3
 800e532:	4a35      	ldr	r2, [pc, #212]	; (800e608 <VL53L1_WaitValueMaskEx+0x190>)
 800e534:	218a      	movs	r1, #138	; 0x8a
 800e536:	0089      	lsls	r1, r1, #2
 800e538:	468c      	mov	ip, r1
 800e53a:	44bc      	add	ip, r7
 800e53c:	4462      	add	r2, ip
 800e53e:	7812      	ldrb	r2, [r2, #0]
 800e540:	429a      	cmp	r2, r3
 800e542:	d103      	bne.n	800e54c <VL53L1_WaitValueMaskEx+0xd4>
			found = 1;
 800e544:	4b33      	ldr	r3, [pc, #204]	; (800e614 <VL53L1_WaitValueMaskEx+0x19c>)
 800e546:	18fb      	adds	r3, r7, r3
 800e548:	2201      	movs	r2, #1
 800e54a:	701a      	strb	r2, [r3, #0]

		if (status == VL53L1_ERROR_NONE  &&
 800e54c:	4b2f      	ldr	r3, [pc, #188]	; (800e60c <VL53L1_WaitValueMaskEx+0x194>)
 800e54e:	18fb      	adds	r3, r7, r3
 800e550:	781b      	ldrb	r3, [r3, #0]
 800e552:	b25b      	sxtb	r3, r3
 800e554:	2b00      	cmp	r3, #0
 800e556:	d117      	bne.n	800e588 <VL53L1_WaitValueMaskEx+0x110>
 800e558:	4b2e      	ldr	r3, [pc, #184]	; (800e614 <VL53L1_WaitValueMaskEx+0x19c>)
 800e55a:	18fb      	adds	r3, r7, r3
 800e55c:	781b      	ldrb	r3, [r3, #0]
 800e55e:	2b00      	cmp	r3, #0
 800e560:	d112      	bne.n	800e588 <VL53L1_WaitValueMaskEx+0x110>
			found == 0 &&
 800e562:	238f      	movs	r3, #143	; 0x8f
 800e564:	009b      	lsls	r3, r3, #2
 800e566:	18fb      	adds	r3, r7, r3
 800e568:	681b      	ldr	r3, [r3, #0]
 800e56a:	2b00      	cmp	r3, #0
 800e56c:	d00c      	beq.n	800e588 <VL53L1_WaitValueMaskEx+0x110>
			poll_delay_ms > 0)
			status = VL53L1_WaitMs(
 800e56e:	238f      	movs	r3, #143	; 0x8f
 800e570:	009b      	lsls	r3, r3, #2
 800e572:	18fb      	adds	r3, r7, r3
 800e574:	681a      	ldr	r2, [r3, #0]
 800e576:	4b25      	ldr	r3, [pc, #148]	; (800e60c <VL53L1_WaitValueMaskEx+0x194>)
 800e578:	18fc      	adds	r4, r7, r3
 800e57a:	68fb      	ldr	r3, [r7, #12]
 800e57c:	0011      	movs	r1, r2
 800e57e:	0018      	movs	r0, r3
 800e580:	f7ff ff58 	bl	800e434 <VL53L1_WaitMs>
 800e584:	0003      	movs	r3, r0
 800e586:	7023      	strb	r3, [r4, #0]
					pdev,
					poll_delay_ms);

		/* Update polling time (Compare difference rather than absolute to
		negate 32bit wrap around issue) */
		VL53L1_GetTickCount(&current_time_ms);
 800e588:	2485      	movs	r4, #133	; 0x85
 800e58a:	00a4      	lsls	r4, r4, #2
 800e58c:	193b      	adds	r3, r7, r4
 800e58e:	0018      	movs	r0, r3
 800e590:	f7ff ff3e 	bl	800e410 <VL53L1_GetTickCount>
		polling_time_ms = current_time_ms - start_time_ms;
 800e594:	193b      	adds	r3, r7, r4
 800e596:	681a      	ldr	r2, [r3, #0]
 800e598:	2386      	movs	r3, #134	; 0x86
 800e59a:	009b      	lsls	r3, r3, #2
 800e59c:	18fb      	adds	r3, r7, r3
 800e59e:	681b      	ldr	r3, [r3, #0]
 800e5a0:	1ad3      	subs	r3, r2, r3
 800e5a2:	2288      	movs	r2, #136	; 0x88
 800e5a4:	0092      	lsls	r2, r2, #2
 800e5a6:	18ba      	adds	r2, r7, r2
 800e5a8:	6013      	str	r3, [r2, #0]
	while ((status == VL53L1_ERROR_NONE) &&
 800e5aa:	4b18      	ldr	r3, [pc, #96]	; (800e60c <VL53L1_WaitValueMaskEx+0x194>)
 800e5ac:	18fb      	adds	r3, r7, r3
 800e5ae:	781b      	ldrb	r3, [r3, #0]
 800e5b0:	b25b      	sxtb	r3, r3
 800e5b2:	2b00      	cmp	r3, #0
 800e5b4:	d10b      	bne.n	800e5ce <VL53L1_WaitValueMaskEx+0x156>
 800e5b6:	2388      	movs	r3, #136	; 0x88
 800e5b8:	009b      	lsls	r3, r3, #2
 800e5ba:	18fb      	adds	r3, r7, r3
 800e5bc:	681a      	ldr	r2, [r3, #0]
 800e5be:	68bb      	ldr	r3, [r7, #8]
 800e5c0:	429a      	cmp	r2, r3
 800e5c2:	d204      	bcs.n	800e5ce <VL53L1_WaitValueMaskEx+0x156>
		   (polling_time_ms < timeout_ms) &&
 800e5c4:	4b13      	ldr	r3, [pc, #76]	; (800e614 <VL53L1_WaitValueMaskEx+0x19c>)
 800e5c6:	18fb      	adds	r3, r7, r3
 800e5c8:	781b      	ldrb	r3, [r3, #0]
 800e5ca:	2b00      	cmp	r3, #0
 800e5cc:	d091      	beq.n	800e4f2 <VL53L1_WaitValueMaskEx+0x7a>
#ifdef VL53L1_LOG_ENABLE
	/* Restore function logging */
	VL53L1_set_trace_functions(trace_functions);
#endif

	if (found == 0 && status == VL53L1_ERROR_NONE)
 800e5ce:	4b11      	ldr	r3, [pc, #68]	; (800e614 <VL53L1_WaitValueMaskEx+0x19c>)
 800e5d0:	18fb      	adds	r3, r7, r3
 800e5d2:	781b      	ldrb	r3, [r3, #0]
 800e5d4:	2b00      	cmp	r3, #0
 800e5d6:	d109      	bne.n	800e5ec <VL53L1_WaitValueMaskEx+0x174>
 800e5d8:	4b0c      	ldr	r3, [pc, #48]	; (800e60c <VL53L1_WaitValueMaskEx+0x194>)
 800e5da:	18fb      	adds	r3, r7, r3
 800e5dc:	781b      	ldrb	r3, [r3, #0]
 800e5de:	b25b      	sxtb	r3, r3
 800e5e0:	2b00      	cmp	r3, #0
 800e5e2:	d103      	bne.n	800e5ec <VL53L1_WaitValueMaskEx+0x174>
		status = VL53L1_ERROR_TIME_OUT;
 800e5e4:	4b09      	ldr	r3, [pc, #36]	; (800e60c <VL53L1_WaitValueMaskEx+0x194>)
 800e5e6:	18fb      	adds	r3, r7, r3
 800e5e8:	22f9      	movs	r2, #249	; 0xf9
 800e5ea:	701a      	strb	r2, [r3, #0]

	return status;
 800e5ec:	4b07      	ldr	r3, [pc, #28]	; (800e60c <VL53L1_WaitValueMaskEx+0x194>)
 800e5ee:	18fb      	adds	r3, r7, r3
 800e5f0:	781b      	ldrb	r3, [r3, #0]
 800e5f2:	b25b      	sxtb	r3, r3
}
 800e5f4:	0018      	movs	r0, r3
 800e5f6:	46bd      	mov	sp, r7
 800e5f8:	238b      	movs	r3, #139	; 0x8b
 800e5fa:	009b      	lsls	r3, r3, #2
 800e5fc:	449d      	add	sp, r3
 800e5fe:	bd90      	pop	{r4, r7, pc}
 800e600:	fffffdd4 	.word	0xfffffdd4
 800e604:	fffffdde 	.word	0xfffffdde
 800e608:	fffffddd 	.word	0xfffffddd
 800e60c:	00000227 	.word	0x00000227
 800e610:	00000213 	.word	0x00000213
 800e614:	0000021f 	.word	0x0000021f
 800e618:	000001ff 	.word	0x000001ff
 800e61c:	08014d40 	.word	0x08014d40

0800e620 <Stspin220_Board_Delay>:
 * @brief This function provides an accurate delay in milliseconds
 * @param[in] delay  time length in milliseconds
 * @retval None
 **********************************************************/
void Stspin220_Board_Delay(uint32_t delay)
{
 800e620:	b580      	push	{r7, lr}
 800e622:	b082      	sub	sp, #8
 800e624:	af00      	add	r7, sp, #0
 800e626:	6078      	str	r0, [r7, #4]
  HAL_Delay(delay);
 800e628:	687b      	ldr	r3, [r7, #4]
 800e62a:	0018      	movs	r0, r3
 800e62c:	f000 ff62 	bl	800f4f4 <HAL_Delay>
}
 800e630:	46c0      	nop			; (mov r8, r8)
 800e632:	46bd      	mov	sp, r7
 800e634:	b002      	add	sp, #8
 800e636:	bd80      	pop	{r7, pc}

0800e638 <Stspin220_Board_GpioInit>:
/******************************************************//**
 * @brief  Initiliases the GPIOs used by the STSPIN220
 * @retval None
  **********************************************************/
void Stspin220_Board_GpioInit(void)
{
 800e638:	b590      	push	{r4, r7, lr}
 800e63a:	b089      	sub	sp, #36	; 0x24
 800e63c:	af00      	add	r7, sp, #0
   GPIO_InitTypeDef GPIO_InitStruct;
  
  /* GPIO Ports Clock Enable */
  __GPIOA_CLK_ENABLE();
 800e63e:	4b43      	ldr	r3, [pc, #268]	; (800e74c <Stspin220_Board_GpioInit+0x114>)
 800e640:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800e642:	4b42      	ldr	r3, [pc, #264]	; (800e74c <Stspin220_Board_GpioInit+0x114>)
 800e644:	2101      	movs	r1, #1
 800e646:	430a      	orrs	r2, r1
 800e648:	62da      	str	r2, [r3, #44]	; 0x2c
 800e64a:	4b40      	ldr	r3, [pc, #256]	; (800e74c <Stspin220_Board_GpioInit+0x114>)
 800e64c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800e64e:	2201      	movs	r2, #1
 800e650:	4013      	ands	r3, r2
 800e652:	60bb      	str	r3, [r7, #8]
 800e654:	68bb      	ldr	r3, [r7, #8]
  __GPIOB_CLK_ENABLE();
 800e656:	4b3d      	ldr	r3, [pc, #244]	; (800e74c <Stspin220_Board_GpioInit+0x114>)
 800e658:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800e65a:	4b3c      	ldr	r3, [pc, #240]	; (800e74c <Stspin220_Board_GpioInit+0x114>)
 800e65c:	2102      	movs	r1, #2
 800e65e:	430a      	orrs	r2, r1
 800e660:	62da      	str	r2, [r3, #44]	; 0x2c
 800e662:	4b3a      	ldr	r3, [pc, #232]	; (800e74c <Stspin220_Board_GpioInit+0x114>)
 800e664:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800e666:	2202      	movs	r2, #2
 800e668:	4013      	ands	r3, r2
 800e66a:	607b      	str	r3, [r7, #4]
 800e66c:	687b      	ldr	r3, [r7, #4]
  __GPIOC_CLK_ENABLE();  
 800e66e:	4b37      	ldr	r3, [pc, #220]	; (800e74c <Stspin220_Board_GpioInit+0x114>)
 800e670:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800e672:	4b36      	ldr	r3, [pc, #216]	; (800e74c <Stspin220_Board_GpioInit+0x114>)
 800e674:	2104      	movs	r1, #4
 800e676:	430a      	orrs	r2, r1
 800e678:	62da      	str	r2, [r3, #44]	; 0x2c
 800e67a:	4b34      	ldr	r3, [pc, #208]	; (800e74c <Stspin220_Board_GpioInit+0x114>)
 800e67c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800e67e:	2204      	movs	r2, #4
 800e680:	4013      	ands	r3, r2
 800e682:	603b      	str	r3, [r7, #0]
 800e684:	683b      	ldr	r3, [r7, #0]
  /* Configure STSPIN220 - EN pin --------------------------------------------*/
  /* When this pin is set low, it is configured just before as                */
  /* GPIO_MODE_OUTPUT_PP with GPIO_NOPULL                                     */
  /* When this pin is set high, it is just after configured for FAULT         */
  /* as GPIO_MODE_IT_FALLING with GPIO_PULLUP                                 */
  Stspin220_Board_Disable();
 800e686:	f000 fa05 	bl	800ea94 <Stspin220_Board_Disable>
  
  /* Set Priority of External Line Interrupt used for the FAULT interrupt*/ 
  HAL_NVIC_SetPriority(BSP_MOTOR_CONTROL_BOARD_IRQn_EN_AND_FAULT,\
 800e68a:	2200      	movs	r2, #0
 800e68c:	2101      	movs	r1, #1
 800e68e:	2007      	movs	r0, #7
 800e690:	f001 f82a 	bl	800f6e8 <HAL_NVIC_SetPriority>
    BSP_MOTOR_CONTROL_BOARD_PRIORITY_EN_AND_FAULT,\
    0);
    
  /* Enable the External Line Interrupt used for the FAULT interrupt*/
  HAL_NVIC_EnableIRQ(BSP_MOTOR_CONTROL_BOARD_IRQn_EN_AND_FAULT);  
 800e694:	2007      	movs	r0, #7
 800e696:	f001 f83c 	bl	800f712 <HAL_NVIC_EnableIRQ>
 
  /* Configure STSPIN220 - MODE1 pin -----------------------------------------*/
  GPIO_InitStruct.Pin = BSP_MOTOR_CONTROL_BOARD_PIN_MODE1;
 800e69a:	210c      	movs	r1, #12
 800e69c:	187b      	adds	r3, r7, r1
 800e69e:	2210      	movs	r2, #16
 800e6a0:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800e6a2:	187b      	adds	r3, r7, r1
 800e6a4:	2201      	movs	r2, #1
 800e6a6:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800e6a8:	187b      	adds	r3, r7, r1
 800e6aa:	2200      	movs	r2, #0
 800e6ac:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_MEDIUM;
 800e6ae:	187b      	adds	r3, r7, r1
 800e6b0:	2201      	movs	r2, #1
 800e6b2:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(BSP_MOTOR_CONTROL_BOARD_PORT_MODE1, &GPIO_InitStruct);
 800e6b4:	000c      	movs	r4, r1
 800e6b6:	187b      	adds	r3, r7, r1
 800e6b8:	4a25      	ldr	r2, [pc, #148]	; (800e750 <Stspin220_Board_GpioInit+0x118>)
 800e6ba:	0019      	movs	r1, r3
 800e6bc:	0010      	movs	r0, r2
 800e6be:	f001 f8ad 	bl	800f81c <HAL_GPIO_Init>

  /* Configure STSPIN220 - MODE2 pin -----------------------------------------*/
  GPIO_InitStruct.Pin = BSP_MOTOR_CONTROL_BOARD_PIN_MODE2;
 800e6c2:	0021      	movs	r1, r4
 800e6c4:	187b      	adds	r3, r7, r1
 800e6c6:	2240      	movs	r2, #64	; 0x40
 800e6c8:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800e6ca:	187b      	adds	r3, r7, r1
 800e6cc:	2201      	movs	r2, #1
 800e6ce:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800e6d0:	187b      	adds	r3, r7, r1
 800e6d2:	2200      	movs	r2, #0
 800e6d4:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_MEDIUM;
 800e6d6:	187b      	adds	r3, r7, r1
 800e6d8:	2201      	movs	r2, #1
 800e6da:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(BSP_MOTOR_CONTROL_BOARD_PORT_MODE2, &GPIO_InitStruct);
 800e6dc:	000c      	movs	r4, r1
 800e6de:	187b      	adds	r3, r7, r1
 800e6e0:	4a1b      	ldr	r2, [pc, #108]	; (800e750 <Stspin220_Board_GpioInit+0x118>)
 800e6e2:	0019      	movs	r1, r3
 800e6e4:	0010      	movs	r0, r2
 800e6e6:	f001 f899 	bl	800f81c <HAL_GPIO_Init>

  /* Configure STSPIN220 - DIR pin -------------------------------------------*/
  GPIO_InitStruct.Pin = BSP_MOTOR_CONTROL_BOARD_PIN_DIR_MODE4;
 800e6ea:	0021      	movs	r1, r4
 800e6ec:	187b      	adds	r3, r7, r1
 800e6ee:	2280      	movs	r2, #128	; 0x80
 800e6f0:	0052      	lsls	r2, r2, #1
 800e6f2:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800e6f4:	187b      	adds	r3, r7, r1
 800e6f6:	2201      	movs	r2, #1
 800e6f8:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800e6fa:	187b      	adds	r3, r7, r1
 800e6fc:	2200      	movs	r2, #0
 800e6fe:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_MEDIUM;
 800e700:	187b      	adds	r3, r7, r1
 800e702:	2201      	movs	r2, #1
 800e704:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(BSP_MOTOR_CONTROL_BOARD_PORT_DIR_MODE4, &GPIO_InitStruct);
 800e706:	000c      	movs	r4, r1
 800e708:	187a      	adds	r2, r7, r1
 800e70a:	23a0      	movs	r3, #160	; 0xa0
 800e70c:	05db      	lsls	r3, r3, #23
 800e70e:	0011      	movs	r1, r2
 800e710:	0018      	movs	r0, r3
 800e712:	f001 f883 	bl	800f81c <HAL_GPIO_Init>
  
  /* Configure STSPIN220 - STBY/RESET pin ------------------------------------*/
  GPIO_InitStruct.Pin = BSP_MOTOR_CONTROL_BOARD_PIN_STBY_RESET;
 800e716:	0021      	movs	r1, r4
 800e718:	187b      	adds	r3, r7, r1
 800e71a:	2280      	movs	r2, #128	; 0x80
 800e71c:	0152      	lsls	r2, r2, #5
 800e71e:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800e720:	187b      	adds	r3, r7, r1
 800e722:	2201      	movs	r2, #1
 800e724:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800e726:	187b      	adds	r3, r7, r1
 800e728:	2200      	movs	r2, #0
 800e72a:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_MEDIUM;
 800e72c:	187b      	adds	r3, r7, r1
 800e72e:	2201      	movs	r2, #1
 800e730:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(BSP_MOTOR_CONTROL_BOARD_PORT_STBY_RESET, &GPIO_InitStruct);
 800e732:	187b      	adds	r3, r7, r1
 800e734:	4a06      	ldr	r2, [pc, #24]	; (800e750 <Stspin220_Board_GpioInit+0x118>)
 800e736:	0019      	movs	r1, r3
 800e738:	0010      	movs	r0, r2
 800e73a:	f001 f86f 	bl	800f81c <HAL_GPIO_Init>
  Stspin220_Board_Reset();
 800e73e:	f000 f987 	bl	800ea50 <Stspin220_Board_Reset>

}
 800e742:	46c0      	nop			; (mov r8, r8)
 800e744:	46bd      	mov	sp, r7
 800e746:	b009      	add	sp, #36	; 0x24
 800e748:	bd90      	pop	{r4, r7, pc}
 800e74a:	46c0      	nop			; (mov r8, r8)
 800e74c:	40021000 	.word	0x40021000
 800e750:	50000400 	.word	0x50000400

0800e754 <Stspin220_Board_TimStckStart>:
 * @brief  Starts the step clock
 * @retval None
 * @note The frequency is directly the current speed of the device
 **********************************************************/
void Stspin220_Board_TimStckStart()
{
 800e754:	b580      	push	{r7, lr}
 800e756:	af00      	add	r7, sp, #0
  {
    __HAL_TIM_CLEAR_IT(&hTimerStepClock, TIM_IT_CC1);
  }
  else if (BSP_MOTOR_CONTROL_BOARD_CHAN_TIM_STCK == TIM_CHANNEL_2)
  {
    __HAL_TIM_CLEAR_IT(&hTimerStepClock, TIM_IT_CC2);
 800e758:	4b0f      	ldr	r3, [pc, #60]	; (800e798 <Stspin220_Board_TimStckStart+0x44>)
 800e75a:	681b      	ldr	r3, [r3, #0]
 800e75c:	2205      	movs	r2, #5
 800e75e:	4252      	negs	r2, r2
 800e760:	611a      	str	r2, [r3, #16]
  {
    __HAL_TIM_CLEAR_IT(&hTimerStepClock, TIM_IT_CC4);
  }
  /* Start timer interrupts */
#if (BSP_MOTOR_CONTROL_BOARD_OUTPUT_TIM_STCK == TIMER_MAIN_OUTPUT)
    if (hTimerStepClock.Instance->CCER == 0)
 800e762:	4b0d      	ldr	r3, [pc, #52]	; (800e798 <Stspin220_Board_TimStckStart+0x44>)
 800e764:	681b      	ldr	r3, [r3, #0]
 800e766:	6a1b      	ldr	r3, [r3, #32]
 800e768:	2b00      	cmp	r3, #0
 800e76a:	d108      	bne.n	800e77e <Stspin220_Board_TimStckStart+0x2a>
  {
      hTimerStepClock.Instance->CCER |=\
 800e76c:	4b0a      	ldr	r3, [pc, #40]	; (800e798 <Stspin220_Board_TimStckStart+0x44>)
 800e76e:	681b      	ldr	r3, [r3, #0]
 800e770:	6a1a      	ldr	r2, [r3, #32]
 800e772:	4b09      	ldr	r3, [pc, #36]	; (800e798 <Stspin220_Board_TimStckStart+0x44>)
 800e774:	681b      	ldr	r3, [r3, #0]
 800e776:	2120      	movs	r1, #32
 800e778:	430a      	orrs	r2, r1
 800e77a:	621a      	str	r2, [r3, #32]
 800e77c:	e003      	b.n	800e786 <Stspin220_Board_TimStckStart+0x32>
      (TIM_OCPOLARITY_LOW<<BSP_MOTOR_CONTROL_BOARD_CHAN_TIM_STCK);
  }
  else
  {
      hTimerStepClock.Instance->CCER = 0;
 800e77e:	4b06      	ldr	r3, [pc, #24]	; (800e798 <Stspin220_Board_TimStckStart+0x44>)
 800e780:	681b      	ldr	r3, [r3, #0]
 800e782:	2200      	movs	r2, #0
 800e784:	621a      	str	r2, [r3, #32]
  }
  HAL_TIM_OC_Start_IT(&hTimerStepClock,\
 800e786:	4b04      	ldr	r3, [pc, #16]	; (800e798 <Stspin220_Board_TimStckStart+0x44>)
 800e788:	2104      	movs	r1, #4
 800e78a:	0018      	movs	r0, r3
 800e78c:	f002 ff80 	bl	8011690 <HAL_TIM_OC_Start_IT>
    BSP_MOTOR_CONTROL_BOARD_PIN_TIM_STCK_MODE3,\
        GPIO_PIN_RESET);
    HAL_TIM_OC_Start_IT(&hTimerStepClock,\
    BSP_MOTOR_CONTROL_BOARD_CHAN_TIM_STCK);
#endif /* (BSP_MOTOR_CONTROL_BOARD_OUTPUT_TIM_STCK == TIMER_NO_OUTPUT) */
}
 800e790:	46c0      	nop			; (mov r8, r8)
 800e792:	46bd      	mov	sp, r7
 800e794:	bd80      	pop	{r7, pc}
 800e796:	46c0      	nop			; (mov r8, r8)
 800e798:	200033c8 	.word	0x200033c8

0800e79c <Stspin220_Board_TimStckCompareInit>:
/******************************************************//**
 * @brief Step clock compare value initialization
 * @retval None
 **********************************************************/
void Stspin220_Board_TimStckCompareInit(void)
{
 800e79c:	b580      	push	{r7, lr}
 800e79e:	af00      	add	r7, sp, #0
  ccrValue = hTimerStepClock.Instance->CNT;
 800e7a0:	4b03      	ldr	r3, [pc, #12]	; (800e7b0 <Stspin220_Board_TimStckCompareInit+0x14>)
 800e7a2:	681b      	ldr	r3, [r3, #0]
 800e7a4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800e7a6:	4b03      	ldr	r3, [pc, #12]	; (800e7b4 <Stspin220_Board_TimStckCompareInit+0x18>)
 800e7a8:	601a      	str	r2, [r3, #0]
}
 800e7aa:	46c0      	nop			; (mov r8, r8)
 800e7ac:	46bd      	mov	sp, r7
 800e7ae:	bd80      	pop	{r7, pc}
 800e7b0:	200033c8 	.word	0x200033c8
 800e7b4:	200033c4 	.word	0x200033c4

0800e7b8 <Stspin220_Board_TimStckSetFreq>:
 * @param[in] newFreq in Hz
 * @retval None
 * @note The frequency is directly the current speed of the device
 **********************************************************/
void Stspin220_Board_TimStckSetFreq(uint16_t newFreq)
{
 800e7b8:	b580      	push	{r7, lr}
 800e7ba:	b082      	sub	sp, #8
 800e7bc:	af00      	add	r7, sp, #0
 800e7be:	0002      	movs	r2, r0
 800e7c0:	1dbb      	adds	r3, r7, #6
 800e7c2:	801a      	strh	r2, [r3, #0]
  ccrValue += (HAL_RCC_GetSysClockFreq()/\
 800e7c4:	f002 fce0 	bl	8011188 <HAL_RCC_GetSysClockFreq>
 800e7c8:	0002      	movs	r2, r0
                           (TIMER_PRESCALER * 2 * (uint32_t)newFreq));
 800e7ca:	1dbb      	adds	r3, r7, #6
 800e7cc:	881b      	ldrh	r3, [r3, #0]
 800e7ce:	019b      	lsls	r3, r3, #6
  ccrValue += (HAL_RCC_GetSysClockFreq()/\
 800e7d0:	0019      	movs	r1, r3
 800e7d2:	0010      	movs	r0, r2
 800e7d4:	f7f1 fcaa 	bl	800012c <__udivsi3>
 800e7d8:	0003      	movs	r3, r0
 800e7da:	001a      	movs	r2, r3
 800e7dc:	4b06      	ldr	r3, [pc, #24]	; (800e7f8 <Stspin220_Board_TimStckSetFreq+0x40>)
 800e7de:	681b      	ldr	r3, [r3, #0]
 800e7e0:	18d2      	adds	r2, r2, r3
 800e7e2:	4b05      	ldr	r3, [pc, #20]	; (800e7f8 <Stspin220_Board_TimStckSetFreq+0x40>)
 800e7e4:	601a      	str	r2, [r3, #0]
  __HAL_TIM_SetCompare(&hTimerStepClock,\
 800e7e6:	4b05      	ldr	r3, [pc, #20]	; (800e7fc <Stspin220_Board_TimStckSetFreq+0x44>)
 800e7e8:	681b      	ldr	r3, [r3, #0]
 800e7ea:	4a03      	ldr	r2, [pc, #12]	; (800e7f8 <Stspin220_Board_TimStckSetFreq+0x40>)
 800e7ec:	6812      	ldr	r2, [r2, #0]
 800e7ee:	639a      	str	r2, [r3, #56]	; 0x38
    BSP_MOTOR_CONTROL_BOARD_CHAN_TIM_STCK,\
    ccrValue);
}
 800e7f0:	46c0      	nop			; (mov r8, r8)
 800e7f2:	46bd      	mov	sp, r7
 800e7f4:	b002      	add	sp, #8
 800e7f6:	bd80      	pop	{r7, pc}
 800e7f8:	200033c4 	.word	0x200033c4
 800e7fc:	200033c8 	.word	0x200033c8

0800e800 <Stspin220_Board_PwmRefStart>:
/******************************************************//**
 * @brief  Starts the PWM used for the reference voltage generation
 * @retval None
 **********************************************************/
void Stspin220_Board_PwmRefStart(void)
{
 800e800:	b580      	push	{r7, lr}
 800e802:	af00      	add	r7, sp, #0
  HAL_TIM_PWM_Start_IT(&hTimerPwm,BSP_MOTOR_CONTROL_BOARD_CHAN_PWM_REF);  
 800e804:	4b05      	ldr	r3, [pc, #20]	; (800e81c <Stspin220_Board_PwmRefStart+0x1c>)
 800e806:	2104      	movs	r1, #4
 800e808:	0018      	movs	r0, r3
 800e80a:	f003 f811 	bl	8011830 <HAL_TIM_PWM_Start_IT>
  HAL_Delay(5*PWM_FILTER_TIME_CONSTANT);
 800e80e:	2019      	movs	r0, #25
 800e810:	f000 fe70 	bl	800f4f4 <HAL_Delay>
}
 800e814:	46c0      	nop			; (mov r8, r8)
 800e816:	46bd      	mov	sp, r7
 800e818:	bd80      	pop	{r7, pc}
 800e81a:	46c0      	nop			; (mov r8, r8)
 800e81c:	20003404 	.word	0x20003404

0800e820 <Stspin220_Board_PwmRefSetFreqAndDutyCycle>:
 * @param[in] newFreq in Hz
 * @param[in] dutyCycle 0 - 100%
 * @retval None
 **********************************************************/
void Stspin220_Board_PwmRefSetFreqAndDutyCycle(uint32_t newFreq, uint8_t dutyCycle)
{
 800e820:	b580      	push	{r7, lr}
 800e822:	b086      	sub	sp, #24
 800e824:	af00      	add	r7, sp, #0
 800e826:	6078      	str	r0, [r7, #4]
 800e828:	000a      	movs	r2, r1
 800e82a:	1cfb      	adds	r3, r7, #3
 800e82c:	701a      	strb	r2, [r3, #0]
  uint32_t sysFreq = HAL_RCC_GetSysClockFreq();
 800e82e:	f002 fcab 	bl	8011188 <HAL_RCC_GetSysClockFreq>
 800e832:	0003      	movs	r3, r0
 800e834:	617b      	str	r3, [r7, #20]
  uint32_t period = (sysFreq/newFreq) - 1;
 800e836:	6879      	ldr	r1, [r7, #4]
 800e838:	6978      	ldr	r0, [r7, #20]
 800e83a:	f7f1 fc77 	bl	800012c <__udivsi3>
 800e83e:	0003      	movs	r3, r0
 800e840:	3b01      	subs	r3, #1
 800e842:	613b      	str	r3, [r7, #16]
  uint16_t pulseLength;
  TIM_HandleTypeDef *pHTim;
  
  pHTim = &hTimerPwm;
 800e844:	4b15      	ldr	r3, [pc, #84]	; (800e89c <Stspin220_Board_PwmRefSetFreqAndDutyCycle+0x7c>)
 800e846:	60fb      	str	r3, [r7, #12]
  pHTim->Instance = BSP_MOTOR_CONTROL_BOARD_PWM_REF;
 800e848:	68fb      	ldr	r3, [r7, #12]
 800e84a:	4a15      	ldr	r2, [pc, #84]	; (800e8a0 <Stspin220_Board_PwmRefSetFreqAndDutyCycle+0x80>)
 800e84c:	601a      	str	r2, [r3, #0]
  
  if (dutyCycle > 100) dutyCycle = 100;
 800e84e:	1cfb      	adds	r3, r7, #3
 800e850:	781b      	ldrb	r3, [r3, #0]
 800e852:	2b64      	cmp	r3, #100	; 0x64
 800e854:	d902      	bls.n	800e85c <Stspin220_Board_PwmRefSetFreqAndDutyCycle+0x3c>
 800e856:	1cfb      	adds	r3, r7, #3
 800e858:	2264      	movs	r2, #100	; 0x64
 800e85a:	701a      	strb	r2, [r3, #0]
  pulseLength = (uint16_t)((period * (100-(uint32_t)dutyCycle)) / 100);
 800e85c:	1cfb      	adds	r3, r7, #3
 800e85e:	781b      	ldrb	r3, [r3, #0]
 800e860:	2264      	movs	r2, #100	; 0x64
 800e862:	1ad3      	subs	r3, r2, r3
 800e864:	693a      	ldr	r2, [r7, #16]
 800e866:	4353      	muls	r3, r2
 800e868:	2164      	movs	r1, #100	; 0x64
 800e86a:	0018      	movs	r0, r3
 800e86c:	f7f1 fc5e 	bl	800012c <__udivsi3>
 800e870:	0003      	movs	r3, r0
 800e872:	001a      	movs	r2, r3
 800e874:	210a      	movs	r1, #10
 800e876:	187b      	adds	r3, r7, r1
 800e878:	801a      	strh	r2, [r3, #0]
  
  __HAL_TIM_SetAutoreload(pHTim, period);
 800e87a:	68fb      	ldr	r3, [r7, #12]
 800e87c:	681b      	ldr	r3, [r3, #0]
 800e87e:	693a      	ldr	r2, [r7, #16]
 800e880:	62da      	str	r2, [r3, #44]	; 0x2c
 800e882:	68fb      	ldr	r3, [r7, #12]
 800e884:	693a      	ldr	r2, [r7, #16]
 800e886:	60da      	str	r2, [r3, #12]
  __HAL_TIM_SetCompare(pHTim, BSP_MOTOR_CONTROL_BOARD_CHAN_PWM_REF, pulseLength);
 800e888:	68fb      	ldr	r3, [r7, #12]
 800e88a:	681b      	ldr	r3, [r3, #0]
 800e88c:	187a      	adds	r2, r7, r1
 800e88e:	8812      	ldrh	r2, [r2, #0]
 800e890:	639a      	str	r2, [r3, #56]	; 0x38
}
 800e892:	46c0      	nop			; (mov r8, r8)
 800e894:	46bd      	mov	sp, r7
 800e896:	b006      	add	sp, #24
 800e898:	bd80      	pop	{r7, pc}
 800e89a:	46c0      	nop			; (mov r8, r8)
 800e89c:	20003404 	.word	0x20003404
 800e8a0:	40011400 	.word	0x40011400

0800e8a4 <Stspin220_Board_PwmRefInit>:
/******************************************************//**
 * @brief  Initialises the PWM used for the reference voltage generation
 * @retval None
 **********************************************************/
void Stspin220_Board_PwmRefInit(void)
{
 800e8a4:	b590      	push	{r4, r7, lr}
 800e8a6:	b089      	sub	sp, #36	; 0x24
 800e8a8:	af00      	add	r7, sp, #0
  TIM_OC_InitTypeDef sConfigOC;
  TIM_MasterConfigTypeDef sMasterConfig;
  TIM_HandleTypeDef *pHTim;

  pHTim = &hTimerPwm;
 800e8aa:	4b1a      	ldr	r3, [pc, #104]	; (800e914 <Stspin220_Board_PwmRefInit+0x70>)
 800e8ac:	61fb      	str	r3, [r7, #28]
  
  pHTim->Instance = BSP_MOTOR_CONTROL_BOARD_PWM_REF;
 800e8ae:	69fb      	ldr	r3, [r7, #28]
 800e8b0:	4a19      	ldr	r2, [pc, #100]	; (800e918 <Stspin220_Board_PwmRefInit+0x74>)
 800e8b2:	601a      	str	r2, [r3, #0]
  pHTim->Init.CounterMode = TIM_COUNTERMODE_UP;
 800e8b4:	69fb      	ldr	r3, [r7, #28]
 800e8b6:	2200      	movs	r2, #0
 800e8b8:	609a      	str	r2, [r3, #8]
  pHTim->Init.Prescaler = 0;
 800e8ba:	69fb      	ldr	r3, [r7, #28]
 800e8bc:	2200      	movs	r2, #0
 800e8be:	605a      	str	r2, [r3, #4]
  pHTim->Init.Period = 0;
 800e8c0:	69fb      	ldr	r3, [r7, #28]
 800e8c2:	2200      	movs	r2, #0
 800e8c4:	60da      	str	r2, [r3, #12]
  pHTim->Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 800e8c6:	69fb      	ldr	r3, [r7, #28]
 800e8c8:	2200      	movs	r2, #0
 800e8ca:	611a      	str	r2, [r3, #16]
  
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 800e8cc:	240c      	movs	r4, #12
 800e8ce:	193b      	adds	r3, r7, r4
 800e8d0:	2260      	movs	r2, #96	; 0x60
 800e8d2:	601a      	str	r2, [r3, #0]
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 800e8d4:	193b      	adds	r3, r7, r4
 800e8d6:	2200      	movs	r2, #0
 800e8d8:	60da      	str	r2, [r3, #12]
  sConfigOC.Pulse = 0;
 800e8da:	193b      	adds	r3, r7, r4
 800e8dc:	2200      	movs	r2, #0
 800e8de:	605a      	str	r2, [r3, #4]

  HAL_TIM_PWM_Init(pHTim);
 800e8e0:	69fb      	ldr	r3, [r7, #28]
 800e8e2:	0018      	movs	r0, r3
 800e8e4:	f002 ff78 	bl	80117d8 <HAL_TIM_PWM_Init>
  HAL_TIM_PWM_ConfigChannel(pHTim, &sConfigOC, BSP_MOTOR_CONTROL_BOARD_CHAN_PWM_REF);
 800e8e8:	1939      	adds	r1, r7, r4
 800e8ea:	69fb      	ldr	r3, [r7, #28]
 800e8ec:	2204      	movs	r2, #4
 800e8ee:	0018      	movs	r0, r3
 800e8f0:	f003 f926 	bl	8011b40 <HAL_TIM_PWM_ConfigChannel>

  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 800e8f4:	1d3b      	adds	r3, r7, #4
 800e8f6:	2200      	movs	r2, #0
 800e8f8:	601a      	str	r2, [r3, #0]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 800e8fa:	1d3b      	adds	r3, r7, #4
 800e8fc:	2200      	movs	r2, #0
 800e8fe:	605a      	str	r2, [r3, #4]
  HAL_TIMEx_MasterConfigSynchronization(pHTim, &sMasterConfig);
 800e900:	1d3a      	adds	r2, r7, #4
 800e902:	69fb      	ldr	r3, [r7, #28]
 800e904:	0011      	movs	r1, r2
 800e906:	0018      	movs	r0, r3
 800e908:	f003 fb77 	bl	8011ffa <HAL_TIMEx_MasterConfigSynchronization>
}
 800e90c:	46c0      	nop			; (mov r8, r8)
 800e90e:	46bd      	mov	sp, r7
 800e910:	b009      	add	sp, #36	; 0x24
 800e912:	bd90      	pop	{r4, r7, pc}
 800e914:	20003404 	.word	0x20003404
 800e918:	40011400 	.word	0x40011400

0800e91c <Stspin220_Board_TimStckInit>:
/******************************************************//**
 * @brief  Initialises the timer used for the step clock
 * @retval None
 **********************************************************/
void Stspin220_Board_TimStckInit(void)
{
 800e91c:	b590      	push	{r4, r7, lr}
 800e91e:	b089      	sub	sp, #36	; 0x24
 800e920:	af00      	add	r7, sp, #0
  TIM_OC_InitTypeDef sConfigOC;
  TIM_MasterConfigTypeDef sMasterConfig;
  TIM_HandleTypeDef *pHTim;

  pHTim = &hTimerStepClock;
 800e922:	4b27      	ldr	r3, [pc, #156]	; (800e9c0 <Stspin220_Board_TimStckInit+0xa4>)
 800e924:	61fb      	str	r3, [r7, #28]
  pHTim->Instance = BSP_MOTOR_CONTROL_BOARD_TIM_STCK;
 800e926:	69fb      	ldr	r3, [r7, #28]
 800e928:	2280      	movs	r2, #128	; 0x80
 800e92a:	05d2      	lsls	r2, r2, #23
 800e92c:	601a      	str	r2, [r3, #0]
  pHTim->Init.CounterMode = TIM_COUNTERMODE_UP;
 800e92e:	69fb      	ldr	r3, [r7, #28]
 800e930:	2200      	movs	r2, #0
 800e932:	609a      	str	r2, [r3, #8]
  pHTim->Init.Prescaler = TIMER_PRESCALER -1;
 800e934:	69fb      	ldr	r3, [r7, #28]
 800e936:	221f      	movs	r2, #31
 800e938:	605a      	str	r2, [r3, #4]
  pHTim->Init.Period = 0xFFFF;
 800e93a:	69fb      	ldr	r3, [r7, #28]
 800e93c:	4a21      	ldr	r2, [pc, #132]	; (800e9c4 <Stspin220_Board_TimStckInit+0xa8>)
 800e93e:	60da      	str	r2, [r3, #12]
  pHTim->Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 800e940:	69fb      	ldr	r3, [r7, #28]
 800e942:	2200      	movs	r2, #0
 800e944:	611a      	str	r2, [r3, #16]
  HAL_TIM_OC_Init(pHTim);  
 800e946:	69fb      	ldr	r3, [r7, #28]
 800e948:	0018      	movs	r0, r3
 800e94a:	f002 fe4b 	bl	80115e4 <HAL_TIM_OC_Init>

  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 800e94e:	210c      	movs	r1, #12
 800e950:	187b      	adds	r3, r7, r1
 800e952:	2200      	movs	r2, #0
 800e954:	609a      	str	r2, [r3, #8]
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 800e956:	187b      	adds	r3, r7, r1
 800e958:	2200      	movs	r2, #0
 800e95a:	60da      	str	r2, [r3, #12]
  sConfigOC.Pulse = 0;
 800e95c:	187b      	adds	r3, r7, r1
 800e95e:	2200      	movs	r2, #0
 800e960:	605a      	str	r2, [r3, #4]
  if (pHTim->Instance != TIM21)
 800e962:	69fb      	ldr	r3, [r7, #28]
 800e964:	681b      	ldr	r3, [r3, #0]
 800e966:	4a18      	ldr	r2, [pc, #96]	; (800e9c8 <Stspin220_Board_TimStckInit+0xac>)
 800e968:	4293      	cmp	r3, r2
 800e96a:	d00d      	beq.n	800e988 <Stspin220_Board_TimStckInit+0x6c>
  {
    /* Setting the OCMode to TIM_OCMODE_FORCED_ACTIVE ensures that on the */
    /* first interrupt occuring in the toggle mode, a rising edge will occur */
    sConfigOC.OCMode = TIM_OCMODE_FORCED_ACTIVE;
 800e96c:	240c      	movs	r4, #12
 800e96e:	193b      	adds	r3, r7, r4
 800e970:	2250      	movs	r2, #80	; 0x50
 800e972:	601a      	str	r2, [r3, #0]
    HAL_TIM_OC_ConfigChannel(pHTim, &sConfigOC, BSP_MOTOR_CONTROL_BOARD_CHAN_TIM_STCK);
 800e974:	1939      	adds	r1, r7, r4
 800e976:	69fb      	ldr	r3, [r7, #28]
 800e978:	2204      	movs	r2, #4
 800e97a:	0018      	movs	r0, r3
 800e97c:	f003 f892 	bl	8011aa4 <HAL_TIM_OC_ConfigChannel>
    sConfigOC.OCMode = TIM_OCMODE_TOGGLE;
 800e980:	193b      	adds	r3, r7, r4
 800e982:	2230      	movs	r2, #48	; 0x30
 800e984:	601a      	str	r2, [r3, #0]
 800e986:	e003      	b.n	800e990 <Stspin220_Board_TimStckInit+0x74>
  }
  else
  {
    sConfigOC.OCMode = TIM_OCMODE_TIMING;
 800e988:	230c      	movs	r3, #12
 800e98a:	18fb      	adds	r3, r7, r3
 800e98c:	2200      	movs	r2, #0
 800e98e:	601a      	str	r2, [r3, #0]
  }
  HAL_TIM_OC_ConfigChannel(pHTim, &sConfigOC, BSP_MOTOR_CONTROL_BOARD_CHAN_TIM_STCK);
 800e990:	230c      	movs	r3, #12
 800e992:	18f9      	adds	r1, r7, r3
 800e994:	69fb      	ldr	r3, [r7, #28]
 800e996:	2204      	movs	r2, #4
 800e998:	0018      	movs	r0, r3
 800e99a:	f003 f883 	bl	8011aa4 <HAL_TIM_OC_ConfigChannel>

  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 800e99e:	1d3b      	adds	r3, r7, #4
 800e9a0:	2200      	movs	r2, #0
 800e9a2:	601a      	str	r2, [r3, #0]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 800e9a4:	1d3b      	adds	r3, r7, #4
 800e9a6:	2200      	movs	r2, #0
 800e9a8:	605a      	str	r2, [r3, #4]
  HAL_TIMEx_MasterConfigSynchronization(pHTim, &sMasterConfig);
 800e9aa:	1d3a      	adds	r2, r7, #4
 800e9ac:	69fb      	ldr	r3, [r7, #28]
 800e9ae:	0011      	movs	r1, r2
 800e9b0:	0018      	movs	r0, r3
 800e9b2:	f003 fb22 	bl	8011ffa <HAL_TIMEx_MasterConfigSynchronization>
}
 800e9b6:	46c0      	nop			; (mov r8, r8)
 800e9b8:	46bd      	mov	sp, r7
 800e9ba:	b009      	add	sp, #36	; 0x24
 800e9bc:	bd90      	pop	{r4, r7, pc}
 800e9be:	46c0      	nop			; (mov r8, r8)
 800e9c0:	200033c8 	.word	0x200033c8
 800e9c4:	0000ffff 	.word	0x0000ffff
 800e9c8:	40010800 	.word	0x40010800

0800e9cc <Stspin220_Board_TimStckDeInit>:
/******************************************************//**
 * @brief  DeInitialises the timer used for the step clock
 * @retval None
 **********************************************************/
void Stspin220_Board_TimStckDeInit(void)
{
 800e9cc:	b580      	push	{r7, lr}
 800e9ce:	af00      	add	r7, sp, #0
  HAL_TIM_OC_DeInit(&hTimerStepClock);
 800e9d0:	4b03      	ldr	r3, [pc, #12]	; (800e9e0 <Stspin220_Board_TimStckDeInit+0x14>)
 800e9d2:	0018      	movs	r0, r3
 800e9d4:	f002 fe32 	bl	801163c <HAL_TIM_OC_DeInit>
}
 800e9d8:	46c0      	nop			; (mov r8, r8)
 800e9da:	46bd      	mov	sp, r7
 800e9dc:	bd80      	pop	{r7, pc}
 800e9de:	46c0      	nop			; (mov r8, r8)
 800e9e0:	200033c8 	.word	0x200033c8

0800e9e4 <Stspin220_Board_TimStckStop>:
 * @brief  Stops the timer
 * @param[in] pToggleOdd pointer to the volatile toggleOdd variable
 * @retval 1 if OK, 0 if STCK MODE3 pin is high (forbidden configuration) 
 **********************************************************/
uint8_t Stspin220_Board_TimStckStop(volatile uint8_t *pToggleOdd)
{
 800e9e4:	b580      	push	{r7, lr}
 800e9e6:	b082      	sub	sp, #8
 800e9e8:	af00      	add	r7, sp, #0
 800e9ea:	6078      	str	r0, [r7, #4]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800e9ec:	b672      	cpsid	i
  __disable_irq();
  if (*pToggleOdd == 1)
 800e9ee:	687b      	ldr	r3, [r7, #4]
 800e9f0:	781b      	ldrb	r3, [r3, #0]
 800e9f2:	b2db      	uxtb	r3, r3
 800e9f4:	2b01      	cmp	r3, #1
 800e9f6:	d102      	bne.n	800e9fe <Stspin220_Board_TimStckStop+0x1a>
  __ASM volatile ("cpsie i" : : : "memory");
 800e9f8:	b662      	cpsie	i
{
    __enable_irq();
    return 1;
 800e9fa:	2301      	movs	r3, #1
 800e9fc:	e012      	b.n	800ea24 <Stspin220_Board_TimStckStop+0x40>
  }
  if (HAL_GPIO_ReadPin(BSP_MOTOR_CONTROL_BOARD_PORT_TIM_STCK_MODE3,\
 800e9fe:	4b0b      	ldr	r3, [pc, #44]	; (800ea2c <Stspin220_Board_TimStckStop+0x48>)
 800ea00:	2108      	movs	r1, #8
 800ea02:	0018      	movs	r0, r3
 800ea04:	f001 f96a 	bl	800fcdc <HAL_GPIO_ReadPin>
 800ea08:	1e03      	subs	r3, r0, #0
 800ea0a:	d002      	beq.n	800ea12 <Stspin220_Board_TimStckStop+0x2e>
 800ea0c:	b662      	cpsie	i
    BSP_MOTOR_CONTROL_BOARD_PIN_TIM_STCK_MODE3) != 0)
  {
    __enable_irq();
    return 0;
 800ea0e:	2300      	movs	r3, #0
 800ea10:	e008      	b.n	800ea24 <Stspin220_Board_TimStckStop+0x40>
  }
#if (BSP_MOTOR_CONTROL_BOARD_OUTPUT_TIM_STCK == TIMER_COMPLEMENTARY_OUTPUT)
  HAL_TIMEx_OCN_Stop_IT(&hTimerStepClock, BSP_MOTOR_CONTROL_BOARD_CHAN_TIM_STCK);
#else
  HAL_TIM_OC_Stop_IT(&hTimerStepClock,BSP_MOTOR_CONTROL_BOARD_CHAN_TIM_STCK);
 800ea12:	4b07      	ldr	r3, [pc, #28]	; (800ea30 <Stspin220_Board_TimStckStop+0x4c>)
 800ea14:	2104      	movs	r1, #4
 800ea16:	0018      	movs	r0, r3
 800ea18:	f002 fe8c 	bl	8011734 <HAL_TIM_OC_Stop_IT>
 800ea1c:	b662      	cpsie	i
#endif
  __enable_irq();
  /* DeInitialize the step clock timer */
  Stspin220_Board_TimStckDeInit();
 800ea1e:	f7ff ffd5 	bl	800e9cc <Stspin220_Board_TimStckDeInit>
  return 1;
 800ea22:	2301      	movs	r3, #1
}
 800ea24:	0018      	movs	r0, r3
 800ea26:	46bd      	mov	sp, r7
 800ea28:	b002      	add	sp, #8
 800ea2a:	bd80      	pop	{r7, pc}
 800ea2c:	50000400 	.word	0x50000400
 800ea30:	200033c8 	.word	0x200033c8

0800ea34 <Stspin220_Board_ReleaseReset>:
/******************************************************//**
 * @brief  Releases the STSPIN220 reset (pin set to High)
 * @retval None
 **********************************************************/
void Stspin220_Board_ReleaseReset(void)
{ 
 800ea34:	b580      	push	{r7, lr}
 800ea36:	af00      	add	r7, sp, #0
  HAL_GPIO_WritePin(BSP_MOTOR_CONTROL_BOARD_PORT_STBY_RESET,\
 800ea38:	2380      	movs	r3, #128	; 0x80
 800ea3a:	015b      	lsls	r3, r3, #5
 800ea3c:	4803      	ldr	r0, [pc, #12]	; (800ea4c <Stspin220_Board_ReleaseReset+0x18>)
 800ea3e:	2201      	movs	r2, #1
 800ea40:	0019      	movs	r1, r3
 800ea42:	f001 f968 	bl	800fd16 <HAL_GPIO_WritePin>
    BSP_MOTOR_CONTROL_BOARD_PIN_STBY_RESET,\
    GPIO_PIN_SET);
}
 800ea46:	46c0      	nop			; (mov r8, r8)
 800ea48:	46bd      	mov	sp, r7
 800ea4a:	bd80      	pop	{r7, pc}
 800ea4c:	50000400 	.word	0x50000400

0800ea50 <Stspin220_Board_Reset>:
/******************************************************//**
 * @brief  Resets the STSPIN220 (reset pin set to low)
 * @retval None
 **********************************************************/
void Stspin220_Board_Reset(void)
{
 800ea50:	b580      	push	{r7, lr}
 800ea52:	af00      	add	r7, sp, #0
  HAL_GPIO_WritePin(BSP_MOTOR_CONTROL_BOARD_PORT_STBY_RESET,\
 800ea54:	2380      	movs	r3, #128	; 0x80
 800ea56:	015b      	lsls	r3, r3, #5
 800ea58:	4803      	ldr	r0, [pc, #12]	; (800ea68 <Stspin220_Board_Reset+0x18>)
 800ea5a:	2200      	movs	r2, #0
 800ea5c:	0019      	movs	r1, r3
 800ea5e:	f001 f95a 	bl	800fd16 <HAL_GPIO_WritePin>
    BSP_MOTOR_CONTROL_BOARD_PIN_STBY_RESET,\
    GPIO_PIN_RESET);
}
 800ea62:	46c0      	nop			; (mov r8, r8)
 800ea64:	46bd      	mov	sp, r7
 800ea66:	bd80      	pop	{r7, pc}
 800ea68:	50000400 	.word	0x50000400

0800ea6c <Stspin220_Board_SetDirectionGpio>:
 * @brief  Set the GPIO used for the direction
 * @param[in] gpioState state of the direction gpio (0 to reset, 1 to set)
 * @retval None
 **********************************************************/
void Stspin220_Board_SetDirectionGpio(uint8_t gpioState)
{
 800ea6c:	b580      	push	{r7, lr}
 800ea6e:	b082      	sub	sp, #8
 800ea70:	af00      	add	r7, sp, #0
 800ea72:	0002      	movs	r2, r0
 800ea74:	1dfb      	adds	r3, r7, #7
 800ea76:	701a      	strb	r2, [r3, #0]
  HAL_GPIO_WritePin(BSP_MOTOR_CONTROL_BOARD_PORT_DIR_MODE4,\
 800ea78:	1dfb      	adds	r3, r7, #7
 800ea7a:	781a      	ldrb	r2, [r3, #0]
 800ea7c:	2380      	movs	r3, #128	; 0x80
 800ea7e:	0059      	lsls	r1, r3, #1
 800ea80:	23a0      	movs	r3, #160	; 0xa0
 800ea82:	05db      	lsls	r3, r3, #23
 800ea84:	0018      	movs	r0, r3
 800ea86:	f001 f946 	bl	800fd16 <HAL_GPIO_WritePin>
    BSP_MOTOR_CONTROL_BOARD_PIN_DIR_MODE4,\
    (GPIO_PinState)gpioState);
}
 800ea8a:	46c0      	nop			; (mov r8, r8)
 800ea8c:	46bd      	mov	sp, r7
 800ea8e:	b002      	add	sp, #8
 800ea90:	bd80      	pop	{r7, pc}
	...

0800ea94 <Stspin220_Board_Disable>:
 * @brief Disable the power bridges (leave the output bridges HiZ)
 * the IHM06A1 board
 * @retval None
 **********************************************************/
void Stspin220_Board_Disable(void)
{
 800ea94:	b580      	push	{r7, lr}
 800ea96:	b086      	sub	sp, #24
 800ea98:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct;
  
  /* Configure the GPIO connected to EN pin as an output */
  GPIO_InitStruct.Pin = BSP_MOTOR_CONTROL_BOARD_PIN_EN_AND_FAULT;
 800ea9a:	1d3b      	adds	r3, r7, #4
 800ea9c:	2280      	movs	r2, #128	; 0x80
 800ea9e:	0192      	lsls	r2, r2, #6
 800eaa0:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800eaa2:	1d3b      	adds	r3, r7, #4
 800eaa4:	2201      	movs	r2, #1
 800eaa6:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800eaa8:	1d3b      	adds	r3, r7, #4
 800eaaa:	2200      	movs	r2, #0
 800eaac:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_MEDIUM;
 800eaae:	1d3b      	adds	r3, r7, #4
 800eab0:	2201      	movs	r2, #1
 800eab2:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(BSP_MOTOR_CONTROL_BOARD_PORT_EN_AND_FAULT, &GPIO_InitStruct);
 800eab4:	1d3b      	adds	r3, r7, #4
 800eab6:	4a0b      	ldr	r2, [pc, #44]	; (800eae4 <Stspin220_Board_Disable+0x50>)
 800eab8:	0019      	movs	r1, r3
 800eaba:	0010      	movs	r0, r2
 800eabc:	f000 feae 	bl	800f81c <HAL_GPIO_Init>
  __ASM volatile ("cpsid i" : : : "memory");
 800eac0:	b672      	cpsid	i
  __disable_irq();
  HAL_GPIO_WritePin(BSP_MOTOR_CONTROL_BOARD_PORT_EN_AND_FAULT,\
 800eac2:	2380      	movs	r3, #128	; 0x80
 800eac4:	019b      	lsls	r3, r3, #6
 800eac6:	4807      	ldr	r0, [pc, #28]	; (800eae4 <Stspin220_Board_Disable+0x50>)
 800eac8:	2200      	movs	r2, #0
 800eaca:	0019      	movs	r1, r3
 800eacc:	f001 f923 	bl	800fd16 <HAL_GPIO_WritePin>
    BSP_MOTOR_CONTROL_BOARD_PIN_EN_AND_FAULT,\
    GPIO_PIN_RESET);
  __HAL_GPIO_EXTI_CLEAR_IT(BSP_MOTOR_CONTROL_BOARD_PIN_EN_AND_FAULT);
 800ead0:	4b05      	ldr	r3, [pc, #20]	; (800eae8 <Stspin220_Board_Disable+0x54>)
 800ead2:	2280      	movs	r2, #128	; 0x80
 800ead4:	0192      	lsls	r2, r2, #6
 800ead6:	615a      	str	r2, [r3, #20]
  __ASM volatile ("cpsie i" : : : "memory");
 800ead8:	b662      	cpsie	i
  __enable_irq();
}
 800eada:	46c0      	nop			; (mov r8, r8)
 800eadc:	46bd      	mov	sp, r7
 800eade:	b006      	add	sp, #24
 800eae0:	bd80      	pop	{r7, pc}
 800eae2:	46c0      	nop			; (mov r8, r8)
 800eae4:	50000400 	.word	0x50000400
 800eae8:	40010400 	.word	0x40010400

0800eaec <Stspin220_Board_Enable>:
/******************************************************//**
 * @brief Enable the power bridges (leave the output bridges HiZ)
 * @retval None
 **********************************************************/
void Stspin220_Board_Enable(void)
{
 800eaec:	b580      	push	{r7, lr}
 800eaee:	b086      	sub	sp, #24
 800eaf0:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct;
  if (HAL_GPIO_ReadPin(BSP_MOTOR_CONTROL_BOARD_PORT_EN_AND_FAULT,BSP_MOTOR_CONTROL_BOARD_PIN_EN_AND_FAULT) == 0)
 800eaf2:	2380      	movs	r3, #128	; 0x80
 800eaf4:	019b      	lsls	r3, r3, #6
 800eaf6:	4a19      	ldr	r2, [pc, #100]	; (800eb5c <Stspin220_Board_Enable+0x70>)
 800eaf8:	0019      	movs	r1, r3
 800eafa:	0010      	movs	r0, r2
 800eafc:	f001 f8ee 	bl	800fcdc <HAL_GPIO_ReadPin>
 800eb00:	1e03      	subs	r3, r0, #0
 800eb02:	d126      	bne.n	800eb52 <Stspin220_Board_Enable+0x66>
  {
  HAL_GPIO_WritePin(BSP_MOTOR_CONTROL_BOARD_PORT_EN_AND_FAULT, BSP_MOTOR_CONTROL_BOARD_PIN_EN_AND_FAULT, GPIO_PIN_SET);
 800eb04:	2380      	movs	r3, #128	; 0x80
 800eb06:	019b      	lsls	r3, r3, #6
 800eb08:	4814      	ldr	r0, [pc, #80]	; (800eb5c <Stspin220_Board_Enable+0x70>)
 800eb0a:	2201      	movs	r2, #1
 800eb0c:	0019      	movs	r1, r3
 800eb0e:	f001 f902 	bl	800fd16 <HAL_GPIO_WritePin>
  HAL_Delay(BRIDGE_TURN_ON_DELAY);
 800eb12:	200a      	movs	r0, #10
 800eb14:	f000 fcee 	bl	800f4f4 <HAL_Delay>
  /* Configure the GPIO connected to EN pin to take interrupt */
  GPIO_InitStruct.Pin = BSP_MOTOR_CONTROL_BOARD_PIN_EN_AND_FAULT;
 800eb18:	1d3b      	adds	r3, r7, #4
 800eb1a:	2280      	movs	r2, #128	; 0x80
 800eb1c:	0192      	lsls	r2, r2, #6
 800eb1e:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 800eb20:	1d3b      	adds	r3, r7, #4
 800eb22:	4a0f      	ldr	r2, [pc, #60]	; (800eb60 <Stspin220_Board_Enable+0x74>)
 800eb24:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 800eb26:	1d3b      	adds	r3, r7, #4
 800eb28:	2201      	movs	r2, #1
 800eb2a:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_MEDIUM;
 800eb2c:	1d3b      	adds	r3, r7, #4
 800eb2e:	2201      	movs	r2, #1
 800eb30:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(BSP_MOTOR_CONTROL_BOARD_PORT_EN_AND_FAULT, &GPIO_InitStruct);
 800eb32:	1d3b      	adds	r3, r7, #4
 800eb34:	4a09      	ldr	r2, [pc, #36]	; (800eb5c <Stspin220_Board_Enable+0x70>)
 800eb36:	0019      	movs	r1, r3
 800eb38:	0010      	movs	r0, r2
 800eb3a:	f000 fe6f 	bl	800f81c <HAL_GPIO_Init>
  __HAL_GPIO_EXTI_CLEAR_IT(BSP_MOTOR_CONTROL_BOARD_PIN_EN_AND_FAULT);
 800eb3e:	4b09      	ldr	r3, [pc, #36]	; (800eb64 <Stspin220_Board_Enable+0x78>)
 800eb40:	2280      	movs	r2, #128	; 0x80
 800eb42:	0192      	lsls	r2, r2, #6
 800eb44:	615a      	str	r2, [r3, #20]
  HAL_NVIC_ClearPendingIRQ(BSP_MOTOR_CONTROL_BOARD_IRQn_EN_AND_FAULT);
 800eb46:	2007      	movs	r0, #7
 800eb48:	f000 fe10 	bl	800f76c <HAL_NVIC_ClearPendingIRQ>
  HAL_NVIC_EnableIRQ(BSP_MOTOR_CONTROL_BOARD_IRQn_EN_AND_FAULT);  
 800eb4c:	2007      	movs	r0, #7
 800eb4e:	f000 fde0 	bl	800f712 <HAL_NVIC_EnableIRQ>
  }
}
 800eb52:	46c0      	nop			; (mov r8, r8)
 800eb54:	46bd      	mov	sp, r7
 800eb56:	b006      	add	sp, #24
 800eb58:	bd80      	pop	{r7, pc}
 800eb5a:	46c0      	nop			; (mov r8, r8)
 800eb5c:	50000400 	.word	0x50000400
 800eb60:	10210000 	.word	0x10210000
 800eb64:	40010400 	.word	0x40010400

0800eb68 <Stspin220_Board_EN_AND_FAULT_PIN_GetState>:
/******************************************************//**
 * @brief  Returns the EN FAULT pin state.
 * @retval The EN FAULT pin value.
 **********************************************************/
uint32_t Stspin220_Board_EN_AND_FAULT_PIN_GetState(void)
{
 800eb68:	b580      	push	{r7, lr}
 800eb6a:	af00      	add	r7, sp, #0
  return HAL_GPIO_ReadPin(BSP_MOTOR_CONTROL_BOARD_PORT_EN_AND_FAULT, BSP_MOTOR_CONTROL_BOARD_PIN_EN_AND_FAULT);
 800eb6c:	2380      	movs	r3, #128	; 0x80
 800eb6e:	019b      	lsls	r3, r3, #6
 800eb70:	4a04      	ldr	r2, [pc, #16]	; (800eb84 <Stspin220_Board_EN_AND_FAULT_PIN_GetState+0x1c>)
 800eb72:	0019      	movs	r1, r3
 800eb74:	0010      	movs	r0, r2
 800eb76:	f001 f8b1 	bl	800fcdc <HAL_GPIO_ReadPin>
 800eb7a:	0003      	movs	r3, r0
}
 800eb7c:	0018      	movs	r0, r3
 800eb7e:	46bd      	mov	sp, r7
 800eb80:	bd80      	pop	{r7, pc}
 800eb82:	46c0      	nop			; (mov r8, r8)
 800eb84:	50000400 	.word	0x50000400

0800eb88 <Stspin220_Board_SetModePins>:
 **********************************************************/
uint8_t Stspin220_Board_SetModePins(uint8_t modePin1Level,\
  uint8_t modePin2Level,\
  uint8_t modePin3Level,\
  uint8_t modePin4Level)
{
 800eb88:	b5b0      	push	{r4, r5, r7, lr}
 800eb8a:	b088      	sub	sp, #32
 800eb8c:	af00      	add	r7, sp, #0
 800eb8e:	0005      	movs	r5, r0
 800eb90:	000c      	movs	r4, r1
 800eb92:	0010      	movs	r0, r2
 800eb94:	0019      	movs	r1, r3
 800eb96:	1dfb      	adds	r3, r7, #7
 800eb98:	1c2a      	adds	r2, r5, #0
 800eb9a:	701a      	strb	r2, [r3, #0]
 800eb9c:	1dbb      	adds	r3, r7, #6
 800eb9e:	1c22      	adds	r2, r4, #0
 800eba0:	701a      	strb	r2, [r3, #0]
 800eba2:	1d7b      	adds	r3, r7, #5
 800eba4:	1c02      	adds	r2, r0, #0
 800eba6:	701a      	strb	r2, [r3, #0]
 800eba8:	1d3b      	adds	r3, r7, #4
 800ebaa:	1c0a      	adds	r2, r1, #0
 800ebac:	701a      	strb	r2, [r3, #0]
  GPIO_InitTypeDef GPIO_InitStruct;
  
  if (modePin1Level != 0)
 800ebae:	1dfb      	adds	r3, r7, #7
 800ebb0:	781b      	ldrb	r3, [r3, #0]
 800ebb2:	2b00      	cmp	r3, #0
 800ebb4:	d006      	beq.n	800ebc4 <Stspin220_Board_SetModePins+0x3c>
{
    HAL_GPIO_WritePin(BSP_MOTOR_CONTROL_BOARD_PORT_MODE1,\
 800ebb6:	4b2f      	ldr	r3, [pc, #188]	; (800ec74 <Stspin220_Board_SetModePins+0xec>)
 800ebb8:	2201      	movs	r2, #1
 800ebba:	2110      	movs	r1, #16
 800ebbc:	0018      	movs	r0, r3
 800ebbe:	f001 f8aa 	bl	800fd16 <HAL_GPIO_WritePin>
 800ebc2:	e005      	b.n	800ebd0 <Stspin220_Board_SetModePins+0x48>
      BSP_MOTOR_CONTROL_BOARD_PIN_MODE1,\
      GPIO_PIN_SET);
  }
  else
  {
    HAL_GPIO_WritePin(BSP_MOTOR_CONTROL_BOARD_PORT_MODE1,\
 800ebc4:	4b2b      	ldr	r3, [pc, #172]	; (800ec74 <Stspin220_Board_SetModePins+0xec>)
 800ebc6:	2200      	movs	r2, #0
 800ebc8:	2110      	movs	r1, #16
 800ebca:	0018      	movs	r0, r3
 800ebcc:	f001 f8a3 	bl	800fd16 <HAL_GPIO_WritePin>
      BSP_MOTOR_CONTROL_BOARD_PIN_MODE1,\
      GPIO_PIN_RESET);
  }

  if (modePin2Level != 0)
 800ebd0:	1dbb      	adds	r3, r7, #6
 800ebd2:	781b      	ldrb	r3, [r3, #0]
 800ebd4:	2b00      	cmp	r3, #0
 800ebd6:	d006      	beq.n	800ebe6 <Stspin220_Board_SetModePins+0x5e>
  {
    HAL_GPIO_WritePin(BSP_MOTOR_CONTROL_BOARD_PORT_MODE2,\
 800ebd8:	4b26      	ldr	r3, [pc, #152]	; (800ec74 <Stspin220_Board_SetModePins+0xec>)
 800ebda:	2201      	movs	r2, #1
 800ebdc:	2140      	movs	r1, #64	; 0x40
 800ebde:	0018      	movs	r0, r3
 800ebe0:	f001 f899 	bl	800fd16 <HAL_GPIO_WritePin>
 800ebe4:	e005      	b.n	800ebf2 <Stspin220_Board_SetModePins+0x6a>
      BSP_MOTOR_CONTROL_BOARD_PIN_MODE2,\
      GPIO_PIN_SET);
  }
  else
  {
    HAL_GPIO_WritePin(BSP_MOTOR_CONTROL_BOARD_PORT_MODE2,\
 800ebe6:	4b23      	ldr	r3, [pc, #140]	; (800ec74 <Stspin220_Board_SetModePins+0xec>)
 800ebe8:	2200      	movs	r2, #0
 800ebea:	2140      	movs	r1, #64	; 0x40
 800ebec:	0018      	movs	r0, r3
 800ebee:	f001 f892 	bl	800fd16 <HAL_GPIO_WritePin>
      BSP_MOTOR_CONTROL_BOARD_PIN_MODE2,\
      GPIO_PIN_RESET);
  }

  Stspin220_Board_TimStckDeInit();
 800ebf2:	f7ff feeb 	bl	800e9cc <Stspin220_Board_TimStckDeInit>
  GPIO_InitStruct.Pin = BSP_MOTOR_CONTROL_BOARD_PIN_TIM_STCK_MODE3;
 800ebf6:	210c      	movs	r1, #12
 800ebf8:	187b      	adds	r3, r7, r1
 800ebfa:	2208      	movs	r2, #8
 800ebfc:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800ebfe:	187b      	adds	r3, r7, r1
 800ec00:	2201      	movs	r2, #1
 800ec02:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800ec04:	187b      	adds	r3, r7, r1
 800ec06:	2200      	movs	r2, #0
 800ec08:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_MEDIUM;
 800ec0a:	187b      	adds	r3, r7, r1
 800ec0c:	2201      	movs	r2, #1
 800ec0e:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(BSP_MOTOR_CONTROL_BOARD_PORT_TIM_STCK_MODE3, &GPIO_InitStruct);
 800ec10:	187b      	adds	r3, r7, r1
 800ec12:	4a18      	ldr	r2, [pc, #96]	; (800ec74 <Stspin220_Board_SetModePins+0xec>)
 800ec14:	0019      	movs	r1, r3
 800ec16:	0010      	movs	r0, r2
 800ec18:	f000 fe00 	bl	800f81c <HAL_GPIO_Init>
  
  if (modePin3Level != 0)
 800ec1c:	1d7b      	adds	r3, r7, #5
 800ec1e:	781b      	ldrb	r3, [r3, #0]
 800ec20:	2b00      	cmp	r3, #0
 800ec22:	d006      	beq.n	800ec32 <Stspin220_Board_SetModePins+0xaa>
  {
    HAL_GPIO_WritePin(BSP_MOTOR_CONTROL_BOARD_PORT_TIM_STCK_MODE3,\
 800ec24:	4b13      	ldr	r3, [pc, #76]	; (800ec74 <Stspin220_Board_SetModePins+0xec>)
 800ec26:	2201      	movs	r2, #1
 800ec28:	2108      	movs	r1, #8
 800ec2a:	0018      	movs	r0, r3
 800ec2c:	f001 f873 	bl	800fd16 <HAL_GPIO_WritePin>
 800ec30:	e005      	b.n	800ec3e <Stspin220_Board_SetModePins+0xb6>
      BSP_MOTOR_CONTROL_BOARD_PIN_TIM_STCK_MODE3,\
      GPIO_PIN_SET);
  }
  else
  {
    HAL_GPIO_WritePin(BSP_MOTOR_CONTROL_BOARD_PORT_TIM_STCK_MODE3,\
 800ec32:	4b10      	ldr	r3, [pc, #64]	; (800ec74 <Stspin220_Board_SetModePins+0xec>)
 800ec34:	2200      	movs	r2, #0
 800ec36:	2108      	movs	r1, #8
 800ec38:	0018      	movs	r0, r3
 800ec3a:	f001 f86c 	bl	800fd16 <HAL_GPIO_WritePin>
      BSP_MOTOR_CONTROL_BOARD_PIN_TIM_STCK_MODE3,\
      GPIO_PIN_RESET);
  }
  
  if (modePin4Level != 0)
 800ec3e:	1d3b      	adds	r3, r7, #4
 800ec40:	781b      	ldrb	r3, [r3, #0]
 800ec42:	2b00      	cmp	r3, #0
 800ec44:	d008      	beq.n	800ec58 <Stspin220_Board_SetModePins+0xd0>
  {
    HAL_GPIO_WritePin(BSP_MOTOR_CONTROL_BOARD_PORT_DIR_MODE4,\
 800ec46:	2380      	movs	r3, #128	; 0x80
 800ec48:	0059      	lsls	r1, r3, #1
 800ec4a:	23a0      	movs	r3, #160	; 0xa0
 800ec4c:	05db      	lsls	r3, r3, #23
 800ec4e:	2201      	movs	r2, #1
 800ec50:	0018      	movs	r0, r3
 800ec52:	f001 f860 	bl	800fd16 <HAL_GPIO_WritePin>
 800ec56:	e007      	b.n	800ec68 <Stspin220_Board_SetModePins+0xe0>
      BSP_MOTOR_CONTROL_BOARD_PIN_DIR_MODE4,\
      GPIO_PIN_SET);
  }
  else
  {
    HAL_GPIO_WritePin(BSP_MOTOR_CONTROL_BOARD_PORT_DIR_MODE4,\
 800ec58:	2380      	movs	r3, #128	; 0x80
 800ec5a:	0059      	lsls	r1, r3, #1
 800ec5c:	23a0      	movs	r3, #160	; 0xa0
 800ec5e:	05db      	lsls	r3, r3, #23
 800ec60:	2200      	movs	r2, #0
 800ec62:	0018      	movs	r0, r3
 800ec64:	f001 f857 	bl	800fd16 <HAL_GPIO_WritePin>
      BSP_MOTOR_CONTROL_BOARD_PIN_DIR_MODE4,\
      GPIO_PIN_RESET);
  }
  
  return 1;
 800ec68:	2301      	movs	r3, #1
}
 800ec6a:	0018      	movs	r0, r3
 800ec6c:	46bd      	mov	sp, r7
 800ec6e:	b008      	add	sp, #32
 800ec70:	bdb0      	pop	{r4, r5, r7, pc}
 800ec72:	46c0      	nop			; (mov r8, r8)
 800ec74:	50000400 	.word	0x50000400

0800ec78 <Stspin220_Board_SetFullStep>:
/******************************************************//**
 * @brief Select Full Step mode
 * @retval None
 **********************************************************/
void Stspin220_Board_SetFullStep(void)
{
 800ec78:	b580      	push	{r7, lr}
 800ec7a:	af00      	add	r7, sp, #0
  HAL_GPIO_WritePin(BSP_MOTOR_CONTROL_BOARD_PORT_MODE1,\
 800ec7c:	4b07      	ldr	r3, [pc, #28]	; (800ec9c <Stspin220_Board_SetFullStep+0x24>)
 800ec7e:	2200      	movs	r2, #0
 800ec80:	2110      	movs	r1, #16
 800ec82:	0018      	movs	r0, r3
 800ec84:	f001 f847 	bl	800fd16 <HAL_GPIO_WritePin>
    BSP_MOTOR_CONTROL_BOARD_PIN_MODE1,\
    GPIO_PIN_RESET);
  HAL_GPIO_WritePin(BSP_MOTOR_CONTROL_BOARD_PORT_MODE2,\
 800ec88:	4b04      	ldr	r3, [pc, #16]	; (800ec9c <Stspin220_Board_SetFullStep+0x24>)
 800ec8a:	2200      	movs	r2, #0
 800ec8c:	2140      	movs	r1, #64	; 0x40
 800ec8e:	0018      	movs	r0, r3
 800ec90:	f001 f841 	bl	800fd16 <HAL_GPIO_WritePin>
    BSP_MOTOR_CONTROL_BOARD_PIN_MODE2,\
    GPIO_PIN_RESET);
}
 800ec94:	46c0      	nop			; (mov r8, r8)
 800ec96:	46bd      	mov	sp, r7
 800ec98:	bd80      	pop	{r7, pc}
 800ec9a:	46c0      	nop			; (mov r8, r8)
 800ec9c:	50000400 	.word	0x50000400

0800eca0 <Stspin220_Board_UnsetFullStep>:
/******************************************************//**
 * @brief Unselect Full Step mode
 * @retval None
 **********************************************************/
void Stspin220_Board_UnsetFullStep(void)
{
 800eca0:	b580      	push	{r7, lr}
 800eca2:	af00      	add	r7, sp, #0
  HAL_GPIO_WritePin(BSP_MOTOR_CONTROL_BOARD_PORT_MODE1,\
 800eca4:	4b04      	ldr	r3, [pc, #16]	; (800ecb8 <Stspin220_Board_UnsetFullStep+0x18>)
 800eca6:	2201      	movs	r2, #1
 800eca8:	2110      	movs	r1, #16
 800ecaa:	0018      	movs	r0, r3
 800ecac:	f001 f833 	bl	800fd16 <HAL_GPIO_WritePin>
    BSP_MOTOR_CONTROL_BOARD_PIN_MODE1,\
    GPIO_PIN_SET);
}
 800ecb0:	46c0      	nop			; (mov r8, r8)
 800ecb2:	46bd      	mov	sp, r7
 800ecb4:	bd80      	pop	{r7, pc}
 800ecb6:	46c0      	nop			; (mov r8, r8)
 800ecb8:	50000400 	.word	0x50000400

0800ecbc <L6474_GetMotorHandle>:

/** @defgroup MOTOR_CONTROL_Weak_Private_Functions MOTOR CONTROL Weak Private Functions
 * @{
 */
/// Get motor handle for L6474
__weak motorDrv_t* L6474_GetMotorHandle(void){return ((motorDrv_t* )0);}
 800ecbc:	b580      	push	{r7, lr}
 800ecbe:	af00      	add	r7, sp, #0
 800ecc0:	2300      	movs	r3, #0
 800ecc2:	0018      	movs	r0, r3
 800ecc4:	46bd      	mov	sp, r7
 800ecc6:	bd80      	pop	{r7, pc}

0800ecc8 <l647x_GetMotorHandle>:
/// Get motor handle for L647x
__weak motorDrv_t* l647x_GetMotorHandle(void){return ((motorDrv_t* )0);}
 800ecc8:	b580      	push	{r7, lr}
 800ecca:	af00      	add	r7, sp, #0
 800eccc:	2300      	movs	r3, #0
 800ecce:	0018      	movs	r0, r3
 800ecd0:	46bd      	mov	sp, r7
 800ecd2:	bd80      	pop	{r7, pc}

0800ecd4 <l648x_GetMotorHandle>:
/// Get motor handle for L648x
__weak motorDrv_t* l648x_GetMotorHandle(void){return ((motorDrv_t* )0);}
 800ecd4:	b580      	push	{r7, lr}
 800ecd6:	af00      	add	r7, sp, #0
 800ecd8:	2300      	movs	r3, #0
 800ecda:	0018      	movs	r0, r3
 800ecdc:	46bd      	mov	sp, r7
 800ecde:	bd80      	pop	{r7, pc}

0800ece0 <Powerstep01_GetMotorHandle>:
/// Get motor handle for Powerstep
__weak motorDrv_t* Powerstep01_GetMotorHandle(void){return ((motorDrv_t* )0);}
 800ece0:	b580      	push	{r7, lr}
 800ece2:	af00      	add	r7, sp, #0
 800ece4:	2300      	movs	r3, #0
 800ece6:	0018      	movs	r0, r3
 800ece8:	46bd      	mov	sp, r7
 800ecea:	bd80      	pop	{r7, pc}

0800ecec <L6206_GetMotorHandle>:
/// Get motor handle for L6206
__weak motorDrv_t* L6206_GetMotorHandle(void){return ((motorDrv_t* )0);}
 800ecec:	b580      	push	{r7, lr}
 800ecee:	af00      	add	r7, sp, #0
 800ecf0:	2300      	movs	r3, #0
 800ecf2:	0018      	movs	r0, r3
 800ecf4:	46bd      	mov	sp, r7
 800ecf6:	bd80      	pop	{r7, pc}

0800ecf8 <L6208_GetMotorHandle>:
/// Get motor handle for L6208
__weak motorDrv_t* L6208_GetMotorHandle(void){return ((motorDrv_t* )0);}
 800ecf8:	b580      	push	{r7, lr}
 800ecfa:	af00      	add	r7, sp, #0
 800ecfc:	2300      	movs	r3, #0
 800ecfe:	0018      	movs	r0, r3
 800ed00:	46bd      	mov	sp, r7
 800ed02:	bd80      	pop	{r7, pc}

0800ed04 <Stspin240_250_GetMotorHandle>:
/// Get motor handle for STSPIN220
__weak motorDrv_t* Stspin220_GetMotorHandle(void){return ((motorDrv_t* )0);}
/// Get motor handle for STSPIN240
__weak motorDrv_t* Stspin240_250_GetMotorHandle(void){return ((motorDrv_t* )0);}
 800ed04:	b580      	push	{r7, lr}
 800ed06:	af00      	add	r7, sp, #0
 800ed08:	2300      	movs	r3, #0
 800ed0a:	0018      	movs	r0, r3
 800ed0c:	46bd      	mov	sp, r7
 800ed0e:	bd80      	pop	{r7, pc}

0800ed10 <BSP_MotorControl_AttachErrorHandler>:
 * @param[in] callback Name of the callback to attach 
 * to the error Hanlder
 * @retval None
 **********************************************************/
void BSP_MotorControl_AttachErrorHandler(void (*callback)(uint16_t))
{
 800ed10:	b580      	push	{r7, lr}
 800ed12:	b082      	sub	sp, #8
 800ed14:	af00      	add	r7, sp, #0
 800ed16:	6078      	str	r0, [r7, #4]
  if ((motorDrvHandle != 0)&&(motorDrvHandle->AttachErrorHandler != 0))
 800ed18:	4b0b      	ldr	r3, [pc, #44]	; (800ed48 <BSP_MotorControl_AttachErrorHandler+0x38>)
 800ed1a:	681b      	ldr	r3, [r3, #0]
 800ed1c:	2b00      	cmp	r3, #0
 800ed1e:	d00b      	beq.n	800ed38 <BSP_MotorControl_AttachErrorHandler+0x28>
 800ed20:	4b09      	ldr	r3, [pc, #36]	; (800ed48 <BSP_MotorControl_AttachErrorHandler+0x38>)
 800ed22:	681b      	ldr	r3, [r3, #0]
 800ed24:	689b      	ldr	r3, [r3, #8]
 800ed26:	2b00      	cmp	r3, #0
 800ed28:	d006      	beq.n	800ed38 <BSP_MotorControl_AttachErrorHandler+0x28>
  {
    motorDrvHandle->AttachErrorHandler(callback);
 800ed2a:	4b07      	ldr	r3, [pc, #28]	; (800ed48 <BSP_MotorControl_AttachErrorHandler+0x38>)
 800ed2c:	681b      	ldr	r3, [r3, #0]
 800ed2e:	689b      	ldr	r3, [r3, #8]
 800ed30:	687a      	ldr	r2, [r7, #4]
 800ed32:	0010      	movs	r0, r2
 800ed34:	4798      	blx	r3
 800ed36:	e003      	b.n	800ed40 <BSP_MotorControl_AttachErrorHandler+0x30>
  }
  else
  {
    MOTOR_CONTROL_ERROR_UNDEFINED_FUNCTION(2);
 800ed38:	4b04      	ldr	r3, [pc, #16]	; (800ed4c <BSP_MotorControl_AttachErrorHandler+0x3c>)
 800ed3a:	0018      	movs	r0, r3
 800ed3c:	f000 f828 	bl	800ed90 <BSP_MotorControl_ErrorHandler>
  }
}
 800ed40:	46c0      	nop			; (mov r8, r8)
 800ed42:	46bd      	mov	sp, r7
 800ed44:	b002      	add	sp, #8
 800ed46:	bd80      	pop	{r7, pc}
 800ed48:	20000460 	.word	0x20000460
 800ed4c:	00000802 	.word	0x00000802

0800ed50 <BSP_MotorControl_AttachFlagInterrupt>:
 * @param[in] callback Name of the callback to attach 
 * to the Flag interrupt Hanlder
 * @retval None
 **********************************************************/
void BSP_MotorControl_AttachFlagInterrupt(void (*callback)(void))
{
 800ed50:	b580      	push	{r7, lr}
 800ed52:	b082      	sub	sp, #8
 800ed54:	af00      	add	r7, sp, #0
 800ed56:	6078      	str	r0, [r7, #4]
  if ((motorDrvHandle != 0)&&(motorDrvHandle->AttachFlagInterrupt != 0))
 800ed58:	4b0b      	ldr	r3, [pc, #44]	; (800ed88 <BSP_MotorControl_AttachFlagInterrupt+0x38>)
 800ed5a:	681b      	ldr	r3, [r3, #0]
 800ed5c:	2b00      	cmp	r3, #0
 800ed5e:	d00b      	beq.n	800ed78 <BSP_MotorControl_AttachFlagInterrupt+0x28>
 800ed60:	4b09      	ldr	r3, [pc, #36]	; (800ed88 <BSP_MotorControl_AttachFlagInterrupt+0x38>)
 800ed62:	681b      	ldr	r3, [r3, #0]
 800ed64:	68db      	ldr	r3, [r3, #12]
 800ed66:	2b00      	cmp	r3, #0
 800ed68:	d006      	beq.n	800ed78 <BSP_MotorControl_AttachFlagInterrupt+0x28>
  {
    motorDrvHandle->AttachFlagInterrupt(callback);
 800ed6a:	4b07      	ldr	r3, [pc, #28]	; (800ed88 <BSP_MotorControl_AttachFlagInterrupt+0x38>)
 800ed6c:	681b      	ldr	r3, [r3, #0]
 800ed6e:	68db      	ldr	r3, [r3, #12]
 800ed70:	687a      	ldr	r2, [r7, #4]
 800ed72:	0010      	movs	r0, r2
 800ed74:	4798      	blx	r3
 800ed76:	e003      	b.n	800ed80 <BSP_MotorControl_AttachFlagInterrupt+0x30>
  }
  else
  {
    MOTOR_CONTROL_ERROR_UNDEFINED_FUNCTION(3);
 800ed78:	4b04      	ldr	r3, [pc, #16]	; (800ed8c <BSP_MotorControl_AttachFlagInterrupt+0x3c>)
 800ed7a:	0018      	movs	r0, r3
 800ed7c:	f000 f808 	bl	800ed90 <BSP_MotorControl_ErrorHandler>
  }  
}
 800ed80:	46c0      	nop			; (mov r8, r8)
 800ed82:	46bd      	mov	sp, r7
 800ed84:	b002      	add	sp, #8
 800ed86:	bd80      	pop	{r7, pc}
 800ed88:	20000460 	.word	0x20000460
 800ed8c:	00000803 	.word	0x00000803

0800ed90 <BSP_MotorControl_ErrorHandler>:
 * @brief Motor control error handler
 * @param[in] error number of the error
 * @retval None
 **********************************************************/
void BSP_MotorControl_ErrorHandler(uint16_t error)
{
 800ed90:	b580      	push	{r7, lr}
 800ed92:	b082      	sub	sp, #8
 800ed94:	af00      	add	r7, sp, #0
 800ed96:	0002      	movs	r2, r0
 800ed98:	1dbb      	adds	r3, r7, #6
 800ed9a:	801a      	strh	r2, [r3, #0]
  if ((motorDrvHandle != 0)&&(motorDrvHandle->ErrorHandler != 0))
 800ed9c:	4b0b      	ldr	r3, [pc, #44]	; (800edcc <BSP_MotorControl_ErrorHandler+0x3c>)
 800ed9e:	681b      	ldr	r3, [r3, #0]
 800eda0:	2b00      	cmp	r3, #0
 800eda2:	d00e      	beq.n	800edc2 <BSP_MotorControl_ErrorHandler+0x32>
 800eda4:	4b09      	ldr	r3, [pc, #36]	; (800edcc <BSP_MotorControl_ErrorHandler+0x3c>)
 800eda6:	681b      	ldr	r3, [r3, #0]
 800eda8:	22f0      	movs	r2, #240	; 0xf0
 800edaa:	589b      	ldr	r3, [r3, r2]
 800edac:	2b00      	cmp	r3, #0
 800edae:	d008      	beq.n	800edc2 <BSP_MotorControl_ErrorHandler+0x32>
  {
    motorDrvHandle->ErrorHandler(error);
 800edb0:	4b06      	ldr	r3, [pc, #24]	; (800edcc <BSP_MotorControl_ErrorHandler+0x3c>)
 800edb2:	681b      	ldr	r3, [r3, #0]
 800edb4:	22f0      	movs	r2, #240	; 0xf0
 800edb6:	589b      	ldr	r3, [r3, r2]
 800edb8:	1dba      	adds	r2, r7, #6
 800edba:	8812      	ldrh	r2, [r2, #0]
 800edbc:	0010      	movs	r0, r2
 800edbe:	4798      	blx	r3
    while(1)
    {
      /* Infinite loop as Error handler must be defined*/
    }
  }
}
 800edc0:	e000      	b.n	800edc4 <BSP_MotorControl_ErrorHandler+0x34>
    while(1)
 800edc2:	e7fe      	b.n	800edc2 <BSP_MotorControl_ErrorHandler+0x32>
}
 800edc4:	46bd      	mov	sp, r7
 800edc6:	b002      	add	sp, #8
 800edc8:	bd80      	pop	{r7, pc}
 800edca:	46c0      	nop			; (mov r8, r8)
 800edcc:	20000460 	.word	0x20000460

0800edd0 <BSP_MotorControl_Init>:
 * @param[in] id Component Id (L6474, Powerstep01,...)
 * @param[in] initDeviceParameters Initialization structure for one device
 * @retval None
 **********************************************************/
void BSP_MotorControl_Init(uint16_t id, void* initDeviceParameters)
{
 800edd0:	b580      	push	{r7, lr}
 800edd2:	b082      	sub	sp, #8
 800edd4:	af00      	add	r7, sp, #0
 800edd6:	0002      	movs	r2, r0
 800edd8:	6039      	str	r1, [r7, #0]
 800edda:	1dbb      	adds	r3, r7, #6
 800eddc:	801a      	strh	r2, [r3, #0]
  if ((motorDrvHandle != 0)&&(motorDrvHandle->Init != 0))
 800edde:	4b0c      	ldr	r3, [pc, #48]	; (800ee10 <BSP_MotorControl_Init+0x40>)
 800ede0:	681b      	ldr	r3, [r3, #0]
 800ede2:	2b00      	cmp	r3, #0
 800ede4:	d00b      	beq.n	800edfe <BSP_MotorControl_Init+0x2e>
 800ede6:	4b0a      	ldr	r3, [pc, #40]	; (800ee10 <BSP_MotorControl_Init+0x40>)
 800ede8:	681b      	ldr	r3, [r3, #0]
 800edea:	681b      	ldr	r3, [r3, #0]
 800edec:	2b00      	cmp	r3, #0
 800edee:	d006      	beq.n	800edfe <BSP_MotorControl_Init+0x2e>
  {
    motorDrvHandle->Init(initDeviceParameters);
 800edf0:	4b07      	ldr	r3, [pc, #28]	; (800ee10 <BSP_MotorControl_Init+0x40>)
 800edf2:	681b      	ldr	r3, [r3, #0]
 800edf4:	681b      	ldr	r3, [r3, #0]
 800edf6:	683a      	ldr	r2, [r7, #0]
 800edf8:	0010      	movs	r0, r2
 800edfa:	4798      	blx	r3
 800edfc:	e004      	b.n	800ee08 <BSP_MotorControl_Init+0x38>
  }  
  else
  {
    MOTOR_CONTROL_ERROR_UNDEFINED_FUNCTION(0);
 800edfe:	2380      	movs	r3, #128	; 0x80
 800ee00:	011b      	lsls	r3, r3, #4
 800ee02:	0018      	movs	r0, r3
 800ee04:	f7ff ffc4 	bl	800ed90 <BSP_MotorControl_ErrorHandler>
  }  
}
 800ee08:	46c0      	nop			; (mov r8, r8)
 800ee0a:	46bd      	mov	sp, r7
 800ee0c:	b002      	add	sp, #8
 800ee0e:	bd80      	pop	{r7, pc}
 800ee10:	20000460 	.word	0x20000460

0800ee14 <BSP_MotorControl_GetPosition>:
 * @param[in] deviceId (from 0 to MAX_NUMBER_OF_DEVICES - 1)
 * For L6208: dummy parameter for compatibility with motor.h
 * @retval ABS_POSITION register value converted in a 32b signed integer
 **********************************************************/
int32_t BSP_MotorControl_GetPosition(uint8_t deviceId)
{
 800ee14:	b580      	push	{r7, lr}
 800ee16:	b084      	sub	sp, #16
 800ee18:	af00      	add	r7, sp, #0
 800ee1a:	0002      	movs	r2, r0
 800ee1c:	1dfb      	adds	r3, r7, #7
 800ee1e:	701a      	strb	r2, [r3, #0]
  int32_t pos = 0;
 800ee20:	2300      	movs	r3, #0
 800ee22:	60fb      	str	r3, [r7, #12]
  
  if ((motorDrvHandle != 0)&&(motorDrvHandle->GetPosition != 0))
 800ee24:	4b0d      	ldr	r3, [pc, #52]	; (800ee5c <BSP_MotorControl_GetPosition+0x48>)
 800ee26:	681b      	ldr	r3, [r3, #0]
 800ee28:	2b00      	cmp	r3, #0
 800ee2a:	d00e      	beq.n	800ee4a <BSP_MotorControl_GetPosition+0x36>
 800ee2c:	4b0b      	ldr	r3, [pc, #44]	; (800ee5c <BSP_MotorControl_GetPosition+0x48>)
 800ee2e:	681b      	ldr	r3, [r3, #0]
 800ee30:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ee32:	2b00      	cmp	r3, #0
 800ee34:	d009      	beq.n	800ee4a <BSP_MotorControl_GetPosition+0x36>
  {
    pos = motorDrvHandle->GetPosition(deviceId);
 800ee36:	4b09      	ldr	r3, [pc, #36]	; (800ee5c <BSP_MotorControl_GetPosition+0x48>)
 800ee38:	681b      	ldr	r3, [r3, #0]
 800ee3a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ee3c:	1dfa      	adds	r2, r7, #7
 800ee3e:	7812      	ldrb	r2, [r2, #0]
 800ee40:	0010      	movs	r0, r2
 800ee42:	4798      	blx	r3
 800ee44:	0003      	movs	r3, r0
 800ee46:	60fb      	str	r3, [r7, #12]
 800ee48:	e003      	b.n	800ee52 <BSP_MotorControl_GetPosition+0x3e>
  }
  else
  {
    MOTOR_CONTROL_ERROR_UNDEFINED_FUNCTION(14);
 800ee4a:	4b05      	ldr	r3, [pc, #20]	; (800ee60 <BSP_MotorControl_GetPosition+0x4c>)
 800ee4c:	0018      	movs	r0, r3
 800ee4e:	f7ff ff9f 	bl	800ed90 <BSP_MotorControl_ErrorHandler>
  }      
  return(pos);
 800ee52:	68fb      	ldr	r3, [r7, #12]
}
 800ee54:	0018      	movs	r0, r3
 800ee56:	46bd      	mov	sp, r7
 800ee58:	b004      	add	sp, #16
 800ee5a:	bd80      	pop	{r7, pc}
 800ee5c:	20000460 	.word	0x20000460
 800ee60:	0000080e 	.word	0x0000080e

0800ee64 <BSP_MotorControl_GoTo>:
 * For L6208: dummy parameter for compatibility with motor.h
 * @param[in] targetPosition absolute position in steps
 * @retval None
 **********************************************************/
void BSP_MotorControl_GoTo(uint8_t deviceId, int32_t targetPosition)
{
 800ee64:	b580      	push	{r7, lr}
 800ee66:	b082      	sub	sp, #8
 800ee68:	af00      	add	r7, sp, #0
 800ee6a:	0002      	movs	r2, r0
 800ee6c:	6039      	str	r1, [r7, #0]
 800ee6e:	1dfb      	adds	r3, r7, #7
 800ee70:	701a      	strb	r2, [r3, #0]
  if ((motorDrvHandle != 0)&&(motorDrvHandle->GoTo != 0))
 800ee72:	4b0d      	ldr	r3, [pc, #52]	; (800eea8 <BSP_MotorControl_GoTo+0x44>)
 800ee74:	681b      	ldr	r3, [r3, #0]
 800ee76:	2b00      	cmp	r3, #0
 800ee78:	d00d      	beq.n	800ee96 <BSP_MotorControl_GoTo+0x32>
 800ee7a:	4b0b      	ldr	r3, [pc, #44]	; (800eea8 <BSP_MotorControl_GoTo+0x44>)
 800ee7c:	681b      	ldr	r3, [r3, #0]
 800ee7e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ee80:	2b00      	cmp	r3, #0
 800ee82:	d008      	beq.n	800ee96 <BSP_MotorControl_GoTo+0x32>
  {
    motorDrvHandle->GoTo(deviceId, targetPosition);
 800ee84:	4b08      	ldr	r3, [pc, #32]	; (800eea8 <BSP_MotorControl_GoTo+0x44>)
 800ee86:	681b      	ldr	r3, [r3, #0]
 800ee88:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ee8a:	6839      	ldr	r1, [r7, #0]
 800ee8c:	1dfa      	adds	r2, r7, #7
 800ee8e:	7812      	ldrb	r2, [r2, #0]
 800ee90:	0010      	movs	r0, r2
 800ee92:	4798      	blx	r3
 800ee94:	e003      	b.n	800ee9e <BSP_MotorControl_GoTo+0x3a>
  }
  else
  {
    MOTOR_CONTROL_ERROR_UNDEFINED_FUNCTION(17);
 800ee96:	4b05      	ldr	r3, [pc, #20]	; (800eeac <BSP_MotorControl_GoTo+0x48>)
 800ee98:	0018      	movs	r0, r3
 800ee9a:	f7ff ff79 	bl	800ed90 <BSP_MotorControl_ErrorHandler>
  }      
}
 800ee9e:	46c0      	nop			; (mov r8, r8)
 800eea0:	46bd      	mov	sp, r7
 800eea2:	b002      	add	sp, #8
 800eea4:	bd80      	pop	{r7, pc}
 800eea6:	46c0      	nop			; (mov r8, r8)
 800eea8:	20000460 	.word	0x20000460
 800eeac:	00000811 	.word	0x00000811

0800eeb0 <BSP_MotorControl_Move>:
 * @param[in] direction FORWARD or BACKWARD
 * @param[in] stepCount Number of steps to perform
 * @retval None
 **********************************************************/
void BSP_MotorControl_Move(uint8_t deviceId, motorDir_t direction, uint32_t stepCount)
{
 800eeb0:	b590      	push	{r4, r7, lr}
 800eeb2:	b083      	sub	sp, #12
 800eeb4:	af00      	add	r7, sp, #0
 800eeb6:	603a      	str	r2, [r7, #0]
 800eeb8:	1dfb      	adds	r3, r7, #7
 800eeba:	1c02      	adds	r2, r0, #0
 800eebc:	701a      	strb	r2, [r3, #0]
 800eebe:	1dbb      	adds	r3, r7, #6
 800eec0:	1c0a      	adds	r2, r1, #0
 800eec2:	701a      	strb	r2, [r3, #0]
  if ((motorDrvHandle != 0)&&(motorDrvHandle->Move != 0))
 800eec4:	4b0d      	ldr	r3, [pc, #52]	; (800eefc <BSP_MotorControl_Move+0x4c>)
 800eec6:	681b      	ldr	r3, [r3, #0]
 800eec8:	2b00      	cmp	r3, #0
 800eeca:	d00f      	beq.n	800eeec <BSP_MotorControl_Move+0x3c>
 800eecc:	4b0b      	ldr	r3, [pc, #44]	; (800eefc <BSP_MotorControl_Move+0x4c>)
 800eece:	681b      	ldr	r3, [r3, #0]
 800eed0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800eed2:	2b00      	cmp	r3, #0
 800eed4:	d00a      	beq.n	800eeec <BSP_MotorControl_Move+0x3c>
  {
    motorDrvHandle->Move(deviceId, direction, stepCount);
 800eed6:	4b09      	ldr	r3, [pc, #36]	; (800eefc <BSP_MotorControl_Move+0x4c>)
 800eed8:	681b      	ldr	r3, [r3, #0]
 800eeda:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800eedc:	683c      	ldr	r4, [r7, #0]
 800eede:	1dba      	adds	r2, r7, #6
 800eee0:	7811      	ldrb	r1, [r2, #0]
 800eee2:	1dfa      	adds	r2, r7, #7
 800eee4:	7810      	ldrb	r0, [r2, #0]
 800eee6:	0022      	movs	r2, r4
 800eee8:	4798      	blx	r3
 800eeea:	e003      	b.n	800eef4 <BSP_MotorControl_Move+0x44>
  }
  else
  {
    MOTOR_CONTROL_ERROR_UNDEFINED_FUNCTION(19);
 800eeec:	4b04      	ldr	r3, [pc, #16]	; (800ef00 <BSP_MotorControl_Move+0x50>)
 800eeee:	0018      	movs	r0, r3
 800eef0:	f7ff ff4e 	bl	800ed90 <BSP_MotorControl_ErrorHandler>
  }      
}
 800eef4:	46c0      	nop			; (mov r8, r8)
 800eef6:	46bd      	mov	sp, r7
 800eef8:	b003      	add	sp, #12
 800eefa:	bd90      	pop	{r4, r7, pc}
 800eefc:	20000460 	.word	0x20000460
 800ef00:	00000813 	.word	0x00000813

0800ef04 <BSP_MotorControl_Run>:
 * @retval None
 * @note For unidirectionnal brush DC motor, direction parameter 
 * has no effect
 **********************************************************/
void BSP_MotorControl_Run(uint8_t deviceId, motorDir_t direction)
{
 800ef04:	b580      	push	{r7, lr}
 800ef06:	b082      	sub	sp, #8
 800ef08:	af00      	add	r7, sp, #0
 800ef0a:	0002      	movs	r2, r0
 800ef0c:	1dfb      	adds	r3, r7, #7
 800ef0e:	701a      	strb	r2, [r3, #0]
 800ef10:	1dbb      	adds	r3, r7, #6
 800ef12:	1c0a      	adds	r2, r1, #0
 800ef14:	701a      	strb	r2, [r3, #0]
  if ((motorDrvHandle != 0)&&(motorDrvHandle->Run != 0))
 800ef16:	4b0d      	ldr	r3, [pc, #52]	; (800ef4c <BSP_MotorControl_Run+0x48>)
 800ef18:	681b      	ldr	r3, [r3, #0]
 800ef1a:	2b00      	cmp	r3, #0
 800ef1c:	d00e      	beq.n	800ef3c <BSP_MotorControl_Run+0x38>
 800ef1e:	4b0b      	ldr	r3, [pc, #44]	; (800ef4c <BSP_MotorControl_Run+0x48>)
 800ef20:	681b      	ldr	r3, [r3, #0]
 800ef22:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800ef24:	2b00      	cmp	r3, #0
 800ef26:	d009      	beq.n	800ef3c <BSP_MotorControl_Run+0x38>
  {
    motorDrvHandle->Run(deviceId, direction); 
 800ef28:	4b08      	ldr	r3, [pc, #32]	; (800ef4c <BSP_MotorControl_Run+0x48>)
 800ef2a:	681b      	ldr	r3, [r3, #0]
 800ef2c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800ef2e:	1dba      	adds	r2, r7, #6
 800ef30:	7811      	ldrb	r1, [r2, #0]
 800ef32:	1dfa      	adds	r2, r7, #7
 800ef34:	7812      	ldrb	r2, [r2, #0]
 800ef36:	0010      	movs	r0, r2
 800ef38:	4798      	blx	r3
 800ef3a:	e003      	b.n	800ef44 <BSP_MotorControl_Run+0x40>
  }
  else
  {
    MOTOR_CONTROL_ERROR_UNDEFINED_FUNCTION(21);
 800ef3c:	4b04      	ldr	r3, [pc, #16]	; (800ef50 <BSP_MotorControl_Run+0x4c>)
 800ef3e:	0018      	movs	r0, r3
 800ef40:	f7ff ff26 	bl	800ed90 <BSP_MotorControl_ErrorHandler>
  }      
}
 800ef44:	46c0      	nop			; (mov r8, r8)
 800ef46:	46bd      	mov	sp, r7
 800ef48:	b002      	add	sp, #8
 800ef4a:	bd80      	pop	{r7, pc}
 800ef4c:	20000460 	.word	0x20000460
 800ef50:	00000815 	.word	0x00000815

0800ef54 <BSP_MotorControl_SetAcceleration>:
 * @retval true if the command is successfully executed, else false
 * @note The command is not performed is the device is executing 
 * a MOVE or GOTO command (but it can be used during a RUN command)
 **********************************************************/
bool BSP_MotorControl_SetAcceleration(uint8_t deviceId,uint16_t newAcc)
{                                                  
 800ef54:	b590      	push	{r4, r7, lr}
 800ef56:	b085      	sub	sp, #20
 800ef58:	af00      	add	r7, sp, #0
 800ef5a:	0002      	movs	r2, r0
 800ef5c:	1dfb      	adds	r3, r7, #7
 800ef5e:	701a      	strb	r2, [r3, #0]
 800ef60:	1d3b      	adds	r3, r7, #4
 800ef62:	1c0a      	adds	r2, r1, #0
 800ef64:	801a      	strh	r2, [r3, #0]
  bool status = FALSE;
 800ef66:	230f      	movs	r3, #15
 800ef68:	18fb      	adds	r3, r7, r3
 800ef6a:	2200      	movs	r2, #0
 800ef6c:	701a      	strb	r2, [r3, #0]
  if ((motorDrvHandle != 0)&&(motorDrvHandle->SetAcceleration != 0))
 800ef6e:	4b11      	ldr	r3, [pc, #68]	; (800efb4 <BSP_MotorControl_SetAcceleration+0x60>)
 800ef70:	681b      	ldr	r3, [r3, #0]
 800ef72:	2b00      	cmp	r3, #0
 800ef74:	d012      	beq.n	800ef9c <BSP_MotorControl_SetAcceleration+0x48>
 800ef76:	4b0f      	ldr	r3, [pc, #60]	; (800efb4 <BSP_MotorControl_SetAcceleration+0x60>)
 800ef78:	681b      	ldr	r3, [r3, #0]
 800ef7a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800ef7c:	2b00      	cmp	r3, #0
 800ef7e:	d00d      	beq.n	800ef9c <BSP_MotorControl_SetAcceleration+0x48>
  {
    status = motorDrvHandle->SetAcceleration(deviceId, newAcc);
 800ef80:	4b0c      	ldr	r3, [pc, #48]	; (800efb4 <BSP_MotorControl_SetAcceleration+0x60>)
 800ef82:	681b      	ldr	r3, [r3, #0]
 800ef84:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800ef86:	220f      	movs	r2, #15
 800ef88:	18bc      	adds	r4, r7, r2
 800ef8a:	1d3a      	adds	r2, r7, #4
 800ef8c:	8811      	ldrh	r1, [r2, #0]
 800ef8e:	1dfa      	adds	r2, r7, #7
 800ef90:	7812      	ldrb	r2, [r2, #0]
 800ef92:	0010      	movs	r0, r2
 800ef94:	4798      	blx	r3
 800ef96:	0003      	movs	r3, r0
 800ef98:	7023      	strb	r3, [r4, #0]
 800ef9a:	e003      	b.n	800efa4 <BSP_MotorControl_SetAcceleration+0x50>
  }
  else
  {
    MOTOR_CONTROL_ERROR_UNDEFINED_FUNCTION(22);
 800ef9c:	4b06      	ldr	r3, [pc, #24]	; (800efb8 <BSP_MotorControl_SetAcceleration+0x64>)
 800ef9e:	0018      	movs	r0, r3
 800efa0:	f7ff fef6 	bl	800ed90 <BSP_MotorControl_ErrorHandler>
  }      
  return (status);
 800efa4:	230f      	movs	r3, #15
 800efa6:	18fb      	adds	r3, r7, r3
 800efa8:	781b      	ldrb	r3, [r3, #0]
}            
 800efaa:	0018      	movs	r0, r3
 800efac:	46bd      	mov	sp, r7
 800efae:	b005      	add	sp, #20
 800efb0:	bd90      	pop	{r4, r7, pc}
 800efb2:	46c0      	nop			; (mov r8, r8)
 800efb4:	20000460 	.word	0x20000460
 800efb8:	00000816 	.word	0x00000816

0800efbc <BSP_MotorControl_SetDeceleration>:
 * @retval true if the command is successfully executed, else false
 * @note The command is not performed is the device is executing 
 * a MOVE or GOTO command (but it can be used during a RUN command)
 **********************************************************/
bool BSP_MotorControl_SetDeceleration(uint8_t deviceId, uint16_t newDec)
{                                                  
 800efbc:	b590      	push	{r4, r7, lr}
 800efbe:	b085      	sub	sp, #20
 800efc0:	af00      	add	r7, sp, #0
 800efc2:	0002      	movs	r2, r0
 800efc4:	1dfb      	adds	r3, r7, #7
 800efc6:	701a      	strb	r2, [r3, #0]
 800efc8:	1d3b      	adds	r3, r7, #4
 800efca:	1c0a      	adds	r2, r1, #0
 800efcc:	801a      	strh	r2, [r3, #0]
  bool status = FALSE;
 800efce:	230f      	movs	r3, #15
 800efd0:	18fb      	adds	r3, r7, r3
 800efd2:	2200      	movs	r2, #0
 800efd4:	701a      	strb	r2, [r3, #0]
  if ((motorDrvHandle != 0)&&(motorDrvHandle->SetDeceleration != 0))
 800efd6:	4b11      	ldr	r3, [pc, #68]	; (800f01c <BSP_MotorControl_SetDeceleration+0x60>)
 800efd8:	681b      	ldr	r3, [r3, #0]
 800efda:	2b00      	cmp	r3, #0
 800efdc:	d012      	beq.n	800f004 <BSP_MotorControl_SetDeceleration+0x48>
 800efde:	4b0f      	ldr	r3, [pc, #60]	; (800f01c <BSP_MotorControl_SetDeceleration+0x60>)
 800efe0:	681b      	ldr	r3, [r3, #0]
 800efe2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800efe4:	2b00      	cmp	r3, #0
 800efe6:	d00d      	beq.n	800f004 <BSP_MotorControl_SetDeceleration+0x48>
  {
    status = motorDrvHandle->SetDeceleration(deviceId, newDec);
 800efe8:	4b0c      	ldr	r3, [pc, #48]	; (800f01c <BSP_MotorControl_SetDeceleration+0x60>)
 800efea:	681b      	ldr	r3, [r3, #0]
 800efec:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800efee:	220f      	movs	r2, #15
 800eff0:	18bc      	adds	r4, r7, r2
 800eff2:	1d3a      	adds	r2, r7, #4
 800eff4:	8811      	ldrh	r1, [r2, #0]
 800eff6:	1dfa      	adds	r2, r7, #7
 800eff8:	7812      	ldrb	r2, [r2, #0]
 800effa:	0010      	movs	r0, r2
 800effc:	4798      	blx	r3
 800effe:	0003      	movs	r3, r0
 800f000:	7023      	strb	r3, [r4, #0]
 800f002:	e003      	b.n	800f00c <BSP_MotorControl_SetDeceleration+0x50>
  }
  else
  {
    MOTOR_CONTROL_ERROR_UNDEFINED_FUNCTION(23);
 800f004:	4b06      	ldr	r3, [pc, #24]	; (800f020 <BSP_MotorControl_SetDeceleration+0x64>)
 800f006:	0018      	movs	r0, r3
 800f008:	f7ff fec2 	bl	800ed90 <BSP_MotorControl_ErrorHandler>
  }        
  return (status);
 800f00c:	230f      	movs	r3, #15
 800f00e:	18fb      	adds	r3, r7, r3
 800f010:	781b      	ldrb	r3, [r3, #0]
}        
 800f012:	0018      	movs	r0, r3
 800f014:	46bd      	mov	sp, r7
 800f016:	b005      	add	sp, #20
 800f018:	bd90      	pop	{r4, r7, pc}
 800f01a:	46c0      	nop			; (mov r8, r8)
 800f01c:	20000460 	.word	0x20000460
 800f020:	00000817 	.word	0x00000817

0800f024 <BSP_MotorControl_SetHome>:
 * @param[in] homePosition new absolute home position 
 * For L6208: dummy parameter for compatibility with motor.h
 * @retval None
 **********************************************************/
void BSP_MotorControl_SetHome(uint8_t deviceId, int32_t homePosition)
{
 800f024:	b580      	push	{r7, lr}
 800f026:	b082      	sub	sp, #8
 800f028:	af00      	add	r7, sp, #0
 800f02a:	0002      	movs	r2, r0
 800f02c:	6039      	str	r1, [r7, #0]
 800f02e:	1dfb      	adds	r3, r7, #7
 800f030:	701a      	strb	r2, [r3, #0]
  if ((motorDrvHandle != 0)&&(motorDrvHandle->SetHome != 0))
 800f032:	4b0d      	ldr	r3, [pc, #52]	; (800f068 <BSP_MotorControl_SetHome+0x44>)
 800f034:	681b      	ldr	r3, [r3, #0]
 800f036:	2b00      	cmp	r3, #0
 800f038:	d00d      	beq.n	800f056 <BSP_MotorControl_SetHome+0x32>
 800f03a:	4b0b      	ldr	r3, [pc, #44]	; (800f068 <BSP_MotorControl_SetHome+0x44>)
 800f03c:	681b      	ldr	r3, [r3, #0]
 800f03e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800f040:	2b00      	cmp	r3, #0
 800f042:	d008      	beq.n	800f056 <BSP_MotorControl_SetHome+0x32>
  {
    motorDrvHandle->SetHome(deviceId, homePosition);
 800f044:	4b08      	ldr	r3, [pc, #32]	; (800f068 <BSP_MotorControl_SetHome+0x44>)
 800f046:	681b      	ldr	r3, [r3, #0]
 800f048:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800f04a:	6839      	ldr	r1, [r7, #0]
 800f04c:	1dfa      	adds	r2, r7, #7
 800f04e:	7812      	ldrb	r2, [r2, #0]
 800f050:	0010      	movs	r0, r2
 800f052:	4798      	blx	r3
 800f054:	e003      	b.n	800f05e <BSP_MotorControl_SetHome+0x3a>
  }
  else
  {
    MOTOR_CONTROL_ERROR_UNDEFINED_FUNCTION(24);
 800f056:	4b05      	ldr	r3, [pc, #20]	; (800f06c <BSP_MotorControl_SetHome+0x48>)
 800f058:	0018      	movs	r0, r3
 800f05a:	f7ff fe99 	bl	800ed90 <BSP_MotorControl_ErrorHandler>
  }        
}
 800f05e:	46c0      	nop			; (mov r8, r8)
 800f060:	46bd      	mov	sp, r7
 800f062:	b002      	add	sp, #8
 800f064:	bd80      	pop	{r7, pc}
 800f066:	46c0      	nop			; (mov r8, r8)
 800f068:	20000460 	.word	0x20000460
 800f06c:	00000818 	.word	0x00000818

0800f070 <BSP_MotorControl_SetMaxSpeed>:
 * @retval true if the command is successfully executed, else false
 * @note For a stepper motor, the command is not performed if the device 
 * is executing a MOVE or GOTO command (but it can be used during a RUN command).
 **********************************************************/
bool BSP_MotorControl_SetMaxSpeed(uint8_t deviceId, uint16_t newMaxSpeed)
{                                                  
 800f070:	b590      	push	{r4, r7, lr}
 800f072:	b085      	sub	sp, #20
 800f074:	af00      	add	r7, sp, #0
 800f076:	0002      	movs	r2, r0
 800f078:	1dfb      	adds	r3, r7, #7
 800f07a:	701a      	strb	r2, [r3, #0]
 800f07c:	1d3b      	adds	r3, r7, #4
 800f07e:	1c0a      	adds	r2, r1, #0
 800f080:	801a      	strh	r2, [r3, #0]
  bool status = FALSE;
 800f082:	230f      	movs	r3, #15
 800f084:	18fb      	adds	r3, r7, r3
 800f086:	2200      	movs	r2, #0
 800f088:	701a      	strb	r2, [r3, #0]
  if ((motorDrvHandle != 0)&&(motorDrvHandle->SetMaxSpeed != 0))
 800f08a:	4b11      	ldr	r3, [pc, #68]	; (800f0d0 <BSP_MotorControl_SetMaxSpeed+0x60>)
 800f08c:	681b      	ldr	r3, [r3, #0]
 800f08e:	2b00      	cmp	r3, #0
 800f090:	d012      	beq.n	800f0b8 <BSP_MotorControl_SetMaxSpeed+0x48>
 800f092:	4b0f      	ldr	r3, [pc, #60]	; (800f0d0 <BSP_MotorControl_SetMaxSpeed+0x60>)
 800f094:	681b      	ldr	r3, [r3, #0]
 800f096:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800f098:	2b00      	cmp	r3, #0
 800f09a:	d00d      	beq.n	800f0b8 <BSP_MotorControl_SetMaxSpeed+0x48>
  {
    status = motorDrvHandle->SetMaxSpeed(deviceId, newMaxSpeed);
 800f09c:	4b0c      	ldr	r3, [pc, #48]	; (800f0d0 <BSP_MotorControl_SetMaxSpeed+0x60>)
 800f09e:	681b      	ldr	r3, [r3, #0]
 800f0a0:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800f0a2:	220f      	movs	r2, #15
 800f0a4:	18bc      	adds	r4, r7, r2
 800f0a6:	1d3a      	adds	r2, r7, #4
 800f0a8:	8811      	ldrh	r1, [r2, #0]
 800f0aa:	1dfa      	adds	r2, r7, #7
 800f0ac:	7812      	ldrb	r2, [r2, #0]
 800f0ae:	0010      	movs	r0, r2
 800f0b0:	4798      	blx	r3
 800f0b2:	0003      	movs	r3, r0
 800f0b4:	7023      	strb	r3, [r4, #0]
 800f0b6:	e003      	b.n	800f0c0 <BSP_MotorControl_SetMaxSpeed+0x50>
  }
  else
  {
    MOTOR_CONTROL_ERROR_UNDEFINED_FUNCTION(26);
 800f0b8:	4b06      	ldr	r3, [pc, #24]	; (800f0d4 <BSP_MotorControl_SetMaxSpeed+0x64>)
 800f0ba:	0018      	movs	r0, r3
 800f0bc:	f7ff fe68 	bl	800ed90 <BSP_MotorControl_ErrorHandler>
  }     
  return (status);  
 800f0c0:	230f      	movs	r3, #15
 800f0c2:	18fb      	adds	r3, r7, r3
 800f0c4:	781b      	ldrb	r3, [r3, #0]
}                                                     
 800f0c6:	0018      	movs	r0, r3
 800f0c8:	46bd      	mov	sp, r7
 800f0ca:	b005      	add	sp, #20
 800f0cc:	bd90      	pop	{r4, r7, pc}
 800f0ce:	46c0      	nop			; (mov r8, r8)
 800f0d0:	20000460 	.word	0x20000460
 800f0d4:	0000081a 	.word	0x0000081a

0800f0d8 <BSP_MotorControl_SoftStop>:
 *            motorId  from 0 to MAX_NUMBER_OF_BRUSH_DC_MOTORS for Brush DC motor
 * @retval true if the command is successfully executed, else false
 * @note The command is not performed is the device is in INACTIVE state.
 **********************************************************/
bool BSP_MotorControl_SoftStop(uint8_t deviceId)
{	
 800f0d8:	b590      	push	{r4, r7, lr}
 800f0da:	b085      	sub	sp, #20
 800f0dc:	af00      	add	r7, sp, #0
 800f0de:	0002      	movs	r2, r0
 800f0e0:	1dfb      	adds	r3, r7, #7
 800f0e2:	701a      	strb	r2, [r3, #0]
  bool status = FALSE;
 800f0e4:	230f      	movs	r3, #15
 800f0e6:	18fb      	adds	r3, r7, r3
 800f0e8:	2200      	movs	r2, #0
 800f0ea:	701a      	strb	r2, [r3, #0]
  if ((motorDrvHandle != 0)&&(motorDrvHandle->SoftStop != 0))
 800f0ec:	4b0f      	ldr	r3, [pc, #60]	; (800f12c <BSP_MotorControl_SoftStop+0x54>)
 800f0ee:	681b      	ldr	r3, [r3, #0]
 800f0f0:	2b00      	cmp	r3, #0
 800f0f2:	d010      	beq.n	800f116 <BSP_MotorControl_SoftStop+0x3e>
 800f0f4:	4b0d      	ldr	r3, [pc, #52]	; (800f12c <BSP_MotorControl_SoftStop+0x54>)
 800f0f6:	681b      	ldr	r3, [r3, #0]
 800f0f8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800f0fa:	2b00      	cmp	r3, #0
 800f0fc:	d00b      	beq.n	800f116 <BSP_MotorControl_SoftStop+0x3e>
  {
    status = motorDrvHandle->SoftStop(deviceId);
 800f0fe:	4b0b      	ldr	r3, [pc, #44]	; (800f12c <BSP_MotorControl_SoftStop+0x54>)
 800f100:	681b      	ldr	r3, [r3, #0]
 800f102:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800f104:	220f      	movs	r2, #15
 800f106:	18bc      	adds	r4, r7, r2
 800f108:	1dfa      	adds	r2, r7, #7
 800f10a:	7812      	ldrb	r2, [r2, #0]
 800f10c:	0010      	movs	r0, r2
 800f10e:	4798      	blx	r3
 800f110:	0003      	movs	r3, r0
 800f112:	7023      	strb	r3, [r4, #0]
 800f114:	e003      	b.n	800f11e <BSP_MotorControl_SoftStop+0x46>
  }
  else
  {
    MOTOR_CONTROL_ERROR_UNDEFINED_FUNCTION(28);
 800f116:	4b06      	ldr	r3, [pc, #24]	; (800f130 <BSP_MotorControl_SoftStop+0x58>)
 800f118:	0018      	movs	r0, r3
 800f11a:	f7ff fe39 	bl	800ed90 <BSP_MotorControl_ErrorHandler>
  }    
  return (status);  
 800f11e:	230f      	movs	r3, #15
 800f120:	18fb      	adds	r3, r7, r3
 800f122:	781b      	ldrb	r3, [r3, #0]
}
 800f124:	0018      	movs	r0, r3
 800f126:	46bd      	mov	sp, r7
 800f128:	b005      	add	sp, #20
 800f12a:	bd90      	pop	{r4, r7, pc}
 800f12c:	20000460 	.word	0x20000460
 800f130:	0000081c 	.word	0x0000081c

0800f134 <BSP_MotorControl_StepClockHandler>:
 * For L6208: dummy parameter for compatibility with motor.h
 * @retval None
 * @note Must only be called by the timer ISR
 **********************************************************/
void BSP_MotorControl_StepClockHandler(uint8_t deviceId)
{
 800f134:	b580      	push	{r7, lr}
 800f136:	b082      	sub	sp, #8
 800f138:	af00      	add	r7, sp, #0
 800f13a:	0002      	movs	r2, r0
 800f13c:	1dfb      	adds	r3, r7, #7
 800f13e:	701a      	strb	r2, [r3, #0]
  if ((motorDrvHandle != 0)&&(motorDrvHandle->StepClockHandler != 0))
 800f140:	4b0c      	ldr	r3, [pc, #48]	; (800f174 <BSP_MotorControl_StepClockHandler+0x40>)
 800f142:	681b      	ldr	r3, [r3, #0]
 800f144:	2b00      	cmp	r3, #0
 800f146:	d00c      	beq.n	800f162 <BSP_MotorControl_StepClockHandler+0x2e>
 800f148:	4b0a      	ldr	r3, [pc, #40]	; (800f174 <BSP_MotorControl_StepClockHandler+0x40>)
 800f14a:	681b      	ldr	r3, [r3, #0]
 800f14c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800f14e:	2b00      	cmp	r3, #0
 800f150:	d007      	beq.n	800f162 <BSP_MotorControl_StepClockHandler+0x2e>
  {
    motorDrvHandle->StepClockHandler(deviceId);
 800f152:	4b08      	ldr	r3, [pc, #32]	; (800f174 <BSP_MotorControl_StepClockHandler+0x40>)
 800f154:	681b      	ldr	r3, [r3, #0]
 800f156:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800f158:	1dfa      	adds	r2, r7, #7
 800f15a:	7812      	ldrb	r2, [r2, #0]
 800f15c:	0010      	movs	r0, r2
 800f15e:	4798      	blx	r3
 800f160:	e003      	b.n	800f16a <BSP_MotorControl_StepClockHandler+0x36>
  }
  else
  {
    MOTOR_CONTROL_ERROR_UNDEFINED_FUNCTION(29);
 800f162:	4b05      	ldr	r3, [pc, #20]	; (800f178 <BSP_MotorControl_StepClockHandler+0x44>)
 800f164:	0018      	movs	r0, r3
 800f166:	f7ff fe13 	bl	800ed90 <BSP_MotorControl_ErrorHandler>
  }   
}
 800f16a:	46c0      	nop			; (mov r8, r8)
 800f16c:	46bd      	mov	sp, r7
 800f16e:	b002      	add	sp, #8
 800f170:	bd80      	pop	{r7, pc}
 800f172:	46c0      	nop			; (mov r8, r8)
 800f174:	20000460 	.word	0x20000460
 800f178:	0000081d 	.word	0x0000081d

0800f17c <BSP_MotorControl_WaitWhileActive>:
 * @param[in] deviceId (from 0 to MAX_NUMBER_OF_DEVICES - 1)
 * For L6208: dummy parameter for compatibility with motor.h
 * @retval None
 **********************************************************/
void BSP_MotorControl_WaitWhileActive(uint8_t deviceId)
{
 800f17c:	b580      	push	{r7, lr}
 800f17e:	b082      	sub	sp, #8
 800f180:	af00      	add	r7, sp, #0
 800f182:	0002      	movs	r2, r0
 800f184:	1dfb      	adds	r3, r7, #7
 800f186:	701a      	strb	r2, [r3, #0]
  if ((motorDrvHandle != 0)&&(motorDrvHandle->WaitWhileActive != 0))
 800f188:	4b0c      	ldr	r3, [pc, #48]	; (800f1bc <BSP_MotorControl_WaitWhileActive+0x40>)
 800f18a:	681b      	ldr	r3, [r3, #0]
 800f18c:	2b00      	cmp	r3, #0
 800f18e:	d00c      	beq.n	800f1aa <BSP_MotorControl_WaitWhileActive+0x2e>
 800f190:	4b0a      	ldr	r3, [pc, #40]	; (800f1bc <BSP_MotorControl_WaitWhileActive+0x40>)
 800f192:	681b      	ldr	r3, [r3, #0]
 800f194:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800f196:	2b00      	cmp	r3, #0
 800f198:	d007      	beq.n	800f1aa <BSP_MotorControl_WaitWhileActive+0x2e>
  {
    motorDrvHandle->WaitWhileActive(deviceId);
 800f19a:	4b08      	ldr	r3, [pc, #32]	; (800f1bc <BSP_MotorControl_WaitWhileActive+0x40>)
 800f19c:	681b      	ldr	r3, [r3, #0]
 800f19e:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800f1a0:	1dfa      	adds	r2, r7, #7
 800f1a2:	7812      	ldrb	r2, [r2, #0]
 800f1a4:	0010      	movs	r0, r2
 800f1a6:	4798      	blx	r3
 800f1a8:	e003      	b.n	800f1b2 <BSP_MotorControl_WaitWhileActive+0x36>
  }
  else
  {
    MOTOR_CONTROL_ERROR_UNDEFINED_FUNCTION(30);
 800f1aa:	4b05      	ldr	r3, [pc, #20]	; (800f1c0 <BSP_MotorControl_WaitWhileActive+0x44>)
 800f1ac:	0018      	movs	r0, r3
 800f1ae:	f7ff fdef 	bl	800ed90 <BSP_MotorControl_ErrorHandler>
  }    
}
 800f1b2:	46c0      	nop			; (mov r8, r8)
 800f1b4:	46bd      	mov	sp, r7
 800f1b6:	b002      	add	sp, #8
 800f1b8:	bd80      	pop	{r7, pc}
 800f1ba:	46c0      	nop			; (mov r8, r8)
 800f1bc:	20000460 	.word	0x20000460
 800f1c0:	0000081e 	.word	0x0000081e

0800f1c4 <BSP_MotorControl_CmdDisable>:
 * @note For brush DC motor, when input of different brigdes are parallelized 
 * together, the disabling of one bridge leads to the disabling
 * of the second one
 **********************************************************/
void BSP_MotorControl_CmdDisable(uint8_t deviceId)
{
 800f1c4:	b580      	push	{r7, lr}
 800f1c6:	b082      	sub	sp, #8
 800f1c8:	af00      	add	r7, sp, #0
 800f1ca:	0002      	movs	r2, r0
 800f1cc:	1dfb      	adds	r3, r7, #7
 800f1ce:	701a      	strb	r2, [r3, #0]
  if ((motorDrvHandle != 0)&&(motorDrvHandle->CmdDisable != 0))
 800f1d0:	4b0c      	ldr	r3, [pc, #48]	; (800f204 <BSP_MotorControl_CmdDisable+0x40>)
 800f1d2:	681b      	ldr	r3, [r3, #0]
 800f1d4:	2b00      	cmp	r3, #0
 800f1d6:	d00c      	beq.n	800f1f2 <BSP_MotorControl_CmdDisable+0x2e>
 800f1d8:	4b0a      	ldr	r3, [pc, #40]	; (800f204 <BSP_MotorControl_CmdDisable+0x40>)
 800f1da:	681b      	ldr	r3, [r3, #0]
 800f1dc:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800f1de:	2b00      	cmp	r3, #0
 800f1e0:	d007      	beq.n	800f1f2 <BSP_MotorControl_CmdDisable+0x2e>
  {
    motorDrvHandle->CmdDisable(deviceId);
 800f1e2:	4b08      	ldr	r3, [pc, #32]	; (800f204 <BSP_MotorControl_CmdDisable+0x40>)
 800f1e4:	681b      	ldr	r3, [r3, #0]
 800f1e6:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800f1e8:	1dfa      	adds	r2, r7, #7
 800f1ea:	7812      	ldrb	r2, [r2, #0]
 800f1ec:	0010      	movs	r0, r2
 800f1ee:	4798      	blx	r3
 800f1f0:	e003      	b.n	800f1fa <BSP_MotorControl_CmdDisable+0x36>
  }
  else
  {
    MOTOR_CONTROL_ERROR_UNDEFINED_FUNCTION(31);
 800f1f2:	4b05      	ldr	r3, [pc, #20]	; (800f208 <BSP_MotorControl_CmdDisable+0x44>)
 800f1f4:	0018      	movs	r0, r3
 800f1f6:	f7ff fdcb 	bl	800ed90 <BSP_MotorControl_ErrorHandler>
  }    
}
 800f1fa:	46c0      	nop			; (mov r8, r8)
 800f1fc:	46bd      	mov	sp, r7
 800f1fe:	b002      	add	sp, #8
 800f200:	bd80      	pop	{r7, pc}
 800f202:	46c0      	nop			; (mov r8, r8)
 800f204:	20000460 	.word	0x20000460
 800f208:	0000081f 	.word	0x0000081f

0800f20c <BSP_MotorControl_GetBridgeInputPwmFreq>:
 * @param[in] bridgeId from 0 for bridge A to 1 for bridge B for brush DC motor
 * bridgeId must be 0 for L6208 (both bridges are set with the same frequency)
 * @retval Freq in Hz
 **********************************************************/
uint32_t BSP_MotorControl_GetBridgeInputPwmFreq(uint8_t bridgeId)
{	
 800f20c:	b580      	push	{r7, lr}
 800f20e:	b084      	sub	sp, #16
 800f210:	af00      	add	r7, sp, #0
 800f212:	0002      	movs	r2, r0
 800f214:	1dfb      	adds	r3, r7, #7
 800f216:	701a      	strb	r2, [r3, #0]
  uint32_t pwmFreq = 0;
 800f218:	2300      	movs	r3, #0
 800f21a:	60fb      	str	r3, [r7, #12]
  
  if ((motorDrvHandle != 0)&&(motorDrvHandle->GetBridgeInputPwmFreq != 0))
 800f21c:	4b0f      	ldr	r3, [pc, #60]	; (800f25c <BSP_MotorControl_GetBridgeInputPwmFreq+0x50>)
 800f21e:	681b      	ldr	r3, [r3, #0]
 800f220:	2b00      	cmp	r3, #0
 800f222:	d012      	beq.n	800f24a <BSP_MotorControl_GetBridgeInputPwmFreq+0x3e>
 800f224:	4b0d      	ldr	r3, [pc, #52]	; (800f25c <BSP_MotorControl_GetBridgeInputPwmFreq+0x50>)
 800f226:	681a      	ldr	r2, [r3, #0]
 800f228:	2384      	movs	r3, #132	; 0x84
 800f22a:	005b      	lsls	r3, r3, #1
 800f22c:	58d3      	ldr	r3, [r2, r3]
 800f22e:	2b00      	cmp	r3, #0
 800f230:	d00b      	beq.n	800f24a <BSP_MotorControl_GetBridgeInputPwmFreq+0x3e>
  {
    pwmFreq = motorDrvHandle->GetBridgeInputPwmFreq(bridgeId);
 800f232:	4b0a      	ldr	r3, [pc, #40]	; (800f25c <BSP_MotorControl_GetBridgeInputPwmFreq+0x50>)
 800f234:	681a      	ldr	r2, [r3, #0]
 800f236:	2384      	movs	r3, #132	; 0x84
 800f238:	005b      	lsls	r3, r3, #1
 800f23a:	58d3      	ldr	r3, [r2, r3]
 800f23c:	1dfa      	adds	r2, r7, #7
 800f23e:	7812      	ldrb	r2, [r2, #0]
 800f240:	0010      	movs	r0, r2
 800f242:	4798      	blx	r3
 800f244:	0003      	movs	r3, r0
 800f246:	60fb      	str	r3, [r7, #12]
 800f248:	e003      	b.n	800f252 <BSP_MotorControl_GetBridgeInputPwmFreq+0x46>
  }
  else
  {
    MOTOR_CONTROL_ERROR_UNDEFINED_FUNCTION(66);
 800f24a:	4b05      	ldr	r3, [pc, #20]	; (800f260 <BSP_MotorControl_GetBridgeInputPwmFreq+0x54>)
 800f24c:	0018      	movs	r0, r3
 800f24e:	f7ff fd9f 	bl	800ed90 <BSP_MotorControl_ErrorHandler>
  }    
  return (pwmFreq);
 800f252:	68fb      	ldr	r3, [r7, #12]
}
 800f254:	0018      	movs	r0, r3
 800f256:	46bd      	mov	sp, r7
 800f258:	b004      	add	sp, #16
 800f25a:	bd80      	pop	{r7, pc}
 800f25c:	20000460 	.word	0x20000460
 800f260:	00000842 	.word	0x00000842

0800f264 <BSP_MotorControl_SetStopMode>:
 *            deviceId dummy parameter for compatibility with motor.h
 * @param[in] stopMode selected stop mode
 * @retval None
 **********************************************************/
void BSP_MotorControl_SetStopMode(uint8_t deviceId, motorStopMode_t stopMode)
{
 800f264:	b580      	push	{r7, lr}
 800f266:	b082      	sub	sp, #8
 800f268:	af00      	add	r7, sp, #0
 800f26a:	0002      	movs	r2, r0
 800f26c:	1dfb      	adds	r3, r7, #7
 800f26e:	701a      	strb	r2, [r3, #0]
 800f270:	1dbb      	adds	r3, r7, #6
 800f272:	1c0a      	adds	r2, r1, #0
 800f274:	701a      	strb	r2, [r3, #0]
  if ((motorDrvHandle != 0)&&(motorDrvHandle->SetStopMode != 0))
 800f276:	4b0f      	ldr	r3, [pc, #60]	; (800f2b4 <BSP_MotorControl_SetStopMode+0x50>)
 800f278:	681b      	ldr	r3, [r3, #0]
 800f27a:	2b00      	cmp	r3, #0
 800f27c:	d012      	beq.n	800f2a4 <BSP_MotorControl_SetStopMode+0x40>
 800f27e:	4b0d      	ldr	r3, [pc, #52]	; (800f2b4 <BSP_MotorControl_SetStopMode+0x50>)
 800f280:	681a      	ldr	r2, [r3, #0]
 800f282:	2388      	movs	r3, #136	; 0x88
 800f284:	005b      	lsls	r3, r3, #1
 800f286:	58d3      	ldr	r3, [r2, r3]
 800f288:	2b00      	cmp	r3, #0
 800f28a:	d00b      	beq.n	800f2a4 <BSP_MotorControl_SetStopMode+0x40>
  {
    motorDrvHandle->SetStopMode(deviceId, stopMode);
 800f28c:	4b09      	ldr	r3, [pc, #36]	; (800f2b4 <BSP_MotorControl_SetStopMode+0x50>)
 800f28e:	681a      	ldr	r2, [r3, #0]
 800f290:	2388      	movs	r3, #136	; 0x88
 800f292:	005b      	lsls	r3, r3, #1
 800f294:	58d3      	ldr	r3, [r2, r3]
 800f296:	1dba      	adds	r2, r7, #6
 800f298:	7811      	ldrb	r1, [r2, #0]
 800f29a:	1dfa      	adds	r2, r7, #7
 800f29c:	7812      	ldrb	r2, [r2, #0]
 800f29e:	0010      	movs	r0, r2
 800f2a0:	4798      	blx	r3
 800f2a2:	e003      	b.n	800f2ac <BSP_MotorControl_SetStopMode+0x48>
  }
  else
  {
    MOTOR_CONTROL_ERROR_UNDEFINED_FUNCTION(68);
 800f2a4:	4b04      	ldr	r3, [pc, #16]	; (800f2b8 <BSP_MotorControl_SetStopMode+0x54>)
 800f2a6:	0018      	movs	r0, r3
 800f2a8:	f7ff fd72 	bl	800ed90 <BSP_MotorControl_ErrorHandler>
  } 
}
 800f2ac:	46c0      	nop			; (mov r8, r8)
 800f2ae:	46bd      	mov	sp, r7
 800f2b0:	b002      	add	sp, #8
 800f2b2:	bd80      	pop	{r7, pc}
 800f2b4:	20000460 	.word	0x20000460
 800f2b8:	00000844 	.word	0x00000844

0800f2bc <BSP_MotorControl_SetNbDevices>:
 * from 1 to MAX_NUMBER_OF_DEVICES
 * @retval TRUE if successfull, FALSE if failure, attempt 
 * to set a number of devices greater than MAX_NUMBER_OF_DEVICES
 **********************************************************/
bool BSP_MotorControl_SetNbDevices(uint16_t id, uint8_t nbDevices)
{
 800f2bc:	b590      	push	{r4, r7, lr}
 800f2be:	b085      	sub	sp, #20
 800f2c0:	af00      	add	r7, sp, #0
 800f2c2:	0002      	movs	r2, r0
 800f2c4:	1dbb      	adds	r3, r7, #6
 800f2c6:	801a      	strh	r2, [r3, #0]
 800f2c8:	1d7b      	adds	r3, r7, #5
 800f2ca:	1c0a      	adds	r2, r1, #0
 800f2cc:	701a      	strb	r2, [r3, #0]
  MotorControlBoardId = id;
 800f2ce:	4b49      	ldr	r3, [pc, #292]	; (800f3f4 <BSP_MotorControl_SetNbDevices+0x138>)
 800f2d0:	1dba      	adds	r2, r7, #6
 800f2d2:	8812      	ldrh	r2, [r2, #0]
 800f2d4:	801a      	strh	r2, [r3, #0]
  bool status = FALSE;
 800f2d6:	230f      	movs	r3, #15
 800f2d8:	18fb      	adds	r3, r7, r3
 800f2da:	2200      	movs	r2, #0
 800f2dc:	701a      	strb	r2, [r3, #0]
  if (id == BSP_MOTOR_CONTROL_BOARD_ID_L6474)
 800f2de:	1dbb      	adds	r3, r7, #6
 800f2e0:	881b      	ldrh	r3, [r3, #0]
 800f2e2:	4a45      	ldr	r2, [pc, #276]	; (800f3f8 <BSP_MotorControl_SetNbDevices+0x13c>)
 800f2e4:	4293      	cmp	r3, r2
 800f2e6:	d105      	bne.n	800f2f4 <BSP_MotorControl_SetNbDevices+0x38>
  {
    motorDrvHandle = L6474_GetMotorHandle();
 800f2e8:	f7ff fce8 	bl	800ecbc <L6474_GetMotorHandle>
 800f2ec:	0002      	movs	r2, r0
 800f2ee:	4b43      	ldr	r3, [pc, #268]	; (800f3fc <BSP_MotorControl_SetNbDevices+0x140>)
 800f2f0:	601a      	str	r2, [r3, #0]
 800f2f2:	e05b      	b.n	800f3ac <BSP_MotorControl_SetNbDevices+0xf0>
  }
  else if (id == BSP_MOTOR_CONTROL_BOARD_ID_POWERSTEP01)
 800f2f4:	1dbb      	adds	r3, r7, #6
 800f2f6:	881b      	ldrh	r3, [r3, #0]
 800f2f8:	2b01      	cmp	r3, #1
 800f2fa:	d105      	bne.n	800f308 <BSP_MotorControl_SetNbDevices+0x4c>
  {
    motorDrvHandle = Powerstep01_GetMotorHandle();
 800f2fc:	f7ff fcf0 	bl	800ece0 <Powerstep01_GetMotorHandle>
 800f300:	0002      	movs	r2, r0
 800f302:	4b3e      	ldr	r3, [pc, #248]	; (800f3fc <BSP_MotorControl_SetNbDevices+0x140>)
 800f304:	601a      	str	r2, [r3, #0]
 800f306:	e051      	b.n	800f3ac <BSP_MotorControl_SetNbDevices+0xf0>
  }
  else if (id == BSP_MOTOR_CONTROL_BOARD_ID_L6206)
 800f308:	1dbb      	adds	r3, r7, #6
 800f30a:	881b      	ldrh	r3, [r3, #0]
 800f30c:	4a3c      	ldr	r2, [pc, #240]	; (800f400 <BSP_MotorControl_SetNbDevices+0x144>)
 800f30e:	4293      	cmp	r3, r2
 800f310:	d105      	bne.n	800f31e <BSP_MotorControl_SetNbDevices+0x62>
  {
    motorDrvHandle = L6206_GetMotorHandle();
 800f312:	f7ff fceb 	bl	800ecec <L6206_GetMotorHandle>
 800f316:	0002      	movs	r2, r0
 800f318:	4b38      	ldr	r3, [pc, #224]	; (800f3fc <BSP_MotorControl_SetNbDevices+0x140>)
 800f31a:	601a      	str	r2, [r3, #0]
 800f31c:	e046      	b.n	800f3ac <BSP_MotorControl_SetNbDevices+0xf0>
  }
  else if (id == BSP_MOTOR_CONTROL_BOARD_ID_L6208)
 800f31e:	1dbb      	adds	r3, r7, #6
 800f320:	881a      	ldrh	r2, [r3, #0]
 800f322:	23c2      	movs	r3, #194	; 0xc2
 800f324:	015b      	lsls	r3, r3, #5
 800f326:	429a      	cmp	r2, r3
 800f328:	d105      	bne.n	800f336 <BSP_MotorControl_SetNbDevices+0x7a>
  {
    motorDrvHandle = L6208_GetMotorHandle();
 800f32a:	f7ff fce5 	bl	800ecf8 <L6208_GetMotorHandle>
 800f32e:	0002      	movs	r2, r0
 800f330:	4b32      	ldr	r3, [pc, #200]	; (800f3fc <BSP_MotorControl_SetNbDevices+0x140>)
 800f332:	601a      	str	r2, [r3, #0]
 800f334:	e03a      	b.n	800f3ac <BSP_MotorControl_SetNbDevices+0xf0>
  }
  else if (id == BSP_MOTOR_CONTROL_BOARD_ID_STSPIN220)
 800f336:	1dbb      	adds	r3, r7, #6
 800f338:	881b      	ldrh	r3, [r3, #0]
 800f33a:	2bdc      	cmp	r3, #220	; 0xdc
 800f33c:	d105      	bne.n	800f34a <BSP_MotorControl_SetNbDevices+0x8e>
  {
    motorDrvHandle = Stspin220_GetMotorHandle();
 800f33e:	f7f6 ffc7 	bl	80062d0 <Stspin220_GetMotorHandle>
 800f342:	0002      	movs	r2, r0
 800f344:	4b2d      	ldr	r3, [pc, #180]	; (800f3fc <BSP_MotorControl_SetNbDevices+0x140>)
 800f346:	601a      	str	r2, [r3, #0]
 800f348:	e030      	b.n	800f3ac <BSP_MotorControl_SetNbDevices+0xf0>
  }
  else if ( (id == BSP_MOTOR_CONTROL_BOARD_ID_L6470) ||
 800f34a:	1dbb      	adds	r3, r7, #6
 800f34c:	881b      	ldrh	r3, [r3, #0]
 800f34e:	4a2d      	ldr	r2, [pc, #180]	; (800f404 <BSP_MotorControl_SetNbDevices+0x148>)
 800f350:	4293      	cmp	r3, r2
 800f352:	d004      	beq.n	800f35e <BSP_MotorControl_SetNbDevices+0xa2>
 800f354:	1dbb      	adds	r3, r7, #6
 800f356:	881b      	ldrh	r3, [r3, #0]
 800f358:	4a2b      	ldr	r2, [pc, #172]	; (800f408 <BSP_MotorControl_SetNbDevices+0x14c>)
 800f35a:	4293      	cmp	r3, r2
 800f35c:	d105      	bne.n	800f36a <BSP_MotorControl_SetNbDevices+0xae>
		     (id == BSP_MOTOR_CONTROL_BOARD_ID_L6472) )
  {
    motorDrvHandle = l647x_GetMotorHandle();
 800f35e:	f7ff fcb3 	bl	800ecc8 <l647x_GetMotorHandle>
 800f362:	0002      	movs	r2, r0
 800f364:	4b25      	ldr	r3, [pc, #148]	; (800f3fc <BSP_MotorControl_SetNbDevices+0x140>)
 800f366:	601a      	str	r2, [r3, #0]
 800f368:	e020      	b.n	800f3ac <BSP_MotorControl_SetNbDevices+0xf0>
  }
  else if ( (id == BSP_MOTOR_CONTROL_BOARD_ID_L6480) ||
 800f36a:	1dbb      	adds	r3, r7, #6
 800f36c:	881b      	ldrh	r3, [r3, #0]
 800f36e:	4a27      	ldr	r2, [pc, #156]	; (800f40c <BSP_MotorControl_SetNbDevices+0x150>)
 800f370:	4293      	cmp	r3, r2
 800f372:	d004      	beq.n	800f37e <BSP_MotorControl_SetNbDevices+0xc2>
 800f374:	1dbb      	adds	r3, r7, #6
 800f376:	881b      	ldrh	r3, [r3, #0]
 800f378:	4a25      	ldr	r2, [pc, #148]	; (800f410 <BSP_MotorControl_SetNbDevices+0x154>)
 800f37a:	4293      	cmp	r3, r2
 800f37c:	d105      	bne.n	800f38a <BSP_MotorControl_SetNbDevices+0xce>
		     (id == BSP_MOTOR_CONTROL_BOARD_ID_L6482) )
  {
    motorDrvHandle = l648x_GetMotorHandle();
 800f37e:	f7ff fca9 	bl	800ecd4 <l648x_GetMotorHandle>
 800f382:	0002      	movs	r2, r0
 800f384:	4b1d      	ldr	r3, [pc, #116]	; (800f3fc <BSP_MotorControl_SetNbDevices+0x140>)
 800f386:	601a      	str	r2, [r3, #0]
 800f388:	e010      	b.n	800f3ac <BSP_MotorControl_SetNbDevices+0xf0>
  }
  else if ((id == BSP_MOTOR_CONTROL_BOARD_ID_STSPIN240)||
 800f38a:	1dbb      	adds	r3, r7, #6
 800f38c:	881b      	ldrh	r3, [r3, #0]
 800f38e:	2bf0      	cmp	r3, #240	; 0xf0
 800f390:	d003      	beq.n	800f39a <BSP_MotorControl_SetNbDevices+0xde>
 800f392:	1dbb      	adds	r3, r7, #6
 800f394:	881b      	ldrh	r3, [r3, #0]
 800f396:	2bfa      	cmp	r3, #250	; 0xfa
 800f398:	d105      	bne.n	800f3a6 <BSP_MotorControl_SetNbDevices+0xea>
            (id == BSP_MOTOR_CONTROL_BOARD_ID_STSPIN250))
  {
    motorDrvHandle = Stspin240_250_GetMotorHandle();
 800f39a:	f7ff fcb3 	bl	800ed04 <Stspin240_250_GetMotorHandle>
 800f39e:	0002      	movs	r2, r0
 800f3a0:	4b16      	ldr	r3, [pc, #88]	; (800f3fc <BSP_MotorControl_SetNbDevices+0x140>)
 800f3a2:	601a      	str	r2, [r3, #0]
 800f3a4:	e002      	b.n	800f3ac <BSP_MotorControl_SetNbDevices+0xf0>
  }  
  else
  {
    motorDrvHandle = 0;
 800f3a6:	4b15      	ldr	r3, [pc, #84]	; (800f3fc <BSP_MotorControl_SetNbDevices+0x140>)
 800f3a8:	2200      	movs	r2, #0
 800f3aa:	601a      	str	r2, [r3, #0]
  }
  if ((motorDrvHandle != 0)&&(motorDrvHandle->SetNbDevices != 0)&&(nbDevices !=0))
 800f3ac:	4b13      	ldr	r3, [pc, #76]	; (800f3fc <BSP_MotorControl_SetNbDevices+0x140>)
 800f3ae:	681b      	ldr	r3, [r3, #0]
 800f3b0:	2b00      	cmp	r3, #0
 800f3b2:	d017      	beq.n	800f3e4 <BSP_MotorControl_SetNbDevices+0x128>
 800f3b4:	4b11      	ldr	r3, [pc, #68]	; (800f3fc <BSP_MotorControl_SetNbDevices+0x140>)
 800f3b6:	681a      	ldr	r2, [r3, #0]
 800f3b8:	23a2      	movs	r3, #162	; 0xa2
 800f3ba:	005b      	lsls	r3, r3, #1
 800f3bc:	58d3      	ldr	r3, [r2, r3]
 800f3be:	2b00      	cmp	r3, #0
 800f3c0:	d010      	beq.n	800f3e4 <BSP_MotorControl_SetNbDevices+0x128>
 800f3c2:	1d7b      	adds	r3, r7, #5
 800f3c4:	781b      	ldrb	r3, [r3, #0]
 800f3c6:	2b00      	cmp	r3, #0
 800f3c8:	d00c      	beq.n	800f3e4 <BSP_MotorControl_SetNbDevices+0x128>
  {
    status = motorDrvHandle->SetNbDevices(nbDevices);
 800f3ca:	4b0c      	ldr	r3, [pc, #48]	; (800f3fc <BSP_MotorControl_SetNbDevices+0x140>)
 800f3cc:	681a      	ldr	r2, [r3, #0]
 800f3ce:	23a2      	movs	r3, #162	; 0xa2
 800f3d0:	005b      	lsls	r3, r3, #1
 800f3d2:	58d3      	ldr	r3, [r2, r3]
 800f3d4:	220f      	movs	r2, #15
 800f3d6:	18bc      	adds	r4, r7, r2
 800f3d8:	1d7a      	adds	r2, r7, #5
 800f3da:	7812      	ldrb	r2, [r2, #0]
 800f3dc:	0010      	movs	r0, r2
 800f3de:	4798      	blx	r3
 800f3e0:	0003      	movs	r3, r0
 800f3e2:	7023      	strb	r3, [r4, #0]
  }
  return (status);
 800f3e4:	230f      	movs	r3, #15
 800f3e6:	18fb      	adds	r3, r7, r3
 800f3e8:	781b      	ldrb	r3, [r3, #0]
}
 800f3ea:	0018      	movs	r0, r3
 800f3ec:	46bd      	mov	sp, r7
 800f3ee:	b005      	add	sp, #20
 800f3f0:	bd90      	pop	{r4, r7, pc}
 800f3f2:	46c0      	nop			; (mov r8, r8)
 800f3f4:	20000464 	.word	0x20000464
 800f3f8:	0000194a 	.word	0x0000194a
 800f3fc:	20000460 	.word	0x20000460
 800f400:	0000183e 	.word	0x0000183e
 800f404:	00001946 	.word	0x00001946
 800f408:	00001948 	.word	0x00001948
 800f40c:	00001950 	.word	0x00001950
 800f410:	00001952 	.word	0x00001952

0800f414 <HAL_Init>:
  *        In the default implementation,Systick is used as source of time base.
  *        the tick variable is incremented each 1ms in its ISR.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 800f414:	b580      	push	{r7, lr}
 800f416:	b082      	sub	sp, #8
 800f418:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef  status = HAL_OK;
 800f41a:	1dfb      	adds	r3, r7, #7
 800f41c:	2200      	movs	r2, #0
 800f41e:	701a      	strb	r2, [r3, #0]
#if (BUFFER_CACHE_DISABLE != 0)
  __HAL_FLASH_BUFFER_CACHE_DISABLE();
#endif /* BUFFER_CACHE_DISABLE */

#if (PREREAD_ENABLE != 0)
  __HAL_FLASH_PREREAD_BUFFER_ENABLE();
 800f420:	4b0b      	ldr	r3, [pc, #44]	; (800f450 <HAL_Init+0x3c>)
 800f422:	681a      	ldr	r2, [r3, #0]
 800f424:	4b0a      	ldr	r3, [pc, #40]	; (800f450 <HAL_Init+0x3c>)
 800f426:	2140      	movs	r1, #64	; 0x40
 800f428:	430a      	orrs	r2, r1
 800f42a:	601a      	str	r2, [r3, #0]
#if (PREFETCH_ENABLE != 0)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
#endif /* PREFETCH_ENABLE */

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 800f42c:	2000      	movs	r0, #0
 800f42e:	f000 f811 	bl	800f454 <HAL_InitTick>
 800f432:	1e03      	subs	r3, r0, #0
 800f434:	d003      	beq.n	800f43e <HAL_Init+0x2a>
  {
    status = HAL_ERROR;
 800f436:	1dfb      	adds	r3, r7, #7
 800f438:	2201      	movs	r2, #1
 800f43a:	701a      	strb	r2, [r3, #0]
 800f43c:	e001      	b.n	800f442 <HAL_Init+0x2e>
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
 800f43e:	f7f6 fd59 	bl	8005ef4 <HAL_MspInit>
  }

  /* Return function status */
  return status;
 800f442:	1dfb      	adds	r3, r7, #7
 800f444:	781b      	ldrb	r3, [r3, #0]
}
 800f446:	0018      	movs	r0, r3
 800f448:	46bd      	mov	sp, r7
 800f44a:	b002      	add	sp, #8
 800f44c:	bd80      	pop	{r7, pc}
 800f44e:	46c0      	nop			; (mov r8, r8)
 800f450:	40022000 	.word	0x40022000

0800f454 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800f454:	b590      	push	{r4, r7, lr}
 800f456:	b083      	sub	sp, #12
 800f458:	af00      	add	r7, sp, #0
 800f45a:	6078      	str	r0, [r7, #4]
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 800f45c:	4b14      	ldr	r3, [pc, #80]	; (800f4b0 <HAL_InitTick+0x5c>)
 800f45e:	681c      	ldr	r4, [r3, #0]
 800f460:	4b14      	ldr	r3, [pc, #80]	; (800f4b4 <HAL_InitTick+0x60>)
 800f462:	781b      	ldrb	r3, [r3, #0]
 800f464:	0019      	movs	r1, r3
 800f466:	23fa      	movs	r3, #250	; 0xfa
 800f468:	0098      	lsls	r0, r3, #2
 800f46a:	f7f0 fe5f 	bl	800012c <__udivsi3>
 800f46e:	0003      	movs	r3, r0
 800f470:	0019      	movs	r1, r3
 800f472:	0020      	movs	r0, r4
 800f474:	f7f0 fe5a 	bl	800012c <__udivsi3>
 800f478:	0003      	movs	r3, r0
 800f47a:	0018      	movs	r0, r3
 800f47c:	f000 f969 	bl	800f752 <HAL_SYSTICK_Config>
 800f480:	1e03      	subs	r3, r0, #0
 800f482:	d001      	beq.n	800f488 <HAL_InitTick+0x34>
  {
    return HAL_ERROR;
 800f484:	2301      	movs	r3, #1
 800f486:	e00f      	b.n	800f4a8 <HAL_InitTick+0x54>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 800f488:	687b      	ldr	r3, [r7, #4]
 800f48a:	2b03      	cmp	r3, #3
 800f48c:	d80b      	bhi.n	800f4a6 <HAL_InitTick+0x52>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 800f48e:	6879      	ldr	r1, [r7, #4]
 800f490:	2301      	movs	r3, #1
 800f492:	425b      	negs	r3, r3
 800f494:	2200      	movs	r2, #0
 800f496:	0018      	movs	r0, r3
 800f498:	f000 f926 	bl	800f6e8 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 800f49c:	4b06      	ldr	r3, [pc, #24]	; (800f4b8 <HAL_InitTick+0x64>)
 800f49e:	687a      	ldr	r2, [r7, #4]
 800f4a0:	601a      	str	r2, [r3, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
 800f4a2:	2300      	movs	r3, #0
 800f4a4:	e000      	b.n	800f4a8 <HAL_InitTick+0x54>
    return HAL_ERROR;
 800f4a6:	2301      	movs	r3, #1
}
 800f4a8:	0018      	movs	r0, r3
 800f4aa:	46bd      	mov	sp, r7
 800f4ac:	b003      	add	sp, #12
 800f4ae:	bd90      	pop	{r4, r7, pc}
 800f4b0:	200000d8 	.word	0x200000d8
 800f4b4:	20000264 	.word	0x20000264
 800f4b8:	20000260 	.word	0x20000260

0800f4bc <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 800f4bc:	b580      	push	{r7, lr}
 800f4be:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 800f4c0:	4b05      	ldr	r3, [pc, #20]	; (800f4d8 <HAL_IncTick+0x1c>)
 800f4c2:	781b      	ldrb	r3, [r3, #0]
 800f4c4:	001a      	movs	r2, r3
 800f4c6:	4b05      	ldr	r3, [pc, #20]	; (800f4dc <HAL_IncTick+0x20>)
 800f4c8:	681b      	ldr	r3, [r3, #0]
 800f4ca:	18d2      	adds	r2, r2, r3
 800f4cc:	4b03      	ldr	r3, [pc, #12]	; (800f4dc <HAL_IncTick+0x20>)
 800f4ce:	601a      	str	r2, [r3, #0]
}
 800f4d0:	46c0      	nop			; (mov r8, r8)
 800f4d2:	46bd      	mov	sp, r7
 800f4d4:	bd80      	pop	{r7, pc}
 800f4d6:	46c0      	nop			; (mov r8, r8)
 800f4d8:	20000264 	.word	0x20000264
 800f4dc:	20003440 	.word	0x20003440

0800f4e0 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 800f4e0:	b580      	push	{r7, lr}
 800f4e2:	af00      	add	r7, sp, #0
  return uwTick;
 800f4e4:	4b02      	ldr	r3, [pc, #8]	; (800f4f0 <HAL_GetTick+0x10>)
 800f4e6:	681b      	ldr	r3, [r3, #0]
}
 800f4e8:	0018      	movs	r0, r3
 800f4ea:	46bd      	mov	sp, r7
 800f4ec:	bd80      	pop	{r7, pc}
 800f4ee:	46c0      	nop			; (mov r8, r8)
 800f4f0:	20003440 	.word	0x20003440

0800f4f4 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 800f4f4:	b580      	push	{r7, lr}
 800f4f6:	b084      	sub	sp, #16
 800f4f8:	af00      	add	r7, sp, #0
 800f4fa:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 800f4fc:	f7ff fff0 	bl	800f4e0 <HAL_GetTick>
 800f500:	0003      	movs	r3, r0
 800f502:	60bb      	str	r3, [r7, #8]
  uint32_t wait = Delay;
 800f504:	687b      	ldr	r3, [r7, #4]
 800f506:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 800f508:	68fb      	ldr	r3, [r7, #12]
 800f50a:	3301      	adds	r3, #1
 800f50c:	d005      	beq.n	800f51a <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
 800f50e:	4b09      	ldr	r3, [pc, #36]	; (800f534 <HAL_Delay+0x40>)
 800f510:	781b      	ldrb	r3, [r3, #0]
 800f512:	001a      	movs	r2, r3
 800f514:	68fb      	ldr	r3, [r7, #12]
 800f516:	189b      	adds	r3, r3, r2
 800f518:	60fb      	str	r3, [r7, #12]
  }

  while((HAL_GetTick() - tickstart) < wait)
 800f51a:	46c0      	nop			; (mov r8, r8)
 800f51c:	f7ff ffe0 	bl	800f4e0 <HAL_GetTick>
 800f520:	0002      	movs	r2, r0
 800f522:	68bb      	ldr	r3, [r7, #8]
 800f524:	1ad3      	subs	r3, r2, r3
 800f526:	68fa      	ldr	r2, [r7, #12]
 800f528:	429a      	cmp	r2, r3
 800f52a:	d8f7      	bhi.n	800f51c <HAL_Delay+0x28>
  {
  }
}
 800f52c:	46c0      	nop			; (mov r8, r8)
 800f52e:	46bd      	mov	sp, r7
 800f530:	b004      	add	sp, #16
 800f532:	bd80      	pop	{r7, pc}
 800f534:	20000264 	.word	0x20000264

0800f538 <NVIC_EnableIRQ>:
  \brief   Enable External Interrupt
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800f538:	b580      	push	{r7, lr}
 800f53a:	b082      	sub	sp, #8
 800f53c:	af00      	add	r7, sp, #0
 800f53e:	0002      	movs	r2, r0
 800f540:	1dfb      	adds	r3, r7, #7
 800f542:	701a      	strb	r2, [r3, #0]
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 800f544:	1dfb      	adds	r3, r7, #7
 800f546:	781b      	ldrb	r3, [r3, #0]
 800f548:	001a      	movs	r2, r3
 800f54a:	231f      	movs	r3, #31
 800f54c:	401a      	ands	r2, r3
 800f54e:	4b04      	ldr	r3, [pc, #16]	; (800f560 <NVIC_EnableIRQ+0x28>)
 800f550:	2101      	movs	r1, #1
 800f552:	4091      	lsls	r1, r2
 800f554:	000a      	movs	r2, r1
 800f556:	601a      	str	r2, [r3, #0]
}
 800f558:	46c0      	nop			; (mov r8, r8)
 800f55a:	46bd      	mov	sp, r7
 800f55c:	b002      	add	sp, #8
 800f55e:	bd80      	pop	{r7, pc}
 800f560:	e000e100 	.word	0xe000e100

0800f564 <NVIC_DisableIRQ>:
  \brief   Disable External Interrupt
  \details Disables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
 800f564:	b580      	push	{r7, lr}
 800f566:	b082      	sub	sp, #8
 800f568:	af00      	add	r7, sp, #0
 800f56a:	0002      	movs	r2, r0
 800f56c:	1dfb      	adds	r3, r7, #7
 800f56e:	701a      	strb	r2, [r3, #0]
  NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 800f570:	1dfb      	adds	r3, r7, #7
 800f572:	781b      	ldrb	r3, [r3, #0]
 800f574:	001a      	movs	r2, r3
 800f576:	231f      	movs	r3, #31
 800f578:	4013      	ands	r3, r2
 800f57a:	4905      	ldr	r1, [pc, #20]	; (800f590 <NVIC_DisableIRQ+0x2c>)
 800f57c:	2201      	movs	r2, #1
 800f57e:	409a      	lsls	r2, r3
 800f580:	0013      	movs	r3, r2
 800f582:	2280      	movs	r2, #128	; 0x80
 800f584:	508b      	str	r3, [r1, r2]
}
 800f586:	46c0      	nop			; (mov r8, r8)
 800f588:	46bd      	mov	sp, r7
 800f58a:	b002      	add	sp, #8
 800f58c:	bd80      	pop	{r7, pc}
 800f58e:	46c0      	nop			; (mov r8, r8)
 800f590:	e000e100 	.word	0xe000e100

0800f594 <NVIC_ClearPendingIRQ>:
  \brief   Clear Pending Interrupt
  \details Clears the pending bit of an external interrupt.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
 800f594:	b580      	push	{r7, lr}
 800f596:	b082      	sub	sp, #8
 800f598:	af00      	add	r7, sp, #0
 800f59a:	0002      	movs	r2, r0
 800f59c:	1dfb      	adds	r3, r7, #7
 800f59e:	701a      	strb	r2, [r3, #0]
  NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 800f5a0:	1dfb      	adds	r3, r7, #7
 800f5a2:	781b      	ldrb	r3, [r3, #0]
 800f5a4:	001a      	movs	r2, r3
 800f5a6:	231f      	movs	r3, #31
 800f5a8:	4013      	ands	r3, r2
 800f5aa:	4905      	ldr	r1, [pc, #20]	; (800f5c0 <NVIC_ClearPendingIRQ+0x2c>)
 800f5ac:	2201      	movs	r2, #1
 800f5ae:	409a      	lsls	r2, r3
 800f5b0:	23c0      	movs	r3, #192	; 0xc0
 800f5b2:	005b      	lsls	r3, r3, #1
 800f5b4:	50ca      	str	r2, [r1, r3]
}
 800f5b6:	46c0      	nop			; (mov r8, r8)
 800f5b8:	46bd      	mov	sp, r7
 800f5ba:	b002      	add	sp, #8
 800f5bc:	bd80      	pop	{r7, pc}
 800f5be:	46c0      	nop			; (mov r8, r8)
 800f5c0:	e000e100 	.word	0xe000e100

0800f5c4 <NVIC_SetPriority>:
  \note    The priority cannot be set for every core interrupt.
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 800f5c4:	b590      	push	{r4, r7, lr}
 800f5c6:	b083      	sub	sp, #12
 800f5c8:	af00      	add	r7, sp, #0
 800f5ca:	0002      	movs	r2, r0
 800f5cc:	6039      	str	r1, [r7, #0]
 800f5ce:	1dfb      	adds	r3, r7, #7
 800f5d0:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) < 0)
 800f5d2:	1dfb      	adds	r3, r7, #7
 800f5d4:	781b      	ldrb	r3, [r3, #0]
 800f5d6:	2b7f      	cmp	r3, #127	; 0x7f
 800f5d8:	d932      	bls.n	800f640 <NVIC_SetPriority+0x7c>
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800f5da:	4a2f      	ldr	r2, [pc, #188]	; (800f698 <NVIC_SetPriority+0xd4>)
 800f5dc:	1dfb      	adds	r3, r7, #7
 800f5de:	781b      	ldrb	r3, [r3, #0]
 800f5e0:	0019      	movs	r1, r3
 800f5e2:	230f      	movs	r3, #15
 800f5e4:	400b      	ands	r3, r1
 800f5e6:	3b08      	subs	r3, #8
 800f5e8:	089b      	lsrs	r3, r3, #2
 800f5ea:	3306      	adds	r3, #6
 800f5ec:	009b      	lsls	r3, r3, #2
 800f5ee:	18d3      	adds	r3, r2, r3
 800f5f0:	3304      	adds	r3, #4
 800f5f2:	681b      	ldr	r3, [r3, #0]
 800f5f4:	1dfa      	adds	r2, r7, #7
 800f5f6:	7812      	ldrb	r2, [r2, #0]
 800f5f8:	0011      	movs	r1, r2
 800f5fa:	2203      	movs	r2, #3
 800f5fc:	400a      	ands	r2, r1
 800f5fe:	00d2      	lsls	r2, r2, #3
 800f600:	21ff      	movs	r1, #255	; 0xff
 800f602:	4091      	lsls	r1, r2
 800f604:	000a      	movs	r2, r1
 800f606:	43d2      	mvns	r2, r2
 800f608:	401a      	ands	r2, r3
 800f60a:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 800f60c:	683b      	ldr	r3, [r7, #0]
 800f60e:	019b      	lsls	r3, r3, #6
 800f610:	22ff      	movs	r2, #255	; 0xff
 800f612:	401a      	ands	r2, r3
 800f614:	1dfb      	adds	r3, r7, #7
 800f616:	781b      	ldrb	r3, [r3, #0]
 800f618:	0018      	movs	r0, r3
 800f61a:	2303      	movs	r3, #3
 800f61c:	4003      	ands	r3, r0
 800f61e:	00db      	lsls	r3, r3, #3
 800f620:	409a      	lsls	r2, r3
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800f622:	481d      	ldr	r0, [pc, #116]	; (800f698 <NVIC_SetPriority+0xd4>)
 800f624:	1dfb      	adds	r3, r7, #7
 800f626:	781b      	ldrb	r3, [r3, #0]
 800f628:	001c      	movs	r4, r3
 800f62a:	230f      	movs	r3, #15
 800f62c:	4023      	ands	r3, r4
 800f62e:	3b08      	subs	r3, #8
 800f630:	089b      	lsrs	r3, r3, #2
 800f632:	430a      	orrs	r2, r1
 800f634:	3306      	adds	r3, #6
 800f636:	009b      	lsls	r3, r3, #2
 800f638:	18c3      	adds	r3, r0, r3
 800f63a:	3304      	adds	r3, #4
 800f63c:	601a      	str	r2, [r3, #0]
  else
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
}
 800f63e:	e027      	b.n	800f690 <NVIC_SetPriority+0xcc>
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800f640:	4a16      	ldr	r2, [pc, #88]	; (800f69c <NVIC_SetPriority+0xd8>)
 800f642:	1dfb      	adds	r3, r7, #7
 800f644:	781b      	ldrb	r3, [r3, #0]
 800f646:	b25b      	sxtb	r3, r3
 800f648:	089b      	lsrs	r3, r3, #2
 800f64a:	33c0      	adds	r3, #192	; 0xc0
 800f64c:	009b      	lsls	r3, r3, #2
 800f64e:	589b      	ldr	r3, [r3, r2]
 800f650:	1dfa      	adds	r2, r7, #7
 800f652:	7812      	ldrb	r2, [r2, #0]
 800f654:	0011      	movs	r1, r2
 800f656:	2203      	movs	r2, #3
 800f658:	400a      	ands	r2, r1
 800f65a:	00d2      	lsls	r2, r2, #3
 800f65c:	21ff      	movs	r1, #255	; 0xff
 800f65e:	4091      	lsls	r1, r2
 800f660:	000a      	movs	r2, r1
 800f662:	43d2      	mvns	r2, r2
 800f664:	401a      	ands	r2, r3
 800f666:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 800f668:	683b      	ldr	r3, [r7, #0]
 800f66a:	019b      	lsls	r3, r3, #6
 800f66c:	22ff      	movs	r2, #255	; 0xff
 800f66e:	401a      	ands	r2, r3
 800f670:	1dfb      	adds	r3, r7, #7
 800f672:	781b      	ldrb	r3, [r3, #0]
 800f674:	0018      	movs	r0, r3
 800f676:	2303      	movs	r3, #3
 800f678:	4003      	ands	r3, r0
 800f67a:	00db      	lsls	r3, r3, #3
 800f67c:	409a      	lsls	r2, r3
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800f67e:	4807      	ldr	r0, [pc, #28]	; (800f69c <NVIC_SetPriority+0xd8>)
 800f680:	1dfb      	adds	r3, r7, #7
 800f682:	781b      	ldrb	r3, [r3, #0]
 800f684:	b25b      	sxtb	r3, r3
 800f686:	089b      	lsrs	r3, r3, #2
 800f688:	430a      	orrs	r2, r1
 800f68a:	33c0      	adds	r3, #192	; 0xc0
 800f68c:	009b      	lsls	r3, r3, #2
 800f68e:	501a      	str	r2, [r3, r0]
}
 800f690:	46c0      	nop			; (mov r8, r8)
 800f692:	46bd      	mov	sp, r7
 800f694:	b003      	add	sp, #12
 800f696:	bd90      	pop	{r4, r7, pc}
 800f698:	e000ed00 	.word	0xe000ed00
 800f69c:	e000e100 	.word	0xe000e100

0800f6a0 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 800f6a0:	b580      	push	{r7, lr}
 800f6a2:	b082      	sub	sp, #8
 800f6a4:	af00      	add	r7, sp, #0
 800f6a6:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 800f6a8:	687b      	ldr	r3, [r7, #4]
 800f6aa:	3b01      	subs	r3, #1
 800f6ac:	4a0c      	ldr	r2, [pc, #48]	; (800f6e0 <SysTick_Config+0x40>)
 800f6ae:	4293      	cmp	r3, r2
 800f6b0:	d901      	bls.n	800f6b6 <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 800f6b2:	2301      	movs	r3, #1
 800f6b4:	e010      	b.n	800f6d8 <SysTick_Config+0x38>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800f6b6:	4b0b      	ldr	r3, [pc, #44]	; (800f6e4 <SysTick_Config+0x44>)
 800f6b8:	687a      	ldr	r2, [r7, #4]
 800f6ba:	3a01      	subs	r2, #1
 800f6bc:	605a      	str	r2, [r3, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 800f6be:	2301      	movs	r3, #1
 800f6c0:	425b      	negs	r3, r3
 800f6c2:	2103      	movs	r1, #3
 800f6c4:	0018      	movs	r0, r3
 800f6c6:	f7ff ff7d 	bl	800f5c4 <NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800f6ca:	4b06      	ldr	r3, [pc, #24]	; (800f6e4 <SysTick_Config+0x44>)
 800f6cc:	2200      	movs	r2, #0
 800f6ce:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800f6d0:	4b04      	ldr	r3, [pc, #16]	; (800f6e4 <SysTick_Config+0x44>)
 800f6d2:	2207      	movs	r2, #7
 800f6d4:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 800f6d6:	2300      	movs	r3, #0
}
 800f6d8:	0018      	movs	r0, r3
 800f6da:	46bd      	mov	sp, r7
 800f6dc:	b002      	add	sp, #8
 800f6de:	bd80      	pop	{r7, pc}
 800f6e0:	00ffffff 	.word	0x00ffffff
 800f6e4:	e000e010 	.word	0xe000e010

0800f6e8 <HAL_NVIC_SetPriority>:
  *         with stm32l0xx devices, this parameter is a dummy value and it is ignored, because 
  *         no subpriority supported in Cortex M0+ based products.   
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 800f6e8:	b580      	push	{r7, lr}
 800f6ea:	b084      	sub	sp, #16
 800f6ec:	af00      	add	r7, sp, #0
 800f6ee:	60b9      	str	r1, [r7, #8]
 800f6f0:	607a      	str	r2, [r7, #4]
 800f6f2:	210f      	movs	r1, #15
 800f6f4:	187b      	adds	r3, r7, r1
 800f6f6:	1c02      	adds	r2, r0, #0
 800f6f8:	701a      	strb	r2, [r3, #0]
    /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn,PreemptPriority);
 800f6fa:	68ba      	ldr	r2, [r7, #8]
 800f6fc:	187b      	adds	r3, r7, r1
 800f6fe:	781b      	ldrb	r3, [r3, #0]
 800f700:	b25b      	sxtb	r3, r3
 800f702:	0011      	movs	r1, r2
 800f704:	0018      	movs	r0, r3
 800f706:	f7ff ff5d 	bl	800f5c4 <NVIC_SetPriority>
}
 800f70a:	46c0      	nop			; (mov r8, r8)
 800f70c:	46bd      	mov	sp, r7
 800f70e:	b004      	add	sp, #16
 800f710:	bd80      	pop	{r7, pc}

0800f712 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of  IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to stm32l0xx.h file)  
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800f712:	b580      	push	{r7, lr}
 800f714:	b082      	sub	sp, #8
 800f716:	af00      	add	r7, sp, #0
 800f718:	0002      	movs	r2, r0
 800f71a:	1dfb      	adds	r3, r7, #7
 800f71c:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 800f71e:	1dfb      	adds	r3, r7, #7
 800f720:	781b      	ldrb	r3, [r3, #0]
 800f722:	b25b      	sxtb	r3, r3
 800f724:	0018      	movs	r0, r3
 800f726:	f7ff ff07 	bl	800f538 <NVIC_EnableIRQ>
}
 800f72a:	46c0      	nop			; (mov r8, r8)
 800f72c:	46bd      	mov	sp, r7
 800f72e:	b002      	add	sp, #8
 800f730:	bd80      	pop	{r7, pc}

0800f732 <HAL_NVIC_DisableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to stm32l0xx.h file)  
  * @retval None
  */
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
 800f732:	b580      	push	{r7, lr}
 800f734:	b082      	sub	sp, #8
 800f736:	af00      	add	r7, sp, #0
 800f738:	0002      	movs	r2, r0
 800f73a:	1dfb      	adds	r3, r7, #7
 800f73c:	701a      	strb	r2, [r3, #0]
    /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
 800f73e:	1dfb      	adds	r3, r7, #7
 800f740:	781b      	ldrb	r3, [r3, #0]
 800f742:	b25b      	sxtb	r3, r3
 800f744:	0018      	movs	r0, r3
 800f746:	f7ff ff0d 	bl	800f564 <NVIC_DisableIRQ>
}
 800f74a:	46c0      	nop			; (mov r8, r8)
 800f74c:	46bd      	mov	sp, r7
 800f74e:	b002      	add	sp, #8
 800f750:	bd80      	pop	{r7, pc}

0800f752 <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 800f752:	b580      	push	{r7, lr}
 800f754:	b082      	sub	sp, #8
 800f756:	af00      	add	r7, sp, #0
 800f758:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 800f75a:	687b      	ldr	r3, [r7, #4]
 800f75c:	0018      	movs	r0, r3
 800f75e:	f7ff ff9f 	bl	800f6a0 <SysTick_Config>
 800f762:	0003      	movs	r3, r0
}
 800f764:	0018      	movs	r0, r3
 800f766:	46bd      	mov	sp, r7
 800f768:	b002      	add	sp, #8
 800f76a:	bd80      	pop	{r7, pc}

0800f76c <HAL_NVIC_ClearPendingIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to stm32l0xx.h file)  
  * @retval None
  */
void HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{ 
 800f76c:	b580      	push	{r7, lr}
 800f76e:	b082      	sub	sp, #8
 800f770:	af00      	add	r7, sp, #0
 800f772:	0002      	movs	r2, r0
 800f774:	1dfb      	adds	r3, r7, #7
 800f776:	701a      	strb	r2, [r3, #0]
  /* Clear pending interrupt */
  NVIC_ClearPendingIRQ(IRQn);
 800f778:	1dfb      	adds	r3, r7, #7
 800f77a:	781b      	ldrb	r3, [r3, #0]
 800f77c:	b25b      	sxtb	r3, r3
 800f77e:	0018      	movs	r0, r3
 800f780:	f7ff ff08 	bl	800f594 <NVIC_ClearPendingIRQ>
}
 800f784:	46c0      	nop			; (mov r8, r8)
 800f786:	46bd      	mov	sp, r7
 800f788:	b002      	add	sp, #8
 800f78a:	bd80      	pop	{r7, pc}

0800f78c <HAL_DMA_Abort_IT>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified DMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
 800f78c:	b580      	push	{r7, lr}
 800f78e:	b084      	sub	sp, #16
 800f790:	af00      	add	r7, sp, #0
 800f792:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 800f794:	230f      	movs	r3, #15
 800f796:	18fb      	adds	r3, r7, r3
 800f798:	2200      	movs	r2, #0
 800f79a:	701a      	strb	r2, [r3, #0]

  if(HAL_DMA_STATE_BUSY != hdma->State)
 800f79c:	687b      	ldr	r3, [r7, #4]
 800f79e:	2225      	movs	r2, #37	; 0x25
 800f7a0:	5c9b      	ldrb	r3, [r3, r2]
 800f7a2:	b2db      	uxtb	r3, r3
 800f7a4:	2b02      	cmp	r3, #2
 800f7a6:	d007      	beq.n	800f7b8 <HAL_DMA_Abort_IT+0x2c>
  {
    /* no transfer ongoing */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 800f7a8:	687b      	ldr	r3, [r7, #4]
 800f7aa:	2204      	movs	r2, #4
 800f7ac:	63da      	str	r2, [r3, #60]	; 0x3c

    status = HAL_ERROR;
 800f7ae:	230f      	movs	r3, #15
 800f7b0:	18fb      	adds	r3, r7, r3
 800f7b2:	2201      	movs	r2, #1
 800f7b4:	701a      	strb	r2, [r3, #0]
 800f7b6:	e02a      	b.n	800f80e <HAL_DMA_Abort_IT+0x82>
  }
  else
  {
    /* Disable DMA IT */
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 800f7b8:	687b      	ldr	r3, [r7, #4]
 800f7ba:	681b      	ldr	r3, [r3, #0]
 800f7bc:	681a      	ldr	r2, [r3, #0]
 800f7be:	687b      	ldr	r3, [r7, #4]
 800f7c0:	681b      	ldr	r3, [r3, #0]
 800f7c2:	210e      	movs	r1, #14
 800f7c4:	438a      	bics	r2, r1
 800f7c6:	601a      	str	r2, [r3, #0]

    /* Disable the channel */
    __HAL_DMA_DISABLE(hdma);
 800f7c8:	687b      	ldr	r3, [r7, #4]
 800f7ca:	681b      	ldr	r3, [r3, #0]
 800f7cc:	681a      	ldr	r2, [r3, #0]
 800f7ce:	687b      	ldr	r3, [r7, #4]
 800f7d0:	681b      	ldr	r3, [r3, #0]
 800f7d2:	2101      	movs	r1, #1
 800f7d4:	438a      	bics	r2, r1
 800f7d6:	601a      	str	r2, [r3, #0]

    /* Clear all flags */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1cU));
 800f7d8:	687b      	ldr	r3, [r7, #4]
 800f7da:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800f7dc:	221c      	movs	r2, #28
 800f7de:	401a      	ands	r2, r3
 800f7e0:	687b      	ldr	r3, [r7, #4]
 800f7e2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800f7e4:	2101      	movs	r1, #1
 800f7e6:	4091      	lsls	r1, r2
 800f7e8:	000a      	movs	r2, r1
 800f7ea:	605a      	str	r2, [r3, #4]

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
 800f7ec:	687b      	ldr	r3, [r7, #4]
 800f7ee:	2225      	movs	r2, #37	; 0x25
 800f7f0:	2101      	movs	r1, #1
 800f7f2:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 800f7f4:	687b      	ldr	r3, [r7, #4]
 800f7f6:	2224      	movs	r2, #36	; 0x24
 800f7f8:	2100      	movs	r1, #0
 800f7fa:	5499      	strb	r1, [r3, r2]

    /* Call User Abort callback */
    if(hdma->XferAbortCallback != NULL)
 800f7fc:	687b      	ldr	r3, [r7, #4]
 800f7fe:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800f800:	2b00      	cmp	r3, #0
 800f802:	d004      	beq.n	800f80e <HAL_DMA_Abort_IT+0x82>
    {
      hdma->XferAbortCallback(hdma);
 800f804:	687b      	ldr	r3, [r7, #4]
 800f806:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800f808:	687a      	ldr	r2, [r7, #4]
 800f80a:	0010      	movs	r0, r2
 800f80c:	4798      	blx	r3
    }
  }
  return status;
 800f80e:	230f      	movs	r3, #15
 800f810:	18fb      	adds	r3, r7, r3
 800f812:	781b      	ldrb	r3, [r3, #0]
}
 800f814:	0018      	movs	r0, r3
 800f816:	46bd      	mov	sp, r7
 800f818:	b004      	add	sp, #16
 800f81a:	bd80      	pop	{r7, pc}

0800f81c <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *                    the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 800f81c:	b580      	push	{r7, lr}
 800f81e:	b086      	sub	sp, #24
 800f820:	af00      	add	r7, sp, #0
 800f822:	6078      	str	r0, [r7, #4]
 800f824:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
 800f826:	2300      	movs	r3, #0
 800f828:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00U;
 800f82a:	2300      	movs	r3, #0
 800f82c:	60fb      	str	r3, [r7, #12]
  uint32_t temp = 0x00U;
 800f82e:	2300      	movs	r3, #0
 800f830:	613b      	str	r3, [r7, #16]
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
  assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx, (GPIO_Init->Pin)));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0)
 800f832:	e155      	b.n	800fae0 <HAL_GPIO_Init+0x2c4>
  {
    /* Get the IO position */
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 800f834:	683b      	ldr	r3, [r7, #0]
 800f836:	681b      	ldr	r3, [r3, #0]
 800f838:	2101      	movs	r1, #1
 800f83a:	697a      	ldr	r2, [r7, #20]
 800f83c:	4091      	lsls	r1, r2
 800f83e:	000a      	movs	r2, r1
 800f840:	4013      	ands	r3, r2
 800f842:	60fb      	str	r3, [r7, #12]

    if (iocurrent)
 800f844:	68fb      	ldr	r3, [r7, #12]
 800f846:	2b00      	cmp	r3, #0
 800f848:	d100      	bne.n	800f84c <HAL_GPIO_Init+0x30>
 800f84a:	e146      	b.n	800fada <HAL_GPIO_Init+0x2be>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800f84c:	683b      	ldr	r3, [r7, #0]
 800f84e:	685b      	ldr	r3, [r3, #4]
 800f850:	2b01      	cmp	r3, #1
 800f852:	d00b      	beq.n	800f86c <HAL_GPIO_Init+0x50>
 800f854:	683b      	ldr	r3, [r7, #0]
 800f856:	685b      	ldr	r3, [r3, #4]
 800f858:	2b02      	cmp	r3, #2
 800f85a:	d007      	beq.n	800f86c <HAL_GPIO_Init+0x50>
          (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 800f85c:	683b      	ldr	r3, [r7, #0]
 800f85e:	685b      	ldr	r3, [r3, #4]
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800f860:	2b11      	cmp	r3, #17
 800f862:	d003      	beq.n	800f86c <HAL_GPIO_Init+0x50>
          (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 800f864:	683b      	ldr	r3, [r7, #0]
 800f866:	685b      	ldr	r3, [r3, #4]
 800f868:	2b12      	cmp	r3, #18
 800f86a:	d130      	bne.n	800f8ce <HAL_GPIO_Init+0xb2>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 800f86c:	687b      	ldr	r3, [r7, #4]
 800f86e:	689b      	ldr	r3, [r3, #8]
 800f870:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDER_OSPEED0 << (position * 2U));
 800f872:	697b      	ldr	r3, [r7, #20]
 800f874:	005b      	lsls	r3, r3, #1
 800f876:	2203      	movs	r2, #3
 800f878:	409a      	lsls	r2, r3
 800f87a:	0013      	movs	r3, r2
 800f87c:	43da      	mvns	r2, r3
 800f87e:	693b      	ldr	r3, [r7, #16]
 800f880:	4013      	ands	r3, r2
 800f882:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * 2U));
 800f884:	683b      	ldr	r3, [r7, #0]
 800f886:	68da      	ldr	r2, [r3, #12]
 800f888:	697b      	ldr	r3, [r7, #20]
 800f88a:	005b      	lsls	r3, r3, #1
 800f88c:	409a      	lsls	r2, r3
 800f88e:	0013      	movs	r3, r2
 800f890:	693a      	ldr	r2, [r7, #16]
 800f892:	4313      	orrs	r3, r2
 800f894:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
 800f896:	687b      	ldr	r3, [r7, #4]
 800f898:	693a      	ldr	r2, [r7, #16]
 800f89a:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 800f89c:	687b      	ldr	r3, [r7, #4]
 800f89e:	685b      	ldr	r3, [r3, #4]
 800f8a0:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 800f8a2:	2201      	movs	r2, #1
 800f8a4:	697b      	ldr	r3, [r7, #20]
 800f8a6:	409a      	lsls	r2, r3
 800f8a8:	0013      	movs	r3, r2
 800f8aa:	43da      	mvns	r2, r3
 800f8ac:	693b      	ldr	r3, [r7, #16]
 800f8ae:	4013      	ands	r3, r2
 800f8b0:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 800f8b2:	683b      	ldr	r3, [r7, #0]
 800f8b4:	685b      	ldr	r3, [r3, #4]
 800f8b6:	091b      	lsrs	r3, r3, #4
 800f8b8:	2201      	movs	r2, #1
 800f8ba:	401a      	ands	r2, r3
 800f8bc:	697b      	ldr	r3, [r7, #20]
 800f8be:	409a      	lsls	r2, r3
 800f8c0:	0013      	movs	r3, r2
 800f8c2:	693a      	ldr	r2, [r7, #16]
 800f8c4:	4313      	orrs	r3, r2
 800f8c6:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
 800f8c8:	687b      	ldr	r3, [r7, #4]
 800f8ca:	693a      	ldr	r2, [r7, #16]
 800f8cc:	605a      	str	r2, [r3, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 800f8ce:	687b      	ldr	r3, [r7, #4]
 800f8d0:	68db      	ldr	r3, [r3, #12]
 800f8d2:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 800f8d4:	697b      	ldr	r3, [r7, #20]
 800f8d6:	005b      	lsls	r3, r3, #1
 800f8d8:	2203      	movs	r2, #3
 800f8da:	409a      	lsls	r2, r3
 800f8dc:	0013      	movs	r3, r2
 800f8de:	43da      	mvns	r2, r3
 800f8e0:	693b      	ldr	r3, [r7, #16]
 800f8e2:	4013      	ands	r3, r2
 800f8e4:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 800f8e6:	683b      	ldr	r3, [r7, #0]
 800f8e8:	689a      	ldr	r2, [r3, #8]
 800f8ea:	697b      	ldr	r3, [r7, #20]
 800f8ec:	005b      	lsls	r3, r3, #1
 800f8ee:	409a      	lsls	r2, r3
 800f8f0:	0013      	movs	r3, r2
 800f8f2:	693a      	ldr	r2, [r7, #16]
 800f8f4:	4313      	orrs	r3, r2
 800f8f6:	613b      	str	r3, [r7, #16]
      GPIOx->PUPDR = temp;
 800f8f8:	687b      	ldr	r3, [r7, #4]
 800f8fa:	693a      	ldr	r2, [r7, #16]
 800f8fc:	60da      	str	r2, [r3, #12]

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 800f8fe:	683b      	ldr	r3, [r7, #0]
 800f900:	685b      	ldr	r3, [r3, #4]
 800f902:	2b02      	cmp	r3, #2
 800f904:	d003      	beq.n	800f90e <HAL_GPIO_Init+0xf2>
 800f906:	683b      	ldr	r3, [r7, #0]
 800f908:	685b      	ldr	r3, [r3, #4]
 800f90a:	2b12      	cmp	r3, #18
 800f90c:	d123      	bne.n	800f956 <HAL_GPIO_Init+0x13a>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 800f90e:	697b      	ldr	r3, [r7, #20]
 800f910:	08da      	lsrs	r2, r3, #3
 800f912:	687b      	ldr	r3, [r7, #4]
 800f914:	3208      	adds	r2, #8
 800f916:	0092      	lsls	r2, r2, #2
 800f918:	58d3      	ldr	r3, [r2, r3]
 800f91a:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U));
 800f91c:	697b      	ldr	r3, [r7, #20]
 800f91e:	2207      	movs	r2, #7
 800f920:	4013      	ands	r3, r2
 800f922:	009b      	lsls	r3, r3, #2
 800f924:	220f      	movs	r2, #15
 800f926:	409a      	lsls	r2, r3
 800f928:	0013      	movs	r3, r2
 800f92a:	43da      	mvns	r2, r3
 800f92c:	693b      	ldr	r3, [r7, #16]
 800f92e:	4013      	ands	r3, r2
 800f930:	613b      	str	r3, [r7, #16]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U));
 800f932:	683b      	ldr	r3, [r7, #0]
 800f934:	691a      	ldr	r2, [r3, #16]
 800f936:	697b      	ldr	r3, [r7, #20]
 800f938:	2107      	movs	r1, #7
 800f93a:	400b      	ands	r3, r1
 800f93c:	009b      	lsls	r3, r3, #2
 800f93e:	409a      	lsls	r2, r3
 800f940:	0013      	movs	r3, r2
 800f942:	693a      	ldr	r2, [r7, #16]
 800f944:	4313      	orrs	r3, r2
 800f946:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3U] = temp;
 800f948:	697b      	ldr	r3, [r7, #20]
 800f94a:	08da      	lsrs	r2, r3, #3
 800f94c:	687b      	ldr	r3, [r7, #4]
 800f94e:	3208      	adds	r2, #8
 800f950:	0092      	lsls	r2, r2, #2
 800f952:	6939      	ldr	r1, [r7, #16]
 800f954:	50d1      	str	r1, [r2, r3]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 800f956:	687b      	ldr	r3, [r7, #4]
 800f958:	681b      	ldr	r3, [r3, #0]
 800f95a:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 800f95c:	697b      	ldr	r3, [r7, #20]
 800f95e:	005b      	lsls	r3, r3, #1
 800f960:	2203      	movs	r2, #3
 800f962:	409a      	lsls	r2, r3
 800f964:	0013      	movs	r3, r2
 800f966:	43da      	mvns	r2, r3
 800f968:	693b      	ldr	r3, [r7, #16]
 800f96a:	4013      	ands	r3, r2
 800f96c:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800f96e:	683b      	ldr	r3, [r7, #0]
 800f970:	685b      	ldr	r3, [r3, #4]
 800f972:	2203      	movs	r2, #3
 800f974:	401a      	ands	r2, r3
 800f976:	697b      	ldr	r3, [r7, #20]
 800f978:	005b      	lsls	r3, r3, #1
 800f97a:	409a      	lsls	r2, r3
 800f97c:	0013      	movs	r3, r2
 800f97e:	693a      	ldr	r2, [r7, #16]
 800f980:	4313      	orrs	r3, r2
 800f982:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
 800f984:	687b      	ldr	r3, [r7, #4]
 800f986:	693a      	ldr	r2, [r7, #16]
 800f988:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 800f98a:	683b      	ldr	r3, [r7, #0]
 800f98c:	685a      	ldr	r2, [r3, #4]
 800f98e:	2380      	movs	r3, #128	; 0x80
 800f990:	055b      	lsls	r3, r3, #21
 800f992:	4013      	ands	r3, r2
 800f994:	d100      	bne.n	800f998 <HAL_GPIO_Init+0x17c>
 800f996:	e0a0      	b.n	800fada <HAL_GPIO_Init+0x2be>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800f998:	4b57      	ldr	r3, [pc, #348]	; (800faf8 <HAL_GPIO_Init+0x2dc>)
 800f99a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800f99c:	4b56      	ldr	r3, [pc, #344]	; (800faf8 <HAL_GPIO_Init+0x2dc>)
 800f99e:	2101      	movs	r1, #1
 800f9a0:	430a      	orrs	r2, r1
 800f9a2:	635a      	str	r2, [r3, #52]	; 0x34

        temp = SYSCFG->EXTICR[position >> 2U];
 800f9a4:	4a55      	ldr	r2, [pc, #340]	; (800fafc <HAL_GPIO_Init+0x2e0>)
 800f9a6:	697b      	ldr	r3, [r7, #20]
 800f9a8:	089b      	lsrs	r3, r3, #2
 800f9aa:	3302      	adds	r3, #2
 800f9ac:	009b      	lsls	r3, r3, #2
 800f9ae:	589b      	ldr	r3, [r3, r2]
 800f9b0:	613b      	str	r3, [r7, #16]
        CLEAR_BIT(temp, ((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 800f9b2:	697b      	ldr	r3, [r7, #20]
 800f9b4:	2203      	movs	r2, #3
 800f9b6:	4013      	ands	r3, r2
 800f9b8:	009b      	lsls	r3, r3, #2
 800f9ba:	220f      	movs	r2, #15
 800f9bc:	409a      	lsls	r2, r3
 800f9be:	0013      	movs	r3, r2
 800f9c0:	43da      	mvns	r2, r3
 800f9c2:	693b      	ldr	r3, [r7, #16]
 800f9c4:	4013      	ands	r3, r2
 800f9c6:	613b      	str	r3, [r7, #16]
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03U)));
 800f9c8:	687a      	ldr	r2, [r7, #4]
 800f9ca:	23a0      	movs	r3, #160	; 0xa0
 800f9cc:	05db      	lsls	r3, r3, #23
 800f9ce:	429a      	cmp	r2, r3
 800f9d0:	d01f      	beq.n	800fa12 <HAL_GPIO_Init+0x1f6>
 800f9d2:	687b      	ldr	r3, [r7, #4]
 800f9d4:	4a4a      	ldr	r2, [pc, #296]	; (800fb00 <HAL_GPIO_Init+0x2e4>)
 800f9d6:	4293      	cmp	r3, r2
 800f9d8:	d019      	beq.n	800fa0e <HAL_GPIO_Init+0x1f2>
 800f9da:	687b      	ldr	r3, [r7, #4]
 800f9dc:	4a49      	ldr	r2, [pc, #292]	; (800fb04 <HAL_GPIO_Init+0x2e8>)
 800f9de:	4293      	cmp	r3, r2
 800f9e0:	d013      	beq.n	800fa0a <HAL_GPIO_Init+0x1ee>
 800f9e2:	687b      	ldr	r3, [r7, #4]
 800f9e4:	4a48      	ldr	r2, [pc, #288]	; (800fb08 <HAL_GPIO_Init+0x2ec>)
 800f9e6:	4293      	cmp	r3, r2
 800f9e8:	d00d      	beq.n	800fa06 <HAL_GPIO_Init+0x1ea>
 800f9ea:	687b      	ldr	r3, [r7, #4]
 800f9ec:	4a47      	ldr	r2, [pc, #284]	; (800fb0c <HAL_GPIO_Init+0x2f0>)
 800f9ee:	4293      	cmp	r3, r2
 800f9f0:	d007      	beq.n	800fa02 <HAL_GPIO_Init+0x1e6>
 800f9f2:	687b      	ldr	r3, [r7, #4]
 800f9f4:	4a46      	ldr	r2, [pc, #280]	; (800fb10 <HAL_GPIO_Init+0x2f4>)
 800f9f6:	4293      	cmp	r3, r2
 800f9f8:	d101      	bne.n	800f9fe <HAL_GPIO_Init+0x1e2>
 800f9fa:	2305      	movs	r3, #5
 800f9fc:	e00a      	b.n	800fa14 <HAL_GPIO_Init+0x1f8>
 800f9fe:	2306      	movs	r3, #6
 800fa00:	e008      	b.n	800fa14 <HAL_GPIO_Init+0x1f8>
 800fa02:	2304      	movs	r3, #4
 800fa04:	e006      	b.n	800fa14 <HAL_GPIO_Init+0x1f8>
 800fa06:	2303      	movs	r3, #3
 800fa08:	e004      	b.n	800fa14 <HAL_GPIO_Init+0x1f8>
 800fa0a:	2302      	movs	r3, #2
 800fa0c:	e002      	b.n	800fa14 <HAL_GPIO_Init+0x1f8>
 800fa0e:	2301      	movs	r3, #1
 800fa10:	e000      	b.n	800fa14 <HAL_GPIO_Init+0x1f8>
 800fa12:	2300      	movs	r3, #0
 800fa14:	697a      	ldr	r2, [r7, #20]
 800fa16:	2103      	movs	r1, #3
 800fa18:	400a      	ands	r2, r1
 800fa1a:	0092      	lsls	r2, r2, #2
 800fa1c:	4093      	lsls	r3, r2
 800fa1e:	693a      	ldr	r2, [r7, #16]
 800fa20:	4313      	orrs	r3, r2
 800fa22:	613b      	str	r3, [r7, #16]
        SYSCFG->EXTICR[position >> 2U] = temp;
 800fa24:	4935      	ldr	r1, [pc, #212]	; (800fafc <HAL_GPIO_Init+0x2e0>)
 800fa26:	697b      	ldr	r3, [r7, #20]
 800fa28:	089b      	lsrs	r3, r3, #2
 800fa2a:	3302      	adds	r3, #2
 800fa2c:	009b      	lsls	r3, r3, #2
 800fa2e:	693a      	ldr	r2, [r7, #16]
 800fa30:	505a      	str	r2, [r3, r1]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 800fa32:	4b38      	ldr	r3, [pc, #224]	; (800fb14 <HAL_GPIO_Init+0x2f8>)
 800fa34:	681b      	ldr	r3, [r3, #0]
 800fa36:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)iocurrent);
 800fa38:	68fb      	ldr	r3, [r7, #12]
 800fa3a:	43da      	mvns	r2, r3
 800fa3c:	693b      	ldr	r3, [r7, #16]
 800fa3e:	4013      	ands	r3, r2
 800fa40:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800fa42:	683b      	ldr	r3, [r7, #0]
 800fa44:	685a      	ldr	r2, [r3, #4]
 800fa46:	2380      	movs	r3, #128	; 0x80
 800fa48:	025b      	lsls	r3, r3, #9
 800fa4a:	4013      	ands	r3, r2
 800fa4c:	d003      	beq.n	800fa56 <HAL_GPIO_Init+0x23a>
        {
          temp |= iocurrent;
 800fa4e:	693a      	ldr	r2, [r7, #16]
 800fa50:	68fb      	ldr	r3, [r7, #12]
 800fa52:	4313      	orrs	r3, r2
 800fa54:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR = temp;
 800fa56:	4b2f      	ldr	r3, [pc, #188]	; (800fb14 <HAL_GPIO_Init+0x2f8>)
 800fa58:	693a      	ldr	r2, [r7, #16]
 800fa5a:	601a      	str	r2, [r3, #0]

        temp = EXTI->EMR;
 800fa5c:	4b2d      	ldr	r3, [pc, #180]	; (800fb14 <HAL_GPIO_Init+0x2f8>)
 800fa5e:	685b      	ldr	r3, [r3, #4]
 800fa60:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)iocurrent);
 800fa62:	68fb      	ldr	r3, [r7, #12]
 800fa64:	43da      	mvns	r2, r3
 800fa66:	693b      	ldr	r3, [r7, #16]
 800fa68:	4013      	ands	r3, r2
 800fa6a:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800fa6c:	683b      	ldr	r3, [r7, #0]
 800fa6e:	685a      	ldr	r2, [r3, #4]
 800fa70:	2380      	movs	r3, #128	; 0x80
 800fa72:	029b      	lsls	r3, r3, #10
 800fa74:	4013      	ands	r3, r2
 800fa76:	d003      	beq.n	800fa80 <HAL_GPIO_Init+0x264>
        {
          temp |= iocurrent;
 800fa78:	693a      	ldr	r2, [r7, #16]
 800fa7a:	68fb      	ldr	r3, [r7, #12]
 800fa7c:	4313      	orrs	r3, r2
 800fa7e:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR = temp;
 800fa80:	4b24      	ldr	r3, [pc, #144]	; (800fb14 <HAL_GPIO_Init+0x2f8>)
 800fa82:	693a      	ldr	r2, [r7, #16]
 800fa84:	605a      	str	r2, [r3, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 800fa86:	4b23      	ldr	r3, [pc, #140]	; (800fb14 <HAL_GPIO_Init+0x2f8>)
 800fa88:	689b      	ldr	r3, [r3, #8]
 800fa8a:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)iocurrent);
 800fa8c:	68fb      	ldr	r3, [r7, #12]
 800fa8e:	43da      	mvns	r2, r3
 800fa90:	693b      	ldr	r3, [r7, #16]
 800fa92:	4013      	ands	r3, r2
 800fa94:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 800fa96:	683b      	ldr	r3, [r7, #0]
 800fa98:	685a      	ldr	r2, [r3, #4]
 800fa9a:	2380      	movs	r3, #128	; 0x80
 800fa9c:	035b      	lsls	r3, r3, #13
 800fa9e:	4013      	ands	r3, r2
 800faa0:	d003      	beq.n	800faaa <HAL_GPIO_Init+0x28e>
        {
          temp |= iocurrent;
 800faa2:	693a      	ldr	r2, [r7, #16]
 800faa4:	68fb      	ldr	r3, [r7, #12]
 800faa6:	4313      	orrs	r3, r2
 800faa8:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR = temp;
 800faaa:	4b1a      	ldr	r3, [pc, #104]	; (800fb14 <HAL_GPIO_Init+0x2f8>)
 800faac:	693a      	ldr	r2, [r7, #16]
 800faae:	609a      	str	r2, [r3, #8]

        temp = EXTI->FTSR;
 800fab0:	4b18      	ldr	r3, [pc, #96]	; (800fb14 <HAL_GPIO_Init+0x2f8>)
 800fab2:	68db      	ldr	r3, [r3, #12]
 800fab4:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)iocurrent);
 800fab6:	68fb      	ldr	r3, [r7, #12]
 800fab8:	43da      	mvns	r2, r3
 800faba:	693b      	ldr	r3, [r7, #16]
 800fabc:	4013      	ands	r3, r2
 800fabe:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 800fac0:	683b      	ldr	r3, [r7, #0]
 800fac2:	685a      	ldr	r2, [r3, #4]
 800fac4:	2380      	movs	r3, #128	; 0x80
 800fac6:	039b      	lsls	r3, r3, #14
 800fac8:	4013      	ands	r3, r2
 800faca:	d003      	beq.n	800fad4 <HAL_GPIO_Init+0x2b8>
        {
          temp |= iocurrent;
 800facc:	693a      	ldr	r2, [r7, #16]
 800face:	68fb      	ldr	r3, [r7, #12]
 800fad0:	4313      	orrs	r3, r2
 800fad2:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR = temp;
 800fad4:	4b0f      	ldr	r3, [pc, #60]	; (800fb14 <HAL_GPIO_Init+0x2f8>)
 800fad6:	693a      	ldr	r2, [r7, #16]
 800fad8:	60da      	str	r2, [r3, #12]
      }
    }
    position++;
 800fada:	697b      	ldr	r3, [r7, #20]
 800fadc:	3301      	adds	r3, #1
 800fade:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0)
 800fae0:	683b      	ldr	r3, [r7, #0]
 800fae2:	681a      	ldr	r2, [r3, #0]
 800fae4:	697b      	ldr	r3, [r7, #20]
 800fae6:	40da      	lsrs	r2, r3
 800fae8:	1e13      	subs	r3, r2, #0
 800faea:	d000      	beq.n	800faee <HAL_GPIO_Init+0x2d2>
 800faec:	e6a2      	b.n	800f834 <HAL_GPIO_Init+0x18>
  }
}
 800faee:	46c0      	nop			; (mov r8, r8)
 800faf0:	46bd      	mov	sp, r7
 800faf2:	b006      	add	sp, #24
 800faf4:	bd80      	pop	{r7, pc}
 800faf6:	46c0      	nop			; (mov r8, r8)
 800faf8:	40021000 	.word	0x40021000
 800fafc:	40010000 	.word	0x40010000
 800fb00:	50000400 	.word	0x50000400
 800fb04:	50000800 	.word	0x50000800
 800fb08:	50000c00 	.word	0x50000c00
 800fb0c:	50001000 	.word	0x50001000
 800fb10:	50001c00 	.word	0x50001c00
 800fb14:	40010400 	.word	0x40010400

0800fb18 <HAL_GPIO_DeInit>:
  *                   This parameter can be one of GPIO_PIN_x where x can be (0..15).
  *                   All port bits are not necessarily available on all GPIOs.
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
 800fb18:	b580      	push	{r7, lr}
 800fb1a:	b086      	sub	sp, #24
 800fb1c:	af00      	add	r7, sp, #0
 800fb1e:	6078      	str	r0, [r7, #4]
 800fb20:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
 800fb22:	2300      	movs	r3, #0
 800fb24:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00U;
 800fb26:	2300      	movs	r3, #0
 800fb28:	613b      	str	r3, [r7, #16]
  uint32_t tmp = 0x00U;
 800fb2a:	2300      	movs	r3, #0
 800fb2c:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx, GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != 0)
 800fb2e:	e0bc      	b.n	800fcaa <HAL_GPIO_DeInit+0x192>
  {
    /* Get the IO position */
    iocurrent = (GPIO_Pin) & (1U << position);
 800fb30:	2201      	movs	r2, #1
 800fb32:	697b      	ldr	r3, [r7, #20]
 800fb34:	409a      	lsls	r2, r3
 800fb36:	683b      	ldr	r3, [r7, #0]
 800fb38:	4013      	ands	r3, r2
 800fb3a:	613b      	str	r3, [r7, #16]

    if (iocurrent)
 800fb3c:	693b      	ldr	r3, [r7, #16]
 800fb3e:	2b00      	cmp	r3, #0
 800fb40:	d100      	bne.n	800fb44 <HAL_GPIO_DeInit+0x2c>
 800fb42:	e0af      	b.n	800fca4 <HAL_GPIO_DeInit+0x18c>
    {
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */

      tmp = SYSCFG->EXTICR[position >> 2U];
 800fb44:	4a5e      	ldr	r2, [pc, #376]	; (800fcc0 <HAL_GPIO_DeInit+0x1a8>)
 800fb46:	697b      	ldr	r3, [r7, #20]
 800fb48:	089b      	lsrs	r3, r3, #2
 800fb4a:	3302      	adds	r3, #2
 800fb4c:	009b      	lsls	r3, r3, #2
 800fb4e:	589b      	ldr	r3, [r3, r2]
 800fb50:	60fb      	str	r3, [r7, #12]
      tmp &= (((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 800fb52:	697b      	ldr	r3, [r7, #20]
 800fb54:	2203      	movs	r2, #3
 800fb56:	4013      	ands	r3, r2
 800fb58:	009b      	lsls	r3, r3, #2
 800fb5a:	220f      	movs	r2, #15
 800fb5c:	409a      	lsls	r2, r3
 800fb5e:	68fb      	ldr	r3, [r7, #12]
 800fb60:	4013      	ands	r3, r2
 800fb62:	60fb      	str	r3, [r7, #12]
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 800fb64:	687a      	ldr	r2, [r7, #4]
 800fb66:	23a0      	movs	r3, #160	; 0xa0
 800fb68:	05db      	lsls	r3, r3, #23
 800fb6a:	429a      	cmp	r2, r3
 800fb6c:	d01f      	beq.n	800fbae <HAL_GPIO_DeInit+0x96>
 800fb6e:	687b      	ldr	r3, [r7, #4]
 800fb70:	4a54      	ldr	r2, [pc, #336]	; (800fcc4 <HAL_GPIO_DeInit+0x1ac>)
 800fb72:	4293      	cmp	r3, r2
 800fb74:	d019      	beq.n	800fbaa <HAL_GPIO_DeInit+0x92>
 800fb76:	687b      	ldr	r3, [r7, #4]
 800fb78:	4a53      	ldr	r2, [pc, #332]	; (800fcc8 <HAL_GPIO_DeInit+0x1b0>)
 800fb7a:	4293      	cmp	r3, r2
 800fb7c:	d013      	beq.n	800fba6 <HAL_GPIO_DeInit+0x8e>
 800fb7e:	687b      	ldr	r3, [r7, #4]
 800fb80:	4a52      	ldr	r2, [pc, #328]	; (800fccc <HAL_GPIO_DeInit+0x1b4>)
 800fb82:	4293      	cmp	r3, r2
 800fb84:	d00d      	beq.n	800fba2 <HAL_GPIO_DeInit+0x8a>
 800fb86:	687b      	ldr	r3, [r7, #4]
 800fb88:	4a51      	ldr	r2, [pc, #324]	; (800fcd0 <HAL_GPIO_DeInit+0x1b8>)
 800fb8a:	4293      	cmp	r3, r2
 800fb8c:	d007      	beq.n	800fb9e <HAL_GPIO_DeInit+0x86>
 800fb8e:	687b      	ldr	r3, [r7, #4]
 800fb90:	4a50      	ldr	r2, [pc, #320]	; (800fcd4 <HAL_GPIO_DeInit+0x1bc>)
 800fb92:	4293      	cmp	r3, r2
 800fb94:	d101      	bne.n	800fb9a <HAL_GPIO_DeInit+0x82>
 800fb96:	2305      	movs	r3, #5
 800fb98:	e00a      	b.n	800fbb0 <HAL_GPIO_DeInit+0x98>
 800fb9a:	2306      	movs	r3, #6
 800fb9c:	e008      	b.n	800fbb0 <HAL_GPIO_DeInit+0x98>
 800fb9e:	2304      	movs	r3, #4
 800fba0:	e006      	b.n	800fbb0 <HAL_GPIO_DeInit+0x98>
 800fba2:	2303      	movs	r3, #3
 800fba4:	e004      	b.n	800fbb0 <HAL_GPIO_DeInit+0x98>
 800fba6:	2302      	movs	r3, #2
 800fba8:	e002      	b.n	800fbb0 <HAL_GPIO_DeInit+0x98>
 800fbaa:	2301      	movs	r3, #1
 800fbac:	e000      	b.n	800fbb0 <HAL_GPIO_DeInit+0x98>
 800fbae:	2300      	movs	r3, #0
 800fbb0:	697a      	ldr	r2, [r7, #20]
 800fbb2:	2103      	movs	r1, #3
 800fbb4:	400a      	ands	r2, r1
 800fbb6:	0092      	lsls	r2, r2, #2
 800fbb8:	4093      	lsls	r3, r2
 800fbba:	68fa      	ldr	r2, [r7, #12]
 800fbbc:	429a      	cmp	r2, r3
 800fbbe:	d132      	bne.n	800fc26 <HAL_GPIO_DeInit+0x10e>
      {
        /* Clear EXTI line configuration */
        EXTI->IMR &= ~((uint32_t)iocurrent);
 800fbc0:	4b45      	ldr	r3, [pc, #276]	; (800fcd8 <HAL_GPIO_DeInit+0x1c0>)
 800fbc2:	681a      	ldr	r2, [r3, #0]
 800fbc4:	693b      	ldr	r3, [r7, #16]
 800fbc6:	43d9      	mvns	r1, r3
 800fbc8:	4b43      	ldr	r3, [pc, #268]	; (800fcd8 <HAL_GPIO_DeInit+0x1c0>)
 800fbca:	400a      	ands	r2, r1
 800fbcc:	601a      	str	r2, [r3, #0]
        EXTI->EMR &= ~((uint32_t)iocurrent);
 800fbce:	4b42      	ldr	r3, [pc, #264]	; (800fcd8 <HAL_GPIO_DeInit+0x1c0>)
 800fbd0:	685a      	ldr	r2, [r3, #4]
 800fbd2:	693b      	ldr	r3, [r7, #16]
 800fbd4:	43d9      	mvns	r1, r3
 800fbd6:	4b40      	ldr	r3, [pc, #256]	; (800fcd8 <HAL_GPIO_DeInit+0x1c0>)
 800fbd8:	400a      	ands	r2, r1
 800fbda:	605a      	str	r2, [r3, #4]

        /* Clear Rising Falling edge configuration */
        EXTI->RTSR &= ~((uint32_t)iocurrent);
 800fbdc:	4b3e      	ldr	r3, [pc, #248]	; (800fcd8 <HAL_GPIO_DeInit+0x1c0>)
 800fbde:	689a      	ldr	r2, [r3, #8]
 800fbe0:	693b      	ldr	r3, [r7, #16]
 800fbe2:	43d9      	mvns	r1, r3
 800fbe4:	4b3c      	ldr	r3, [pc, #240]	; (800fcd8 <HAL_GPIO_DeInit+0x1c0>)
 800fbe6:	400a      	ands	r2, r1
 800fbe8:	609a      	str	r2, [r3, #8]
        EXTI->FTSR &= ~((uint32_t)iocurrent);
 800fbea:	4b3b      	ldr	r3, [pc, #236]	; (800fcd8 <HAL_GPIO_DeInit+0x1c0>)
 800fbec:	68da      	ldr	r2, [r3, #12]
 800fbee:	693b      	ldr	r3, [r7, #16]
 800fbf0:	43d9      	mvns	r1, r3
 800fbf2:	4b39      	ldr	r3, [pc, #228]	; (800fcd8 <HAL_GPIO_DeInit+0x1c0>)
 800fbf4:	400a      	ands	r2, r1
 800fbf6:	60da      	str	r2, [r3, #12]
        
        tmp = ((uint32_t)0x0FU) << (4U * (position & 0x03U));
 800fbf8:	697b      	ldr	r3, [r7, #20]
 800fbfa:	2203      	movs	r2, #3
 800fbfc:	4013      	ands	r3, r2
 800fbfe:	009b      	lsls	r3, r3, #2
 800fc00:	220f      	movs	r2, #15
 800fc02:	409a      	lsls	r2, r3
 800fc04:	0013      	movs	r3, r2
 800fc06:	60fb      	str	r3, [r7, #12]
        SYSCFG->EXTICR[position >> 2U] &= ~tmp;
 800fc08:	4a2d      	ldr	r2, [pc, #180]	; (800fcc0 <HAL_GPIO_DeInit+0x1a8>)
 800fc0a:	697b      	ldr	r3, [r7, #20]
 800fc0c:	089b      	lsrs	r3, r3, #2
 800fc0e:	3302      	adds	r3, #2
 800fc10:	009b      	lsls	r3, r3, #2
 800fc12:	589a      	ldr	r2, [r3, r2]
 800fc14:	68fb      	ldr	r3, [r7, #12]
 800fc16:	43d9      	mvns	r1, r3
 800fc18:	4829      	ldr	r0, [pc, #164]	; (800fcc0 <HAL_GPIO_DeInit+0x1a8>)
 800fc1a:	697b      	ldr	r3, [r7, #20]
 800fc1c:	089b      	lsrs	r3, r3, #2
 800fc1e:	400a      	ands	r2, r1
 800fc20:	3302      	adds	r3, #2
 800fc22:	009b      	lsls	r3, r3, #2
 800fc24:	501a      	str	r2, [r3, r0]
      }

      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO Direction in Input Floting Mode */
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 800fc26:	687b      	ldr	r3, [r7, #4]
 800fc28:	681a      	ldr	r2, [r3, #0]
 800fc2a:	697b      	ldr	r3, [r7, #20]
 800fc2c:	005b      	lsls	r3, r3, #1
 800fc2e:	2103      	movs	r1, #3
 800fc30:	4099      	lsls	r1, r3
 800fc32:	000b      	movs	r3, r1
 800fc34:	431a      	orrs	r2, r3
 800fc36:	687b      	ldr	r3, [r7, #4]
 800fc38:	601a      	str	r2, [r3, #0]

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3U] &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U));
 800fc3a:	697b      	ldr	r3, [r7, #20]
 800fc3c:	08da      	lsrs	r2, r3, #3
 800fc3e:	687b      	ldr	r3, [r7, #4]
 800fc40:	3208      	adds	r2, #8
 800fc42:	0092      	lsls	r2, r2, #2
 800fc44:	58d3      	ldr	r3, [r2, r3]
 800fc46:	697a      	ldr	r2, [r7, #20]
 800fc48:	2107      	movs	r1, #7
 800fc4a:	400a      	ands	r2, r1
 800fc4c:	0092      	lsls	r2, r2, #2
 800fc4e:	210f      	movs	r1, #15
 800fc50:	4091      	lsls	r1, r2
 800fc52:	000a      	movs	r2, r1
 800fc54:	43d1      	mvns	r1, r2
 800fc56:	697a      	ldr	r2, [r7, #20]
 800fc58:	08d2      	lsrs	r2, r2, #3
 800fc5a:	4019      	ands	r1, r3
 800fc5c:	687b      	ldr	r3, [r7, #4]
 800fc5e:	3208      	adds	r2, #8
 800fc60:	0092      	lsls	r2, r2, #2
 800fc62:	50d1      	str	r1, [r2, r3]

      /* Deactivate the Pull-up oand Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 800fc64:	687b      	ldr	r3, [r7, #4]
 800fc66:	68db      	ldr	r3, [r3, #12]
 800fc68:	697a      	ldr	r2, [r7, #20]
 800fc6a:	0052      	lsls	r2, r2, #1
 800fc6c:	2103      	movs	r1, #3
 800fc6e:	4091      	lsls	r1, r2
 800fc70:	000a      	movs	r2, r1
 800fc72:	43d2      	mvns	r2, r2
 800fc74:	401a      	ands	r2, r3
 800fc76:	687b      	ldr	r3, [r7, #4]
 800fc78:	60da      	str	r2, [r3, #12]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position);
 800fc7a:	687b      	ldr	r3, [r7, #4]
 800fc7c:	685b      	ldr	r3, [r3, #4]
 800fc7e:	2101      	movs	r1, #1
 800fc80:	697a      	ldr	r2, [r7, #20]
 800fc82:	4091      	lsls	r1, r2
 800fc84:	000a      	movs	r2, r1
 800fc86:	43d2      	mvns	r2, r2
 800fc88:	401a      	ands	r2, r3
 800fc8a:	687b      	ldr	r3, [r7, #4]
 800fc8c:	605a      	str	r2, [r3, #4]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEED0 << (position * 2U));
 800fc8e:	687b      	ldr	r3, [r7, #4]
 800fc90:	689b      	ldr	r3, [r3, #8]
 800fc92:	697a      	ldr	r2, [r7, #20]
 800fc94:	0052      	lsls	r2, r2, #1
 800fc96:	2103      	movs	r1, #3
 800fc98:	4091      	lsls	r1, r2
 800fc9a:	000a      	movs	r2, r1
 800fc9c:	43d2      	mvns	r2, r2
 800fc9e:	401a      	ands	r2, r3
 800fca0:	687b      	ldr	r3, [r7, #4]
 800fca2:	609a      	str	r2, [r3, #8]
    }
    position++;
 800fca4:	697b      	ldr	r3, [r7, #20]
 800fca6:	3301      	adds	r3, #1
 800fca8:	617b      	str	r3, [r7, #20]
  while ((GPIO_Pin >> position) != 0)
 800fcaa:	683a      	ldr	r2, [r7, #0]
 800fcac:	697b      	ldr	r3, [r7, #20]
 800fcae:	40da      	lsrs	r2, r3
 800fcb0:	1e13      	subs	r3, r2, #0
 800fcb2:	d000      	beq.n	800fcb6 <HAL_GPIO_DeInit+0x19e>
 800fcb4:	e73c      	b.n	800fb30 <HAL_GPIO_DeInit+0x18>
  }
}
 800fcb6:	46c0      	nop			; (mov r8, r8)
 800fcb8:	46bd      	mov	sp, r7
 800fcba:	b006      	add	sp, #24
 800fcbc:	bd80      	pop	{r7, pc}
 800fcbe:	46c0      	nop			; (mov r8, r8)
 800fcc0:	40010000 	.word	0x40010000
 800fcc4:	50000400 	.word	0x50000400
 800fcc8:	50000800 	.word	0x50000800
 800fccc:	50000c00 	.word	0x50000c00
 800fcd0:	50001000 	.word	0x50001000
 800fcd4:	50001c00 	.word	0x50001c00
 800fcd8:	40010400 	.word	0x40010400

0800fcdc <HAL_GPIO_ReadPin>:
  *                   This parameter can be GPIO_PIN_x where x can be (0..15).
  *                   All port bits are not necessarily available on all GPIOs.
  * @retval The input port pin value.
  */
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
 800fcdc:	b580      	push	{r7, lr}
 800fcde:	b084      	sub	sp, #16
 800fce0:	af00      	add	r7, sp, #0
 800fce2:	6078      	str	r0, [r7, #4]
 800fce4:	000a      	movs	r2, r1
 800fce6:	1cbb      	adds	r3, r7, #2
 800fce8:	801a      	strh	r2, [r3, #0]
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx, GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 800fcea:	687b      	ldr	r3, [r7, #4]
 800fcec:	691b      	ldr	r3, [r3, #16]
 800fcee:	1cba      	adds	r2, r7, #2
 800fcf0:	8812      	ldrh	r2, [r2, #0]
 800fcf2:	4013      	ands	r3, r2
 800fcf4:	d004      	beq.n	800fd00 <HAL_GPIO_ReadPin+0x24>
  {
    bitstatus = GPIO_PIN_SET;
 800fcf6:	230f      	movs	r3, #15
 800fcf8:	18fb      	adds	r3, r7, r3
 800fcfa:	2201      	movs	r2, #1
 800fcfc:	701a      	strb	r2, [r3, #0]
 800fcfe:	e003      	b.n	800fd08 <HAL_GPIO_ReadPin+0x2c>
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
 800fd00:	230f      	movs	r3, #15
 800fd02:	18fb      	adds	r3, r7, r3
 800fd04:	2200      	movs	r2, #0
 800fd06:	701a      	strb	r2, [r3, #0]
  }
  return bitstatus;
 800fd08:	230f      	movs	r3, #15
 800fd0a:	18fb      	adds	r3, r7, r3
 800fd0c:	781b      	ldrb	r3, [r3, #0]
}
 800fd0e:	0018      	movs	r0, r3
 800fd10:	46bd      	mov	sp, r7
 800fd12:	b004      	add	sp, #16
 800fd14:	bd80      	pop	{r7, pc}

0800fd16 <HAL_GPIO_WritePin>:
  *                        GPIO_PIN_RESET: to clear the port pin
  *                        GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 800fd16:	b580      	push	{r7, lr}
 800fd18:	b082      	sub	sp, #8
 800fd1a:	af00      	add	r7, sp, #0
 800fd1c:	6078      	str	r0, [r7, #4]
 800fd1e:	0008      	movs	r0, r1
 800fd20:	0011      	movs	r1, r2
 800fd22:	1cbb      	adds	r3, r7, #2
 800fd24:	1c02      	adds	r2, r0, #0
 800fd26:	801a      	strh	r2, [r3, #0]
 800fd28:	1c7b      	adds	r3, r7, #1
 800fd2a:	1c0a      	adds	r2, r1, #0
 800fd2c:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx, GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 800fd2e:	1c7b      	adds	r3, r7, #1
 800fd30:	781b      	ldrb	r3, [r3, #0]
 800fd32:	2b00      	cmp	r3, #0
 800fd34:	d004      	beq.n	800fd40 <HAL_GPIO_WritePin+0x2a>
  {
    GPIOx->BSRR = GPIO_Pin;
 800fd36:	1cbb      	adds	r3, r7, #2
 800fd38:	881a      	ldrh	r2, [r3, #0]
 800fd3a:	687b      	ldr	r3, [r7, #4]
 800fd3c:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = GPIO_Pin ;
  }
}
 800fd3e:	e003      	b.n	800fd48 <HAL_GPIO_WritePin+0x32>
    GPIOx->BRR = GPIO_Pin ;
 800fd40:	1cbb      	adds	r3, r7, #2
 800fd42:	881a      	ldrh	r2, [r3, #0]
 800fd44:	687b      	ldr	r3, [r7, #4]
 800fd46:	629a      	str	r2, [r3, #40]	; 0x28
}
 800fd48:	46c0      	nop			; (mov r8, r8)
 800fd4a:	46bd      	mov	sp, r7
 800fd4c:	b002      	add	sp, #8
 800fd4e:	bd80      	pop	{r7, pc}

0800fd50 <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
 800fd50:	b580      	push	{r7, lr}
 800fd52:	b082      	sub	sp, #8
 800fd54:	af00      	add	r7, sp, #0
 800fd56:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
 800fd58:	687b      	ldr	r3, [r7, #4]
 800fd5a:	2b00      	cmp	r3, #0
 800fd5c:	d101      	bne.n	800fd62 <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
 800fd5e:	2301      	movs	r3, #1
 800fd60:	e082      	b.n	800fe68 <HAL_I2C_Init+0x118>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
 800fd62:	687b      	ldr	r3, [r7, #4]
 800fd64:	2241      	movs	r2, #65	; 0x41
 800fd66:	5c9b      	ldrb	r3, [r3, r2]
 800fd68:	b2db      	uxtb	r3, r3
 800fd6a:	2b00      	cmp	r3, #0
 800fd6c:	d107      	bne.n	800fd7e <HAL_I2C_Init+0x2e>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
 800fd6e:	687b      	ldr	r3, [r7, #4]
 800fd70:	2240      	movs	r2, #64	; 0x40
 800fd72:	2100      	movs	r1, #0
 800fd74:	5499      	strb	r1, [r3, r2]

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
 800fd76:	687b      	ldr	r3, [r7, #4]
 800fd78:	0018      	movs	r0, r3
 800fd7a:	f7f5 f8a5 	bl	8004ec8 <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
 800fd7e:	687b      	ldr	r3, [r7, #4]
 800fd80:	2241      	movs	r2, #65	; 0x41
 800fd82:	2124      	movs	r1, #36	; 0x24
 800fd84:	5499      	strb	r1, [r3, r2]

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 800fd86:	687b      	ldr	r3, [r7, #4]
 800fd88:	681b      	ldr	r3, [r3, #0]
 800fd8a:	681a      	ldr	r2, [r3, #0]
 800fd8c:	687b      	ldr	r3, [r7, #4]
 800fd8e:	681b      	ldr	r3, [r3, #0]
 800fd90:	2101      	movs	r1, #1
 800fd92:	438a      	bics	r2, r1
 800fd94:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 800fd96:	687b      	ldr	r3, [r7, #4]
 800fd98:	685a      	ldr	r2, [r3, #4]
 800fd9a:	687b      	ldr	r3, [r7, #4]
 800fd9c:	681b      	ldr	r3, [r3, #0]
 800fd9e:	4934      	ldr	r1, [pc, #208]	; (800fe70 <HAL_I2C_Init+0x120>)
 800fda0:	400a      	ands	r2, r1
 800fda2:	611a      	str	r2, [r3, #16]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 800fda4:	687b      	ldr	r3, [r7, #4]
 800fda6:	681b      	ldr	r3, [r3, #0]
 800fda8:	689a      	ldr	r2, [r3, #8]
 800fdaa:	687b      	ldr	r3, [r7, #4]
 800fdac:	681b      	ldr	r3, [r3, #0]
 800fdae:	4931      	ldr	r1, [pc, #196]	; (800fe74 <HAL_I2C_Init+0x124>)
 800fdb0:	400a      	ands	r2, r1
 800fdb2:	609a      	str	r2, [r3, #8]

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 800fdb4:	687b      	ldr	r3, [r7, #4]
 800fdb6:	68db      	ldr	r3, [r3, #12]
 800fdb8:	2b01      	cmp	r3, #1
 800fdba:	d108      	bne.n	800fdce <HAL_I2C_Init+0x7e>
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 800fdbc:	687b      	ldr	r3, [r7, #4]
 800fdbe:	689a      	ldr	r2, [r3, #8]
 800fdc0:	687b      	ldr	r3, [r7, #4]
 800fdc2:	681b      	ldr	r3, [r3, #0]
 800fdc4:	2180      	movs	r1, #128	; 0x80
 800fdc6:	0209      	lsls	r1, r1, #8
 800fdc8:	430a      	orrs	r2, r1
 800fdca:	609a      	str	r2, [r3, #8]
 800fdcc:	e007      	b.n	800fdde <HAL_I2C_Init+0x8e>
  }
  else /* I2C_ADDRESSINGMODE_10BIT */
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 800fdce:	687b      	ldr	r3, [r7, #4]
 800fdd0:	689a      	ldr	r2, [r3, #8]
 800fdd2:	687b      	ldr	r3, [r7, #4]
 800fdd4:	681b      	ldr	r3, [r3, #0]
 800fdd6:	2184      	movs	r1, #132	; 0x84
 800fdd8:	0209      	lsls	r1, r1, #8
 800fdda:	430a      	orrs	r2, r1
 800fddc:	609a      	str	r2, [r3, #8]
  }

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 800fdde:	687b      	ldr	r3, [r7, #4]
 800fde0:	68db      	ldr	r3, [r3, #12]
 800fde2:	2b02      	cmp	r3, #2
 800fde4:	d104      	bne.n	800fdf0 <HAL_I2C_Init+0xa0>
  {
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 800fde6:	687b      	ldr	r3, [r7, #4]
 800fde8:	681b      	ldr	r3, [r3, #0]
 800fdea:	2280      	movs	r2, #128	; 0x80
 800fdec:	0112      	lsls	r2, r2, #4
 800fdee:	605a      	str	r2, [r3, #4]
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 800fdf0:	687b      	ldr	r3, [r7, #4]
 800fdf2:	681b      	ldr	r3, [r3, #0]
 800fdf4:	685a      	ldr	r2, [r3, #4]
 800fdf6:	687b      	ldr	r3, [r7, #4]
 800fdf8:	681b      	ldr	r3, [r3, #0]
 800fdfa:	491f      	ldr	r1, [pc, #124]	; (800fe78 <HAL_I2C_Init+0x128>)
 800fdfc:	430a      	orrs	r2, r1
 800fdfe:	605a      	str	r2, [r3, #4]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 800fe00:	687b      	ldr	r3, [r7, #4]
 800fe02:	681b      	ldr	r3, [r3, #0]
 800fe04:	68da      	ldr	r2, [r3, #12]
 800fe06:	687b      	ldr	r3, [r7, #4]
 800fe08:	681b      	ldr	r3, [r3, #0]
 800fe0a:	491a      	ldr	r1, [pc, #104]	; (800fe74 <HAL_I2C_Init+0x124>)
 800fe0c:	400a      	ands	r2, r1
 800fe0e:	60da      	str	r2, [r3, #12]

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 800fe10:	687b      	ldr	r3, [r7, #4]
 800fe12:	691a      	ldr	r2, [r3, #16]
 800fe14:	687b      	ldr	r3, [r7, #4]
 800fe16:	695b      	ldr	r3, [r3, #20]
 800fe18:	431a      	orrs	r2, r3
 800fe1a:	0011      	movs	r1, r2
 800fe1c:	687b      	ldr	r3, [r7, #4]
 800fe1e:	699b      	ldr	r3, [r3, #24]
 800fe20:	021a      	lsls	r2, r3, #8
 800fe22:	687b      	ldr	r3, [r7, #4]
 800fe24:	681b      	ldr	r3, [r3, #0]
 800fe26:	430a      	orrs	r2, r1
 800fe28:	60da      	str	r2, [r3, #12]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 800fe2a:	687b      	ldr	r3, [r7, #4]
 800fe2c:	69d9      	ldr	r1, [r3, #28]
 800fe2e:	687b      	ldr	r3, [r7, #4]
 800fe30:	6a1a      	ldr	r2, [r3, #32]
 800fe32:	687b      	ldr	r3, [r7, #4]
 800fe34:	681b      	ldr	r3, [r3, #0]
 800fe36:	430a      	orrs	r2, r1
 800fe38:	601a      	str	r2, [r3, #0]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
 800fe3a:	687b      	ldr	r3, [r7, #4]
 800fe3c:	681b      	ldr	r3, [r3, #0]
 800fe3e:	681a      	ldr	r2, [r3, #0]
 800fe40:	687b      	ldr	r3, [r7, #4]
 800fe42:	681b      	ldr	r3, [r3, #0]
 800fe44:	2101      	movs	r1, #1
 800fe46:	430a      	orrs	r2, r1
 800fe48:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800fe4a:	687b      	ldr	r3, [r7, #4]
 800fe4c:	2200      	movs	r2, #0
 800fe4e:	645a      	str	r2, [r3, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 800fe50:	687b      	ldr	r3, [r7, #4]
 800fe52:	2241      	movs	r2, #65	; 0x41
 800fe54:	2120      	movs	r1, #32
 800fe56:	5499      	strb	r1, [r3, r2]
  hi2c->PreviousState = I2C_STATE_NONE;
 800fe58:	687b      	ldr	r3, [r7, #4]
 800fe5a:	2200      	movs	r2, #0
 800fe5c:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 800fe5e:	687b      	ldr	r3, [r7, #4]
 800fe60:	2242      	movs	r2, #66	; 0x42
 800fe62:	2100      	movs	r1, #0
 800fe64:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 800fe66:	2300      	movs	r3, #0
}
 800fe68:	0018      	movs	r0, r3
 800fe6a:	46bd      	mov	sp, r7
 800fe6c:	b002      	add	sp, #8
 800fe6e:	bd80      	pop	{r7, pc}
 800fe70:	f0ffffff 	.word	0xf0ffffff
 800fe74:	ffff7fff 	.word	0xffff7fff
 800fe78:	02008000 	.word	0x02008000

0800fe7c <HAL_I2C_Master_Transmit>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size,
                                          uint32_t Timeout)
{
 800fe7c:	b590      	push	{r4, r7, lr}
 800fe7e:	b089      	sub	sp, #36	; 0x24
 800fe80:	af02      	add	r7, sp, #8
 800fe82:	60f8      	str	r0, [r7, #12]
 800fe84:	0008      	movs	r0, r1
 800fe86:	607a      	str	r2, [r7, #4]
 800fe88:	0019      	movs	r1, r3
 800fe8a:	230a      	movs	r3, #10
 800fe8c:	18fb      	adds	r3, r7, r3
 800fe8e:	1c02      	adds	r2, r0, #0
 800fe90:	801a      	strh	r2, [r3, #0]
 800fe92:	2308      	movs	r3, #8
 800fe94:	18fb      	adds	r3, r7, r3
 800fe96:	1c0a      	adds	r2, r1, #0
 800fe98:	801a      	strh	r2, [r3, #0]
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
 800fe9a:	68fb      	ldr	r3, [r7, #12]
 800fe9c:	2241      	movs	r2, #65	; 0x41
 800fe9e:	5c9b      	ldrb	r3, [r3, r2]
 800fea0:	b2db      	uxtb	r3, r3
 800fea2:	2b20      	cmp	r3, #32
 800fea4:	d000      	beq.n	800fea8 <HAL_I2C_Master_Transmit+0x2c>
 800fea6:	e0e7      	b.n	8010078 <HAL_I2C_Master_Transmit+0x1fc>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 800fea8:	68fb      	ldr	r3, [r7, #12]
 800feaa:	2240      	movs	r2, #64	; 0x40
 800feac:	5c9b      	ldrb	r3, [r3, r2]
 800feae:	2b01      	cmp	r3, #1
 800feb0:	d101      	bne.n	800feb6 <HAL_I2C_Master_Transmit+0x3a>
 800feb2:	2302      	movs	r3, #2
 800feb4:	e0e1      	b.n	801007a <HAL_I2C_Master_Transmit+0x1fe>
 800feb6:	68fb      	ldr	r3, [r7, #12]
 800feb8:	2240      	movs	r2, #64	; 0x40
 800feba:	2101      	movs	r1, #1
 800febc:	5499      	strb	r1, [r3, r2]

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
 800febe:	f7ff fb0f 	bl	800f4e0 <HAL_GetTick>
 800fec2:	0003      	movs	r3, r0
 800fec4:	617b      	str	r3, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 800fec6:	2380      	movs	r3, #128	; 0x80
 800fec8:	0219      	lsls	r1, r3, #8
 800feca:	68f8      	ldr	r0, [r7, #12]
 800fecc:	697b      	ldr	r3, [r7, #20]
 800fece:	9300      	str	r3, [sp, #0]
 800fed0:	2319      	movs	r3, #25
 800fed2:	2201      	movs	r2, #1
 800fed4:	f000 fa04 	bl	80102e0 <I2C_WaitOnFlagUntilTimeout>
 800fed8:	1e03      	subs	r3, r0, #0
 800feda:	d001      	beq.n	800fee0 <HAL_I2C_Master_Transmit+0x64>
    {
      return HAL_ERROR;
 800fedc:	2301      	movs	r3, #1
 800fede:	e0cc      	b.n	801007a <HAL_I2C_Master_Transmit+0x1fe>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 800fee0:	68fb      	ldr	r3, [r7, #12]
 800fee2:	2241      	movs	r2, #65	; 0x41
 800fee4:	2121      	movs	r1, #33	; 0x21
 800fee6:	5499      	strb	r1, [r3, r2]
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
 800fee8:	68fb      	ldr	r3, [r7, #12]
 800feea:	2242      	movs	r2, #66	; 0x42
 800feec:	2110      	movs	r1, #16
 800feee:	5499      	strb	r1, [r3, r2]
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800fef0:	68fb      	ldr	r3, [r7, #12]
 800fef2:	2200      	movs	r2, #0
 800fef4:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
 800fef6:	68fb      	ldr	r3, [r7, #12]
 800fef8:	687a      	ldr	r2, [r7, #4]
 800fefa:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
 800fefc:	68fb      	ldr	r3, [r7, #12]
 800fefe:	2208      	movs	r2, #8
 800ff00:	18ba      	adds	r2, r7, r2
 800ff02:	8812      	ldrh	r2, [r2, #0]
 800ff04:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
 800ff06:	68fb      	ldr	r3, [r7, #12]
 800ff08:	2200      	movs	r2, #0
 800ff0a:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800ff0c:	68fb      	ldr	r3, [r7, #12]
 800ff0e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800ff10:	b29b      	uxth	r3, r3
 800ff12:	2bff      	cmp	r3, #255	; 0xff
 800ff14:	d911      	bls.n	800ff3a <HAL_I2C_Master_Transmit+0xbe>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
 800ff16:	68fb      	ldr	r3, [r7, #12]
 800ff18:	22ff      	movs	r2, #255	; 0xff
 800ff1a:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
 800ff1c:	68fb      	ldr	r3, [r7, #12]
 800ff1e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800ff20:	b2da      	uxtb	r2, r3
 800ff22:	2380      	movs	r3, #128	; 0x80
 800ff24:	045c      	lsls	r4, r3, #17
 800ff26:	230a      	movs	r3, #10
 800ff28:	18fb      	adds	r3, r7, r3
 800ff2a:	8819      	ldrh	r1, [r3, #0]
 800ff2c:	68f8      	ldr	r0, [r7, #12]
 800ff2e:	4b55      	ldr	r3, [pc, #340]	; (8010084 <HAL_I2C_Master_Transmit+0x208>)
 800ff30:	9300      	str	r3, [sp, #0]
 800ff32:	0023      	movs	r3, r4
 800ff34:	f000 fb60 	bl	80105f8 <I2C_TransferConfig>
 800ff38:	e075      	b.n	8010026 <HAL_I2C_Master_Transmit+0x1aa>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
 800ff3a:	68fb      	ldr	r3, [r7, #12]
 800ff3c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800ff3e:	b29a      	uxth	r2, r3
 800ff40:	68fb      	ldr	r3, [r7, #12]
 800ff42:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
 800ff44:	68fb      	ldr	r3, [r7, #12]
 800ff46:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800ff48:	b2da      	uxtb	r2, r3
 800ff4a:	2380      	movs	r3, #128	; 0x80
 800ff4c:	049c      	lsls	r4, r3, #18
 800ff4e:	230a      	movs	r3, #10
 800ff50:	18fb      	adds	r3, r7, r3
 800ff52:	8819      	ldrh	r1, [r3, #0]
 800ff54:	68f8      	ldr	r0, [r7, #12]
 800ff56:	4b4b      	ldr	r3, [pc, #300]	; (8010084 <HAL_I2C_Master_Transmit+0x208>)
 800ff58:	9300      	str	r3, [sp, #0]
 800ff5a:	0023      	movs	r3, r4
 800ff5c:	f000 fb4c 	bl	80105f8 <I2C_TransferConfig>
    }

    while (hi2c->XferCount > 0U)
 800ff60:	e061      	b.n	8010026 <HAL_I2C_Master_Transmit+0x1aa>
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800ff62:	697a      	ldr	r2, [r7, #20]
 800ff64:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800ff66:	68fb      	ldr	r3, [r7, #12]
 800ff68:	0018      	movs	r0, r3
 800ff6a:	f000 f9f8 	bl	801035e <I2C_WaitOnTXISFlagUntilTimeout>
 800ff6e:	1e03      	subs	r3, r0, #0
 800ff70:	d001      	beq.n	800ff76 <HAL_I2C_Master_Transmit+0xfa>
      {
        return HAL_ERROR;
 800ff72:	2301      	movs	r3, #1
 800ff74:	e081      	b.n	801007a <HAL_I2C_Master_Transmit+0x1fe>
      }
      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 800ff76:	68fb      	ldr	r3, [r7, #12]
 800ff78:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ff7a:	781a      	ldrb	r2, [r3, #0]
 800ff7c:	68fb      	ldr	r3, [r7, #12]
 800ff7e:	681b      	ldr	r3, [r3, #0]
 800ff80:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 800ff82:	68fb      	ldr	r3, [r7, #12]
 800ff84:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ff86:	1c5a      	adds	r2, r3, #1
 800ff88:	68fb      	ldr	r3, [r7, #12]
 800ff8a:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
 800ff8c:	68fb      	ldr	r3, [r7, #12]
 800ff8e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800ff90:	b29b      	uxth	r3, r3
 800ff92:	3b01      	subs	r3, #1
 800ff94:	b29a      	uxth	r2, r3
 800ff96:	68fb      	ldr	r3, [r7, #12]
 800ff98:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
 800ff9a:	68fb      	ldr	r3, [r7, #12]
 800ff9c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800ff9e:	3b01      	subs	r3, #1
 800ffa0:	b29a      	uxth	r2, r3
 800ffa2:	68fb      	ldr	r3, [r7, #12]
 800ffa4:	851a      	strh	r2, [r3, #40]	; 0x28

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 800ffa6:	68fb      	ldr	r3, [r7, #12]
 800ffa8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800ffaa:	b29b      	uxth	r3, r3
 800ffac:	2b00      	cmp	r3, #0
 800ffae:	d03a      	beq.n	8010026 <HAL_I2C_Master_Transmit+0x1aa>
 800ffb0:	68fb      	ldr	r3, [r7, #12]
 800ffb2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800ffb4:	2b00      	cmp	r3, #0
 800ffb6:	d136      	bne.n	8010026 <HAL_I2C_Master_Transmit+0x1aa>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 800ffb8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800ffba:	68f8      	ldr	r0, [r7, #12]
 800ffbc:	697b      	ldr	r3, [r7, #20]
 800ffbe:	9300      	str	r3, [sp, #0]
 800ffc0:	0013      	movs	r3, r2
 800ffc2:	2200      	movs	r2, #0
 800ffc4:	2180      	movs	r1, #128	; 0x80
 800ffc6:	f000 f98b 	bl	80102e0 <I2C_WaitOnFlagUntilTimeout>
 800ffca:	1e03      	subs	r3, r0, #0
 800ffcc:	d001      	beq.n	800ffd2 <HAL_I2C_Master_Transmit+0x156>
        {
          return HAL_ERROR;
 800ffce:	2301      	movs	r3, #1
 800ffd0:	e053      	b.n	801007a <HAL_I2C_Master_Transmit+0x1fe>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800ffd2:	68fb      	ldr	r3, [r7, #12]
 800ffd4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800ffd6:	b29b      	uxth	r3, r3
 800ffd8:	2bff      	cmp	r3, #255	; 0xff
 800ffda:	d911      	bls.n	8010000 <HAL_I2C_Master_Transmit+0x184>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
 800ffdc:	68fb      	ldr	r3, [r7, #12]
 800ffde:	22ff      	movs	r2, #255	; 0xff
 800ffe0:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 800ffe2:	68fb      	ldr	r3, [r7, #12]
 800ffe4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800ffe6:	b2da      	uxtb	r2, r3
 800ffe8:	2380      	movs	r3, #128	; 0x80
 800ffea:	045c      	lsls	r4, r3, #17
 800ffec:	230a      	movs	r3, #10
 800ffee:	18fb      	adds	r3, r7, r3
 800fff0:	8819      	ldrh	r1, [r3, #0]
 800fff2:	68f8      	ldr	r0, [r7, #12]
 800fff4:	2300      	movs	r3, #0
 800fff6:	9300      	str	r3, [sp, #0]
 800fff8:	0023      	movs	r3, r4
 800fffa:	f000 fafd 	bl	80105f8 <I2C_TransferConfig>
 800fffe:	e012      	b.n	8010026 <HAL_I2C_Master_Transmit+0x1aa>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
 8010000:	68fb      	ldr	r3, [r7, #12]
 8010002:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8010004:	b29a      	uxth	r2, r3
 8010006:	68fb      	ldr	r3, [r7, #12]
 8010008:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 801000a:	68fb      	ldr	r3, [r7, #12]
 801000c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 801000e:	b2da      	uxtb	r2, r3
 8010010:	2380      	movs	r3, #128	; 0x80
 8010012:	049c      	lsls	r4, r3, #18
 8010014:	230a      	movs	r3, #10
 8010016:	18fb      	adds	r3, r7, r3
 8010018:	8819      	ldrh	r1, [r3, #0]
 801001a:	68f8      	ldr	r0, [r7, #12]
 801001c:	2300      	movs	r3, #0
 801001e:	9300      	str	r3, [sp, #0]
 8010020:	0023      	movs	r3, r4
 8010022:	f000 fae9 	bl	80105f8 <I2C_TransferConfig>
    while (hi2c->XferCount > 0U)
 8010026:	68fb      	ldr	r3, [r7, #12]
 8010028:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 801002a:	b29b      	uxth	r3, r3
 801002c:	2b00      	cmp	r3, #0
 801002e:	d198      	bne.n	800ff62 <HAL_I2C_Master_Transmit+0xe6>
      }
    }

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8010030:	697a      	ldr	r2, [r7, #20]
 8010032:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8010034:	68fb      	ldr	r3, [r7, #12]
 8010036:	0018      	movs	r0, r3
 8010038:	f000 f9d0 	bl	80103dc <I2C_WaitOnSTOPFlagUntilTimeout>
 801003c:	1e03      	subs	r3, r0, #0
 801003e:	d001      	beq.n	8010044 <HAL_I2C_Master_Transmit+0x1c8>
    {
      return HAL_ERROR;
 8010040:	2301      	movs	r3, #1
 8010042:	e01a      	b.n	801007a <HAL_I2C_Master_Transmit+0x1fe>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8010044:	68fb      	ldr	r3, [r7, #12]
 8010046:	681b      	ldr	r3, [r3, #0]
 8010048:	2220      	movs	r2, #32
 801004a:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 801004c:	68fb      	ldr	r3, [r7, #12]
 801004e:	681b      	ldr	r3, [r3, #0]
 8010050:	685a      	ldr	r2, [r3, #4]
 8010052:	68fb      	ldr	r3, [r7, #12]
 8010054:	681b      	ldr	r3, [r3, #0]
 8010056:	490c      	ldr	r1, [pc, #48]	; (8010088 <HAL_I2C_Master_Transmit+0x20c>)
 8010058:	400a      	ands	r2, r1
 801005a:	605a      	str	r2, [r3, #4]

    hi2c->State = HAL_I2C_STATE_READY;
 801005c:	68fb      	ldr	r3, [r7, #12]
 801005e:	2241      	movs	r2, #65	; 0x41
 8010060:	2120      	movs	r1, #32
 8010062:	5499      	strb	r1, [r3, r2]
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8010064:	68fb      	ldr	r3, [r7, #12]
 8010066:	2242      	movs	r2, #66	; 0x42
 8010068:	2100      	movs	r1, #0
 801006a:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 801006c:	68fb      	ldr	r3, [r7, #12]
 801006e:	2240      	movs	r2, #64	; 0x40
 8010070:	2100      	movs	r1, #0
 8010072:	5499      	strb	r1, [r3, r2]

    return HAL_OK;
 8010074:	2300      	movs	r3, #0
 8010076:	e000      	b.n	801007a <HAL_I2C_Master_Transmit+0x1fe>
  }
  else
  {
    return HAL_BUSY;
 8010078:	2302      	movs	r3, #2
  }
}
 801007a:	0018      	movs	r0, r3
 801007c:	46bd      	mov	sp, r7
 801007e:	b007      	add	sp, #28
 8010080:	bd90      	pop	{r4, r7, pc}
 8010082:	46c0      	nop			; (mov r8, r8)
 8010084:	80002000 	.word	0x80002000
 8010088:	fe00e800 	.word	0xfe00e800

0801008c <HAL_I2C_Master_Receive>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size,
                                         uint32_t Timeout)
{
 801008c:	b590      	push	{r4, r7, lr}
 801008e:	b089      	sub	sp, #36	; 0x24
 8010090:	af02      	add	r7, sp, #8
 8010092:	60f8      	str	r0, [r7, #12]
 8010094:	0008      	movs	r0, r1
 8010096:	607a      	str	r2, [r7, #4]
 8010098:	0019      	movs	r1, r3
 801009a:	230a      	movs	r3, #10
 801009c:	18fb      	adds	r3, r7, r3
 801009e:	1c02      	adds	r2, r0, #0
 80100a0:	801a      	strh	r2, [r3, #0]
 80100a2:	2308      	movs	r3, #8
 80100a4:	18fb      	adds	r3, r7, r3
 80100a6:	1c0a      	adds	r2, r1, #0
 80100a8:	801a      	strh	r2, [r3, #0]
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
 80100aa:	68fb      	ldr	r3, [r7, #12]
 80100ac:	2241      	movs	r2, #65	; 0x41
 80100ae:	5c9b      	ldrb	r3, [r3, r2]
 80100b0:	b2db      	uxtb	r3, r3
 80100b2:	2b20      	cmp	r3, #32
 80100b4:	d000      	beq.n	80100b8 <HAL_I2C_Master_Receive+0x2c>
 80100b6:	e0e8      	b.n	801028a <HAL_I2C_Master_Receive+0x1fe>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 80100b8:	68fb      	ldr	r3, [r7, #12]
 80100ba:	2240      	movs	r2, #64	; 0x40
 80100bc:	5c9b      	ldrb	r3, [r3, r2]
 80100be:	2b01      	cmp	r3, #1
 80100c0:	d101      	bne.n	80100c6 <HAL_I2C_Master_Receive+0x3a>
 80100c2:	2302      	movs	r3, #2
 80100c4:	e0e2      	b.n	801028c <HAL_I2C_Master_Receive+0x200>
 80100c6:	68fb      	ldr	r3, [r7, #12]
 80100c8:	2240      	movs	r2, #64	; 0x40
 80100ca:	2101      	movs	r1, #1
 80100cc:	5499      	strb	r1, [r3, r2]

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
 80100ce:	f7ff fa07 	bl	800f4e0 <HAL_GetTick>
 80100d2:	0003      	movs	r3, r0
 80100d4:	617b      	str	r3, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 80100d6:	2380      	movs	r3, #128	; 0x80
 80100d8:	0219      	lsls	r1, r3, #8
 80100da:	68f8      	ldr	r0, [r7, #12]
 80100dc:	697b      	ldr	r3, [r7, #20]
 80100de:	9300      	str	r3, [sp, #0]
 80100e0:	2319      	movs	r3, #25
 80100e2:	2201      	movs	r2, #1
 80100e4:	f000 f8fc 	bl	80102e0 <I2C_WaitOnFlagUntilTimeout>
 80100e8:	1e03      	subs	r3, r0, #0
 80100ea:	d001      	beq.n	80100f0 <HAL_I2C_Master_Receive+0x64>
    {
      return HAL_ERROR;
 80100ec:	2301      	movs	r3, #1
 80100ee:	e0cd      	b.n	801028c <HAL_I2C_Master_Receive+0x200>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 80100f0:	68fb      	ldr	r3, [r7, #12]
 80100f2:	2241      	movs	r2, #65	; 0x41
 80100f4:	2122      	movs	r1, #34	; 0x22
 80100f6:	5499      	strb	r1, [r3, r2]
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
 80100f8:	68fb      	ldr	r3, [r7, #12]
 80100fa:	2242      	movs	r2, #66	; 0x42
 80100fc:	2110      	movs	r1, #16
 80100fe:	5499      	strb	r1, [r3, r2]
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8010100:	68fb      	ldr	r3, [r7, #12]
 8010102:	2200      	movs	r2, #0
 8010104:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
 8010106:	68fb      	ldr	r3, [r7, #12]
 8010108:	687a      	ldr	r2, [r7, #4]
 801010a:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
 801010c:	68fb      	ldr	r3, [r7, #12]
 801010e:	2208      	movs	r2, #8
 8010110:	18ba      	adds	r2, r7, r2
 8010112:	8812      	ldrh	r2, [r2, #0]
 8010114:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
 8010116:	68fb      	ldr	r3, [r7, #12]
 8010118:	2200      	movs	r2, #0
 801011a:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 801011c:	68fb      	ldr	r3, [r7, #12]
 801011e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8010120:	b29b      	uxth	r3, r3
 8010122:	2bff      	cmp	r3, #255	; 0xff
 8010124:	d911      	bls.n	801014a <HAL_I2C_Master_Receive+0xbe>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
 8010126:	68fb      	ldr	r3, [r7, #12]
 8010128:	22ff      	movs	r2, #255	; 0xff
 801012a:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
 801012c:	68fb      	ldr	r3, [r7, #12]
 801012e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8010130:	b2da      	uxtb	r2, r3
 8010132:	2380      	movs	r3, #128	; 0x80
 8010134:	045c      	lsls	r4, r3, #17
 8010136:	230a      	movs	r3, #10
 8010138:	18fb      	adds	r3, r7, r3
 801013a:	8819      	ldrh	r1, [r3, #0]
 801013c:	68f8      	ldr	r0, [r7, #12]
 801013e:	4b55      	ldr	r3, [pc, #340]	; (8010294 <HAL_I2C_Master_Receive+0x208>)
 8010140:	9300      	str	r3, [sp, #0]
 8010142:	0023      	movs	r3, r4
 8010144:	f000 fa58 	bl	80105f8 <I2C_TransferConfig>
 8010148:	e076      	b.n	8010238 <HAL_I2C_Master_Receive+0x1ac>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
 801014a:	68fb      	ldr	r3, [r7, #12]
 801014c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 801014e:	b29a      	uxth	r2, r3
 8010150:	68fb      	ldr	r3, [r7, #12]
 8010152:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
 8010154:	68fb      	ldr	r3, [r7, #12]
 8010156:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8010158:	b2da      	uxtb	r2, r3
 801015a:	2380      	movs	r3, #128	; 0x80
 801015c:	049c      	lsls	r4, r3, #18
 801015e:	230a      	movs	r3, #10
 8010160:	18fb      	adds	r3, r7, r3
 8010162:	8819      	ldrh	r1, [r3, #0]
 8010164:	68f8      	ldr	r0, [r7, #12]
 8010166:	4b4b      	ldr	r3, [pc, #300]	; (8010294 <HAL_I2C_Master_Receive+0x208>)
 8010168:	9300      	str	r3, [sp, #0]
 801016a:	0023      	movs	r3, r4
 801016c:	f000 fa44 	bl	80105f8 <I2C_TransferConfig>
    }

    while (hi2c->XferCount > 0U)
 8010170:	e062      	b.n	8010238 <HAL_I2C_Master_Receive+0x1ac>
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8010172:	697a      	ldr	r2, [r7, #20]
 8010174:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8010176:	68fb      	ldr	r3, [r7, #12]
 8010178:	0018      	movs	r0, r3
 801017a:	f000 f96b 	bl	8010454 <I2C_WaitOnRXNEFlagUntilTimeout>
 801017e:	1e03      	subs	r3, r0, #0
 8010180:	d001      	beq.n	8010186 <HAL_I2C_Master_Receive+0xfa>
      {
        return HAL_ERROR;
 8010182:	2301      	movs	r3, #1
 8010184:	e082      	b.n	801028c <HAL_I2C_Master_Receive+0x200>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 8010186:	68fb      	ldr	r3, [r7, #12]
 8010188:	681b      	ldr	r3, [r3, #0]
 801018a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 801018c:	68fb      	ldr	r3, [r7, #12]
 801018e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010190:	b2d2      	uxtb	r2, r2
 8010192:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 8010194:	68fb      	ldr	r3, [r7, #12]
 8010196:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010198:	1c5a      	adds	r2, r3, #1
 801019a:	68fb      	ldr	r3, [r7, #12]
 801019c:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferSize--;
 801019e:	68fb      	ldr	r3, [r7, #12]
 80101a0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 80101a2:	3b01      	subs	r3, #1
 80101a4:	b29a      	uxth	r2, r3
 80101a6:	68fb      	ldr	r3, [r7, #12]
 80101a8:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
 80101aa:	68fb      	ldr	r3, [r7, #12]
 80101ac:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 80101ae:	b29b      	uxth	r3, r3
 80101b0:	3b01      	subs	r3, #1
 80101b2:	b29a      	uxth	r2, r3
 80101b4:	68fb      	ldr	r3, [r7, #12]
 80101b6:	855a      	strh	r2, [r3, #42]	; 0x2a

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 80101b8:	68fb      	ldr	r3, [r7, #12]
 80101ba:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 80101bc:	b29b      	uxth	r3, r3
 80101be:	2b00      	cmp	r3, #0
 80101c0:	d03a      	beq.n	8010238 <HAL_I2C_Master_Receive+0x1ac>
 80101c2:	68fb      	ldr	r3, [r7, #12]
 80101c4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 80101c6:	2b00      	cmp	r3, #0
 80101c8:	d136      	bne.n	8010238 <HAL_I2C_Master_Receive+0x1ac>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 80101ca:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80101cc:	68f8      	ldr	r0, [r7, #12]
 80101ce:	697b      	ldr	r3, [r7, #20]
 80101d0:	9300      	str	r3, [sp, #0]
 80101d2:	0013      	movs	r3, r2
 80101d4:	2200      	movs	r2, #0
 80101d6:	2180      	movs	r1, #128	; 0x80
 80101d8:	f000 f882 	bl	80102e0 <I2C_WaitOnFlagUntilTimeout>
 80101dc:	1e03      	subs	r3, r0, #0
 80101de:	d001      	beq.n	80101e4 <HAL_I2C_Master_Receive+0x158>
        {
          return HAL_ERROR;
 80101e0:	2301      	movs	r3, #1
 80101e2:	e053      	b.n	801028c <HAL_I2C_Master_Receive+0x200>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 80101e4:	68fb      	ldr	r3, [r7, #12]
 80101e6:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 80101e8:	b29b      	uxth	r3, r3
 80101ea:	2bff      	cmp	r3, #255	; 0xff
 80101ec:	d911      	bls.n	8010212 <HAL_I2C_Master_Receive+0x186>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
 80101ee:	68fb      	ldr	r3, [r7, #12]
 80101f0:	22ff      	movs	r2, #255	; 0xff
 80101f2:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 80101f4:	68fb      	ldr	r3, [r7, #12]
 80101f6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 80101f8:	b2da      	uxtb	r2, r3
 80101fa:	2380      	movs	r3, #128	; 0x80
 80101fc:	045c      	lsls	r4, r3, #17
 80101fe:	230a      	movs	r3, #10
 8010200:	18fb      	adds	r3, r7, r3
 8010202:	8819      	ldrh	r1, [r3, #0]
 8010204:	68f8      	ldr	r0, [r7, #12]
 8010206:	2300      	movs	r3, #0
 8010208:	9300      	str	r3, [sp, #0]
 801020a:	0023      	movs	r3, r4
 801020c:	f000 f9f4 	bl	80105f8 <I2C_TransferConfig>
 8010210:	e012      	b.n	8010238 <HAL_I2C_Master_Receive+0x1ac>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
 8010212:	68fb      	ldr	r3, [r7, #12]
 8010214:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8010216:	b29a      	uxth	r2, r3
 8010218:	68fb      	ldr	r3, [r7, #12]
 801021a:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 801021c:	68fb      	ldr	r3, [r7, #12]
 801021e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8010220:	b2da      	uxtb	r2, r3
 8010222:	2380      	movs	r3, #128	; 0x80
 8010224:	049c      	lsls	r4, r3, #18
 8010226:	230a      	movs	r3, #10
 8010228:	18fb      	adds	r3, r7, r3
 801022a:	8819      	ldrh	r1, [r3, #0]
 801022c:	68f8      	ldr	r0, [r7, #12]
 801022e:	2300      	movs	r3, #0
 8010230:	9300      	str	r3, [sp, #0]
 8010232:	0023      	movs	r3, r4
 8010234:	f000 f9e0 	bl	80105f8 <I2C_TransferConfig>
    while (hi2c->XferCount > 0U)
 8010238:	68fb      	ldr	r3, [r7, #12]
 801023a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 801023c:	b29b      	uxth	r3, r3
 801023e:	2b00      	cmp	r3, #0
 8010240:	d197      	bne.n	8010172 <HAL_I2C_Master_Receive+0xe6>
      }
    }

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8010242:	697a      	ldr	r2, [r7, #20]
 8010244:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8010246:	68fb      	ldr	r3, [r7, #12]
 8010248:	0018      	movs	r0, r3
 801024a:	f000 f8c7 	bl	80103dc <I2C_WaitOnSTOPFlagUntilTimeout>
 801024e:	1e03      	subs	r3, r0, #0
 8010250:	d001      	beq.n	8010256 <HAL_I2C_Master_Receive+0x1ca>
    {
      return HAL_ERROR;
 8010252:	2301      	movs	r3, #1
 8010254:	e01a      	b.n	801028c <HAL_I2C_Master_Receive+0x200>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8010256:	68fb      	ldr	r3, [r7, #12]
 8010258:	681b      	ldr	r3, [r3, #0]
 801025a:	2220      	movs	r2, #32
 801025c:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 801025e:	68fb      	ldr	r3, [r7, #12]
 8010260:	681b      	ldr	r3, [r3, #0]
 8010262:	685a      	ldr	r2, [r3, #4]
 8010264:	68fb      	ldr	r3, [r7, #12]
 8010266:	681b      	ldr	r3, [r3, #0]
 8010268:	490b      	ldr	r1, [pc, #44]	; (8010298 <HAL_I2C_Master_Receive+0x20c>)
 801026a:	400a      	ands	r2, r1
 801026c:	605a      	str	r2, [r3, #4]

    hi2c->State = HAL_I2C_STATE_READY;
 801026e:	68fb      	ldr	r3, [r7, #12]
 8010270:	2241      	movs	r2, #65	; 0x41
 8010272:	2120      	movs	r1, #32
 8010274:	5499      	strb	r1, [r3, r2]
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8010276:	68fb      	ldr	r3, [r7, #12]
 8010278:	2242      	movs	r2, #66	; 0x42
 801027a:	2100      	movs	r1, #0
 801027c:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 801027e:	68fb      	ldr	r3, [r7, #12]
 8010280:	2240      	movs	r2, #64	; 0x40
 8010282:	2100      	movs	r1, #0
 8010284:	5499      	strb	r1, [r3, r2]

    return HAL_OK;
 8010286:	2300      	movs	r3, #0
 8010288:	e000      	b.n	801028c <HAL_I2C_Master_Receive+0x200>
  }
  else
  {
    return HAL_BUSY;
 801028a:	2302      	movs	r3, #2
  }
}
 801028c:	0018      	movs	r0, r3
 801028e:	46bd      	mov	sp, r7
 8010290:	b007      	add	sp, #28
 8010292:	bd90      	pop	{r4, r7, pc}
 8010294:	80002400 	.word	0x80002400
 8010298:	fe00e800 	.word	0xfe00e800

0801029c <I2C_Flush_TXDR>:
  * @brief  I2C Tx data register flush process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
 801029c:	b580      	push	{r7, lr}
 801029e:	b082      	sub	sp, #8
 80102a0:	af00      	add	r7, sp, #0
 80102a2:	6078      	str	r0, [r7, #4]
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 80102a4:	687b      	ldr	r3, [r7, #4]
 80102a6:	681b      	ldr	r3, [r3, #0]
 80102a8:	699b      	ldr	r3, [r3, #24]
 80102aa:	2202      	movs	r2, #2
 80102ac:	4013      	ands	r3, r2
 80102ae:	2b02      	cmp	r3, #2
 80102b0:	d103      	bne.n	80102ba <I2C_Flush_TXDR+0x1e>
  {
    hi2c->Instance->TXDR = 0x00U;
 80102b2:	687b      	ldr	r3, [r7, #4]
 80102b4:	681b      	ldr	r3, [r3, #0]
 80102b6:	2200      	movs	r2, #0
 80102b8:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 80102ba:	687b      	ldr	r3, [r7, #4]
 80102bc:	681b      	ldr	r3, [r3, #0]
 80102be:	699b      	ldr	r3, [r3, #24]
 80102c0:	2201      	movs	r2, #1
 80102c2:	4013      	ands	r3, r2
 80102c4:	2b01      	cmp	r3, #1
 80102c6:	d007      	beq.n	80102d8 <I2C_Flush_TXDR+0x3c>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 80102c8:	687b      	ldr	r3, [r7, #4]
 80102ca:	681b      	ldr	r3, [r3, #0]
 80102cc:	699a      	ldr	r2, [r3, #24]
 80102ce:	687b      	ldr	r3, [r7, #4]
 80102d0:	681b      	ldr	r3, [r3, #0]
 80102d2:	2101      	movs	r1, #1
 80102d4:	430a      	orrs	r2, r1
 80102d6:	619a      	str	r2, [r3, #24]
  }
}
 80102d8:	46c0      	nop			; (mov r8, r8)
 80102da:	46bd      	mov	sp, r7
 80102dc:	b002      	add	sp, #8
 80102de:	bd80      	pop	{r7, pc}

080102e0 <I2C_WaitOnFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status,
                                                    uint32_t Timeout, uint32_t Tickstart)
{
 80102e0:	b580      	push	{r7, lr}
 80102e2:	b084      	sub	sp, #16
 80102e4:	af00      	add	r7, sp, #0
 80102e6:	60f8      	str	r0, [r7, #12]
 80102e8:	60b9      	str	r1, [r7, #8]
 80102ea:	603b      	str	r3, [r7, #0]
 80102ec:	1dfb      	adds	r3, r7, #7
 80102ee:	701a      	strb	r2, [r3, #0]
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 80102f0:	e021      	b.n	8010336 <I2C_WaitOnFlagUntilTimeout+0x56>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 80102f2:	683b      	ldr	r3, [r7, #0]
 80102f4:	3301      	adds	r3, #1
 80102f6:	d01e      	beq.n	8010336 <I2C_WaitOnFlagUntilTimeout+0x56>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80102f8:	f7ff f8f2 	bl	800f4e0 <HAL_GetTick>
 80102fc:	0002      	movs	r2, r0
 80102fe:	69bb      	ldr	r3, [r7, #24]
 8010300:	1ad3      	subs	r3, r2, r3
 8010302:	683a      	ldr	r2, [r7, #0]
 8010304:	429a      	cmp	r2, r3
 8010306:	d302      	bcc.n	801030e <I2C_WaitOnFlagUntilTimeout+0x2e>
 8010308:	683b      	ldr	r3, [r7, #0]
 801030a:	2b00      	cmp	r3, #0
 801030c:	d113      	bne.n	8010336 <I2C_WaitOnFlagUntilTimeout+0x56>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 801030e:	68fb      	ldr	r3, [r7, #12]
 8010310:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8010312:	2220      	movs	r2, #32
 8010314:	431a      	orrs	r2, r3
 8010316:	68fb      	ldr	r3, [r7, #12]
 8010318:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 801031a:	68fb      	ldr	r3, [r7, #12]
 801031c:	2241      	movs	r2, #65	; 0x41
 801031e:	2120      	movs	r1, #32
 8010320:	5499      	strb	r1, [r3, r2]
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8010322:	68fb      	ldr	r3, [r7, #12]
 8010324:	2242      	movs	r2, #66	; 0x42
 8010326:	2100      	movs	r1, #0
 8010328:	5499      	strb	r1, [r3, r2]

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 801032a:	68fb      	ldr	r3, [r7, #12]
 801032c:	2240      	movs	r2, #64	; 0x40
 801032e:	2100      	movs	r1, #0
 8010330:	5499      	strb	r1, [r3, r2]
        return HAL_ERROR;
 8010332:	2301      	movs	r3, #1
 8010334:	e00f      	b.n	8010356 <I2C_WaitOnFlagUntilTimeout+0x76>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8010336:	68fb      	ldr	r3, [r7, #12]
 8010338:	681b      	ldr	r3, [r3, #0]
 801033a:	699b      	ldr	r3, [r3, #24]
 801033c:	68ba      	ldr	r2, [r7, #8]
 801033e:	4013      	ands	r3, r2
 8010340:	68ba      	ldr	r2, [r7, #8]
 8010342:	1ad3      	subs	r3, r2, r3
 8010344:	425a      	negs	r2, r3
 8010346:	4153      	adcs	r3, r2
 8010348:	b2db      	uxtb	r3, r3
 801034a:	001a      	movs	r2, r3
 801034c:	1dfb      	adds	r3, r7, #7
 801034e:	781b      	ldrb	r3, [r3, #0]
 8010350:	429a      	cmp	r2, r3
 8010352:	d0ce      	beq.n	80102f2 <I2C_WaitOnFlagUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
 8010354:	2300      	movs	r3, #0
}
 8010356:	0018      	movs	r0, r3
 8010358:	46bd      	mov	sp, r7
 801035a:	b004      	add	sp, #16
 801035c:	bd80      	pop	{r7, pc}

0801035e <I2C_WaitOnTXISFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 801035e:	b580      	push	{r7, lr}
 8010360:	b084      	sub	sp, #16
 8010362:	af00      	add	r7, sp, #0
 8010364:	60f8      	str	r0, [r7, #12]
 8010366:	60b9      	str	r1, [r7, #8]
 8010368:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 801036a:	e02b      	b.n	80103c4 <I2C_WaitOnTXISFlagUntilTimeout+0x66>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 801036c:	687a      	ldr	r2, [r7, #4]
 801036e:	68b9      	ldr	r1, [r7, #8]
 8010370:	68fb      	ldr	r3, [r7, #12]
 8010372:	0018      	movs	r0, r3
 8010374:	f000 f8da 	bl	801052c <I2C_IsAcknowledgeFailed>
 8010378:	1e03      	subs	r3, r0, #0
 801037a:	d001      	beq.n	8010380 <I2C_WaitOnTXISFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
 801037c:	2301      	movs	r3, #1
 801037e:	e029      	b.n	80103d4 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 8010380:	68bb      	ldr	r3, [r7, #8]
 8010382:	3301      	adds	r3, #1
 8010384:	d01e      	beq.n	80103c4 <I2C_WaitOnTXISFlagUntilTimeout+0x66>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8010386:	f7ff f8ab 	bl	800f4e0 <HAL_GetTick>
 801038a:	0002      	movs	r2, r0
 801038c:	687b      	ldr	r3, [r7, #4]
 801038e:	1ad3      	subs	r3, r2, r3
 8010390:	68ba      	ldr	r2, [r7, #8]
 8010392:	429a      	cmp	r2, r3
 8010394:	d302      	bcc.n	801039c <I2C_WaitOnTXISFlagUntilTimeout+0x3e>
 8010396:	68bb      	ldr	r3, [r7, #8]
 8010398:	2b00      	cmp	r3, #0
 801039a:	d113      	bne.n	80103c4 <I2C_WaitOnTXISFlagUntilTimeout+0x66>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 801039c:	68fb      	ldr	r3, [r7, #12]
 801039e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80103a0:	2220      	movs	r2, #32
 80103a2:	431a      	orrs	r2, r3
 80103a4:	68fb      	ldr	r3, [r7, #12]
 80103a6:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 80103a8:	68fb      	ldr	r3, [r7, #12]
 80103aa:	2241      	movs	r2, #65	; 0x41
 80103ac:	2120      	movs	r1, #32
 80103ae:	5499      	strb	r1, [r3, r2]
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80103b0:	68fb      	ldr	r3, [r7, #12]
 80103b2:	2242      	movs	r2, #66	; 0x42
 80103b4:	2100      	movs	r1, #0
 80103b6:	5499      	strb	r1, [r3, r2]

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 80103b8:	68fb      	ldr	r3, [r7, #12]
 80103ba:	2240      	movs	r2, #64	; 0x40
 80103bc:	2100      	movs	r1, #0
 80103be:	5499      	strb	r1, [r3, r2]

        return HAL_ERROR;
 80103c0:	2301      	movs	r3, #1
 80103c2:	e007      	b.n	80103d4 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 80103c4:	68fb      	ldr	r3, [r7, #12]
 80103c6:	681b      	ldr	r3, [r3, #0]
 80103c8:	699b      	ldr	r3, [r3, #24]
 80103ca:	2202      	movs	r2, #2
 80103cc:	4013      	ands	r3, r2
 80103ce:	2b02      	cmp	r3, #2
 80103d0:	d1cc      	bne.n	801036c <I2C_WaitOnTXISFlagUntilTimeout+0xe>
      }
    }
  }
  return HAL_OK;
 80103d2:	2300      	movs	r3, #0
}
 80103d4:	0018      	movs	r0, r3
 80103d6:	46bd      	mov	sp, r7
 80103d8:	b004      	add	sp, #16
 80103da:	bd80      	pop	{r7, pc}

080103dc <I2C_WaitOnSTOPFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 80103dc:	b580      	push	{r7, lr}
 80103de:	b084      	sub	sp, #16
 80103e0:	af00      	add	r7, sp, #0
 80103e2:	60f8      	str	r0, [r7, #12]
 80103e4:	60b9      	str	r1, [r7, #8]
 80103e6:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 80103e8:	e028      	b.n	801043c <I2C_WaitOnSTOPFlagUntilTimeout+0x60>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 80103ea:	687a      	ldr	r2, [r7, #4]
 80103ec:	68b9      	ldr	r1, [r7, #8]
 80103ee:	68fb      	ldr	r3, [r7, #12]
 80103f0:	0018      	movs	r0, r3
 80103f2:	f000 f89b 	bl	801052c <I2C_IsAcknowledgeFailed>
 80103f6:	1e03      	subs	r3, r0, #0
 80103f8:	d001      	beq.n	80103fe <I2C_WaitOnSTOPFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
 80103fa:	2301      	movs	r3, #1
 80103fc:	e026      	b.n	801044c <I2C_WaitOnSTOPFlagUntilTimeout+0x70>
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80103fe:	f7ff f86f 	bl	800f4e0 <HAL_GetTick>
 8010402:	0002      	movs	r2, r0
 8010404:	687b      	ldr	r3, [r7, #4]
 8010406:	1ad3      	subs	r3, r2, r3
 8010408:	68ba      	ldr	r2, [r7, #8]
 801040a:	429a      	cmp	r2, r3
 801040c:	d302      	bcc.n	8010414 <I2C_WaitOnSTOPFlagUntilTimeout+0x38>
 801040e:	68bb      	ldr	r3, [r7, #8]
 8010410:	2b00      	cmp	r3, #0
 8010412:	d113      	bne.n	801043c <I2C_WaitOnSTOPFlagUntilTimeout+0x60>
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8010414:	68fb      	ldr	r3, [r7, #12]
 8010416:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8010418:	2220      	movs	r2, #32
 801041a:	431a      	orrs	r2, r3
 801041c:	68fb      	ldr	r3, [r7, #12]
 801041e:	645a      	str	r2, [r3, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
 8010420:	68fb      	ldr	r3, [r7, #12]
 8010422:	2241      	movs	r2, #65	; 0x41
 8010424:	2120      	movs	r1, #32
 8010426:	5499      	strb	r1, [r3, r2]
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8010428:	68fb      	ldr	r3, [r7, #12]
 801042a:	2242      	movs	r2, #66	; 0x42
 801042c:	2100      	movs	r1, #0
 801042e:	5499      	strb	r1, [r3, r2]

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 8010430:	68fb      	ldr	r3, [r7, #12]
 8010432:	2240      	movs	r2, #64	; 0x40
 8010434:	2100      	movs	r1, #0
 8010436:	5499      	strb	r1, [r3, r2]

      return HAL_ERROR;
 8010438:	2301      	movs	r3, #1
 801043a:	e007      	b.n	801044c <I2C_WaitOnSTOPFlagUntilTimeout+0x70>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 801043c:	68fb      	ldr	r3, [r7, #12]
 801043e:	681b      	ldr	r3, [r3, #0]
 8010440:	699b      	ldr	r3, [r3, #24]
 8010442:	2220      	movs	r2, #32
 8010444:	4013      	ands	r3, r2
 8010446:	2b20      	cmp	r3, #32
 8010448:	d1cf      	bne.n	80103ea <I2C_WaitOnSTOPFlagUntilTimeout+0xe>
    }
  }
  return HAL_OK;
 801044a:	2300      	movs	r3, #0
}
 801044c:	0018      	movs	r0, r3
 801044e:	46bd      	mov	sp, r7
 8010450:	b004      	add	sp, #16
 8010452:	bd80      	pop	{r7, pc}

08010454 <I2C_WaitOnRXNEFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 8010454:	b580      	push	{r7, lr}
 8010456:	b084      	sub	sp, #16
 8010458:	af00      	add	r7, sp, #0
 801045a:	60f8      	str	r0, [r7, #12]
 801045c:	60b9      	str	r1, [r7, #8]
 801045e:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
 8010460:	e055      	b.n	801050e <I2C_WaitOnRXNEFlagUntilTimeout+0xba>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 8010462:	687a      	ldr	r2, [r7, #4]
 8010464:	68b9      	ldr	r1, [r7, #8]
 8010466:	68fb      	ldr	r3, [r7, #12]
 8010468:	0018      	movs	r0, r3
 801046a:	f000 f85f 	bl	801052c <I2C_IsAcknowledgeFailed>
 801046e:	1e03      	subs	r3, r0, #0
 8010470:	d001      	beq.n	8010476 <I2C_WaitOnRXNEFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
 8010472:	2301      	movs	r3, #1
 8010474:	e053      	b.n	801051e <I2C_WaitOnRXNEFlagUntilTimeout+0xca>
    }

    /* Check if a STOPF is detected */
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
 8010476:	68fb      	ldr	r3, [r7, #12]
 8010478:	681b      	ldr	r3, [r3, #0]
 801047a:	699b      	ldr	r3, [r3, #24]
 801047c:	2220      	movs	r2, #32
 801047e:	4013      	ands	r3, r2
 8010480:	2b20      	cmp	r3, #32
 8010482:	d129      	bne.n	80104d8 <I2C_WaitOnRXNEFlagUntilTimeout+0x84>
    {
      /* Check if an RXNE is pending */
      /* Store Last receive data if any */
      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) && (hi2c->XferSize > 0U))
 8010484:	68fb      	ldr	r3, [r7, #12]
 8010486:	681b      	ldr	r3, [r3, #0]
 8010488:	699b      	ldr	r3, [r3, #24]
 801048a:	2204      	movs	r2, #4
 801048c:	4013      	ands	r3, r2
 801048e:	2b04      	cmp	r3, #4
 8010490:	d105      	bne.n	801049e <I2C_WaitOnRXNEFlagUntilTimeout+0x4a>
 8010492:	68fb      	ldr	r3, [r7, #12]
 8010494:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8010496:	2b00      	cmp	r3, #0
 8010498:	d001      	beq.n	801049e <I2C_WaitOnRXNEFlagUntilTimeout+0x4a>
      {
        /* Return HAL_OK */
        /* The Reading of data from RXDR will be done in caller function */
        return HAL_OK;
 801049a:	2300      	movs	r3, #0
 801049c:	e03f      	b.n	801051e <I2C_WaitOnRXNEFlagUntilTimeout+0xca>
      }
      else
      {
        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 801049e:	68fb      	ldr	r3, [r7, #12]
 80104a0:	681b      	ldr	r3, [r3, #0]
 80104a2:	2220      	movs	r2, #32
 80104a4:	61da      	str	r2, [r3, #28]

        /* Clear Configuration Register 2 */
        I2C_RESET_CR2(hi2c);
 80104a6:	68fb      	ldr	r3, [r7, #12]
 80104a8:	681b      	ldr	r3, [r3, #0]
 80104aa:	685a      	ldr	r2, [r3, #4]
 80104ac:	68fb      	ldr	r3, [r7, #12]
 80104ae:	681b      	ldr	r3, [r3, #0]
 80104b0:	491d      	ldr	r1, [pc, #116]	; (8010528 <I2C_WaitOnRXNEFlagUntilTimeout+0xd4>)
 80104b2:	400a      	ands	r2, r1
 80104b4:	605a      	str	r2, [r3, #4]

        hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80104b6:	68fb      	ldr	r3, [r7, #12]
 80104b8:	2200      	movs	r2, #0
 80104ba:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 80104bc:	68fb      	ldr	r3, [r7, #12]
 80104be:	2241      	movs	r2, #65	; 0x41
 80104c0:	2120      	movs	r1, #32
 80104c2:	5499      	strb	r1, [r3, r2]
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80104c4:	68fb      	ldr	r3, [r7, #12]
 80104c6:	2242      	movs	r2, #66	; 0x42
 80104c8:	2100      	movs	r1, #0
 80104ca:	5499      	strb	r1, [r3, r2]

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 80104cc:	68fb      	ldr	r3, [r7, #12]
 80104ce:	2240      	movs	r2, #64	; 0x40
 80104d0:	2100      	movs	r1, #0
 80104d2:	5499      	strb	r1, [r3, r2]

        return HAL_ERROR;
 80104d4:	2301      	movs	r3, #1
 80104d6:	e022      	b.n	801051e <I2C_WaitOnRXNEFlagUntilTimeout+0xca>
      }
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80104d8:	f7ff f802 	bl	800f4e0 <HAL_GetTick>
 80104dc:	0002      	movs	r2, r0
 80104de:	687b      	ldr	r3, [r7, #4]
 80104e0:	1ad3      	subs	r3, r2, r3
 80104e2:	68ba      	ldr	r2, [r7, #8]
 80104e4:	429a      	cmp	r2, r3
 80104e6:	d302      	bcc.n	80104ee <I2C_WaitOnRXNEFlagUntilTimeout+0x9a>
 80104e8:	68bb      	ldr	r3, [r7, #8]
 80104ea:	2b00      	cmp	r3, #0
 80104ec:	d10f      	bne.n	801050e <I2C_WaitOnRXNEFlagUntilTimeout+0xba>
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80104ee:	68fb      	ldr	r3, [r7, #12]
 80104f0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80104f2:	2220      	movs	r2, #32
 80104f4:	431a      	orrs	r2, r3
 80104f6:	68fb      	ldr	r3, [r7, #12]
 80104f8:	645a      	str	r2, [r3, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
 80104fa:	68fb      	ldr	r3, [r7, #12]
 80104fc:	2241      	movs	r2, #65	; 0x41
 80104fe:	2120      	movs	r1, #32
 8010500:	5499      	strb	r1, [r3, r2]

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 8010502:	68fb      	ldr	r3, [r7, #12]
 8010504:	2240      	movs	r2, #64	; 0x40
 8010506:	2100      	movs	r1, #0
 8010508:	5499      	strb	r1, [r3, r2]

      return HAL_ERROR;
 801050a:	2301      	movs	r3, #1
 801050c:	e007      	b.n	801051e <I2C_WaitOnRXNEFlagUntilTimeout+0xca>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
 801050e:	68fb      	ldr	r3, [r7, #12]
 8010510:	681b      	ldr	r3, [r3, #0]
 8010512:	699b      	ldr	r3, [r3, #24]
 8010514:	2204      	movs	r2, #4
 8010516:	4013      	ands	r3, r2
 8010518:	2b04      	cmp	r3, #4
 801051a:	d1a2      	bne.n	8010462 <I2C_WaitOnRXNEFlagUntilTimeout+0xe>
    }
  }
  return HAL_OK;
 801051c:	2300      	movs	r3, #0
}
 801051e:	0018      	movs	r0, r3
 8010520:	46bd      	mov	sp, r7
 8010522:	b004      	add	sp, #16
 8010524:	bd80      	pop	{r7, pc}
 8010526:	46c0      	nop			; (mov r8, r8)
 8010528:	fe00e800 	.word	0xfe00e800

0801052c <I2C_IsAcknowledgeFailed>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 801052c:	b580      	push	{r7, lr}
 801052e:	b084      	sub	sp, #16
 8010530:	af00      	add	r7, sp, #0
 8010532:	60f8      	str	r0, [r7, #12]
 8010534:	60b9      	str	r1, [r7, #8]
 8010536:	607a      	str	r2, [r7, #4]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8010538:	68fb      	ldr	r3, [r7, #12]
 801053a:	681b      	ldr	r3, [r3, #0]
 801053c:	699b      	ldr	r3, [r3, #24]
 801053e:	2210      	movs	r2, #16
 8010540:	4013      	ands	r3, r2
 8010542:	2b10      	cmp	r3, #16
 8010544:	d151      	bne.n	80105ea <I2C_IsAcknowledgeFailed+0xbe>
  {
    /* Wait until STOP Flag is reset */
    /* AutoEnd should be initiate after AF */
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8010546:	e021      	b.n	801058c <I2C_IsAcknowledgeFailed+0x60>
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
 8010548:	68bb      	ldr	r3, [r7, #8]
 801054a:	3301      	adds	r3, #1
 801054c:	d01e      	beq.n	801058c <I2C_IsAcknowledgeFailed+0x60>
      {
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 801054e:	f7fe ffc7 	bl	800f4e0 <HAL_GetTick>
 8010552:	0002      	movs	r2, r0
 8010554:	687b      	ldr	r3, [r7, #4]
 8010556:	1ad3      	subs	r3, r2, r3
 8010558:	68ba      	ldr	r2, [r7, #8]
 801055a:	429a      	cmp	r2, r3
 801055c:	d302      	bcc.n	8010564 <I2C_IsAcknowledgeFailed+0x38>
 801055e:	68bb      	ldr	r3, [r7, #8]
 8010560:	2b00      	cmp	r3, #0
 8010562:	d113      	bne.n	801058c <I2C_IsAcknowledgeFailed+0x60>
        {
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8010564:	68fb      	ldr	r3, [r7, #12]
 8010566:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8010568:	2220      	movs	r2, #32
 801056a:	431a      	orrs	r2, r3
 801056c:	68fb      	ldr	r3, [r7, #12]
 801056e:	645a      	str	r2, [r3, #68]	; 0x44
          hi2c->State = HAL_I2C_STATE_READY;
 8010570:	68fb      	ldr	r3, [r7, #12]
 8010572:	2241      	movs	r2, #65	; 0x41
 8010574:	2120      	movs	r1, #32
 8010576:	5499      	strb	r1, [r3, r2]
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8010578:	68fb      	ldr	r3, [r7, #12]
 801057a:	2242      	movs	r2, #66	; 0x42
 801057c:	2100      	movs	r1, #0
 801057e:	5499      	strb	r1, [r3, r2]

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
 8010580:	68fb      	ldr	r3, [r7, #12]
 8010582:	2240      	movs	r2, #64	; 0x40
 8010584:	2100      	movs	r1, #0
 8010586:	5499      	strb	r1, [r3, r2]

          return HAL_ERROR;
 8010588:	2301      	movs	r3, #1
 801058a:	e02f      	b.n	80105ec <I2C_IsAcknowledgeFailed+0xc0>
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 801058c:	68fb      	ldr	r3, [r7, #12]
 801058e:	681b      	ldr	r3, [r3, #0]
 8010590:	699b      	ldr	r3, [r3, #24]
 8010592:	2220      	movs	r2, #32
 8010594:	4013      	ands	r3, r2
 8010596:	2b20      	cmp	r3, #32
 8010598:	d1d6      	bne.n	8010548 <I2C_IsAcknowledgeFailed+0x1c>
        }
      }
    }

    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 801059a:	68fb      	ldr	r3, [r7, #12]
 801059c:	681b      	ldr	r3, [r3, #0]
 801059e:	2210      	movs	r2, #16
 80105a0:	61da      	str	r2, [r3, #28]

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80105a2:	68fb      	ldr	r3, [r7, #12]
 80105a4:	681b      	ldr	r3, [r3, #0]
 80105a6:	2220      	movs	r2, #32
 80105a8:	61da      	str	r2, [r3, #28]

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
 80105aa:	68fb      	ldr	r3, [r7, #12]
 80105ac:	0018      	movs	r0, r3
 80105ae:	f7ff fe75 	bl	801029c <I2C_Flush_TXDR>

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 80105b2:	68fb      	ldr	r3, [r7, #12]
 80105b4:	681b      	ldr	r3, [r3, #0]
 80105b6:	685a      	ldr	r2, [r3, #4]
 80105b8:	68fb      	ldr	r3, [r7, #12]
 80105ba:	681b      	ldr	r3, [r3, #0]
 80105bc:	490d      	ldr	r1, [pc, #52]	; (80105f4 <I2C_IsAcknowledgeFailed+0xc8>)
 80105be:	400a      	ands	r2, r1
 80105c0:	605a      	str	r2, [r3, #4]

    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 80105c2:	68fb      	ldr	r3, [r7, #12]
 80105c4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80105c6:	2204      	movs	r2, #4
 80105c8:	431a      	orrs	r2, r3
 80105ca:	68fb      	ldr	r3, [r7, #12]
 80105cc:	645a      	str	r2, [r3, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 80105ce:	68fb      	ldr	r3, [r7, #12]
 80105d0:	2241      	movs	r2, #65	; 0x41
 80105d2:	2120      	movs	r1, #32
 80105d4:	5499      	strb	r1, [r3, r2]
    hi2c->Mode = HAL_I2C_MODE_NONE;
 80105d6:	68fb      	ldr	r3, [r7, #12]
 80105d8:	2242      	movs	r2, #66	; 0x42
 80105da:	2100      	movs	r1, #0
 80105dc:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 80105de:	68fb      	ldr	r3, [r7, #12]
 80105e0:	2240      	movs	r2, #64	; 0x40
 80105e2:	2100      	movs	r1, #0
 80105e4:	5499      	strb	r1, [r3, r2]

    return HAL_ERROR;
 80105e6:	2301      	movs	r3, #1
 80105e8:	e000      	b.n	80105ec <I2C_IsAcknowledgeFailed+0xc0>
  }
  return HAL_OK;
 80105ea:	2300      	movs	r3, #0
}
 80105ec:	0018      	movs	r0, r3
 80105ee:	46bd      	mov	sp, r7
 80105f0:	b004      	add	sp, #16
 80105f2:	bd80      	pop	{r7, pc}
 80105f4:	fe00e800 	.word	0xfe00e800

080105f8 <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,
                               uint32_t Request)
{
 80105f8:	b590      	push	{r4, r7, lr}
 80105fa:	b085      	sub	sp, #20
 80105fc:	af00      	add	r7, sp, #0
 80105fe:	60f8      	str	r0, [r7, #12]
 8010600:	0008      	movs	r0, r1
 8010602:	0011      	movs	r1, r2
 8010604:	607b      	str	r3, [r7, #4]
 8010606:	240a      	movs	r4, #10
 8010608:	193b      	adds	r3, r7, r4
 801060a:	1c02      	adds	r2, r0, #0
 801060c:	801a      	strh	r2, [r3, #0]
 801060e:	2009      	movs	r0, #9
 8010610:	183b      	adds	r3, r7, r0
 8010612:	1c0a      	adds	r2, r1, #0
 8010614:	701a      	strb	r2, [r3, #0]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2,
 8010616:	68fb      	ldr	r3, [r7, #12]
 8010618:	681b      	ldr	r3, [r3, #0]
 801061a:	685b      	ldr	r3, [r3, #4]
 801061c:	6a3a      	ldr	r2, [r7, #32]
 801061e:	0d51      	lsrs	r1, r2, #21
 8010620:	2280      	movs	r2, #128	; 0x80
 8010622:	00d2      	lsls	r2, r2, #3
 8010624:	400a      	ands	r2, r1
 8010626:	490e      	ldr	r1, [pc, #56]	; (8010660 <I2C_TransferConfig+0x68>)
 8010628:	430a      	orrs	r2, r1
 801062a:	43d2      	mvns	r2, r2
 801062c:	401a      	ands	r2, r3
 801062e:	0011      	movs	r1, r2
 8010630:	193b      	adds	r3, r7, r4
 8010632:	881b      	ldrh	r3, [r3, #0]
 8010634:	059b      	lsls	r3, r3, #22
 8010636:	0d9a      	lsrs	r2, r3, #22
 8010638:	183b      	adds	r3, r7, r0
 801063a:	781b      	ldrb	r3, [r3, #0]
 801063c:	0418      	lsls	r0, r3, #16
 801063e:	23ff      	movs	r3, #255	; 0xff
 8010640:	041b      	lsls	r3, r3, #16
 8010642:	4003      	ands	r3, r0
 8010644:	431a      	orrs	r2, r3
 8010646:	687b      	ldr	r3, [r7, #4]
 8010648:	431a      	orrs	r2, r3
 801064a:	6a3b      	ldr	r3, [r7, #32]
 801064c:	431a      	orrs	r2, r3
 801064e:	68fb      	ldr	r3, [r7, #12]
 8010650:	681b      	ldr	r3, [r3, #0]
 8010652:	430a      	orrs	r2, r1
 8010654:	605a      	str	r2, [r3, #4]
             ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | \
               (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
             (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) |
                        (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | (uint32_t)Mode | (uint32_t)Request));
}
 8010656:	46c0      	nop			; (mov r8, r8)
 8010658:	46bd      	mov	sp, r7
 801065a:	b005      	add	sp, #20
 801065c:	bd90      	pop	{r4, r7, pc}
 801065e:	46c0      	nop			; (mov r8, r8)
 8010660:	03ff63ff 	.word	0x03ff63ff

08010664 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
 8010664:	b580      	push	{r7, lr}
 8010666:	b082      	sub	sp, #8
 8010668:	af00      	add	r7, sp, #0
 801066a:	6078      	str	r0, [r7, #4]
 801066c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 801066e:	687b      	ldr	r3, [r7, #4]
 8010670:	2241      	movs	r2, #65	; 0x41
 8010672:	5c9b      	ldrb	r3, [r3, r2]
 8010674:	b2db      	uxtb	r3, r3
 8010676:	2b20      	cmp	r3, #32
 8010678:	d138      	bne.n	80106ec <HAL_I2CEx_ConfigAnalogFilter+0x88>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 801067a:	687b      	ldr	r3, [r7, #4]
 801067c:	2240      	movs	r2, #64	; 0x40
 801067e:	5c9b      	ldrb	r3, [r3, r2]
 8010680:	2b01      	cmp	r3, #1
 8010682:	d101      	bne.n	8010688 <HAL_I2CEx_ConfigAnalogFilter+0x24>
 8010684:	2302      	movs	r3, #2
 8010686:	e032      	b.n	80106ee <HAL_I2CEx_ConfigAnalogFilter+0x8a>
 8010688:	687b      	ldr	r3, [r7, #4]
 801068a:	2240      	movs	r2, #64	; 0x40
 801068c:	2101      	movs	r1, #1
 801068e:	5499      	strb	r1, [r3, r2]

    hi2c->State = HAL_I2C_STATE_BUSY;
 8010690:	687b      	ldr	r3, [r7, #4]
 8010692:	2241      	movs	r2, #65	; 0x41
 8010694:	2124      	movs	r1, #36	; 0x24
 8010696:	5499      	strb	r1, [r3, r2]

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 8010698:	687b      	ldr	r3, [r7, #4]
 801069a:	681b      	ldr	r3, [r3, #0]
 801069c:	681a      	ldr	r2, [r3, #0]
 801069e:	687b      	ldr	r3, [r7, #4]
 80106a0:	681b      	ldr	r3, [r3, #0]
 80106a2:	2101      	movs	r1, #1
 80106a4:	438a      	bics	r2, r1
 80106a6:	601a      	str	r2, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
 80106a8:	687b      	ldr	r3, [r7, #4]
 80106aa:	681b      	ldr	r3, [r3, #0]
 80106ac:	681a      	ldr	r2, [r3, #0]
 80106ae:	687b      	ldr	r3, [r7, #4]
 80106b0:	681b      	ldr	r3, [r3, #0]
 80106b2:	4911      	ldr	r1, [pc, #68]	; (80106f8 <HAL_I2CEx_ConfigAnalogFilter+0x94>)
 80106b4:	400a      	ands	r2, r1
 80106b6:	601a      	str	r2, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
 80106b8:	687b      	ldr	r3, [r7, #4]
 80106ba:	681b      	ldr	r3, [r3, #0]
 80106bc:	6819      	ldr	r1, [r3, #0]
 80106be:	687b      	ldr	r3, [r7, #4]
 80106c0:	681b      	ldr	r3, [r3, #0]
 80106c2:	683a      	ldr	r2, [r7, #0]
 80106c4:	430a      	orrs	r2, r1
 80106c6:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
 80106c8:	687b      	ldr	r3, [r7, #4]
 80106ca:	681b      	ldr	r3, [r3, #0]
 80106cc:	681a      	ldr	r2, [r3, #0]
 80106ce:	687b      	ldr	r3, [r7, #4]
 80106d0:	681b      	ldr	r3, [r3, #0]
 80106d2:	2101      	movs	r1, #1
 80106d4:	430a      	orrs	r2, r1
 80106d6:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
 80106d8:	687b      	ldr	r3, [r7, #4]
 80106da:	2241      	movs	r2, #65	; 0x41
 80106dc:	2120      	movs	r1, #32
 80106de:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 80106e0:	687b      	ldr	r3, [r7, #4]
 80106e2:	2240      	movs	r2, #64	; 0x40
 80106e4:	2100      	movs	r1, #0
 80106e6:	5499      	strb	r1, [r3, r2]

    return HAL_OK;
 80106e8:	2300      	movs	r3, #0
 80106ea:	e000      	b.n	80106ee <HAL_I2CEx_ConfigAnalogFilter+0x8a>
  }
  else
  {
    return HAL_BUSY;
 80106ec:	2302      	movs	r3, #2
  }
}
 80106ee:	0018      	movs	r0, r3
 80106f0:	46bd      	mov	sp, r7
 80106f2:	b002      	add	sp, #8
 80106f4:	bd80      	pop	{r7, pc}
 80106f6:	46c0      	nop			; (mov r8, r8)
 80106f8:	ffffefff 	.word	0xffffefff

080106fc <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
 80106fc:	b580      	push	{r7, lr}
 80106fe:	b084      	sub	sp, #16
 8010700:	af00      	add	r7, sp, #0
 8010702:	6078      	str	r0, [r7, #4]
 8010704:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 8010706:	687b      	ldr	r3, [r7, #4]
 8010708:	2241      	movs	r2, #65	; 0x41
 801070a:	5c9b      	ldrb	r3, [r3, r2]
 801070c:	b2db      	uxtb	r3, r3
 801070e:	2b20      	cmp	r3, #32
 8010710:	d139      	bne.n	8010786 <HAL_I2CEx_ConfigDigitalFilter+0x8a>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8010712:	687b      	ldr	r3, [r7, #4]
 8010714:	2240      	movs	r2, #64	; 0x40
 8010716:	5c9b      	ldrb	r3, [r3, r2]
 8010718:	2b01      	cmp	r3, #1
 801071a:	d101      	bne.n	8010720 <HAL_I2CEx_ConfigDigitalFilter+0x24>
 801071c:	2302      	movs	r3, #2
 801071e:	e033      	b.n	8010788 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
 8010720:	687b      	ldr	r3, [r7, #4]
 8010722:	2240      	movs	r2, #64	; 0x40
 8010724:	2101      	movs	r1, #1
 8010726:	5499      	strb	r1, [r3, r2]

    hi2c->State = HAL_I2C_STATE_BUSY;
 8010728:	687b      	ldr	r3, [r7, #4]
 801072a:	2241      	movs	r2, #65	; 0x41
 801072c:	2124      	movs	r1, #36	; 0x24
 801072e:	5499      	strb	r1, [r3, r2]

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 8010730:	687b      	ldr	r3, [r7, #4]
 8010732:	681b      	ldr	r3, [r3, #0]
 8010734:	681a      	ldr	r2, [r3, #0]
 8010736:	687b      	ldr	r3, [r7, #4]
 8010738:	681b      	ldr	r3, [r3, #0]
 801073a:	2101      	movs	r1, #1
 801073c:	438a      	bics	r2, r1
 801073e:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
 8010740:	687b      	ldr	r3, [r7, #4]
 8010742:	681b      	ldr	r3, [r3, #0]
 8010744:	681b      	ldr	r3, [r3, #0]
 8010746:	60fb      	str	r3, [r7, #12]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
 8010748:	68fb      	ldr	r3, [r7, #12]
 801074a:	4a11      	ldr	r2, [pc, #68]	; (8010790 <HAL_I2CEx_ConfigDigitalFilter+0x94>)
 801074c:	4013      	ands	r3, r2
 801074e:	60fb      	str	r3, [r7, #12]

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
 8010750:	683b      	ldr	r3, [r7, #0]
 8010752:	021b      	lsls	r3, r3, #8
 8010754:	68fa      	ldr	r2, [r7, #12]
 8010756:	4313      	orrs	r3, r2
 8010758:	60fb      	str	r3, [r7, #12]

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
 801075a:	687b      	ldr	r3, [r7, #4]
 801075c:	681b      	ldr	r3, [r3, #0]
 801075e:	68fa      	ldr	r2, [r7, #12]
 8010760:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
 8010762:	687b      	ldr	r3, [r7, #4]
 8010764:	681b      	ldr	r3, [r3, #0]
 8010766:	681a      	ldr	r2, [r3, #0]
 8010768:	687b      	ldr	r3, [r7, #4]
 801076a:	681b      	ldr	r3, [r3, #0]
 801076c:	2101      	movs	r1, #1
 801076e:	430a      	orrs	r2, r1
 8010770:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
 8010772:	687b      	ldr	r3, [r7, #4]
 8010774:	2241      	movs	r2, #65	; 0x41
 8010776:	2120      	movs	r1, #32
 8010778:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 801077a:	687b      	ldr	r3, [r7, #4]
 801077c:	2240      	movs	r2, #64	; 0x40
 801077e:	2100      	movs	r1, #0
 8010780:	5499      	strb	r1, [r3, r2]

    return HAL_OK;
 8010782:	2300      	movs	r3, #0
 8010784:	e000      	b.n	8010788 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
  }
  else
  {
    return HAL_BUSY;
 8010786:	2302      	movs	r3, #2
  }
}
 8010788:	0018      	movs	r0, r3
 801078a:	46bd      	mov	sp, r7
 801078c:	b004      	add	sp, #16
 801078e:	bd80      	pop	{r7, pc}
 8010790:	fffff0ff 	.word	0xfffff0ff

08010794 <HAL_RCC_OscConfig>:
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8010794:	b5b0      	push	{r4, r5, r7, lr}
 8010796:	b08a      	sub	sp, #40	; 0x28
 8010798:	af00      	add	r7, sp, #0
 801079a:	6078      	str	r0, [r7, #4]
  uint32_t hsi_state;
  HAL_StatusTypeDef status;
  uint32_t sysclk_source, pll_config;

  /* Check the parameters */
  if(RCC_OscInitStruct == NULL)
 801079c:	687b      	ldr	r3, [r7, #4]
 801079e:	2b00      	cmp	r3, #0
 80107a0:	d102      	bne.n	80107a8 <HAL_RCC_OscConfig+0x14>
  {
    return HAL_ERROR;
 80107a2:	2301      	movs	r3, #1
 80107a4:	f000 fbbc 	bl	8010f20 <HAL_RCC_OscConfig+0x78c>
  }

  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 80107a8:	4bc8      	ldr	r3, [pc, #800]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 80107aa:	68db      	ldr	r3, [r3, #12]
 80107ac:	220c      	movs	r2, #12
 80107ae:	4013      	ands	r3, r2
 80107b0:	61fb      	str	r3, [r7, #28]
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 80107b2:	4bc6      	ldr	r3, [pc, #792]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 80107b4:	68da      	ldr	r2, [r3, #12]
 80107b6:	2380      	movs	r3, #128	; 0x80
 80107b8:	025b      	lsls	r3, r3, #9
 80107ba:	4013      	ands	r3, r2
 80107bc:	61bb      	str	r3, [r7, #24]

  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80107be:	687b      	ldr	r3, [r7, #4]
 80107c0:	681b      	ldr	r3, [r3, #0]
 80107c2:	2201      	movs	r2, #1
 80107c4:	4013      	ands	r3, r2
 80107c6:	d100      	bne.n	80107ca <HAL_RCC_OscConfig+0x36>
 80107c8:	e07e      	b.n	80108c8 <HAL_RCC_OscConfig+0x134>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 80107ca:	69fb      	ldr	r3, [r7, #28]
 80107cc:	2b08      	cmp	r3, #8
 80107ce:	d007      	beq.n	80107e0 <HAL_RCC_OscConfig+0x4c>
       || ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSE)))
 80107d0:	69fb      	ldr	r3, [r7, #28]
 80107d2:	2b0c      	cmp	r3, #12
 80107d4:	d112      	bne.n	80107fc <HAL_RCC_OscConfig+0x68>
 80107d6:	69ba      	ldr	r2, [r7, #24]
 80107d8:	2380      	movs	r3, #128	; 0x80
 80107da:	025b      	lsls	r3, r3, #9
 80107dc:	429a      	cmp	r2, r3
 80107de:	d10d      	bne.n	80107fc <HAL_RCC_OscConfig+0x68>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80107e0:	4bba      	ldr	r3, [pc, #744]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 80107e2:	681a      	ldr	r2, [r3, #0]
 80107e4:	2380      	movs	r3, #128	; 0x80
 80107e6:	029b      	lsls	r3, r3, #10
 80107e8:	4013      	ands	r3, r2
 80107ea:	d100      	bne.n	80107ee <HAL_RCC_OscConfig+0x5a>
 80107ec:	e06b      	b.n	80108c6 <HAL_RCC_OscConfig+0x132>
 80107ee:	687b      	ldr	r3, [r7, #4]
 80107f0:	685b      	ldr	r3, [r3, #4]
 80107f2:	2b00      	cmp	r3, #0
 80107f4:	d167      	bne.n	80108c6 <HAL_RCC_OscConfig+0x132>
      {
        return HAL_ERROR;
 80107f6:	2301      	movs	r3, #1
 80107f8:	f000 fb92 	bl	8010f20 <HAL_RCC_OscConfig+0x78c>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80107fc:	687b      	ldr	r3, [r7, #4]
 80107fe:	685a      	ldr	r2, [r3, #4]
 8010800:	2380      	movs	r3, #128	; 0x80
 8010802:	025b      	lsls	r3, r3, #9
 8010804:	429a      	cmp	r2, r3
 8010806:	d107      	bne.n	8010818 <HAL_RCC_OscConfig+0x84>
 8010808:	4bb0      	ldr	r3, [pc, #704]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 801080a:	681a      	ldr	r2, [r3, #0]
 801080c:	4baf      	ldr	r3, [pc, #700]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 801080e:	2180      	movs	r1, #128	; 0x80
 8010810:	0249      	lsls	r1, r1, #9
 8010812:	430a      	orrs	r2, r1
 8010814:	601a      	str	r2, [r3, #0]
 8010816:	e027      	b.n	8010868 <HAL_RCC_OscConfig+0xd4>
 8010818:	687b      	ldr	r3, [r7, #4]
 801081a:	685a      	ldr	r2, [r3, #4]
 801081c:	23a0      	movs	r3, #160	; 0xa0
 801081e:	02db      	lsls	r3, r3, #11
 8010820:	429a      	cmp	r2, r3
 8010822:	d10e      	bne.n	8010842 <HAL_RCC_OscConfig+0xae>
 8010824:	4ba9      	ldr	r3, [pc, #676]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 8010826:	681a      	ldr	r2, [r3, #0]
 8010828:	4ba8      	ldr	r3, [pc, #672]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 801082a:	2180      	movs	r1, #128	; 0x80
 801082c:	02c9      	lsls	r1, r1, #11
 801082e:	430a      	orrs	r2, r1
 8010830:	601a      	str	r2, [r3, #0]
 8010832:	4ba6      	ldr	r3, [pc, #664]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 8010834:	681a      	ldr	r2, [r3, #0]
 8010836:	4ba5      	ldr	r3, [pc, #660]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 8010838:	2180      	movs	r1, #128	; 0x80
 801083a:	0249      	lsls	r1, r1, #9
 801083c:	430a      	orrs	r2, r1
 801083e:	601a      	str	r2, [r3, #0]
 8010840:	e012      	b.n	8010868 <HAL_RCC_OscConfig+0xd4>
 8010842:	4ba2      	ldr	r3, [pc, #648]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 8010844:	681a      	ldr	r2, [r3, #0]
 8010846:	4ba1      	ldr	r3, [pc, #644]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 8010848:	49a1      	ldr	r1, [pc, #644]	; (8010ad0 <HAL_RCC_OscConfig+0x33c>)
 801084a:	400a      	ands	r2, r1
 801084c:	601a      	str	r2, [r3, #0]
 801084e:	4b9f      	ldr	r3, [pc, #636]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 8010850:	681a      	ldr	r2, [r3, #0]
 8010852:	2380      	movs	r3, #128	; 0x80
 8010854:	025b      	lsls	r3, r3, #9
 8010856:	4013      	ands	r3, r2
 8010858:	60fb      	str	r3, [r7, #12]
 801085a:	68fb      	ldr	r3, [r7, #12]
 801085c:	4b9b      	ldr	r3, [pc, #620]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 801085e:	681a      	ldr	r2, [r3, #0]
 8010860:	4b9a      	ldr	r3, [pc, #616]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 8010862:	499c      	ldr	r1, [pc, #624]	; (8010ad4 <HAL_RCC_OscConfig+0x340>)
 8010864:	400a      	ands	r2, r1
 8010866:	601a      	str	r2, [r3, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8010868:	687b      	ldr	r3, [r7, #4]
 801086a:	685b      	ldr	r3, [r3, #4]
 801086c:	2b00      	cmp	r3, #0
 801086e:	d015      	beq.n	801089c <HAL_RCC_OscConfig+0x108>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8010870:	f7fe fe36 	bl	800f4e0 <HAL_GetTick>
 8010874:	0003      	movs	r3, r0
 8010876:	617b      	str	r3, [r7, #20]

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 8010878:	e009      	b.n	801088e <HAL_RCC_OscConfig+0xfa>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 801087a:	f7fe fe31 	bl	800f4e0 <HAL_GetTick>
 801087e:	0002      	movs	r2, r0
 8010880:	697b      	ldr	r3, [r7, #20]
 8010882:	1ad3      	subs	r3, r2, r3
 8010884:	2b64      	cmp	r3, #100	; 0x64
 8010886:	d902      	bls.n	801088e <HAL_RCC_OscConfig+0xfa>
          {
            return HAL_TIMEOUT;
 8010888:	2303      	movs	r3, #3
 801088a:	f000 fb49 	bl	8010f20 <HAL_RCC_OscConfig+0x78c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 801088e:	4b8f      	ldr	r3, [pc, #572]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 8010890:	681a      	ldr	r2, [r3, #0]
 8010892:	2380      	movs	r3, #128	; 0x80
 8010894:	029b      	lsls	r3, r3, #10
 8010896:	4013      	ands	r3, r2
 8010898:	d0ef      	beq.n	801087a <HAL_RCC_OscConfig+0xe6>
 801089a:	e015      	b.n	80108c8 <HAL_RCC_OscConfig+0x134>
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 801089c:	f7fe fe20 	bl	800f4e0 <HAL_GetTick>
 80108a0:	0003      	movs	r3, r0
 80108a2:	617b      	str	r3, [r7, #20]

        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 80108a4:	e008      	b.n	80108b8 <HAL_RCC_OscConfig+0x124>
        {
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80108a6:	f7fe fe1b 	bl	800f4e0 <HAL_GetTick>
 80108aa:	0002      	movs	r2, r0
 80108ac:	697b      	ldr	r3, [r7, #20]
 80108ae:	1ad3      	subs	r3, r2, r3
 80108b0:	2b64      	cmp	r3, #100	; 0x64
 80108b2:	d901      	bls.n	80108b8 <HAL_RCC_OscConfig+0x124>
          {
            return HAL_TIMEOUT;
 80108b4:	2303      	movs	r3, #3
 80108b6:	e333      	b.n	8010f20 <HAL_RCC_OscConfig+0x78c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 80108b8:	4b84      	ldr	r3, [pc, #528]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 80108ba:	681a      	ldr	r2, [r3, #0]
 80108bc:	2380      	movs	r3, #128	; 0x80
 80108be:	029b      	lsls	r3, r3, #10
 80108c0:	4013      	ands	r3, r2
 80108c2:	d1f0      	bne.n	80108a6 <HAL_RCC_OscConfig+0x112>
 80108c4:	e000      	b.n	80108c8 <HAL_RCC_OscConfig+0x134>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80108c6:	46c0      	nop			; (mov r8, r8)
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80108c8:	687b      	ldr	r3, [r7, #4]
 80108ca:	681b      	ldr	r3, [r3, #0]
 80108cc:	2202      	movs	r2, #2
 80108ce:	4013      	ands	r3, r2
 80108d0:	d100      	bne.n	80108d4 <HAL_RCC_OscConfig+0x140>
 80108d2:	e098      	b.n	8010a06 <HAL_RCC_OscConfig+0x272>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    hsi_state = RCC_OscInitStruct->HSIState;
 80108d4:	687b      	ldr	r3, [r7, #4]
 80108d6:	68db      	ldr	r3, [r3, #12]
 80108d8:	627b      	str	r3, [r7, #36]	; 0x24

#if defined(RCC_CR_HSIOUTEN)
    if((hsi_state & RCC_HSI_OUTEN) != 0U)
 80108da:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80108dc:	2220      	movs	r2, #32
 80108de:	4013      	ands	r3, r2
 80108e0:	d009      	beq.n	80108f6 <HAL_RCC_OscConfig+0x162>
    {
      /* HSI Output enable for timer requested */
      SET_BIT(RCC->CR, RCC_CR_HSIOUTEN);
 80108e2:	4b7a      	ldr	r3, [pc, #488]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 80108e4:	681a      	ldr	r2, [r3, #0]
 80108e6:	4b79      	ldr	r3, [pc, #484]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 80108e8:	2120      	movs	r1, #32
 80108ea:	430a      	orrs	r2, r1
 80108ec:	601a      	str	r2, [r3, #0]

      hsi_state &= ~RCC_CR_HSIOUTEN;
 80108ee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80108f0:	2220      	movs	r2, #32
 80108f2:	4393      	bics	r3, r2
 80108f4:	627b      	str	r3, [r7, #36]	; 0x24
    }
#endif

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)
 80108f6:	69fb      	ldr	r3, [r7, #28]
 80108f8:	2b04      	cmp	r3, #4
 80108fa:	d005      	beq.n	8010908 <HAL_RCC_OscConfig+0x174>
       || ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSI)))
 80108fc:	69fb      	ldr	r3, [r7, #28]
 80108fe:	2b0c      	cmp	r3, #12
 8010900:	d13d      	bne.n	801097e <HAL_RCC_OscConfig+0x1ea>
 8010902:	69bb      	ldr	r3, [r7, #24]
 8010904:	2b00      	cmp	r3, #0
 8010906:	d13a      	bne.n	801097e <HAL_RCC_OscConfig+0x1ea>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (hsi_state == RCC_HSI_OFF))
 8010908:	4b70      	ldr	r3, [pc, #448]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 801090a:	681b      	ldr	r3, [r3, #0]
 801090c:	2204      	movs	r2, #4
 801090e:	4013      	ands	r3, r2
 8010910:	d004      	beq.n	801091c <HAL_RCC_OscConfig+0x188>
 8010912:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010914:	2b00      	cmp	r3, #0
 8010916:	d101      	bne.n	801091c <HAL_RCC_OscConfig+0x188>
      {
        return HAL_ERROR;
 8010918:	2301      	movs	r3, #1
 801091a:	e301      	b.n	8010f20 <HAL_RCC_OscConfig+0x78c>
      }
      /* Otherwise, just the calibration and HSI or HSIdiv4 are allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 801091c:	4b6b      	ldr	r3, [pc, #428]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 801091e:	685b      	ldr	r3, [r3, #4]
 8010920:	4a6d      	ldr	r2, [pc, #436]	; (8010ad8 <HAL_RCC_OscConfig+0x344>)
 8010922:	4013      	ands	r3, r2
 8010924:	0019      	movs	r1, r3
 8010926:	687b      	ldr	r3, [r7, #4]
 8010928:	691b      	ldr	r3, [r3, #16]
 801092a:	021a      	lsls	r2, r3, #8
 801092c:	4b67      	ldr	r3, [pc, #412]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 801092e:	430a      	orrs	r2, r1
 8010930:	605a      	str	r2, [r3, #4]

        /* Enable the Internal High Speed oscillator (HSI or HSIdiv4) */
        __HAL_RCC_HSI_CONFIG(hsi_state);
 8010932:	4b66      	ldr	r3, [pc, #408]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 8010934:	681b      	ldr	r3, [r3, #0]
 8010936:	2209      	movs	r2, #9
 8010938:	4393      	bics	r3, r2
 801093a:	0019      	movs	r1, r3
 801093c:	4b63      	ldr	r3, [pc, #396]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 801093e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8010940:	430a      	orrs	r2, r1
 8010942:	601a      	str	r2, [r3, #0]
      }

      /* Update the SystemCoreClock global variable */
      SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 8010944:	f000 fc20 	bl	8011188 <HAL_RCC_GetSysClockFreq>
 8010948:	0001      	movs	r1, r0
 801094a:	4b60      	ldr	r3, [pc, #384]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 801094c:	68db      	ldr	r3, [r3, #12]
 801094e:	091b      	lsrs	r3, r3, #4
 8010950:	220f      	movs	r2, #15
 8010952:	4013      	ands	r3, r2
 8010954:	4a61      	ldr	r2, [pc, #388]	; (8010adc <HAL_RCC_OscConfig+0x348>)
 8010956:	5cd3      	ldrb	r3, [r2, r3]
 8010958:	000a      	movs	r2, r1
 801095a:	40da      	lsrs	r2, r3
 801095c:	4b60      	ldr	r3, [pc, #384]	; (8010ae0 <HAL_RCC_OscConfig+0x34c>)
 801095e:	601a      	str	r2, [r3, #0]

      /* Configure the source of time base considering new system clocks settings*/
      status = HAL_InitTick (TICK_INT_PRIORITY);
 8010960:	2513      	movs	r5, #19
 8010962:	197c      	adds	r4, r7, r5
 8010964:	2000      	movs	r0, #0
 8010966:	f7fe fd75 	bl	800f454 <HAL_InitTick>
 801096a:	0003      	movs	r3, r0
 801096c:	7023      	strb	r3, [r4, #0]
      if(status != HAL_OK)
 801096e:	197b      	adds	r3, r7, r5
 8010970:	781b      	ldrb	r3, [r3, #0]
 8010972:	2b00      	cmp	r3, #0
 8010974:	d047      	beq.n	8010a06 <HAL_RCC_OscConfig+0x272>
      {
        return status;
 8010976:	2313      	movs	r3, #19
 8010978:	18fb      	adds	r3, r7, r3
 801097a:	781b      	ldrb	r3, [r3, #0]
 801097c:	e2d0      	b.n	8010f20 <HAL_RCC_OscConfig+0x78c>
      }
    }
    else
    {
      /* Check the HSI State */
      if(hsi_state != RCC_HSI_OFF)
 801097e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010980:	2b00      	cmp	r3, #0
 8010982:	d027      	beq.n	80109d4 <HAL_RCC_OscConfig+0x240>
      {
        /* Enable the Internal High Speed oscillator (HSI or HSIdiv4) */
        __HAL_RCC_HSI_CONFIG(hsi_state);
 8010984:	4b51      	ldr	r3, [pc, #324]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 8010986:	681b      	ldr	r3, [r3, #0]
 8010988:	2209      	movs	r2, #9
 801098a:	4393      	bics	r3, r2
 801098c:	0019      	movs	r1, r3
 801098e:	4b4f      	ldr	r3, [pc, #316]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 8010990:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8010992:	430a      	orrs	r2, r1
 8010994:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8010996:	f7fe fda3 	bl	800f4e0 <HAL_GetTick>
 801099a:	0003      	movs	r3, r0
 801099c:	617b      	str	r3, [r7, #20]

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 801099e:	e008      	b.n	80109b2 <HAL_RCC_OscConfig+0x21e>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80109a0:	f7fe fd9e 	bl	800f4e0 <HAL_GetTick>
 80109a4:	0002      	movs	r2, r0
 80109a6:	697b      	ldr	r3, [r7, #20]
 80109a8:	1ad3      	subs	r3, r2, r3
 80109aa:	2b02      	cmp	r3, #2
 80109ac:	d901      	bls.n	80109b2 <HAL_RCC_OscConfig+0x21e>
          {
            return HAL_TIMEOUT;
 80109ae:	2303      	movs	r3, #3
 80109b0:	e2b6      	b.n	8010f20 <HAL_RCC_OscConfig+0x78c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 80109b2:	4b46      	ldr	r3, [pc, #280]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 80109b4:	681b      	ldr	r3, [r3, #0]
 80109b6:	2204      	movs	r2, #4
 80109b8:	4013      	ands	r3, r2
 80109ba:	d0f1      	beq.n	80109a0 <HAL_RCC_OscConfig+0x20c>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80109bc:	4b43      	ldr	r3, [pc, #268]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 80109be:	685b      	ldr	r3, [r3, #4]
 80109c0:	4a45      	ldr	r2, [pc, #276]	; (8010ad8 <HAL_RCC_OscConfig+0x344>)
 80109c2:	4013      	ands	r3, r2
 80109c4:	0019      	movs	r1, r3
 80109c6:	687b      	ldr	r3, [r7, #4]
 80109c8:	691b      	ldr	r3, [r3, #16]
 80109ca:	021a      	lsls	r2, r3, #8
 80109cc:	4b3f      	ldr	r3, [pc, #252]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 80109ce:	430a      	orrs	r2, r1
 80109d0:	605a      	str	r2, [r3, #4]
 80109d2:	e018      	b.n	8010a06 <HAL_RCC_OscConfig+0x272>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 80109d4:	4b3d      	ldr	r3, [pc, #244]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 80109d6:	681a      	ldr	r2, [r3, #0]
 80109d8:	4b3c      	ldr	r3, [pc, #240]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 80109da:	2101      	movs	r1, #1
 80109dc:	438a      	bics	r2, r1
 80109de:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80109e0:	f7fe fd7e 	bl	800f4e0 <HAL_GetTick>
 80109e4:	0003      	movs	r3, r0
 80109e6:	617b      	str	r3, [r7, #20]

        /* Wait till HSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 80109e8:	e008      	b.n	80109fc <HAL_RCC_OscConfig+0x268>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80109ea:	f7fe fd79 	bl	800f4e0 <HAL_GetTick>
 80109ee:	0002      	movs	r2, r0
 80109f0:	697b      	ldr	r3, [r7, #20]
 80109f2:	1ad3      	subs	r3, r2, r3
 80109f4:	2b02      	cmp	r3, #2
 80109f6:	d901      	bls.n	80109fc <HAL_RCC_OscConfig+0x268>
          {
            return HAL_TIMEOUT;
 80109f8:	2303      	movs	r3, #3
 80109fa:	e291      	b.n	8010f20 <HAL_RCC_OscConfig+0x78c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 80109fc:	4b33      	ldr	r3, [pc, #204]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 80109fe:	681b      	ldr	r3, [r3, #0]
 8010a00:	2204      	movs	r2, #4
 8010a02:	4013      	ands	r3, r2
 8010a04:	d1f1      	bne.n	80109ea <HAL_RCC_OscConfig+0x256>
        }
      }
    }
  }
  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8010a06:	687b      	ldr	r3, [r7, #4]
 8010a08:	681b      	ldr	r3, [r3, #0]
 8010a0a:	2210      	movs	r2, #16
 8010a0c:	4013      	ands	r3, r2
 8010a0e:	d100      	bne.n	8010a12 <HAL_RCC_OscConfig+0x27e>
 8010a10:	e09f      	b.n	8010b52 <HAL_RCC_OscConfig+0x3be>
  {
    /* When the MSI is used as system clock it will not be disabled */
    if((sysclk_source == RCC_CFGR_SWS_MSI) )
 8010a12:	69fb      	ldr	r3, [r7, #28]
 8010a14:	2b00      	cmp	r3, #0
 8010a16:	d13f      	bne.n	8010a98 <HAL_RCC_OscConfig+0x304>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 8010a18:	4b2c      	ldr	r3, [pc, #176]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 8010a1a:	681a      	ldr	r2, [r3, #0]
 8010a1c:	2380      	movs	r3, #128	; 0x80
 8010a1e:	009b      	lsls	r3, r3, #2
 8010a20:	4013      	ands	r3, r2
 8010a22:	d005      	beq.n	8010a30 <HAL_RCC_OscConfig+0x29c>
 8010a24:	687b      	ldr	r3, [r7, #4]
 8010a26:	69db      	ldr	r3, [r3, #28]
 8010a28:	2b00      	cmp	r3, #0
 8010a2a:	d101      	bne.n	8010a30 <HAL_RCC_OscConfig+0x29c>
      {
        return HAL_ERROR;
 8010a2c:	2301      	movs	r3, #1
 8010a2e:	e277      	b.n	8010f20 <HAL_RCC_OscConfig+0x78c>
        /* Check MSICalibrationValue and MSIClockRange input parameters */
        assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
        assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

        /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8010a30:	4b26      	ldr	r3, [pc, #152]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 8010a32:	685b      	ldr	r3, [r3, #4]
 8010a34:	4a2b      	ldr	r2, [pc, #172]	; (8010ae4 <HAL_RCC_OscConfig+0x350>)
 8010a36:	4013      	ands	r3, r2
 8010a38:	0019      	movs	r1, r3
 8010a3a:	687b      	ldr	r3, [r7, #4]
 8010a3c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8010a3e:	4b23      	ldr	r3, [pc, #140]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 8010a40:	430a      	orrs	r2, r1
 8010a42:	605a      	str	r2, [r3, #4]
        /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8010a44:	4b21      	ldr	r3, [pc, #132]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 8010a46:	685b      	ldr	r3, [r3, #4]
 8010a48:	021b      	lsls	r3, r3, #8
 8010a4a:	0a19      	lsrs	r1, r3, #8
 8010a4c:	687b      	ldr	r3, [r7, #4]
 8010a4e:	6a1b      	ldr	r3, [r3, #32]
 8010a50:	061a      	lsls	r2, r3, #24
 8010a52:	4b1e      	ldr	r3, [pc, #120]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 8010a54:	430a      	orrs	r2, r1
 8010a56:	605a      	str	r2, [r3, #4]


        /* Update the SystemCoreClock global variable */
        SystemCoreClock =  (32768U * (1UL << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_Pos) + 1U)))
 8010a58:	687b      	ldr	r3, [r7, #4]
 8010a5a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010a5c:	0b5b      	lsrs	r3, r3, #13
 8010a5e:	3301      	adds	r3, #1
 8010a60:	2280      	movs	r2, #128	; 0x80
 8010a62:	0212      	lsls	r2, r2, #8
 8010a64:	409a      	lsls	r2, r3
                           >> AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos)];
 8010a66:	4b19      	ldr	r3, [pc, #100]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 8010a68:	68db      	ldr	r3, [r3, #12]
 8010a6a:	091b      	lsrs	r3, r3, #4
 8010a6c:	210f      	movs	r1, #15
 8010a6e:	400b      	ands	r3, r1
 8010a70:	491a      	ldr	r1, [pc, #104]	; (8010adc <HAL_RCC_OscConfig+0x348>)
 8010a72:	5ccb      	ldrb	r3, [r1, r3]
 8010a74:	40da      	lsrs	r2, r3
        SystemCoreClock =  (32768U * (1UL << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_Pos) + 1U)))
 8010a76:	4b1a      	ldr	r3, [pc, #104]	; (8010ae0 <HAL_RCC_OscConfig+0x34c>)
 8010a78:	601a      	str	r2, [r3, #0]

        /* Configure the source of time base considering new system clocks settings*/
        status = HAL_InitTick (TICK_INT_PRIORITY);
 8010a7a:	2513      	movs	r5, #19
 8010a7c:	197c      	adds	r4, r7, r5
 8010a7e:	2000      	movs	r0, #0
 8010a80:	f7fe fce8 	bl	800f454 <HAL_InitTick>
 8010a84:	0003      	movs	r3, r0
 8010a86:	7023      	strb	r3, [r4, #0]
        if(status != HAL_OK)
 8010a88:	197b      	adds	r3, r7, r5
 8010a8a:	781b      	ldrb	r3, [r3, #0]
 8010a8c:	2b00      	cmp	r3, #0
 8010a8e:	d060      	beq.n	8010b52 <HAL_RCC_OscConfig+0x3be>
        {
          return status;
 8010a90:	2313      	movs	r3, #19
 8010a92:	18fb      	adds	r3, r7, r3
 8010a94:	781b      	ldrb	r3, [r3, #0]
 8010a96:	e243      	b.n	8010f20 <HAL_RCC_OscConfig+0x78c>
    {
      /* Check MSI State */
      assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));

      /* Check the MSI State */
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 8010a98:	687b      	ldr	r3, [r7, #4]
 8010a9a:	69db      	ldr	r3, [r3, #28]
 8010a9c:	2b00      	cmp	r3, #0
 8010a9e:	d03e      	beq.n	8010b1e <HAL_RCC_OscConfig+0x38a>
      {
        /* Enable the Multi Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
 8010aa0:	4b0a      	ldr	r3, [pc, #40]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 8010aa2:	681a      	ldr	r2, [r3, #0]
 8010aa4:	4b09      	ldr	r3, [pc, #36]	; (8010acc <HAL_RCC_OscConfig+0x338>)
 8010aa6:	2180      	movs	r1, #128	; 0x80
 8010aa8:	0049      	lsls	r1, r1, #1
 8010aaa:	430a      	orrs	r2, r1
 8010aac:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8010aae:	f7fe fd17 	bl	800f4e0 <HAL_GetTick>
 8010ab2:	0003      	movs	r3, r0
 8010ab4:	617b      	str	r3, [r7, #20]

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == 0U)
 8010ab6:	e017      	b.n	8010ae8 <HAL_RCC_OscConfig+0x354>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8010ab8:	f7fe fd12 	bl	800f4e0 <HAL_GetTick>
 8010abc:	0002      	movs	r2, r0
 8010abe:	697b      	ldr	r3, [r7, #20]
 8010ac0:	1ad3      	subs	r3, r2, r3
 8010ac2:	2b02      	cmp	r3, #2
 8010ac4:	d910      	bls.n	8010ae8 <HAL_RCC_OscConfig+0x354>
          {
            return HAL_TIMEOUT;
 8010ac6:	2303      	movs	r3, #3
 8010ac8:	e22a      	b.n	8010f20 <HAL_RCC_OscConfig+0x78c>
 8010aca:	46c0      	nop			; (mov r8, r8)
 8010acc:	40021000 	.word	0x40021000
 8010ad0:	fffeffff 	.word	0xfffeffff
 8010ad4:	fffbffff 	.word	0xfffbffff
 8010ad8:	ffffe0ff 	.word	0xffffe0ff
 8010adc:	08014eb8 	.word	0x08014eb8
 8010ae0:	200000d8 	.word	0x200000d8
 8010ae4:	ffff1fff 	.word	0xffff1fff
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == 0U)
 8010ae8:	4bc6      	ldr	r3, [pc, #792]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010aea:	681a      	ldr	r2, [r3, #0]
 8010aec:	2380      	movs	r3, #128	; 0x80
 8010aee:	009b      	lsls	r3, r3, #2
 8010af0:	4013      	ands	r3, r2
 8010af2:	d0e1      	beq.n	8010ab8 <HAL_RCC_OscConfig+0x324>
        /* Check MSICalibrationValue and MSIClockRange input parameters */
        assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
        assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

        /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8010af4:	4bc3      	ldr	r3, [pc, #780]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010af6:	685b      	ldr	r3, [r3, #4]
 8010af8:	4ac3      	ldr	r2, [pc, #780]	; (8010e08 <HAL_RCC_OscConfig+0x674>)
 8010afa:	4013      	ands	r3, r2
 8010afc:	0019      	movs	r1, r3
 8010afe:	687b      	ldr	r3, [r7, #4]
 8010b00:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8010b02:	4bc0      	ldr	r3, [pc, #768]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010b04:	430a      	orrs	r2, r1
 8010b06:	605a      	str	r2, [r3, #4]
         /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8010b08:	4bbe      	ldr	r3, [pc, #760]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010b0a:	685b      	ldr	r3, [r3, #4]
 8010b0c:	021b      	lsls	r3, r3, #8
 8010b0e:	0a19      	lsrs	r1, r3, #8
 8010b10:	687b      	ldr	r3, [r7, #4]
 8010b12:	6a1b      	ldr	r3, [r3, #32]
 8010b14:	061a      	lsls	r2, r3, #24
 8010b16:	4bbb      	ldr	r3, [pc, #748]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010b18:	430a      	orrs	r2, r1
 8010b1a:	605a      	str	r2, [r3, #4]
 8010b1c:	e019      	b.n	8010b52 <HAL_RCC_OscConfig+0x3be>
      }
      else
      {
        /* Disable the Multi Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
 8010b1e:	4bb9      	ldr	r3, [pc, #740]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010b20:	681a      	ldr	r2, [r3, #0]
 8010b22:	4bb8      	ldr	r3, [pc, #736]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010b24:	49b9      	ldr	r1, [pc, #740]	; (8010e0c <HAL_RCC_OscConfig+0x678>)
 8010b26:	400a      	ands	r2, r1
 8010b28:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8010b2a:	f7fe fcd9 	bl	800f4e0 <HAL_GetTick>
 8010b2e:	0003      	movs	r3, r0
 8010b30:	617b      	str	r3, [r7, #20]

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != 0U)
 8010b32:	e008      	b.n	8010b46 <HAL_RCC_OscConfig+0x3b2>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8010b34:	f7fe fcd4 	bl	800f4e0 <HAL_GetTick>
 8010b38:	0002      	movs	r2, r0
 8010b3a:	697b      	ldr	r3, [r7, #20]
 8010b3c:	1ad3      	subs	r3, r2, r3
 8010b3e:	2b02      	cmp	r3, #2
 8010b40:	d901      	bls.n	8010b46 <HAL_RCC_OscConfig+0x3b2>
          {
            return HAL_TIMEOUT;
 8010b42:	2303      	movs	r3, #3
 8010b44:	e1ec      	b.n	8010f20 <HAL_RCC_OscConfig+0x78c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != 0U)
 8010b46:	4baf      	ldr	r3, [pc, #700]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010b48:	681a      	ldr	r2, [r3, #0]
 8010b4a:	2380      	movs	r3, #128	; 0x80
 8010b4c:	009b      	lsls	r3, r3, #2
 8010b4e:	4013      	ands	r3, r2
 8010b50:	d1f0      	bne.n	8010b34 <HAL_RCC_OscConfig+0x3a0>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8010b52:	687b      	ldr	r3, [r7, #4]
 8010b54:	681b      	ldr	r3, [r3, #0]
 8010b56:	2208      	movs	r2, #8
 8010b58:	4013      	ands	r3, r2
 8010b5a:	d036      	beq.n	8010bca <HAL_RCC_OscConfig+0x436>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8010b5c:	687b      	ldr	r3, [r7, #4]
 8010b5e:	695b      	ldr	r3, [r3, #20]
 8010b60:	2b00      	cmp	r3, #0
 8010b62:	d019      	beq.n	8010b98 <HAL_RCC_OscConfig+0x404>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8010b64:	4ba7      	ldr	r3, [pc, #668]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010b66:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8010b68:	4ba6      	ldr	r3, [pc, #664]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010b6a:	2101      	movs	r1, #1
 8010b6c:	430a      	orrs	r2, r1
 8010b6e:	651a      	str	r2, [r3, #80]	; 0x50

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8010b70:	f7fe fcb6 	bl	800f4e0 <HAL_GetTick>
 8010b74:	0003      	movs	r3, r0
 8010b76:	617b      	str	r3, [r7, #20]

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 8010b78:	e008      	b.n	8010b8c <HAL_RCC_OscConfig+0x3f8>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8010b7a:	f7fe fcb1 	bl	800f4e0 <HAL_GetTick>
 8010b7e:	0002      	movs	r2, r0
 8010b80:	697b      	ldr	r3, [r7, #20]
 8010b82:	1ad3      	subs	r3, r2, r3
 8010b84:	2b02      	cmp	r3, #2
 8010b86:	d901      	bls.n	8010b8c <HAL_RCC_OscConfig+0x3f8>
        {
          return HAL_TIMEOUT;
 8010b88:	2303      	movs	r3, #3
 8010b8a:	e1c9      	b.n	8010f20 <HAL_RCC_OscConfig+0x78c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 8010b8c:	4b9d      	ldr	r3, [pc, #628]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010b8e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8010b90:	2202      	movs	r2, #2
 8010b92:	4013      	ands	r3, r2
 8010b94:	d0f1      	beq.n	8010b7a <HAL_RCC_OscConfig+0x3e6>
 8010b96:	e018      	b.n	8010bca <HAL_RCC_OscConfig+0x436>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8010b98:	4b9a      	ldr	r3, [pc, #616]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010b9a:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8010b9c:	4b99      	ldr	r3, [pc, #612]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010b9e:	2101      	movs	r1, #1
 8010ba0:	438a      	bics	r2, r1
 8010ba2:	651a      	str	r2, [r3, #80]	; 0x50

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8010ba4:	f7fe fc9c 	bl	800f4e0 <HAL_GetTick>
 8010ba8:	0003      	movs	r3, r0
 8010baa:	617b      	str	r3, [r7, #20]

      /* Wait till LSI is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 8010bac:	e008      	b.n	8010bc0 <HAL_RCC_OscConfig+0x42c>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8010bae:	f7fe fc97 	bl	800f4e0 <HAL_GetTick>
 8010bb2:	0002      	movs	r2, r0
 8010bb4:	697b      	ldr	r3, [r7, #20]
 8010bb6:	1ad3      	subs	r3, r2, r3
 8010bb8:	2b02      	cmp	r3, #2
 8010bba:	d901      	bls.n	8010bc0 <HAL_RCC_OscConfig+0x42c>
        {
          return HAL_TIMEOUT;
 8010bbc:	2303      	movs	r3, #3
 8010bbe:	e1af      	b.n	8010f20 <HAL_RCC_OscConfig+0x78c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 8010bc0:	4b90      	ldr	r3, [pc, #576]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010bc2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8010bc4:	2202      	movs	r2, #2
 8010bc6:	4013      	ands	r3, r2
 8010bc8:	d1f1      	bne.n	8010bae <HAL_RCC_OscConfig+0x41a>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8010bca:	687b      	ldr	r3, [r7, #4]
 8010bcc:	681b      	ldr	r3, [r3, #0]
 8010bce:	2204      	movs	r2, #4
 8010bd0:	4013      	ands	r3, r2
 8010bd2:	d100      	bne.n	8010bd6 <HAL_RCC_OscConfig+0x442>
 8010bd4:	e0af      	b.n	8010d36 <HAL_RCC_OscConfig+0x5a2>
  {
    FlagStatus       pwrclkchanged = RESET;
 8010bd6:	2323      	movs	r3, #35	; 0x23
 8010bd8:	18fb      	adds	r3, r7, r3
 8010bda:	2200      	movs	r2, #0
 8010bdc:	701a      	strb	r2, [r3, #0]
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8010bde:	4b89      	ldr	r3, [pc, #548]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010be0:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8010be2:	2380      	movs	r3, #128	; 0x80
 8010be4:	055b      	lsls	r3, r3, #21
 8010be6:	4013      	ands	r3, r2
 8010be8:	d10a      	bne.n	8010c00 <HAL_RCC_OscConfig+0x46c>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8010bea:	4b86      	ldr	r3, [pc, #536]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010bec:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8010bee:	4b85      	ldr	r3, [pc, #532]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010bf0:	2180      	movs	r1, #128	; 0x80
 8010bf2:	0549      	lsls	r1, r1, #21
 8010bf4:	430a      	orrs	r2, r1
 8010bf6:	639a      	str	r2, [r3, #56]	; 0x38
      pwrclkchanged = SET;
 8010bf8:	2323      	movs	r3, #35	; 0x23
 8010bfa:	18fb      	adds	r3, r7, r3
 8010bfc:	2201      	movs	r2, #1
 8010bfe:	701a      	strb	r2, [r3, #0]
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8010c00:	4b83      	ldr	r3, [pc, #524]	; (8010e10 <HAL_RCC_OscConfig+0x67c>)
 8010c02:	681a      	ldr	r2, [r3, #0]
 8010c04:	2380      	movs	r3, #128	; 0x80
 8010c06:	005b      	lsls	r3, r3, #1
 8010c08:	4013      	ands	r3, r2
 8010c0a:	d11a      	bne.n	8010c42 <HAL_RCC_OscConfig+0x4ae>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8010c0c:	4b80      	ldr	r3, [pc, #512]	; (8010e10 <HAL_RCC_OscConfig+0x67c>)
 8010c0e:	681a      	ldr	r2, [r3, #0]
 8010c10:	4b7f      	ldr	r3, [pc, #508]	; (8010e10 <HAL_RCC_OscConfig+0x67c>)
 8010c12:	2180      	movs	r1, #128	; 0x80
 8010c14:	0049      	lsls	r1, r1, #1
 8010c16:	430a      	orrs	r2, r1
 8010c18:	601a      	str	r2, [r3, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8010c1a:	f7fe fc61 	bl	800f4e0 <HAL_GetTick>
 8010c1e:	0003      	movs	r3, r0
 8010c20:	617b      	str	r3, [r7, #20]

      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8010c22:	e008      	b.n	8010c36 <HAL_RCC_OscConfig+0x4a2>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8010c24:	f7fe fc5c 	bl	800f4e0 <HAL_GetTick>
 8010c28:	0002      	movs	r2, r0
 8010c2a:	697b      	ldr	r3, [r7, #20]
 8010c2c:	1ad3      	subs	r3, r2, r3
 8010c2e:	2b64      	cmp	r3, #100	; 0x64
 8010c30:	d901      	bls.n	8010c36 <HAL_RCC_OscConfig+0x4a2>
        {
          return HAL_TIMEOUT;
 8010c32:	2303      	movs	r3, #3
 8010c34:	e174      	b.n	8010f20 <HAL_RCC_OscConfig+0x78c>
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8010c36:	4b76      	ldr	r3, [pc, #472]	; (8010e10 <HAL_RCC_OscConfig+0x67c>)
 8010c38:	681a      	ldr	r2, [r3, #0]
 8010c3a:	2380      	movs	r3, #128	; 0x80
 8010c3c:	005b      	lsls	r3, r3, #1
 8010c3e:	4013      	ands	r3, r2
 8010c40:	d0f0      	beq.n	8010c24 <HAL_RCC_OscConfig+0x490>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8010c42:	687b      	ldr	r3, [r7, #4]
 8010c44:	689a      	ldr	r2, [r3, #8]
 8010c46:	2380      	movs	r3, #128	; 0x80
 8010c48:	005b      	lsls	r3, r3, #1
 8010c4a:	429a      	cmp	r2, r3
 8010c4c:	d107      	bne.n	8010c5e <HAL_RCC_OscConfig+0x4ca>
 8010c4e:	4b6d      	ldr	r3, [pc, #436]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010c50:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8010c52:	4b6c      	ldr	r3, [pc, #432]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010c54:	2180      	movs	r1, #128	; 0x80
 8010c56:	0049      	lsls	r1, r1, #1
 8010c58:	430a      	orrs	r2, r1
 8010c5a:	651a      	str	r2, [r3, #80]	; 0x50
 8010c5c:	e031      	b.n	8010cc2 <HAL_RCC_OscConfig+0x52e>
 8010c5e:	687b      	ldr	r3, [r7, #4]
 8010c60:	689b      	ldr	r3, [r3, #8]
 8010c62:	2b00      	cmp	r3, #0
 8010c64:	d10c      	bne.n	8010c80 <HAL_RCC_OscConfig+0x4ec>
 8010c66:	4b67      	ldr	r3, [pc, #412]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010c68:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8010c6a:	4b66      	ldr	r3, [pc, #408]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010c6c:	4967      	ldr	r1, [pc, #412]	; (8010e0c <HAL_RCC_OscConfig+0x678>)
 8010c6e:	400a      	ands	r2, r1
 8010c70:	651a      	str	r2, [r3, #80]	; 0x50
 8010c72:	4b64      	ldr	r3, [pc, #400]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010c74:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8010c76:	4b63      	ldr	r3, [pc, #396]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010c78:	4966      	ldr	r1, [pc, #408]	; (8010e14 <HAL_RCC_OscConfig+0x680>)
 8010c7a:	400a      	ands	r2, r1
 8010c7c:	651a      	str	r2, [r3, #80]	; 0x50
 8010c7e:	e020      	b.n	8010cc2 <HAL_RCC_OscConfig+0x52e>
 8010c80:	687b      	ldr	r3, [r7, #4]
 8010c82:	689a      	ldr	r2, [r3, #8]
 8010c84:	23a0      	movs	r3, #160	; 0xa0
 8010c86:	00db      	lsls	r3, r3, #3
 8010c88:	429a      	cmp	r2, r3
 8010c8a:	d10e      	bne.n	8010caa <HAL_RCC_OscConfig+0x516>
 8010c8c:	4b5d      	ldr	r3, [pc, #372]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010c8e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8010c90:	4b5c      	ldr	r3, [pc, #368]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010c92:	2180      	movs	r1, #128	; 0x80
 8010c94:	00c9      	lsls	r1, r1, #3
 8010c96:	430a      	orrs	r2, r1
 8010c98:	651a      	str	r2, [r3, #80]	; 0x50
 8010c9a:	4b5a      	ldr	r3, [pc, #360]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010c9c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8010c9e:	4b59      	ldr	r3, [pc, #356]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010ca0:	2180      	movs	r1, #128	; 0x80
 8010ca2:	0049      	lsls	r1, r1, #1
 8010ca4:	430a      	orrs	r2, r1
 8010ca6:	651a      	str	r2, [r3, #80]	; 0x50
 8010ca8:	e00b      	b.n	8010cc2 <HAL_RCC_OscConfig+0x52e>
 8010caa:	4b56      	ldr	r3, [pc, #344]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010cac:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8010cae:	4b55      	ldr	r3, [pc, #340]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010cb0:	4956      	ldr	r1, [pc, #344]	; (8010e0c <HAL_RCC_OscConfig+0x678>)
 8010cb2:	400a      	ands	r2, r1
 8010cb4:	651a      	str	r2, [r3, #80]	; 0x50
 8010cb6:	4b53      	ldr	r3, [pc, #332]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010cb8:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8010cba:	4b52      	ldr	r3, [pc, #328]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010cbc:	4955      	ldr	r1, [pc, #340]	; (8010e14 <HAL_RCC_OscConfig+0x680>)
 8010cbe:	400a      	ands	r2, r1
 8010cc0:	651a      	str	r2, [r3, #80]	; 0x50
    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8010cc2:	687b      	ldr	r3, [r7, #4]
 8010cc4:	689b      	ldr	r3, [r3, #8]
 8010cc6:	2b00      	cmp	r3, #0
 8010cc8:	d015      	beq.n	8010cf6 <HAL_RCC_OscConfig+0x562>
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8010cca:	f7fe fc09 	bl	800f4e0 <HAL_GetTick>
 8010cce:	0003      	movs	r3, r0
 8010cd0:	617b      	str	r3, [r7, #20]

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8010cd2:	e009      	b.n	8010ce8 <HAL_RCC_OscConfig+0x554>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8010cd4:	f7fe fc04 	bl	800f4e0 <HAL_GetTick>
 8010cd8:	0002      	movs	r2, r0
 8010cda:	697b      	ldr	r3, [r7, #20]
 8010cdc:	1ad3      	subs	r3, r2, r3
 8010cde:	4a4e      	ldr	r2, [pc, #312]	; (8010e18 <HAL_RCC_OscConfig+0x684>)
 8010ce0:	4293      	cmp	r3, r2
 8010ce2:	d901      	bls.n	8010ce8 <HAL_RCC_OscConfig+0x554>
        {
          return HAL_TIMEOUT;
 8010ce4:	2303      	movs	r3, #3
 8010ce6:	e11b      	b.n	8010f20 <HAL_RCC_OscConfig+0x78c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8010ce8:	4b46      	ldr	r3, [pc, #280]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010cea:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8010cec:	2380      	movs	r3, #128	; 0x80
 8010cee:	009b      	lsls	r3, r3, #2
 8010cf0:	4013      	ands	r3, r2
 8010cf2:	d0ef      	beq.n	8010cd4 <HAL_RCC_OscConfig+0x540>
 8010cf4:	e014      	b.n	8010d20 <HAL_RCC_OscConfig+0x58c>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8010cf6:	f7fe fbf3 	bl	800f4e0 <HAL_GetTick>
 8010cfa:	0003      	movs	r3, r0
 8010cfc:	617b      	str	r3, [r7, #20]

      /* Wait till LSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 8010cfe:	e009      	b.n	8010d14 <HAL_RCC_OscConfig+0x580>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8010d00:	f7fe fbee 	bl	800f4e0 <HAL_GetTick>
 8010d04:	0002      	movs	r2, r0
 8010d06:	697b      	ldr	r3, [r7, #20]
 8010d08:	1ad3      	subs	r3, r2, r3
 8010d0a:	4a43      	ldr	r2, [pc, #268]	; (8010e18 <HAL_RCC_OscConfig+0x684>)
 8010d0c:	4293      	cmp	r3, r2
 8010d0e:	d901      	bls.n	8010d14 <HAL_RCC_OscConfig+0x580>
        {
          return HAL_TIMEOUT;
 8010d10:	2303      	movs	r3, #3
 8010d12:	e105      	b.n	8010f20 <HAL_RCC_OscConfig+0x78c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 8010d14:	4b3b      	ldr	r3, [pc, #236]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010d16:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8010d18:	2380      	movs	r3, #128	; 0x80
 8010d1a:	009b      	lsls	r3, r3, #2
 8010d1c:	4013      	ands	r3, r2
 8010d1e:	d1ef      	bne.n	8010d00 <HAL_RCC_OscConfig+0x56c>
        }
      }
    }

    /* Require to disable power clock if necessary */
    if(pwrclkchanged == SET)
 8010d20:	2323      	movs	r3, #35	; 0x23
 8010d22:	18fb      	adds	r3, r7, r3
 8010d24:	781b      	ldrb	r3, [r3, #0]
 8010d26:	2b01      	cmp	r3, #1
 8010d28:	d105      	bne.n	8010d36 <HAL_RCC_OscConfig+0x5a2>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8010d2a:	4b36      	ldr	r3, [pc, #216]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010d2c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8010d2e:	4b35      	ldr	r3, [pc, #212]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010d30:	493a      	ldr	r1, [pc, #232]	; (8010e1c <HAL_RCC_OscConfig+0x688>)
 8010d32:	400a      	ands	r2, r1
 8010d34:	639a      	str	r2, [r3, #56]	; 0x38
    }
  }

#if defined(RCC_HSI48_SUPPORT)
  /*----------------------------- HSI48 Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 8010d36:	687b      	ldr	r3, [r7, #4]
 8010d38:	681b      	ldr	r3, [r3, #0]
 8010d3a:	2220      	movs	r2, #32
 8010d3c:	4013      	ands	r3, r2
 8010d3e:	d049      	beq.n	8010dd4 <HAL_RCC_OscConfig+0x640>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

      /* Check the HSI48 State */
      if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 8010d40:	687b      	ldr	r3, [r7, #4]
 8010d42:	699b      	ldr	r3, [r3, #24]
 8010d44:	2b00      	cmp	r3, #0
 8010d46:	d026      	beq.n	8010d96 <HAL_RCC_OscConfig+0x602>
      {
        /* Enable the Internal High Speed oscillator (HSI48). */
        __HAL_RCC_HSI48_ENABLE();
 8010d48:	4b2e      	ldr	r3, [pc, #184]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010d4a:	689a      	ldr	r2, [r3, #8]
 8010d4c:	4b2d      	ldr	r3, [pc, #180]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010d4e:	2101      	movs	r1, #1
 8010d50:	430a      	orrs	r2, r1
 8010d52:	609a      	str	r2, [r3, #8]
 8010d54:	4b2b      	ldr	r3, [pc, #172]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010d56:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8010d58:	4b2a      	ldr	r3, [pc, #168]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010d5a:	2101      	movs	r1, #1
 8010d5c:	430a      	orrs	r2, r1
 8010d5e:	635a      	str	r2, [r3, #52]	; 0x34
 8010d60:	4b2f      	ldr	r3, [pc, #188]	; (8010e20 <HAL_RCC_OscConfig+0x68c>)
 8010d62:	6a1a      	ldr	r2, [r3, #32]
 8010d64:	4b2e      	ldr	r3, [pc, #184]	; (8010e20 <HAL_RCC_OscConfig+0x68c>)
 8010d66:	2180      	movs	r1, #128	; 0x80
 8010d68:	0189      	lsls	r1, r1, #6
 8010d6a:	430a      	orrs	r2, r1
 8010d6c:	621a      	str	r2, [r3, #32]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8010d6e:	f7fe fbb7 	bl	800f4e0 <HAL_GetTick>
 8010d72:	0003      	movs	r3, r0
 8010d74:	617b      	str	r3, [r7, #20]

        /* Wait till HSI48 is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
 8010d76:	e008      	b.n	8010d8a <HAL_RCC_OscConfig+0x5f6>
        {
          if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8010d78:	f7fe fbb2 	bl	800f4e0 <HAL_GetTick>
 8010d7c:	0002      	movs	r2, r0
 8010d7e:	697b      	ldr	r3, [r7, #20]
 8010d80:	1ad3      	subs	r3, r2, r3
 8010d82:	2b02      	cmp	r3, #2
 8010d84:	d901      	bls.n	8010d8a <HAL_RCC_OscConfig+0x5f6>
          {
            return HAL_TIMEOUT;
 8010d86:	2303      	movs	r3, #3
 8010d88:	e0ca      	b.n	8010f20 <HAL_RCC_OscConfig+0x78c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
 8010d8a:	4b1e      	ldr	r3, [pc, #120]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010d8c:	689b      	ldr	r3, [r3, #8]
 8010d8e:	2202      	movs	r2, #2
 8010d90:	4013      	ands	r3, r2
 8010d92:	d0f1      	beq.n	8010d78 <HAL_RCC_OscConfig+0x5e4>
 8010d94:	e01e      	b.n	8010dd4 <HAL_RCC_OscConfig+0x640>
        }
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI48). */
        __HAL_RCC_HSI48_DISABLE();
 8010d96:	4b1b      	ldr	r3, [pc, #108]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010d98:	689a      	ldr	r2, [r3, #8]
 8010d9a:	4b1a      	ldr	r3, [pc, #104]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010d9c:	2101      	movs	r1, #1
 8010d9e:	438a      	bics	r2, r1
 8010da0:	609a      	str	r2, [r3, #8]
 8010da2:	4b1f      	ldr	r3, [pc, #124]	; (8010e20 <HAL_RCC_OscConfig+0x68c>)
 8010da4:	6a1a      	ldr	r2, [r3, #32]
 8010da6:	4b1e      	ldr	r3, [pc, #120]	; (8010e20 <HAL_RCC_OscConfig+0x68c>)
 8010da8:	491e      	ldr	r1, [pc, #120]	; (8010e24 <HAL_RCC_OscConfig+0x690>)
 8010daa:	400a      	ands	r2, r1
 8010dac:	621a      	str	r2, [r3, #32]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8010dae:	f7fe fb97 	bl	800f4e0 <HAL_GetTick>
 8010db2:	0003      	movs	r3, r0
 8010db4:	617b      	str	r3, [r7, #20]

        /* Wait till HSI48 is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
 8010db6:	e008      	b.n	8010dca <HAL_RCC_OscConfig+0x636>
        {
          if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8010db8:	f7fe fb92 	bl	800f4e0 <HAL_GetTick>
 8010dbc:	0002      	movs	r2, r0
 8010dbe:	697b      	ldr	r3, [r7, #20]
 8010dc0:	1ad3      	subs	r3, r2, r3
 8010dc2:	2b02      	cmp	r3, #2
 8010dc4:	d901      	bls.n	8010dca <HAL_RCC_OscConfig+0x636>
          {
            return HAL_TIMEOUT;
 8010dc6:	2303      	movs	r3, #3
 8010dc8:	e0aa      	b.n	8010f20 <HAL_RCC_OscConfig+0x78c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
 8010dca:	4b0e      	ldr	r3, [pc, #56]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010dcc:	689b      	ldr	r3, [r3, #8]
 8010dce:	2202      	movs	r2, #2
 8010dd0:	4013      	ands	r3, r2
 8010dd2:	d1f1      	bne.n	8010db8 <HAL_RCC_OscConfig+0x624>
#endif /* RCC_HSI48_SUPPORT */

  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8010dd4:	687b      	ldr	r3, [r7, #4]
 8010dd6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8010dd8:	2b00      	cmp	r3, #0
 8010dda:	d100      	bne.n	8010dde <HAL_RCC_OscConfig+0x64a>
 8010ddc:	e09f      	b.n	8010f1e <HAL_RCC_OscConfig+0x78a>
  {
    /* Check if the PLL is used as system clock or not */
    if(sysclk_source != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8010dde:	69fb      	ldr	r3, [r7, #28]
 8010de0:	2b0c      	cmp	r3, #12
 8010de2:	d100      	bne.n	8010de6 <HAL_RCC_OscConfig+0x652>
 8010de4:	e078      	b.n	8010ed8 <HAL_RCC_OscConfig+0x744>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8010de6:	687b      	ldr	r3, [r7, #4]
 8010de8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8010dea:	2b02      	cmp	r3, #2
 8010dec:	d159      	bne.n	8010ea2 <HAL_RCC_OscConfig+0x70e>
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
        assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
        assert_param(IS_RCC_PLL_DIV(RCC_OscInitStruct->PLL.PLLDIV));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8010dee:	4b05      	ldr	r3, [pc, #20]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010df0:	681a      	ldr	r2, [r3, #0]
 8010df2:	4b04      	ldr	r3, [pc, #16]	; (8010e04 <HAL_RCC_OscConfig+0x670>)
 8010df4:	490c      	ldr	r1, [pc, #48]	; (8010e28 <HAL_RCC_OscConfig+0x694>)
 8010df6:	400a      	ands	r2, r1
 8010df8:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8010dfa:	f7fe fb71 	bl	800f4e0 <HAL_GetTick>
 8010dfe:	0003      	movs	r3, r0
 8010e00:	617b      	str	r3, [r7, #20]

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
 8010e02:	e01c      	b.n	8010e3e <HAL_RCC_OscConfig+0x6aa>
 8010e04:	40021000 	.word	0x40021000
 8010e08:	ffff1fff 	.word	0xffff1fff
 8010e0c:	fffffeff 	.word	0xfffffeff
 8010e10:	40007000 	.word	0x40007000
 8010e14:	fffffbff 	.word	0xfffffbff
 8010e18:	00001388 	.word	0x00001388
 8010e1c:	efffffff 	.word	0xefffffff
 8010e20:	40010000 	.word	0x40010000
 8010e24:	ffffdfff 	.word	0xffffdfff
 8010e28:	feffffff 	.word	0xfeffffff
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8010e2c:	f7fe fb58 	bl	800f4e0 <HAL_GetTick>
 8010e30:	0002      	movs	r2, r0
 8010e32:	697b      	ldr	r3, [r7, #20]
 8010e34:	1ad3      	subs	r3, r2, r3
 8010e36:	2b02      	cmp	r3, #2
 8010e38:	d901      	bls.n	8010e3e <HAL_RCC_OscConfig+0x6aa>
          {
            return HAL_TIMEOUT;
 8010e3a:	2303      	movs	r3, #3
 8010e3c:	e070      	b.n	8010f20 <HAL_RCC_OscConfig+0x78c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
 8010e3e:	4b3a      	ldr	r3, [pc, #232]	; (8010f28 <HAL_RCC_OscConfig+0x794>)
 8010e40:	681a      	ldr	r2, [r3, #0]
 8010e42:	2380      	movs	r3, #128	; 0x80
 8010e44:	049b      	lsls	r3, r3, #18
 8010e46:	4013      	ands	r3, r2
 8010e48:	d1f0      	bne.n	8010e2c <HAL_RCC_OscConfig+0x698>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8010e4a:	4b37      	ldr	r3, [pc, #220]	; (8010f28 <HAL_RCC_OscConfig+0x794>)
 8010e4c:	68db      	ldr	r3, [r3, #12]
 8010e4e:	4a37      	ldr	r2, [pc, #220]	; (8010f2c <HAL_RCC_OscConfig+0x798>)
 8010e50:	4013      	ands	r3, r2
 8010e52:	0019      	movs	r1, r3
 8010e54:	687b      	ldr	r3, [r7, #4]
 8010e56:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8010e58:	687b      	ldr	r3, [r7, #4]
 8010e5a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8010e5c:	431a      	orrs	r2, r3
 8010e5e:	687b      	ldr	r3, [r7, #4]
 8010e60:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8010e62:	431a      	orrs	r2, r3
 8010e64:	4b30      	ldr	r3, [pc, #192]	; (8010f28 <HAL_RCC_OscConfig+0x794>)
 8010e66:	430a      	orrs	r2, r1
 8010e68:	60da      	str	r2, [r3, #12]
                             RCC_OscInitStruct->PLL.PLLMUL,
                             RCC_OscInitStruct->PLL.PLLDIV);
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8010e6a:	4b2f      	ldr	r3, [pc, #188]	; (8010f28 <HAL_RCC_OscConfig+0x794>)
 8010e6c:	681a      	ldr	r2, [r3, #0]
 8010e6e:	4b2e      	ldr	r3, [pc, #184]	; (8010f28 <HAL_RCC_OscConfig+0x794>)
 8010e70:	2180      	movs	r1, #128	; 0x80
 8010e72:	0449      	lsls	r1, r1, #17
 8010e74:	430a      	orrs	r2, r1
 8010e76:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8010e78:	f7fe fb32 	bl	800f4e0 <HAL_GetTick>
 8010e7c:	0003      	movs	r3, r0
 8010e7e:	617b      	str	r3, [r7, #20]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == 0U)
 8010e80:	e008      	b.n	8010e94 <HAL_RCC_OscConfig+0x700>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8010e82:	f7fe fb2d 	bl	800f4e0 <HAL_GetTick>
 8010e86:	0002      	movs	r2, r0
 8010e88:	697b      	ldr	r3, [r7, #20]
 8010e8a:	1ad3      	subs	r3, r2, r3
 8010e8c:	2b02      	cmp	r3, #2
 8010e8e:	d901      	bls.n	8010e94 <HAL_RCC_OscConfig+0x700>
          {
            return HAL_TIMEOUT;
 8010e90:	2303      	movs	r3, #3
 8010e92:	e045      	b.n	8010f20 <HAL_RCC_OscConfig+0x78c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == 0U)
 8010e94:	4b24      	ldr	r3, [pc, #144]	; (8010f28 <HAL_RCC_OscConfig+0x794>)
 8010e96:	681a      	ldr	r2, [r3, #0]
 8010e98:	2380      	movs	r3, #128	; 0x80
 8010e9a:	049b      	lsls	r3, r3, #18
 8010e9c:	4013      	ands	r3, r2
 8010e9e:	d0f0      	beq.n	8010e82 <HAL_RCC_OscConfig+0x6ee>
 8010ea0:	e03d      	b.n	8010f1e <HAL_RCC_OscConfig+0x78a>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8010ea2:	4b21      	ldr	r3, [pc, #132]	; (8010f28 <HAL_RCC_OscConfig+0x794>)
 8010ea4:	681a      	ldr	r2, [r3, #0]
 8010ea6:	4b20      	ldr	r3, [pc, #128]	; (8010f28 <HAL_RCC_OscConfig+0x794>)
 8010ea8:	4921      	ldr	r1, [pc, #132]	; (8010f30 <HAL_RCC_OscConfig+0x79c>)
 8010eaa:	400a      	ands	r2, r1
 8010eac:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8010eae:	f7fe fb17 	bl	800f4e0 <HAL_GetTick>
 8010eb2:	0003      	movs	r3, r0
 8010eb4:	617b      	str	r3, [r7, #20]

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
 8010eb6:	e008      	b.n	8010eca <HAL_RCC_OscConfig+0x736>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8010eb8:	f7fe fb12 	bl	800f4e0 <HAL_GetTick>
 8010ebc:	0002      	movs	r2, r0
 8010ebe:	697b      	ldr	r3, [r7, #20]
 8010ec0:	1ad3      	subs	r3, r2, r3
 8010ec2:	2b02      	cmp	r3, #2
 8010ec4:	d901      	bls.n	8010eca <HAL_RCC_OscConfig+0x736>
          {
            return HAL_TIMEOUT;
 8010ec6:	2303      	movs	r3, #3
 8010ec8:	e02a      	b.n	8010f20 <HAL_RCC_OscConfig+0x78c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
 8010eca:	4b17      	ldr	r3, [pc, #92]	; (8010f28 <HAL_RCC_OscConfig+0x794>)
 8010ecc:	681a      	ldr	r2, [r3, #0]
 8010ece:	2380      	movs	r3, #128	; 0x80
 8010ed0:	049b      	lsls	r3, r3, #18
 8010ed2:	4013      	ands	r3, r2
 8010ed4:	d1f0      	bne.n	8010eb8 <HAL_RCC_OscConfig+0x724>
 8010ed6:	e022      	b.n	8010f1e <HAL_RCC_OscConfig+0x78a>
      }
    }
    else
    {
      /* Check if there is a request to disable the PLL used as System clock source */
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 8010ed8:	687b      	ldr	r3, [r7, #4]
 8010eda:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8010edc:	2b01      	cmp	r3, #1
 8010ede:	d101      	bne.n	8010ee4 <HAL_RCC_OscConfig+0x750>
      {
        return HAL_ERROR;
 8010ee0:	2301      	movs	r3, #1
 8010ee2:	e01d      	b.n	8010f20 <HAL_RCC_OscConfig+0x78c>
      }
      else
      {
        /* Do not return HAL_ERROR if request repeats the current configuration */
        pll_config = RCC->CFGR;
 8010ee4:	4b10      	ldr	r3, [pc, #64]	; (8010f28 <HAL_RCC_OscConfig+0x794>)
 8010ee6:	68db      	ldr	r3, [r3, #12]
 8010ee8:	61bb      	str	r3, [r7, #24]
        if((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8010eea:	69ba      	ldr	r2, [r7, #24]
 8010eec:	2380      	movs	r3, #128	; 0x80
 8010eee:	025b      	lsls	r3, r3, #9
 8010ef0:	401a      	ands	r2, r3
 8010ef2:	687b      	ldr	r3, [r7, #4]
 8010ef4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8010ef6:	429a      	cmp	r2, r3
 8010ef8:	d10f      	bne.n	8010f1a <HAL_RCC_OscConfig+0x786>
           (READ_BIT(pll_config, RCC_CFGR_PLLMUL) != RCC_OscInitStruct->PLL.PLLMUL) ||
 8010efa:	69ba      	ldr	r2, [r7, #24]
 8010efc:	23f0      	movs	r3, #240	; 0xf0
 8010efe:	039b      	lsls	r3, r3, #14
 8010f00:	401a      	ands	r2, r3
 8010f02:	687b      	ldr	r3, [r7, #4]
 8010f04:	6b1b      	ldr	r3, [r3, #48]	; 0x30
        if((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8010f06:	429a      	cmp	r2, r3
 8010f08:	d107      	bne.n	8010f1a <HAL_RCC_OscConfig+0x786>
           (READ_BIT(pll_config, RCC_CFGR_PLLDIV) != RCC_OscInitStruct->PLL.PLLDIV))
 8010f0a:	69ba      	ldr	r2, [r7, #24]
 8010f0c:	23c0      	movs	r3, #192	; 0xc0
 8010f0e:	041b      	lsls	r3, r3, #16
 8010f10:	401a      	ands	r2, r3
 8010f12:	687b      	ldr	r3, [r7, #4]
 8010f14:	6b5b      	ldr	r3, [r3, #52]	; 0x34
           (READ_BIT(pll_config, RCC_CFGR_PLLMUL) != RCC_OscInitStruct->PLL.PLLMUL) ||
 8010f16:	429a      	cmp	r2, r3
 8010f18:	d001      	beq.n	8010f1e <HAL_RCC_OscConfig+0x78a>
        {
          return HAL_ERROR;
 8010f1a:	2301      	movs	r3, #1
 8010f1c:	e000      	b.n	8010f20 <HAL_RCC_OscConfig+0x78c>
        }
      }
    }
  }

  return HAL_OK;
 8010f1e:	2300      	movs	r3, #0
}
 8010f20:	0018      	movs	r0, r3
 8010f22:	46bd      	mov	sp, r7
 8010f24:	b00a      	add	sp, #40	; 0x28
 8010f26:	bdb0      	pop	{r4, r5, r7, pc}
 8010f28:	40021000 	.word	0x40021000
 8010f2c:	ff02ffff 	.word	0xff02ffff
 8010f30:	feffffff 	.word	0xfeffffff

08010f34 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8010f34:	b5b0      	push	{r4, r5, r7, lr}
 8010f36:	b084      	sub	sp, #16
 8010f38:	af00      	add	r7, sp, #0
 8010f3a:	6078      	str	r0, [r7, #4]
 8010f3c:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  HAL_StatusTypeDef status;

  /* Check the parameters */
  if(RCC_ClkInitStruct == NULL)
 8010f3e:	687b      	ldr	r3, [r7, #4]
 8010f40:	2b00      	cmp	r3, #0
 8010f42:	d101      	bne.n	8010f48 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 8010f44:	2301      	movs	r3, #1
 8010f46:	e10d      	b.n	8011164 <HAL_RCC_ClockConfig+0x230>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
  must be correctly programmed according to the frequency of the CPU clock
  (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8010f48:	4b88      	ldr	r3, [pc, #544]	; (801116c <HAL_RCC_ClockConfig+0x238>)
 8010f4a:	681b      	ldr	r3, [r3, #0]
 8010f4c:	2201      	movs	r2, #1
 8010f4e:	4013      	ands	r3, r2
 8010f50:	683a      	ldr	r2, [r7, #0]
 8010f52:	429a      	cmp	r2, r3
 8010f54:	d911      	bls.n	8010f7a <HAL_RCC_ClockConfig+0x46>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8010f56:	4b85      	ldr	r3, [pc, #532]	; (801116c <HAL_RCC_ClockConfig+0x238>)
 8010f58:	681b      	ldr	r3, [r3, #0]
 8010f5a:	2201      	movs	r2, #1
 8010f5c:	4393      	bics	r3, r2
 8010f5e:	0019      	movs	r1, r3
 8010f60:	4b82      	ldr	r3, [pc, #520]	; (801116c <HAL_RCC_ClockConfig+0x238>)
 8010f62:	683a      	ldr	r2, [r7, #0]
 8010f64:	430a      	orrs	r2, r1
 8010f66:	601a      	str	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8010f68:	4b80      	ldr	r3, [pc, #512]	; (801116c <HAL_RCC_ClockConfig+0x238>)
 8010f6a:	681b      	ldr	r3, [r3, #0]
 8010f6c:	2201      	movs	r2, #1
 8010f6e:	4013      	ands	r3, r2
 8010f70:	683a      	ldr	r2, [r7, #0]
 8010f72:	429a      	cmp	r2, r3
 8010f74:	d001      	beq.n	8010f7a <HAL_RCC_ClockConfig+0x46>
    {
      return HAL_ERROR;
 8010f76:	2301      	movs	r3, #1
 8010f78:	e0f4      	b.n	8011164 <HAL_RCC_ClockConfig+0x230>
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8010f7a:	687b      	ldr	r3, [r7, #4]
 8010f7c:	681b      	ldr	r3, [r3, #0]
 8010f7e:	2202      	movs	r2, #2
 8010f80:	4013      	ands	r3, r2
 8010f82:	d009      	beq.n	8010f98 <HAL_RCC_ClockConfig+0x64>
  {
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8010f84:	4b7a      	ldr	r3, [pc, #488]	; (8011170 <HAL_RCC_ClockConfig+0x23c>)
 8010f86:	68db      	ldr	r3, [r3, #12]
 8010f88:	22f0      	movs	r2, #240	; 0xf0
 8010f8a:	4393      	bics	r3, r2
 8010f8c:	0019      	movs	r1, r3
 8010f8e:	687b      	ldr	r3, [r7, #4]
 8010f90:	689a      	ldr	r2, [r3, #8]
 8010f92:	4b77      	ldr	r3, [pc, #476]	; (8011170 <HAL_RCC_ClockConfig+0x23c>)
 8010f94:	430a      	orrs	r2, r1
 8010f96:	60da      	str	r2, [r3, #12]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8010f98:	687b      	ldr	r3, [r7, #4]
 8010f9a:	681b      	ldr	r3, [r3, #0]
 8010f9c:	2201      	movs	r2, #1
 8010f9e:	4013      	ands	r3, r2
 8010fa0:	d100      	bne.n	8010fa4 <HAL_RCC_ClockConfig+0x70>
 8010fa2:	e089      	b.n	80110b8 <HAL_RCC_ClockConfig+0x184>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8010fa4:	687b      	ldr	r3, [r7, #4]
 8010fa6:	685b      	ldr	r3, [r3, #4]
 8010fa8:	2b02      	cmp	r3, #2
 8010faa:	d107      	bne.n	8010fbc <HAL_RCC_ClockConfig+0x88>
    {
      /* Check the HSE ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 8010fac:	4b70      	ldr	r3, [pc, #448]	; (8011170 <HAL_RCC_ClockConfig+0x23c>)
 8010fae:	681a      	ldr	r2, [r3, #0]
 8010fb0:	2380      	movs	r3, #128	; 0x80
 8010fb2:	029b      	lsls	r3, r3, #10
 8010fb4:	4013      	ands	r3, r2
 8010fb6:	d120      	bne.n	8010ffa <HAL_RCC_ClockConfig+0xc6>
      {
        return HAL_ERROR;
 8010fb8:	2301      	movs	r3, #1
 8010fba:	e0d3      	b.n	8011164 <HAL_RCC_ClockConfig+0x230>
      }
    }
    /* PLL is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8010fbc:	687b      	ldr	r3, [r7, #4]
 8010fbe:	685b      	ldr	r3, [r3, #4]
 8010fc0:	2b03      	cmp	r3, #3
 8010fc2:	d107      	bne.n	8010fd4 <HAL_RCC_ClockConfig+0xa0>
    {
      /* Check the PLL ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 8010fc4:	4b6a      	ldr	r3, [pc, #424]	; (8011170 <HAL_RCC_ClockConfig+0x23c>)
 8010fc6:	681a      	ldr	r2, [r3, #0]
 8010fc8:	2380      	movs	r3, #128	; 0x80
 8010fca:	049b      	lsls	r3, r3, #18
 8010fcc:	4013      	ands	r3, r2
 8010fce:	d114      	bne.n	8010ffa <HAL_RCC_ClockConfig+0xc6>
      {
        return HAL_ERROR;
 8010fd0:	2301      	movs	r3, #1
 8010fd2:	e0c7      	b.n	8011164 <HAL_RCC_ClockConfig+0x230>
      }
    }
    /* HSI is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
 8010fd4:	687b      	ldr	r3, [r7, #4]
 8010fd6:	685b      	ldr	r3, [r3, #4]
 8010fd8:	2b01      	cmp	r3, #1
 8010fda:	d106      	bne.n	8010fea <HAL_RCC_ClockConfig+0xb6>
    {
      /* Check the HSI ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8010fdc:	4b64      	ldr	r3, [pc, #400]	; (8011170 <HAL_RCC_ClockConfig+0x23c>)
 8010fde:	681b      	ldr	r3, [r3, #0]
 8010fe0:	2204      	movs	r2, #4
 8010fe2:	4013      	ands	r3, r2
 8010fe4:	d109      	bne.n	8010ffa <HAL_RCC_ClockConfig+0xc6>
      {
        return HAL_ERROR;
 8010fe6:	2301      	movs	r3, #1
 8010fe8:	e0bc      	b.n	8011164 <HAL_RCC_ClockConfig+0x230>
    }
    /* MSI is selected as System Clock Source */
    else
    {
      /* Check the MSI ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == 0U)
 8010fea:	4b61      	ldr	r3, [pc, #388]	; (8011170 <HAL_RCC_ClockConfig+0x23c>)
 8010fec:	681a      	ldr	r2, [r3, #0]
 8010fee:	2380      	movs	r3, #128	; 0x80
 8010ff0:	009b      	lsls	r3, r3, #2
 8010ff2:	4013      	ands	r3, r2
 8010ff4:	d101      	bne.n	8010ffa <HAL_RCC_ClockConfig+0xc6>
      {
        return HAL_ERROR;
 8010ff6:	2301      	movs	r3, #1
 8010ff8:	e0b4      	b.n	8011164 <HAL_RCC_ClockConfig+0x230>
      }
    }
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8010ffa:	4b5d      	ldr	r3, [pc, #372]	; (8011170 <HAL_RCC_ClockConfig+0x23c>)
 8010ffc:	68db      	ldr	r3, [r3, #12]
 8010ffe:	2203      	movs	r2, #3
 8011000:	4393      	bics	r3, r2
 8011002:	0019      	movs	r1, r3
 8011004:	687b      	ldr	r3, [r7, #4]
 8011006:	685a      	ldr	r2, [r3, #4]
 8011008:	4b59      	ldr	r3, [pc, #356]	; (8011170 <HAL_RCC_ClockConfig+0x23c>)
 801100a:	430a      	orrs	r2, r1
 801100c:	60da      	str	r2, [r3, #12]

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 801100e:	f7fe fa67 	bl	800f4e0 <HAL_GetTick>
 8011012:	0003      	movs	r3, r0
 8011014:	60fb      	str	r3, [r7, #12]

    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8011016:	687b      	ldr	r3, [r7, #4]
 8011018:	685b      	ldr	r3, [r3, #4]
 801101a:	2b02      	cmp	r3, #2
 801101c:	d111      	bne.n	8011042 <HAL_RCC_ClockConfig+0x10e>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 801101e:	e009      	b.n	8011034 <HAL_RCC_ClockConfig+0x100>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8011020:	f7fe fa5e 	bl	800f4e0 <HAL_GetTick>
 8011024:	0002      	movs	r2, r0
 8011026:	68fb      	ldr	r3, [r7, #12]
 8011028:	1ad3      	subs	r3, r2, r3
 801102a:	4a52      	ldr	r2, [pc, #328]	; (8011174 <HAL_RCC_ClockConfig+0x240>)
 801102c:	4293      	cmp	r3, r2
 801102e:	d901      	bls.n	8011034 <HAL_RCC_ClockConfig+0x100>
        {
          return HAL_TIMEOUT;
 8011030:	2303      	movs	r3, #3
 8011032:	e097      	b.n	8011164 <HAL_RCC_ClockConfig+0x230>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8011034:	4b4e      	ldr	r3, [pc, #312]	; (8011170 <HAL_RCC_ClockConfig+0x23c>)
 8011036:	68db      	ldr	r3, [r3, #12]
 8011038:	220c      	movs	r2, #12
 801103a:	4013      	ands	r3, r2
 801103c:	2b08      	cmp	r3, #8
 801103e:	d1ef      	bne.n	8011020 <HAL_RCC_ClockConfig+0xec>
 8011040:	e03a      	b.n	80110b8 <HAL_RCC_ClockConfig+0x184>
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8011042:	687b      	ldr	r3, [r7, #4]
 8011044:	685b      	ldr	r3, [r3, #4]
 8011046:	2b03      	cmp	r3, #3
 8011048:	d111      	bne.n	801106e <HAL_RCC_ClockConfig+0x13a>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 801104a:	e009      	b.n	8011060 <HAL_RCC_ClockConfig+0x12c>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 801104c:	f7fe fa48 	bl	800f4e0 <HAL_GetTick>
 8011050:	0002      	movs	r2, r0
 8011052:	68fb      	ldr	r3, [r7, #12]
 8011054:	1ad3      	subs	r3, r2, r3
 8011056:	4a47      	ldr	r2, [pc, #284]	; (8011174 <HAL_RCC_ClockConfig+0x240>)
 8011058:	4293      	cmp	r3, r2
 801105a:	d901      	bls.n	8011060 <HAL_RCC_ClockConfig+0x12c>
        {
          return HAL_TIMEOUT;
 801105c:	2303      	movs	r3, #3
 801105e:	e081      	b.n	8011164 <HAL_RCC_ClockConfig+0x230>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8011060:	4b43      	ldr	r3, [pc, #268]	; (8011170 <HAL_RCC_ClockConfig+0x23c>)
 8011062:	68db      	ldr	r3, [r3, #12]
 8011064:	220c      	movs	r2, #12
 8011066:	4013      	ands	r3, r2
 8011068:	2b0c      	cmp	r3, #12
 801106a:	d1ef      	bne.n	801104c <HAL_RCC_ClockConfig+0x118>
 801106c:	e024      	b.n	80110b8 <HAL_RCC_ClockConfig+0x184>
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
 801106e:	687b      	ldr	r3, [r7, #4]
 8011070:	685b      	ldr	r3, [r3, #4]
 8011072:	2b01      	cmp	r3, #1
 8011074:	d11b      	bne.n	80110ae <HAL_RCC_ClockConfig+0x17a>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 8011076:	e009      	b.n	801108c <HAL_RCC_ClockConfig+0x158>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8011078:	f7fe fa32 	bl	800f4e0 <HAL_GetTick>
 801107c:	0002      	movs	r2, r0
 801107e:	68fb      	ldr	r3, [r7, #12]
 8011080:	1ad3      	subs	r3, r2, r3
 8011082:	4a3c      	ldr	r2, [pc, #240]	; (8011174 <HAL_RCC_ClockConfig+0x240>)
 8011084:	4293      	cmp	r3, r2
 8011086:	d901      	bls.n	801108c <HAL_RCC_ClockConfig+0x158>
        {
          return HAL_TIMEOUT;
 8011088:	2303      	movs	r3, #3
 801108a:	e06b      	b.n	8011164 <HAL_RCC_ClockConfig+0x230>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 801108c:	4b38      	ldr	r3, [pc, #224]	; (8011170 <HAL_RCC_ClockConfig+0x23c>)
 801108e:	68db      	ldr	r3, [r3, #12]
 8011090:	220c      	movs	r2, #12
 8011092:	4013      	ands	r3, r2
 8011094:	2b04      	cmp	r3, #4
 8011096:	d1ef      	bne.n	8011078 <HAL_RCC_ClockConfig+0x144>
 8011098:	e00e      	b.n	80110b8 <HAL_RCC_ClockConfig+0x184>
    }
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 801109a:	f7fe fa21 	bl	800f4e0 <HAL_GetTick>
 801109e:	0002      	movs	r2, r0
 80110a0:	68fb      	ldr	r3, [r7, #12]
 80110a2:	1ad3      	subs	r3, r2, r3
 80110a4:	4a33      	ldr	r2, [pc, #204]	; (8011174 <HAL_RCC_ClockConfig+0x240>)
 80110a6:	4293      	cmp	r3, r2
 80110a8:	d901      	bls.n	80110ae <HAL_RCC_ClockConfig+0x17a>
        {
          return HAL_TIMEOUT;
 80110aa:	2303      	movs	r3, #3
 80110ac:	e05a      	b.n	8011164 <HAL_RCC_ClockConfig+0x230>
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
 80110ae:	4b30      	ldr	r3, [pc, #192]	; (8011170 <HAL_RCC_ClockConfig+0x23c>)
 80110b0:	68db      	ldr	r3, [r3, #12]
 80110b2:	220c      	movs	r2, #12
 80110b4:	4013      	ands	r3, r2
 80110b6:	d1f0      	bne.n	801109a <HAL_RCC_ClockConfig+0x166>
        }
      }
    }
  }
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 80110b8:	4b2c      	ldr	r3, [pc, #176]	; (801116c <HAL_RCC_ClockConfig+0x238>)
 80110ba:	681b      	ldr	r3, [r3, #0]
 80110bc:	2201      	movs	r2, #1
 80110be:	4013      	ands	r3, r2
 80110c0:	683a      	ldr	r2, [r7, #0]
 80110c2:	429a      	cmp	r2, r3
 80110c4:	d211      	bcs.n	80110ea <HAL_RCC_ClockConfig+0x1b6>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80110c6:	4b29      	ldr	r3, [pc, #164]	; (801116c <HAL_RCC_ClockConfig+0x238>)
 80110c8:	681b      	ldr	r3, [r3, #0]
 80110ca:	2201      	movs	r2, #1
 80110cc:	4393      	bics	r3, r2
 80110ce:	0019      	movs	r1, r3
 80110d0:	4b26      	ldr	r3, [pc, #152]	; (801116c <HAL_RCC_ClockConfig+0x238>)
 80110d2:	683a      	ldr	r2, [r7, #0]
 80110d4:	430a      	orrs	r2, r1
 80110d6:	601a      	str	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80110d8:	4b24      	ldr	r3, [pc, #144]	; (801116c <HAL_RCC_ClockConfig+0x238>)
 80110da:	681b      	ldr	r3, [r3, #0]
 80110dc:	2201      	movs	r2, #1
 80110de:	4013      	ands	r3, r2
 80110e0:	683a      	ldr	r2, [r7, #0]
 80110e2:	429a      	cmp	r2, r3
 80110e4:	d001      	beq.n	80110ea <HAL_RCC_ClockConfig+0x1b6>
    {
      return HAL_ERROR;
 80110e6:	2301      	movs	r3, #1
 80110e8:	e03c      	b.n	8011164 <HAL_RCC_ClockConfig+0x230>
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80110ea:	687b      	ldr	r3, [r7, #4]
 80110ec:	681b      	ldr	r3, [r3, #0]
 80110ee:	2204      	movs	r2, #4
 80110f0:	4013      	ands	r3, r2
 80110f2:	d009      	beq.n	8011108 <HAL_RCC_ClockConfig+0x1d4>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 80110f4:	4b1e      	ldr	r3, [pc, #120]	; (8011170 <HAL_RCC_ClockConfig+0x23c>)
 80110f6:	68db      	ldr	r3, [r3, #12]
 80110f8:	4a1f      	ldr	r2, [pc, #124]	; (8011178 <HAL_RCC_ClockConfig+0x244>)
 80110fa:	4013      	ands	r3, r2
 80110fc:	0019      	movs	r1, r3
 80110fe:	687b      	ldr	r3, [r7, #4]
 8011100:	68da      	ldr	r2, [r3, #12]
 8011102:	4b1b      	ldr	r3, [pc, #108]	; (8011170 <HAL_RCC_ClockConfig+0x23c>)
 8011104:	430a      	orrs	r2, r1
 8011106:	60da      	str	r2, [r3, #12]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8011108:	687b      	ldr	r3, [r7, #4]
 801110a:	681b      	ldr	r3, [r3, #0]
 801110c:	2208      	movs	r2, #8
 801110e:	4013      	ands	r3, r2
 8011110:	d00a      	beq.n	8011128 <HAL_RCC_ClockConfig+0x1f4>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8011112:	4b17      	ldr	r3, [pc, #92]	; (8011170 <HAL_RCC_ClockConfig+0x23c>)
 8011114:	68db      	ldr	r3, [r3, #12]
 8011116:	4a19      	ldr	r2, [pc, #100]	; (801117c <HAL_RCC_ClockConfig+0x248>)
 8011118:	4013      	ands	r3, r2
 801111a:	0019      	movs	r1, r3
 801111c:	687b      	ldr	r3, [r7, #4]
 801111e:	691b      	ldr	r3, [r3, #16]
 8011120:	00da      	lsls	r2, r3, #3
 8011122:	4b13      	ldr	r3, [pc, #76]	; (8011170 <HAL_RCC_ClockConfig+0x23c>)
 8011124:	430a      	orrs	r2, r1
 8011126:	60da      	str	r2, [r3, #12]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 8011128:	f000 f82e 	bl	8011188 <HAL_RCC_GetSysClockFreq>
 801112c:	0001      	movs	r1, r0
 801112e:	4b10      	ldr	r3, [pc, #64]	; (8011170 <HAL_RCC_ClockConfig+0x23c>)
 8011130:	68db      	ldr	r3, [r3, #12]
 8011132:	091b      	lsrs	r3, r3, #4
 8011134:	220f      	movs	r2, #15
 8011136:	4013      	ands	r3, r2
 8011138:	4a11      	ldr	r2, [pc, #68]	; (8011180 <HAL_RCC_ClockConfig+0x24c>)
 801113a:	5cd3      	ldrb	r3, [r2, r3]
 801113c:	000a      	movs	r2, r1
 801113e:	40da      	lsrs	r2, r3
 8011140:	4b10      	ldr	r3, [pc, #64]	; (8011184 <HAL_RCC_ClockConfig+0x250>)
 8011142:	601a      	str	r2, [r3, #0]

  /* Configure the source of time base considering new system clocks settings*/
  status = HAL_InitTick(TICK_INT_PRIORITY);
 8011144:	250b      	movs	r5, #11
 8011146:	197c      	adds	r4, r7, r5
 8011148:	2000      	movs	r0, #0
 801114a:	f7fe f983 	bl	800f454 <HAL_InitTick>
 801114e:	0003      	movs	r3, r0
 8011150:	7023      	strb	r3, [r4, #0]
  if(status != HAL_OK)
 8011152:	197b      	adds	r3, r7, r5
 8011154:	781b      	ldrb	r3, [r3, #0]
 8011156:	2b00      	cmp	r3, #0
 8011158:	d003      	beq.n	8011162 <HAL_RCC_ClockConfig+0x22e>
  {
    return status;
 801115a:	230b      	movs	r3, #11
 801115c:	18fb      	adds	r3, r7, r3
 801115e:	781b      	ldrb	r3, [r3, #0]
 8011160:	e000      	b.n	8011164 <HAL_RCC_ClockConfig+0x230>
  }

  return HAL_OK;
 8011162:	2300      	movs	r3, #0
}
 8011164:	0018      	movs	r0, r3
 8011166:	46bd      	mov	sp, r7
 8011168:	b004      	add	sp, #16
 801116a:	bdb0      	pop	{r4, r5, r7, pc}
 801116c:	40022000 	.word	0x40022000
 8011170:	40021000 	.word	0x40021000
 8011174:	00001388 	.word	0x00001388
 8011178:	fffff8ff 	.word	0xfffff8ff
 801117c:	ffffc7ff 	.word	0xffffc7ff
 8011180:	08014eb8 	.word	0x08014eb8
 8011184:	200000d8 	.word	0x200000d8

08011188 <HAL_RCC_GetSysClockFreq>:
  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8011188:	b580      	push	{r7, lr}
 801118a:	b086      	sub	sp, #24
 801118c:	af00      	add	r7, sp, #0
  uint32_t tmpreg, pllm, plld, pllvco, msiclkrange;    /* no init needed */
  uint32_t sysclockfreq;

  tmpreg = RCC->CFGR;
 801118e:	4b3b      	ldr	r3, [pc, #236]	; (801127c <HAL_RCC_GetSysClockFreq+0xf4>)
 8011190:	68db      	ldr	r3, [r3, #12]
 8011192:	60fb      	str	r3, [r7, #12]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
 8011194:	68fb      	ldr	r3, [r7, #12]
 8011196:	220c      	movs	r2, #12
 8011198:	4013      	ands	r3, r2
 801119a:	2b08      	cmp	r3, #8
 801119c:	d00e      	beq.n	80111bc <HAL_RCC_GetSysClockFreq+0x34>
 801119e:	2b0c      	cmp	r3, #12
 80111a0:	d00f      	beq.n	80111c2 <HAL_RCC_GetSysClockFreq+0x3a>
 80111a2:	2b04      	cmp	r3, #4
 80111a4:	d157      	bne.n	8011256 <HAL_RCC_GetSysClockFreq+0xce>
  {
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    {
      if ((RCC->CR & RCC_CR_HSIDIVF) != 0U)
 80111a6:	4b35      	ldr	r3, [pc, #212]	; (801127c <HAL_RCC_GetSysClockFreq+0xf4>)
 80111a8:	681b      	ldr	r3, [r3, #0]
 80111aa:	2210      	movs	r2, #16
 80111ac:	4013      	ands	r3, r2
 80111ae:	d002      	beq.n	80111b6 <HAL_RCC_GetSysClockFreq+0x2e>
      {
        sysclockfreq =  (HSI_VALUE >> 2);
 80111b0:	4b33      	ldr	r3, [pc, #204]	; (8011280 <HAL_RCC_GetSysClockFreq+0xf8>)
 80111b2:	613b      	str	r3, [r7, #16]
      }
      else
      {
        sysclockfreq =  HSI_VALUE;
      }
      break;
 80111b4:	e05d      	b.n	8011272 <HAL_RCC_GetSysClockFreq+0xea>
        sysclockfreq =  HSI_VALUE;
 80111b6:	4b33      	ldr	r3, [pc, #204]	; (8011284 <HAL_RCC_GetSysClockFreq+0xfc>)
 80111b8:	613b      	str	r3, [r7, #16]
      break;
 80111ba:	e05a      	b.n	8011272 <HAL_RCC_GetSysClockFreq+0xea>
    }
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock */
    {
      sysclockfreq = HSE_VALUE;
 80111bc:	4b32      	ldr	r3, [pc, #200]	; (8011288 <HAL_RCC_GetSysClockFreq+0x100>)
 80111be:	613b      	str	r3, [r7, #16]
      break;
 80111c0:	e057      	b.n	8011272 <HAL_RCC_GetSysClockFreq+0xea>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
    {
      pllm = PLLMulTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_Pos];
 80111c2:	68fb      	ldr	r3, [r7, #12]
 80111c4:	0c9b      	lsrs	r3, r3, #18
 80111c6:	220f      	movs	r2, #15
 80111c8:	4013      	ands	r3, r2
 80111ca:	4a30      	ldr	r2, [pc, #192]	; (801128c <HAL_RCC_GetSysClockFreq+0x104>)
 80111cc:	5cd3      	ldrb	r3, [r2, r3]
 80111ce:	60bb      	str	r3, [r7, #8]
      plld = ((uint32_t)(tmpreg & RCC_CFGR_PLLDIV) >> RCC_CFGR_PLLDIV_Pos) + 1U;
 80111d0:	68fb      	ldr	r3, [r7, #12]
 80111d2:	0d9b      	lsrs	r3, r3, #22
 80111d4:	2203      	movs	r2, #3
 80111d6:	4013      	ands	r3, r2
 80111d8:	3301      	adds	r3, #1
 80111da:	607b      	str	r3, [r7, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 80111dc:	4b27      	ldr	r3, [pc, #156]	; (801127c <HAL_RCC_GetSysClockFreq+0xf4>)
 80111de:	68da      	ldr	r2, [r3, #12]
 80111e0:	2380      	movs	r3, #128	; 0x80
 80111e2:	025b      	lsls	r3, r3, #9
 80111e4:	4013      	ands	r3, r2
 80111e6:	d00f      	beq.n	8011208 <HAL_RCC_GetSysClockFreq+0x80>
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE * pllm) / plld;
 80111e8:	68b9      	ldr	r1, [r7, #8]
 80111ea:	000a      	movs	r2, r1
 80111ec:	0152      	lsls	r2, r2, #5
 80111ee:	1a52      	subs	r2, r2, r1
 80111f0:	0193      	lsls	r3, r2, #6
 80111f2:	1a9b      	subs	r3, r3, r2
 80111f4:	00db      	lsls	r3, r3, #3
 80111f6:	185b      	adds	r3, r3, r1
 80111f8:	025b      	lsls	r3, r3, #9
 80111fa:	6879      	ldr	r1, [r7, #4]
 80111fc:	0018      	movs	r0, r3
 80111fe:	f7ee ff95 	bl	800012c <__udivsi3>
 8011202:	0003      	movs	r3, r0
 8011204:	617b      	str	r3, [r7, #20]
 8011206:	e023      	b.n	8011250 <HAL_RCC_GetSysClockFreq+0xc8>
      }
      else
      {
        if ((RCC->CR & RCC_CR_HSIDIVF) != 0U)
 8011208:	4b1c      	ldr	r3, [pc, #112]	; (801127c <HAL_RCC_GetSysClockFreq+0xf4>)
 801120a:	681b      	ldr	r3, [r3, #0]
 801120c:	2210      	movs	r2, #16
 801120e:	4013      	ands	r3, r2
 8011210:	d00f      	beq.n	8011232 <HAL_RCC_GetSysClockFreq+0xaa>
        {
          pllvco = ((HSI_VALUE >> 2) * pllm) / plld;
 8011212:	68b9      	ldr	r1, [r7, #8]
 8011214:	000a      	movs	r2, r1
 8011216:	0152      	lsls	r2, r2, #5
 8011218:	1a52      	subs	r2, r2, r1
 801121a:	0193      	lsls	r3, r2, #6
 801121c:	1a9b      	subs	r3, r3, r2
 801121e:	00db      	lsls	r3, r3, #3
 8011220:	185b      	adds	r3, r3, r1
 8011222:	021b      	lsls	r3, r3, #8
 8011224:	6879      	ldr	r1, [r7, #4]
 8011226:	0018      	movs	r0, r3
 8011228:	f7ee ff80 	bl	800012c <__udivsi3>
 801122c:	0003      	movs	r3, r0
 801122e:	617b      	str	r3, [r7, #20]
 8011230:	e00e      	b.n	8011250 <HAL_RCC_GetSysClockFreq+0xc8>
        }
        else
        {
         pllvco = (HSI_VALUE * pllm) / plld;
 8011232:	68b9      	ldr	r1, [r7, #8]
 8011234:	000a      	movs	r2, r1
 8011236:	0152      	lsls	r2, r2, #5
 8011238:	1a52      	subs	r2, r2, r1
 801123a:	0193      	lsls	r3, r2, #6
 801123c:	1a9b      	subs	r3, r3, r2
 801123e:	00db      	lsls	r3, r3, #3
 8011240:	185b      	adds	r3, r3, r1
 8011242:	029b      	lsls	r3, r3, #10
 8011244:	6879      	ldr	r1, [r7, #4]
 8011246:	0018      	movs	r0, r3
 8011248:	f7ee ff70 	bl	800012c <__udivsi3>
 801124c:	0003      	movs	r3, r0
 801124e:	617b      	str	r3, [r7, #20]
        }
      }
      sysclockfreq = pllvco;
 8011250:	697b      	ldr	r3, [r7, #20]
 8011252:	613b      	str	r3, [r7, #16]
      break;
 8011254:	e00d      	b.n	8011272 <HAL_RCC_GetSysClockFreq+0xea>
    }
    case RCC_SYSCLKSOURCE_STATUS_MSI:  /* MSI used as system clock source */
    default: /* MSI used as system clock */
    {
      msiclkrange = (RCC->ICSCR & RCC_ICSCR_MSIRANGE ) >> RCC_ICSCR_MSIRANGE_Pos;
 8011256:	4b09      	ldr	r3, [pc, #36]	; (801127c <HAL_RCC_GetSysClockFreq+0xf4>)
 8011258:	685b      	ldr	r3, [r3, #4]
 801125a:	0b5b      	lsrs	r3, r3, #13
 801125c:	2207      	movs	r2, #7
 801125e:	4013      	ands	r3, r2
 8011260:	603b      	str	r3, [r7, #0]
      sysclockfreq = (32768U * (1UL << (msiclkrange + 1U)));
 8011262:	683b      	ldr	r3, [r7, #0]
 8011264:	3301      	adds	r3, #1
 8011266:	2280      	movs	r2, #128	; 0x80
 8011268:	0212      	lsls	r2, r2, #8
 801126a:	409a      	lsls	r2, r3
 801126c:	0013      	movs	r3, r2
 801126e:	613b      	str	r3, [r7, #16]
      break;
 8011270:	46c0      	nop			; (mov r8, r8)
    }
  }
  return sysclockfreq;
 8011272:	693b      	ldr	r3, [r7, #16]
}
 8011274:	0018      	movs	r0, r3
 8011276:	46bd      	mov	sp, r7
 8011278:	b006      	add	sp, #24
 801127a:	bd80      	pop	{r7, pc}
 801127c:	40021000 	.word	0x40021000
 8011280:	003d0900 	.word	0x003d0900
 8011284:	00f42400 	.word	0x00f42400
 8011288:	007a1200 	.word	0x007a1200
 801128c:	08014ed0 	.word	0x08014ed0

08011290 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8011290:	b580      	push	{r7, lr}
 8011292:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 8011294:	4b02      	ldr	r3, [pc, #8]	; (80112a0 <HAL_RCC_GetHCLKFreq+0x10>)
 8011296:	681b      	ldr	r3, [r3, #0]
}
 8011298:	0018      	movs	r0, r3
 801129a:	46bd      	mov	sp, r7
 801129c:	bd80      	pop	{r7, pc}
 801129e:	46c0      	nop			; (mov r8, r8)
 80112a0:	200000d8 	.word	0x200000d8

080112a4 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 80112a4:	b580      	push	{r7, lr}
 80112a6:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 80112a8:	f7ff fff2 	bl	8011290 <HAL_RCC_GetHCLKFreq>
 80112ac:	0001      	movs	r1, r0
 80112ae:	4b06      	ldr	r3, [pc, #24]	; (80112c8 <HAL_RCC_GetPCLK1Freq+0x24>)
 80112b0:	68db      	ldr	r3, [r3, #12]
 80112b2:	0a1b      	lsrs	r3, r3, #8
 80112b4:	2207      	movs	r2, #7
 80112b6:	4013      	ands	r3, r2
 80112b8:	4a04      	ldr	r2, [pc, #16]	; (80112cc <HAL_RCC_GetPCLK1Freq+0x28>)
 80112ba:	5cd3      	ldrb	r3, [r2, r3]
 80112bc:	40d9      	lsrs	r1, r3
 80112be:	000b      	movs	r3, r1
}
 80112c0:	0018      	movs	r0, r3
 80112c2:	46bd      	mov	sp, r7
 80112c4:	bd80      	pop	{r7, pc}
 80112c6:	46c0      	nop			; (mov r8, r8)
 80112c8:	40021000 	.word	0x40021000
 80112cc:	08014ec8 	.word	0x08014ec8

080112d0 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 80112d0:	b580      	push	{r7, lr}
 80112d2:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 80112d4:	f7ff ffdc 	bl	8011290 <HAL_RCC_GetHCLKFreq>
 80112d8:	0001      	movs	r1, r0
 80112da:	4b06      	ldr	r3, [pc, #24]	; (80112f4 <HAL_RCC_GetPCLK2Freq+0x24>)
 80112dc:	68db      	ldr	r3, [r3, #12]
 80112de:	0adb      	lsrs	r3, r3, #11
 80112e0:	2207      	movs	r2, #7
 80112e2:	4013      	ands	r3, r2
 80112e4:	4a04      	ldr	r2, [pc, #16]	; (80112f8 <HAL_RCC_GetPCLK2Freq+0x28>)
 80112e6:	5cd3      	ldrb	r3, [r2, r3]
 80112e8:	40d9      	lsrs	r1, r3
 80112ea:	000b      	movs	r3, r1
}
 80112ec:	0018      	movs	r0, r3
 80112ee:	46bd      	mov	sp, r7
 80112f0:	bd80      	pop	{r7, pc}
 80112f2:	46c0      	nop			; (mov r8, r8)
 80112f4:	40021000 	.word	0x40021000
 80112f8:	08014ec8 	.word	0x08014ec8

080112fc <HAL_RCCEx_PeriphCLKConfig>:
  * @retval HAL status
  * @note   If HAL_ERROR returned, first switch-OFF HSE clock oscillator with @ref HAL_RCC_OscConfig()
  *         to possibly update HSE divider.
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 80112fc:	b580      	push	{r7, lr}
 80112fe:	b086      	sub	sp, #24
 8011300:	af00      	add	r7, sp, #0
 8011302:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*------------------------------- RTC/LCD Configuration ------------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8011304:	687b      	ldr	r3, [r7, #4]
 8011306:	681b      	ldr	r3, [r3, #0]
 8011308:	2220      	movs	r2, #32
 801130a:	4013      	ands	r3, r2
 801130c:	d106      	bne.n	801131c <HAL_RCCEx_PeriphCLKConfig+0x20>
#if defined(LCD)
   || (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LCD) == RCC_PERIPHCLK_LCD)
 801130e:	687b      	ldr	r3, [r7, #4]
 8011310:	681a      	ldr	r2, [r3, #0]
 8011312:	2380      	movs	r3, #128	; 0x80
 8011314:	011b      	lsls	r3, r3, #4
 8011316:	4013      	ands	r3, r2
 8011318:	d100      	bne.n	801131c <HAL_RCCEx_PeriphCLKConfig+0x20>
 801131a:	e0dd      	b.n	80114d8 <HAL_RCCEx_PeriphCLKConfig+0x1dc>
    {
      assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->LCDClockSelection));
    }
#endif /* LCD */

    FlagStatus       pwrclkchanged = RESET;
 801131c:	2317      	movs	r3, #23
 801131e:	18fb      	adds	r3, r7, r3
 8011320:	2200      	movs	r2, #0
 8011322:	701a      	strb	r2, [r3, #0]

    /* As soon as function is called to change RTC clock source, activation of the
       power domain is done. */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8011324:	4ba4      	ldr	r3, [pc, #656]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 8011326:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8011328:	2380      	movs	r3, #128	; 0x80
 801132a:	055b      	lsls	r3, r3, #21
 801132c:	4013      	ands	r3, r2
 801132e:	d10a      	bne.n	8011346 <HAL_RCCEx_PeriphCLKConfig+0x4a>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8011330:	4ba1      	ldr	r3, [pc, #644]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 8011332:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8011334:	4ba0      	ldr	r3, [pc, #640]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 8011336:	2180      	movs	r1, #128	; 0x80
 8011338:	0549      	lsls	r1, r1, #21
 801133a:	430a      	orrs	r2, r1
 801133c:	639a      	str	r2, [r3, #56]	; 0x38
      pwrclkchanged = SET;
 801133e:	2317      	movs	r3, #23
 8011340:	18fb      	adds	r3, r7, r3
 8011342:	2201      	movs	r2, #1
 8011344:	701a      	strb	r2, [r3, #0]
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8011346:	4b9d      	ldr	r3, [pc, #628]	; (80115bc <HAL_RCCEx_PeriphCLKConfig+0x2c0>)
 8011348:	681a      	ldr	r2, [r3, #0]
 801134a:	2380      	movs	r3, #128	; 0x80
 801134c:	005b      	lsls	r3, r3, #1
 801134e:	4013      	ands	r3, r2
 8011350:	d11a      	bne.n	8011388 <HAL_RCCEx_PeriphCLKConfig+0x8c>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8011352:	4b9a      	ldr	r3, [pc, #616]	; (80115bc <HAL_RCCEx_PeriphCLKConfig+0x2c0>)
 8011354:	681a      	ldr	r2, [r3, #0]
 8011356:	4b99      	ldr	r3, [pc, #612]	; (80115bc <HAL_RCCEx_PeriphCLKConfig+0x2c0>)
 8011358:	2180      	movs	r1, #128	; 0x80
 801135a:	0049      	lsls	r1, r1, #1
 801135c:	430a      	orrs	r2, r1
 801135e:	601a      	str	r2, [r3, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8011360:	f7fe f8be 	bl	800f4e0 <HAL_GetTick>
 8011364:	0003      	movs	r3, r0
 8011366:	613b      	str	r3, [r7, #16]

      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8011368:	e008      	b.n	801137c <HAL_RCCEx_PeriphCLKConfig+0x80>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 801136a:	f7fe f8b9 	bl	800f4e0 <HAL_GetTick>
 801136e:	0002      	movs	r2, r0
 8011370:	693b      	ldr	r3, [r7, #16]
 8011372:	1ad3      	subs	r3, r2, r3
 8011374:	2b64      	cmp	r3, #100	; 0x64
 8011376:	d901      	bls.n	801137c <HAL_RCCEx_PeriphCLKConfig+0x80>
        {
          return HAL_TIMEOUT;
 8011378:	2303      	movs	r3, #3
 801137a:	e118      	b.n	80115ae <HAL_RCCEx_PeriphCLKConfig+0x2b2>
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 801137c:	4b8f      	ldr	r3, [pc, #572]	; (80115bc <HAL_RCCEx_PeriphCLKConfig+0x2c0>)
 801137e:	681a      	ldr	r2, [r3, #0]
 8011380:	2380      	movs	r3, #128	; 0x80
 8011382:	005b      	lsls	r3, r3, #1
 8011384:	4013      	ands	r3, r2
 8011386:	d0f0      	beq.n	801136a <HAL_RCCEx_PeriphCLKConfig+0x6e>
        }
      }
    }

    /* Check if user wants to change HSE RTC prescaler whereas HSE is enabled */
    temp_reg = (RCC->CR & RCC_CR_RTCPRE);
 8011388:	4b8b      	ldr	r3, [pc, #556]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 801138a:	681a      	ldr	r2, [r3, #0]
 801138c:	23c0      	movs	r3, #192	; 0xc0
 801138e:	039b      	lsls	r3, r3, #14
 8011390:	4013      	ands	r3, r2
 8011392:	60fb      	str	r3, [r7, #12]
    if ((temp_reg != (PeriphClkInit->RTCClockSelection & RCC_CR_RTCPRE))
 8011394:	687b      	ldr	r3, [r7, #4]
 8011396:	685a      	ldr	r2, [r3, #4]
 8011398:	23c0      	movs	r3, #192	; 0xc0
 801139a:	039b      	lsls	r3, r3, #14
 801139c:	4013      	ands	r3, r2
 801139e:	68fa      	ldr	r2, [r7, #12]
 80113a0:	429a      	cmp	r2, r3
 80113a2:	d107      	bne.n	80113b4 <HAL_RCCEx_PeriphCLKConfig+0xb8>
#if defined (LCD)
     || (temp_reg != (PeriphClkInit->LCDClockSelection & RCC_CR_RTCPRE))
 80113a4:	687b      	ldr	r3, [r7, #4]
 80113a6:	689a      	ldr	r2, [r3, #8]
 80113a8:	23c0      	movs	r3, #192	; 0xc0
 80113aa:	039b      	lsls	r3, r3, #14
 80113ac:	4013      	ands	r3, r2
 80113ae:	68fa      	ldr	r2, [r7, #12]
 80113b0:	429a      	cmp	r2, r3
 80113b2:	d013      	beq.n	80113dc <HAL_RCCEx_PeriphCLKConfig+0xe0>
#endif /* LCD */
       )
    { /* Check HSE State */
      if ((PeriphClkInit->RTCClockSelection & RCC_CSR_RTCSEL) == RCC_CSR_RTCSEL_HSE)
 80113b4:	687b      	ldr	r3, [r7, #4]
 80113b6:	685a      	ldr	r2, [r3, #4]
 80113b8:	23c0      	movs	r3, #192	; 0xc0
 80113ba:	029b      	lsls	r3, r3, #10
 80113bc:	401a      	ands	r2, r3
 80113be:	23c0      	movs	r3, #192	; 0xc0
 80113c0:	029b      	lsls	r3, r3, #10
 80113c2:	429a      	cmp	r2, r3
 80113c4:	d10a      	bne.n	80113dc <HAL_RCCEx_PeriphCLKConfig+0xe0>
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
 80113c6:	4b7c      	ldr	r3, [pc, #496]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 80113c8:	681a      	ldr	r2, [r3, #0]
 80113ca:	2380      	movs	r3, #128	; 0x80
 80113cc:	029b      	lsls	r3, r3, #10
 80113ce:	401a      	ands	r2, r3
 80113d0:	2380      	movs	r3, #128	; 0x80
 80113d2:	029b      	lsls	r3, r3, #10
 80113d4:	429a      	cmp	r2, r3
 80113d6:	d101      	bne.n	80113dc <HAL_RCCEx_PeriphCLKConfig+0xe0>
        {
          /* To update HSE divider, first switch-OFF HSE clock oscillator*/
          return HAL_ERROR;
 80113d8:	2301      	movs	r3, #1
 80113da:	e0e8      	b.n	80115ae <HAL_RCCEx_PeriphCLKConfig+0x2b2>
        }
      }
    }

    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */
    temp_reg = (RCC->CSR & RCC_CSR_RTCSEL);
 80113dc:	4b76      	ldr	r3, [pc, #472]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 80113de:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80113e0:	23c0      	movs	r3, #192	; 0xc0
 80113e2:	029b      	lsls	r3, r3, #10
 80113e4:	4013      	ands	r3, r2
 80113e6:	60fb      	str	r3, [r7, #12]

    if((temp_reg != 0x00000000U) && (((temp_reg != (PeriphClkInit->RTCClockSelection & RCC_CSR_RTCSEL)) \
 80113e8:	68fb      	ldr	r3, [r7, #12]
 80113ea:	2b00      	cmp	r3, #0
 80113ec:	d049      	beq.n	8011482 <HAL_RCCEx_PeriphCLKConfig+0x186>
 80113ee:	687b      	ldr	r3, [r7, #4]
 80113f0:	685a      	ldr	r2, [r3, #4]
 80113f2:	23c0      	movs	r3, #192	; 0xc0
 80113f4:	029b      	lsls	r3, r3, #10
 80113f6:	4013      	ands	r3, r2
 80113f8:	68fa      	ldr	r2, [r7, #12]
 80113fa:	429a      	cmp	r2, r3
 80113fc:	d004      	beq.n	8011408 <HAL_RCCEx_PeriphCLKConfig+0x10c>
      && (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))
 80113fe:	687b      	ldr	r3, [r7, #4]
 8011400:	681b      	ldr	r3, [r3, #0]
 8011402:	2220      	movs	r2, #32
 8011404:	4013      	ands	r3, r2
 8011406:	d10d      	bne.n	8011424 <HAL_RCCEx_PeriphCLKConfig+0x128>
#if defined(LCD)
      || ((temp_reg != (PeriphClkInit->LCDClockSelection & RCC_CSR_RTCSEL)) \
 8011408:	687b      	ldr	r3, [r7, #4]
 801140a:	689a      	ldr	r2, [r3, #8]
 801140c:	23c0      	movs	r3, #192	; 0xc0
 801140e:	029b      	lsls	r3, r3, #10
 8011410:	4013      	ands	r3, r2
 8011412:	68fa      	ldr	r2, [r7, #12]
 8011414:	429a      	cmp	r2, r3
 8011416:	d034      	beq.n	8011482 <HAL_RCCEx_PeriphCLKConfig+0x186>
       && (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LCD) == RCC_PERIPHCLK_LCD))
 8011418:	687b      	ldr	r3, [r7, #4]
 801141a:	681a      	ldr	r2, [r3, #0]
 801141c:	2380      	movs	r3, #128	; 0x80
 801141e:	011b      	lsls	r3, r3, #4
 8011420:	4013      	ands	r3, r2
 8011422:	d02e      	beq.n	8011482 <HAL_RCCEx_PeriphCLKConfig+0x186>
#endif /* LCD */
     ))
    {
      /* Store the content of CSR register before the reset of Backup Domain */
      temp_reg = (RCC->CSR & ~(RCC_CSR_RTCSEL));
 8011424:	4b64      	ldr	r3, [pc, #400]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 8011426:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8011428:	4a65      	ldr	r2, [pc, #404]	; (80115c0 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 801142a:	4013      	ands	r3, r2
 801142c:	60fb      	str	r3, [r7, #12]

      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 801142e:	4b62      	ldr	r3, [pc, #392]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 8011430:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8011432:	4b61      	ldr	r3, [pc, #388]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 8011434:	2180      	movs	r1, #128	; 0x80
 8011436:	0309      	lsls	r1, r1, #12
 8011438:	430a      	orrs	r2, r1
 801143a:	651a      	str	r2, [r3, #80]	; 0x50
      __HAL_RCC_BACKUPRESET_RELEASE();
 801143c:	4b5e      	ldr	r3, [pc, #376]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 801143e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8011440:	4b5d      	ldr	r3, [pc, #372]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 8011442:	4960      	ldr	r1, [pc, #384]	; (80115c4 <HAL_RCCEx_PeriphCLKConfig+0x2c8>)
 8011444:	400a      	ands	r2, r1
 8011446:	651a      	str	r2, [r3, #80]	; 0x50

      /* Restore the Content of CSR register */
      RCC->CSR = temp_reg;
 8011448:	4b5b      	ldr	r3, [pc, #364]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 801144a:	68fa      	ldr	r2, [r7, #12]
 801144c:	651a      	str	r2, [r3, #80]	; 0x50

       /* Wait for LSERDY if LSE was enabled */
      if (HAL_IS_BIT_SET(temp_reg, RCC_CSR_LSEON))
 801144e:	68fa      	ldr	r2, [r7, #12]
 8011450:	2380      	movs	r3, #128	; 0x80
 8011452:	005b      	lsls	r3, r3, #1
 8011454:	4013      	ands	r3, r2
 8011456:	d014      	beq.n	8011482 <HAL_RCCEx_PeriphCLKConfig+0x186>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8011458:	f7fe f842 	bl	800f4e0 <HAL_GetTick>
 801145c:	0003      	movs	r3, r0
 801145e:	613b      	str	r3, [r7, #16]

        /* Wait till LSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8011460:	e009      	b.n	8011476 <HAL_RCCEx_PeriphCLKConfig+0x17a>
        {
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8011462:	f7fe f83d 	bl	800f4e0 <HAL_GetTick>
 8011466:	0002      	movs	r2, r0
 8011468:	693b      	ldr	r3, [r7, #16]
 801146a:	1ad3      	subs	r3, r2, r3
 801146c:	4a56      	ldr	r2, [pc, #344]	; (80115c8 <HAL_RCCEx_PeriphCLKConfig+0x2cc>)
 801146e:	4293      	cmp	r3, r2
 8011470:	d901      	bls.n	8011476 <HAL_RCCEx_PeriphCLKConfig+0x17a>
          {
            return HAL_TIMEOUT;
 8011472:	2303      	movs	r3, #3
 8011474:	e09b      	b.n	80115ae <HAL_RCCEx_PeriphCLKConfig+0x2b2>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8011476:	4b50      	ldr	r3, [pc, #320]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 8011478:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 801147a:	2380      	movs	r3, #128	; 0x80
 801147c:	009b      	lsls	r3, r3, #2
 801147e:	4013      	ands	r3, r2
 8011480:	d0ef      	beq.n	8011462 <HAL_RCCEx_PeriphCLKConfig+0x166>
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8011482:	687b      	ldr	r3, [r7, #4]
 8011484:	685a      	ldr	r2, [r3, #4]
 8011486:	23c0      	movs	r3, #192	; 0xc0
 8011488:	029b      	lsls	r3, r3, #10
 801148a:	401a      	ands	r2, r3
 801148c:	23c0      	movs	r3, #192	; 0xc0
 801148e:	029b      	lsls	r3, r3, #10
 8011490:	429a      	cmp	r2, r3
 8011492:	d10c      	bne.n	80114ae <HAL_RCCEx_PeriphCLKConfig+0x1b2>
 8011494:	4b48      	ldr	r3, [pc, #288]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 8011496:	681b      	ldr	r3, [r3, #0]
 8011498:	4a4c      	ldr	r2, [pc, #304]	; (80115cc <HAL_RCCEx_PeriphCLKConfig+0x2d0>)
 801149a:	4013      	ands	r3, r2
 801149c:	0019      	movs	r1, r3
 801149e:	687b      	ldr	r3, [r7, #4]
 80114a0:	685a      	ldr	r2, [r3, #4]
 80114a2:	23c0      	movs	r3, #192	; 0xc0
 80114a4:	039b      	lsls	r3, r3, #14
 80114a6:	401a      	ands	r2, r3
 80114a8:	4b43      	ldr	r3, [pc, #268]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 80114aa:	430a      	orrs	r2, r1
 80114ac:	601a      	str	r2, [r3, #0]
 80114ae:	4b42      	ldr	r3, [pc, #264]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 80114b0:	6d19      	ldr	r1, [r3, #80]	; 0x50
 80114b2:	687b      	ldr	r3, [r7, #4]
 80114b4:	685a      	ldr	r2, [r3, #4]
 80114b6:	23c0      	movs	r3, #192	; 0xc0
 80114b8:	029b      	lsls	r3, r3, #10
 80114ba:	401a      	ands	r2, r3
 80114bc:	4b3e      	ldr	r3, [pc, #248]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 80114be:	430a      	orrs	r2, r1
 80114c0:	651a      	str	r2, [r3, #80]	; 0x50

    /* Require to disable power clock if necessary */
    if(pwrclkchanged == SET)
 80114c2:	2317      	movs	r3, #23
 80114c4:	18fb      	adds	r3, r7, r3
 80114c6:	781b      	ldrb	r3, [r3, #0]
 80114c8:	2b01      	cmp	r3, #1
 80114ca:	d105      	bne.n	80114d8 <HAL_RCCEx_PeriphCLKConfig+0x1dc>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 80114cc:	4b3a      	ldr	r3, [pc, #232]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 80114ce:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80114d0:	4b39      	ldr	r3, [pc, #228]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 80114d2:	493f      	ldr	r1, [pc, #252]	; (80115d0 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
 80114d4:	400a      	ands	r2, r1
 80114d6:	639a      	str	r2, [r3, #56]	; 0x38
    }
  }

#if defined (RCC_CCIPR_USART1SEL)
  /*------------------------------- USART1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 80114d8:	687b      	ldr	r3, [r7, #4]
 80114da:	681b      	ldr	r3, [r3, #0]
 80114dc:	2201      	movs	r2, #1
 80114de:	4013      	ands	r3, r2
 80114e0:	d009      	beq.n	80114f6 <HAL_RCCEx_PeriphCLKConfig+0x1fa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 80114e2:	4b35      	ldr	r3, [pc, #212]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 80114e4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80114e6:	2203      	movs	r2, #3
 80114e8:	4393      	bics	r3, r2
 80114ea:	0019      	movs	r1, r3
 80114ec:	687b      	ldr	r3, [r7, #4]
 80114ee:	68da      	ldr	r2, [r3, #12]
 80114f0:	4b31      	ldr	r3, [pc, #196]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 80114f2:	430a      	orrs	r2, r1
 80114f4:	64da      	str	r2, [r3, #76]	; 0x4c
  }
#endif /* RCC_CCIPR_USART1SEL */

  /*----------------------------- USART2 Configuration --------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 80114f6:	687b      	ldr	r3, [r7, #4]
 80114f8:	681b      	ldr	r3, [r3, #0]
 80114fa:	2202      	movs	r2, #2
 80114fc:	4013      	ands	r3, r2
 80114fe:	d009      	beq.n	8011514 <HAL_RCCEx_PeriphCLKConfig+0x218>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8011500:	4b2d      	ldr	r3, [pc, #180]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 8011502:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8011504:	220c      	movs	r2, #12
 8011506:	4393      	bics	r3, r2
 8011508:	0019      	movs	r1, r3
 801150a:	687b      	ldr	r3, [r7, #4]
 801150c:	691a      	ldr	r2, [r3, #16]
 801150e:	4b2a      	ldr	r3, [pc, #168]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 8011510:	430a      	orrs	r2, r1
 8011512:	64da      	str	r2, [r3, #76]	; 0x4c
  }

  /*------------------------------ LPUART1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8011514:	687b      	ldr	r3, [r7, #4]
 8011516:	681b      	ldr	r3, [r3, #0]
 8011518:	2204      	movs	r2, #4
 801151a:	4013      	ands	r3, r2
 801151c:	d009      	beq.n	8011532 <HAL_RCCEx_PeriphCLKConfig+0x236>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 801151e:	4b26      	ldr	r3, [pc, #152]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 8011520:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8011522:	4a2c      	ldr	r2, [pc, #176]	; (80115d4 <HAL_RCCEx_PeriphCLKConfig+0x2d8>)
 8011524:	4013      	ands	r3, r2
 8011526:	0019      	movs	r1, r3
 8011528:	687b      	ldr	r3, [r7, #4]
 801152a:	695a      	ldr	r2, [r3, #20]
 801152c:	4b22      	ldr	r3, [pc, #136]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 801152e:	430a      	orrs	r2, r1
 8011530:	64da      	str	r2, [r3, #76]	; 0x4c
  }

  /*------------------------------ I2C1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8011532:	687b      	ldr	r3, [r7, #4]
 8011534:	681b      	ldr	r3, [r3, #0]
 8011536:	2208      	movs	r2, #8
 8011538:	4013      	ands	r3, r2
 801153a:	d009      	beq.n	8011550 <HAL_RCCEx_PeriphCLKConfig+0x254>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 801153c:	4b1e      	ldr	r3, [pc, #120]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 801153e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8011540:	4a25      	ldr	r2, [pc, #148]	; (80115d8 <HAL_RCCEx_PeriphCLKConfig+0x2dc>)
 8011542:	4013      	ands	r3, r2
 8011544:	0019      	movs	r1, r3
 8011546:	687b      	ldr	r3, [r7, #4]
 8011548:	699a      	ldr	r2, [r3, #24]
 801154a:	4b1b      	ldr	r3, [pc, #108]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 801154c:	430a      	orrs	r2, r1
 801154e:	64da      	str	r2, [r3, #76]	; 0x4c
  }

#if defined (RCC_CCIPR_I2C3SEL)
    /*------------------------------ I2C3 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8011550:	687b      	ldr	r3, [r7, #4]
 8011552:	681a      	ldr	r2, [r3, #0]
 8011554:	2380      	movs	r3, #128	; 0x80
 8011556:	005b      	lsls	r3, r3, #1
 8011558:	4013      	ands	r3, r2
 801155a:	d009      	beq.n	8011570 <HAL_RCCEx_PeriphCLKConfig+0x274>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 801155c:	4b16      	ldr	r3, [pc, #88]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 801155e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8011560:	4a17      	ldr	r2, [pc, #92]	; (80115c0 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 8011562:	4013      	ands	r3, r2
 8011564:	0019      	movs	r1, r3
 8011566:	687b      	ldr	r3, [r7, #4]
 8011568:	69da      	ldr	r2, [r3, #28]
 801156a:	4b13      	ldr	r3, [pc, #76]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 801156c:	430a      	orrs	r2, r1
 801156e:	64da      	str	r2, [r3, #76]	; 0x4c
  }
#endif /* RCC_CCIPR_I2C3SEL */

#if defined(USB)
 /*---------------------------- USB and RNG configuration --------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 8011570:	687b      	ldr	r3, [r7, #4]
 8011572:	681b      	ldr	r3, [r3, #0]
 8011574:	2240      	movs	r2, #64	; 0x40
 8011576:	4013      	ands	r3, r2
 8011578:	d009      	beq.n	801158e <HAL_RCCEx_PeriphCLKConfig+0x292>
  {
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 801157a:	4b0f      	ldr	r3, [pc, #60]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 801157c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801157e:	4a17      	ldr	r2, [pc, #92]	; (80115dc <HAL_RCCEx_PeriphCLKConfig+0x2e0>)
 8011580:	4013      	ands	r3, r2
 8011582:	0019      	movs	r1, r3
 8011584:	687b      	ldr	r3, [r7, #4]
 8011586:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8011588:	4b0b      	ldr	r3, [pc, #44]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 801158a:	430a      	orrs	r2, r1
 801158c:	64da      	str	r2, [r3, #76]	; 0x4c
  }
#endif /* USB */

  /*---------------------------- LPTIM1 configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 801158e:	687b      	ldr	r3, [r7, #4]
 8011590:	681b      	ldr	r3, [r3, #0]
 8011592:	2280      	movs	r2, #128	; 0x80
 8011594:	4013      	ands	r3, r2
 8011596:	d009      	beq.n	80115ac <HAL_RCCEx_PeriphCLKConfig+0x2b0>
  {
    assert_param(IS_RCC_LPTIMCLK(PeriphClkInit->LptimClockSelection));
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->LptimClockSelection);
 8011598:	4b07      	ldr	r3, [pc, #28]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 801159a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801159c:	4a10      	ldr	r2, [pc, #64]	; (80115e0 <HAL_RCCEx_PeriphCLKConfig+0x2e4>)
 801159e:	4013      	ands	r3, r2
 80115a0:	0019      	movs	r1, r3
 80115a2:	687b      	ldr	r3, [r7, #4]
 80115a4:	6a1a      	ldr	r2, [r3, #32]
 80115a6:	4b04      	ldr	r3, [pc, #16]	; (80115b8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
 80115a8:	430a      	orrs	r2, r1
 80115aa:	64da      	str	r2, [r3, #76]	; 0x4c
  }

  return HAL_OK;
 80115ac:	2300      	movs	r3, #0
}
 80115ae:	0018      	movs	r0, r3
 80115b0:	46bd      	mov	sp, r7
 80115b2:	b006      	add	sp, #24
 80115b4:	bd80      	pop	{r7, pc}
 80115b6:	46c0      	nop			; (mov r8, r8)
 80115b8:	40021000 	.word	0x40021000
 80115bc:	40007000 	.word	0x40007000
 80115c0:	fffcffff 	.word	0xfffcffff
 80115c4:	fff7ffff 	.word	0xfff7ffff
 80115c8:	00001388 	.word	0x00001388
 80115cc:	ffcfffff 	.word	0xffcfffff
 80115d0:	efffffff 	.word	0xefffffff
 80115d4:	fffff3ff 	.word	0xfffff3ff
 80115d8:	ffffcfff 	.word	0xffffcfff
 80115dc:	fbffffff 	.word	0xfbffffff
 80115e0:	fff3ffff 	.word	0xfff3ffff

080115e4 <HAL_TIM_OC_Init>:
  *         Ex: call @ref HAL_TIM_OC_DeInit() before HAL_TIM_OC_Init()
  * @param  htim TIM Output Compare handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef *htim)
{
 80115e4:	b580      	push	{r7, lr}
 80115e6:	b082      	sub	sp, #8
 80115e8:	af00      	add	r7, sp, #0
 80115ea:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 80115ec:	687b      	ldr	r3, [r7, #4]
 80115ee:	2b00      	cmp	r3, #0
 80115f0:	d101      	bne.n	80115f6 <HAL_TIM_OC_Init+0x12>
  {
    return HAL_ERROR;
 80115f2:	2301      	movs	r3, #1
 80115f4:	e01e      	b.n	8011634 <HAL_TIM_OC_Init+0x50>
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_PERIOD(htim->Init.Period));
  assert_param(IS_TIM_PRESCALER(htim->Init.Prescaler));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 80115f6:	687b      	ldr	r3, [r7, #4]
 80115f8:	2239      	movs	r2, #57	; 0x39
 80115fa:	5c9b      	ldrb	r3, [r3, r2]
 80115fc:	b2db      	uxtb	r3, r3
 80115fe:	2b00      	cmp	r3, #0
 8011600:	d107      	bne.n	8011612 <HAL_TIM_OC_Init+0x2e>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 8011602:	687b      	ldr	r3, [r7, #4]
 8011604:	2238      	movs	r2, #56	; 0x38
 8011606:	2100      	movs	r1, #0
 8011608:	5499      	strb	r1, [r3, r2]
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->OC_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_OC_MspInit(htim);
 801160a:	687b      	ldr	r3, [r7, #4]
 801160c:	0018      	movs	r0, r3
 801160e:	f7f4 fc05 	bl	8005e1c <HAL_TIM_OC_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 8011612:	687b      	ldr	r3, [r7, #4]
 8011614:	2239      	movs	r2, #57	; 0x39
 8011616:	2102      	movs	r1, #2
 8011618:	5499      	strb	r1, [r3, r2]

  /* Init the base time for the Output Compare */
  TIM_Base_SetConfig(htim->Instance,  &htim->Init);
 801161a:	687b      	ldr	r3, [r7, #4]
 801161c:	681a      	ldr	r2, [r3, #0]
 801161e:	687b      	ldr	r3, [r7, #4]
 8011620:	3304      	adds	r3, #4
 8011622:	0019      	movs	r1, r3
 8011624:	0010      	movs	r0, r2
 8011626:	f000 fb63 	bl	8011cf0 <TIM_Base_SetConfig>

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 801162a:	687b      	ldr	r3, [r7, #4]
 801162c:	2239      	movs	r2, #57	; 0x39
 801162e:	2101      	movs	r1, #1
 8011630:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 8011632:	2300      	movs	r3, #0
}
 8011634:	0018      	movs	r0, r3
 8011636:	46bd      	mov	sp, r7
 8011638:	b002      	add	sp, #8
 801163a:	bd80      	pop	{r7, pc}

0801163c <HAL_TIM_OC_DeInit>:
  * @brief  DeInitializes the TIM peripheral
  * @param  htim TIM Output Compare handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
{
 801163c:	b580      	push	{r7, lr}
 801163e:	b082      	sub	sp, #8
 8011640:	af00      	add	r7, sp, #0
 8011642:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  htim->State = HAL_TIM_STATE_BUSY;
 8011644:	687b      	ldr	r3, [r7, #4]
 8011646:	2239      	movs	r2, #57	; 0x39
 8011648:	2102      	movs	r1, #2
 801164a:	5499      	strb	r1, [r3, r2]

  /* Disable the TIM Peripheral Clock */
  __HAL_TIM_DISABLE(htim);
 801164c:	687b      	ldr	r3, [r7, #4]
 801164e:	681b      	ldr	r3, [r3, #0]
 8011650:	6a1b      	ldr	r3, [r3, #32]
 8011652:	4a0e      	ldr	r2, [pc, #56]	; (801168c <HAL_TIM_OC_DeInit+0x50>)
 8011654:	4013      	ands	r3, r2
 8011656:	d107      	bne.n	8011668 <HAL_TIM_OC_DeInit+0x2c>
 8011658:	687b      	ldr	r3, [r7, #4]
 801165a:	681b      	ldr	r3, [r3, #0]
 801165c:	681a      	ldr	r2, [r3, #0]
 801165e:	687b      	ldr	r3, [r7, #4]
 8011660:	681b      	ldr	r3, [r3, #0]
 8011662:	2101      	movs	r1, #1
 8011664:	438a      	bics	r2, r1
 8011666:	601a      	str	r2, [r3, #0]
  }
  /* DeInit the low level hardware */
  htim->OC_MspDeInitCallback(htim);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
  HAL_TIM_OC_MspDeInit(htim);
 8011668:	687b      	ldr	r3, [r7, #4]
 801166a:	0018      	movs	r0, r3
 801166c:	f7f4 fc0c 	bl	8005e88 <HAL_TIM_OC_MspDeInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */

  /* Change TIM state */
  htim->State = HAL_TIM_STATE_RESET;
 8011670:	687b      	ldr	r3, [r7, #4]
 8011672:	2239      	movs	r2, #57	; 0x39
 8011674:	2100      	movs	r1, #0
 8011676:	5499      	strb	r1, [r3, r2]

  /* Release Lock */
  __HAL_UNLOCK(htim);
 8011678:	687b      	ldr	r3, [r7, #4]
 801167a:	2238      	movs	r2, #56	; 0x38
 801167c:	2100      	movs	r1, #0
 801167e:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 8011680:	2300      	movs	r3, #0
}
 8011682:	0018      	movs	r0, r3
 8011684:	46bd      	mov	sp, r7
 8011686:	b002      	add	sp, #8
 8011688:	bd80      	pop	{r7, pc}
 801168a:	46c0      	nop			; (mov r8, r8)
 801168c:	00001111 	.word	0x00001111

08011690 <HAL_TIM_OC_Start_IT>:
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
{
 8011690:	b580      	push	{r7, lr}
 8011692:	b084      	sub	sp, #16
 8011694:	af00      	add	r7, sp, #0
 8011696:	6078      	str	r0, [r7, #4]
 8011698:	6039      	str	r1, [r7, #0]
  uint32_t tmpsmcr;

  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  switch (Channel)
 801169a:	683b      	ldr	r3, [r7, #0]
 801169c:	2b04      	cmp	r3, #4
 801169e:	d011      	beq.n	80116c4 <HAL_TIM_OC_Start_IT+0x34>
 80116a0:	d802      	bhi.n	80116a8 <HAL_TIM_OC_Start_IT+0x18>
 80116a2:	2b00      	cmp	r3, #0
 80116a4:	d005      	beq.n	80116b2 <HAL_TIM_OC_Start_IT+0x22>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
      break;
    }

    default:
      break;
 80116a6:	e028      	b.n	80116fa <HAL_TIM_OC_Start_IT+0x6a>
  switch (Channel)
 80116a8:	2b08      	cmp	r3, #8
 80116aa:	d014      	beq.n	80116d6 <HAL_TIM_OC_Start_IT+0x46>
 80116ac:	2b0c      	cmp	r3, #12
 80116ae:	d01b      	beq.n	80116e8 <HAL_TIM_OC_Start_IT+0x58>
      break;
 80116b0:	e023      	b.n	80116fa <HAL_TIM_OC_Start_IT+0x6a>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
 80116b2:	687b      	ldr	r3, [r7, #4]
 80116b4:	681b      	ldr	r3, [r3, #0]
 80116b6:	68da      	ldr	r2, [r3, #12]
 80116b8:	687b      	ldr	r3, [r7, #4]
 80116ba:	681b      	ldr	r3, [r3, #0]
 80116bc:	2102      	movs	r1, #2
 80116be:	430a      	orrs	r2, r1
 80116c0:	60da      	str	r2, [r3, #12]
      break;
 80116c2:	e01a      	b.n	80116fa <HAL_TIM_OC_Start_IT+0x6a>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
 80116c4:	687b      	ldr	r3, [r7, #4]
 80116c6:	681b      	ldr	r3, [r3, #0]
 80116c8:	68da      	ldr	r2, [r3, #12]
 80116ca:	687b      	ldr	r3, [r7, #4]
 80116cc:	681b      	ldr	r3, [r3, #0]
 80116ce:	2104      	movs	r1, #4
 80116d0:	430a      	orrs	r2, r1
 80116d2:	60da      	str	r2, [r3, #12]
      break;
 80116d4:	e011      	b.n	80116fa <HAL_TIM_OC_Start_IT+0x6a>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
 80116d6:	687b      	ldr	r3, [r7, #4]
 80116d8:	681b      	ldr	r3, [r3, #0]
 80116da:	68da      	ldr	r2, [r3, #12]
 80116dc:	687b      	ldr	r3, [r7, #4]
 80116de:	681b      	ldr	r3, [r3, #0]
 80116e0:	2108      	movs	r1, #8
 80116e2:	430a      	orrs	r2, r1
 80116e4:	60da      	str	r2, [r3, #12]
      break;
 80116e6:	e008      	b.n	80116fa <HAL_TIM_OC_Start_IT+0x6a>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
 80116e8:	687b      	ldr	r3, [r7, #4]
 80116ea:	681b      	ldr	r3, [r3, #0]
 80116ec:	68da      	ldr	r2, [r3, #12]
 80116ee:	687b      	ldr	r3, [r7, #4]
 80116f0:	681b      	ldr	r3, [r3, #0]
 80116f2:	2110      	movs	r1, #16
 80116f4:	430a      	orrs	r2, r1
 80116f6:	60da      	str	r2, [r3, #12]
      break;
 80116f8:	46c0      	nop			; (mov r8, r8)
  }

  /* Enable the Output compare channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 80116fa:	687b      	ldr	r3, [r7, #4]
 80116fc:	681b      	ldr	r3, [r3, #0]
 80116fe:	6839      	ldr	r1, [r7, #0]
 8011700:	2201      	movs	r2, #1
 8011702:	0018      	movs	r0, r3
 8011704:	f000 fc56 	bl	8011fb4 <TIM_CCxChannelCmd>

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8011708:	687b      	ldr	r3, [r7, #4]
 801170a:	681b      	ldr	r3, [r3, #0]
 801170c:	689b      	ldr	r3, [r3, #8]
 801170e:	2207      	movs	r2, #7
 8011710:	4013      	ands	r3, r2
 8011712:	60fb      	str	r3, [r7, #12]
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8011714:	68fb      	ldr	r3, [r7, #12]
 8011716:	2b06      	cmp	r3, #6
 8011718:	d007      	beq.n	801172a <HAL_TIM_OC_Start_IT+0x9a>
  {
    __HAL_TIM_ENABLE(htim);
 801171a:	687b      	ldr	r3, [r7, #4]
 801171c:	681b      	ldr	r3, [r3, #0]
 801171e:	681a      	ldr	r2, [r3, #0]
 8011720:	687b      	ldr	r3, [r7, #4]
 8011722:	681b      	ldr	r3, [r3, #0]
 8011724:	2101      	movs	r1, #1
 8011726:	430a      	orrs	r2, r1
 8011728:	601a      	str	r2, [r3, #0]
  }

  /* Return function status */
  return HAL_OK;
 801172a:	2300      	movs	r3, #0
}
 801172c:	0018      	movs	r0, r3
 801172e:	46bd      	mov	sp, r7
 8011730:	b004      	add	sp, #16
 8011732:	bd80      	pop	{r7, pc}

08011734 <HAL_TIM_OC_Stop_IT>:
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
{
 8011734:	b580      	push	{r7, lr}
 8011736:	b082      	sub	sp, #8
 8011738:	af00      	add	r7, sp, #0
 801173a:	6078      	str	r0, [r7, #4]
 801173c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  switch (Channel)
 801173e:	683b      	ldr	r3, [r7, #0]
 8011740:	2b04      	cmp	r3, #4
 8011742:	d011      	beq.n	8011768 <HAL_TIM_OC_Stop_IT+0x34>
 8011744:	d802      	bhi.n	801174c <HAL_TIM_OC_Stop_IT+0x18>
 8011746:	2b00      	cmp	r3, #0
 8011748:	d005      	beq.n	8011756 <HAL_TIM_OC_Stop_IT+0x22>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
      break;
    }

    default:
      break;
 801174a:	e028      	b.n	801179e <HAL_TIM_OC_Stop_IT+0x6a>
  switch (Channel)
 801174c:	2b08      	cmp	r3, #8
 801174e:	d014      	beq.n	801177a <HAL_TIM_OC_Stop_IT+0x46>
 8011750:	2b0c      	cmp	r3, #12
 8011752:	d01b      	beq.n	801178c <HAL_TIM_OC_Stop_IT+0x58>
      break;
 8011754:	e023      	b.n	801179e <HAL_TIM_OC_Stop_IT+0x6a>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
 8011756:	687b      	ldr	r3, [r7, #4]
 8011758:	681b      	ldr	r3, [r3, #0]
 801175a:	68da      	ldr	r2, [r3, #12]
 801175c:	687b      	ldr	r3, [r7, #4]
 801175e:	681b      	ldr	r3, [r3, #0]
 8011760:	2102      	movs	r1, #2
 8011762:	438a      	bics	r2, r1
 8011764:	60da      	str	r2, [r3, #12]
      break;
 8011766:	e01a      	b.n	801179e <HAL_TIM_OC_Stop_IT+0x6a>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
 8011768:	687b      	ldr	r3, [r7, #4]
 801176a:	681b      	ldr	r3, [r3, #0]
 801176c:	68da      	ldr	r2, [r3, #12]
 801176e:	687b      	ldr	r3, [r7, #4]
 8011770:	681b      	ldr	r3, [r3, #0]
 8011772:	2104      	movs	r1, #4
 8011774:	438a      	bics	r2, r1
 8011776:	60da      	str	r2, [r3, #12]
      break;
 8011778:	e011      	b.n	801179e <HAL_TIM_OC_Stop_IT+0x6a>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
 801177a:	687b      	ldr	r3, [r7, #4]
 801177c:	681b      	ldr	r3, [r3, #0]
 801177e:	68da      	ldr	r2, [r3, #12]
 8011780:	687b      	ldr	r3, [r7, #4]
 8011782:	681b      	ldr	r3, [r3, #0]
 8011784:	2108      	movs	r1, #8
 8011786:	438a      	bics	r2, r1
 8011788:	60da      	str	r2, [r3, #12]
      break;
 801178a:	e008      	b.n	801179e <HAL_TIM_OC_Stop_IT+0x6a>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
 801178c:	687b      	ldr	r3, [r7, #4]
 801178e:	681b      	ldr	r3, [r3, #0]
 8011790:	68da      	ldr	r2, [r3, #12]
 8011792:	687b      	ldr	r3, [r7, #4]
 8011794:	681b      	ldr	r3, [r3, #0]
 8011796:	2110      	movs	r1, #16
 8011798:	438a      	bics	r2, r1
 801179a:	60da      	str	r2, [r3, #12]
      break;
 801179c:	46c0      	nop			; (mov r8, r8)
  }

  /* Disable the Output compare channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
 801179e:	687b      	ldr	r3, [r7, #4]
 80117a0:	681b      	ldr	r3, [r3, #0]
 80117a2:	6839      	ldr	r1, [r7, #0]
 80117a4:	2200      	movs	r2, #0
 80117a6:	0018      	movs	r0, r3
 80117a8:	f000 fc04 	bl	8011fb4 <TIM_CCxChannelCmd>

  /* Disable the Peripheral */
  __HAL_TIM_DISABLE(htim);
 80117ac:	687b      	ldr	r3, [r7, #4]
 80117ae:	681b      	ldr	r3, [r3, #0]
 80117b0:	6a1b      	ldr	r3, [r3, #32]
 80117b2:	4a08      	ldr	r2, [pc, #32]	; (80117d4 <HAL_TIM_OC_Stop_IT+0xa0>)
 80117b4:	4013      	ands	r3, r2
 80117b6:	d107      	bne.n	80117c8 <HAL_TIM_OC_Stop_IT+0x94>
 80117b8:	687b      	ldr	r3, [r7, #4]
 80117ba:	681b      	ldr	r3, [r3, #0]
 80117bc:	681a      	ldr	r2, [r3, #0]
 80117be:	687b      	ldr	r3, [r7, #4]
 80117c0:	681b      	ldr	r3, [r3, #0]
 80117c2:	2101      	movs	r1, #1
 80117c4:	438a      	bics	r2, r1
 80117c6:	601a      	str	r2, [r3, #0]

  /* Return function status */
  return HAL_OK;
 80117c8:	2300      	movs	r3, #0
}
 80117ca:	0018      	movs	r0, r3
 80117cc:	46bd      	mov	sp, r7
 80117ce:	b002      	add	sp, #8
 80117d0:	bd80      	pop	{r7, pc}
 80117d2:	46c0      	nop			; (mov r8, r8)
 80117d4:	00001111 	.word	0x00001111

080117d8 <HAL_TIM_PWM_Init>:
  *         Ex: call @ref HAL_TIM_PWM_DeInit() before HAL_TIM_PWM_Init()
  * @param  htim TIM PWM handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
{
 80117d8:	b580      	push	{r7, lr}
 80117da:	b082      	sub	sp, #8
 80117dc:	af00      	add	r7, sp, #0
 80117de:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 80117e0:	687b      	ldr	r3, [r7, #4]
 80117e2:	2b00      	cmp	r3, #0
 80117e4:	d101      	bne.n	80117ea <HAL_TIM_PWM_Init+0x12>
  {
    return HAL_ERROR;
 80117e6:	2301      	movs	r3, #1
 80117e8:	e01e      	b.n	8011828 <HAL_TIM_PWM_Init+0x50>
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_PERIOD(htim->Init.Period));
  assert_param(IS_TIM_PRESCALER(htim->Init.Prescaler));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 80117ea:	687b      	ldr	r3, [r7, #4]
 80117ec:	2239      	movs	r2, #57	; 0x39
 80117ee:	5c9b      	ldrb	r3, [r3, r2]
 80117f0:	b2db      	uxtb	r3, r3
 80117f2:	2b00      	cmp	r3, #0
 80117f4:	d107      	bne.n	8011806 <HAL_TIM_PWM_Init+0x2e>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 80117f6:	687b      	ldr	r3, [r7, #4]
 80117f8:	2238      	movs	r2, #56	; 0x38
 80117fa:	2100      	movs	r1, #0
 80117fc:	5499      	strb	r1, [r3, r2]
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->PWM_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_PWM_MspInit(htim);
 80117fe:	687b      	ldr	r3, [r7, #4]
 8011800:	0018      	movs	r0, r3
 8011802:	f7f4 fadb 	bl	8005dbc <HAL_TIM_PWM_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 8011806:	687b      	ldr	r3, [r7, #4]
 8011808:	2239      	movs	r2, #57	; 0x39
 801180a:	2102      	movs	r1, #2
 801180c:	5499      	strb	r1, [r3, r2]

  /* Init the base time for the PWM */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 801180e:	687b      	ldr	r3, [r7, #4]
 8011810:	681a      	ldr	r2, [r3, #0]
 8011812:	687b      	ldr	r3, [r7, #4]
 8011814:	3304      	adds	r3, #4
 8011816:	0019      	movs	r1, r3
 8011818:	0010      	movs	r0, r2
 801181a:	f000 fa69 	bl	8011cf0 <TIM_Base_SetConfig>

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 801181e:	687b      	ldr	r3, [r7, #4]
 8011820:	2239      	movs	r2, #57	; 0x39
 8011822:	2101      	movs	r1, #1
 8011824:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 8011826:	2300      	movs	r3, #0
}
 8011828:	0018      	movs	r0, r3
 801182a:	46bd      	mov	sp, r7
 801182c:	b002      	add	sp, #8
 801182e:	bd80      	pop	{r7, pc}

08011830 <HAL_TIM_PWM_Start_IT>:
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
{
 8011830:	b580      	push	{r7, lr}
 8011832:	b084      	sub	sp, #16
 8011834:	af00      	add	r7, sp, #0
 8011836:	6078      	str	r0, [r7, #4]
 8011838:	6039      	str	r1, [r7, #0]
  uint32_t tmpsmcr;
  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  switch (Channel)
 801183a:	683b      	ldr	r3, [r7, #0]
 801183c:	2b04      	cmp	r3, #4
 801183e:	d011      	beq.n	8011864 <HAL_TIM_PWM_Start_IT+0x34>
 8011840:	d802      	bhi.n	8011848 <HAL_TIM_PWM_Start_IT+0x18>
 8011842:	2b00      	cmp	r3, #0
 8011844:	d005      	beq.n	8011852 <HAL_TIM_PWM_Start_IT+0x22>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
      break;
    }

    default:
      break;
 8011846:	e028      	b.n	801189a <HAL_TIM_PWM_Start_IT+0x6a>
  switch (Channel)
 8011848:	2b08      	cmp	r3, #8
 801184a:	d014      	beq.n	8011876 <HAL_TIM_PWM_Start_IT+0x46>
 801184c:	2b0c      	cmp	r3, #12
 801184e:	d01b      	beq.n	8011888 <HAL_TIM_PWM_Start_IT+0x58>
      break;
 8011850:	e023      	b.n	801189a <HAL_TIM_PWM_Start_IT+0x6a>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
 8011852:	687b      	ldr	r3, [r7, #4]
 8011854:	681b      	ldr	r3, [r3, #0]
 8011856:	68da      	ldr	r2, [r3, #12]
 8011858:	687b      	ldr	r3, [r7, #4]
 801185a:	681b      	ldr	r3, [r3, #0]
 801185c:	2102      	movs	r1, #2
 801185e:	430a      	orrs	r2, r1
 8011860:	60da      	str	r2, [r3, #12]
      break;
 8011862:	e01a      	b.n	801189a <HAL_TIM_PWM_Start_IT+0x6a>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
 8011864:	687b      	ldr	r3, [r7, #4]
 8011866:	681b      	ldr	r3, [r3, #0]
 8011868:	68da      	ldr	r2, [r3, #12]
 801186a:	687b      	ldr	r3, [r7, #4]
 801186c:	681b      	ldr	r3, [r3, #0]
 801186e:	2104      	movs	r1, #4
 8011870:	430a      	orrs	r2, r1
 8011872:	60da      	str	r2, [r3, #12]
      break;
 8011874:	e011      	b.n	801189a <HAL_TIM_PWM_Start_IT+0x6a>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
 8011876:	687b      	ldr	r3, [r7, #4]
 8011878:	681b      	ldr	r3, [r3, #0]
 801187a:	68da      	ldr	r2, [r3, #12]
 801187c:	687b      	ldr	r3, [r7, #4]
 801187e:	681b      	ldr	r3, [r3, #0]
 8011880:	2108      	movs	r1, #8
 8011882:	430a      	orrs	r2, r1
 8011884:	60da      	str	r2, [r3, #12]
      break;
 8011886:	e008      	b.n	801189a <HAL_TIM_PWM_Start_IT+0x6a>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
 8011888:	687b      	ldr	r3, [r7, #4]
 801188a:	681b      	ldr	r3, [r3, #0]
 801188c:	68da      	ldr	r2, [r3, #12]
 801188e:	687b      	ldr	r3, [r7, #4]
 8011890:	681b      	ldr	r3, [r3, #0]
 8011892:	2110      	movs	r1, #16
 8011894:	430a      	orrs	r2, r1
 8011896:	60da      	str	r2, [r3, #12]
      break;
 8011898:	46c0      	nop			; (mov r8, r8)
  }

  /* Enable the Capture compare channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 801189a:	687b      	ldr	r3, [r7, #4]
 801189c:	681b      	ldr	r3, [r3, #0]
 801189e:	6839      	ldr	r1, [r7, #0]
 80118a0:	2201      	movs	r2, #1
 80118a2:	0018      	movs	r0, r3
 80118a4:	f000 fb86 	bl	8011fb4 <TIM_CCxChannelCmd>

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 80118a8:	687b      	ldr	r3, [r7, #4]
 80118aa:	681b      	ldr	r3, [r3, #0]
 80118ac:	689b      	ldr	r3, [r3, #8]
 80118ae:	2207      	movs	r2, #7
 80118b0:	4013      	ands	r3, r2
 80118b2:	60fb      	str	r3, [r7, #12]
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 80118b4:	68fb      	ldr	r3, [r7, #12]
 80118b6:	2b06      	cmp	r3, #6
 80118b8:	d007      	beq.n	80118ca <HAL_TIM_PWM_Start_IT+0x9a>
  {
    __HAL_TIM_ENABLE(htim);
 80118ba:	687b      	ldr	r3, [r7, #4]
 80118bc:	681b      	ldr	r3, [r3, #0]
 80118be:	681a      	ldr	r2, [r3, #0]
 80118c0:	687b      	ldr	r3, [r7, #4]
 80118c2:	681b      	ldr	r3, [r3, #0]
 80118c4:	2101      	movs	r1, #1
 80118c6:	430a      	orrs	r2, r1
 80118c8:	601a      	str	r2, [r3, #0]
  }

  /* Return function status */
  return HAL_OK;
 80118ca:	2300      	movs	r3, #0
}
 80118cc:	0018      	movs	r0, r3
 80118ce:	46bd      	mov	sp, r7
 80118d0:	b004      	add	sp, #16
 80118d2:	bd80      	pop	{r7, pc}

080118d4 <HAL_TIM_IRQHandler>:
  * @brief  This function handles TIM interrupts requests.
  * @param  htim TIM  handle
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
 80118d4:	b580      	push	{r7, lr}
 80118d6:	b082      	sub	sp, #8
 80118d8:	af00      	add	r7, sp, #0
 80118da:	6078      	str	r0, [r7, #4]
  /* Capture compare 1 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 80118dc:	687b      	ldr	r3, [r7, #4]
 80118de:	681b      	ldr	r3, [r3, #0]
 80118e0:	691b      	ldr	r3, [r3, #16]
 80118e2:	2202      	movs	r2, #2
 80118e4:	4013      	ands	r3, r2
 80118e6:	2b02      	cmp	r3, #2
 80118e8:	d124      	bne.n	8011934 <HAL_TIM_IRQHandler+0x60>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 80118ea:	687b      	ldr	r3, [r7, #4]
 80118ec:	681b      	ldr	r3, [r3, #0]
 80118ee:	68db      	ldr	r3, [r3, #12]
 80118f0:	2202      	movs	r2, #2
 80118f2:	4013      	ands	r3, r2
 80118f4:	2b02      	cmp	r3, #2
 80118f6:	d11d      	bne.n	8011934 <HAL_TIM_IRQHandler+0x60>
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 80118f8:	687b      	ldr	r3, [r7, #4]
 80118fa:	681b      	ldr	r3, [r3, #0]
 80118fc:	2203      	movs	r2, #3
 80118fe:	4252      	negs	r2, r2
 8011900:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8011902:	687b      	ldr	r3, [r7, #4]
 8011904:	2201      	movs	r2, #1
 8011906:	761a      	strb	r2, [r3, #24]

        /* Input capture event */
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8011908:	687b      	ldr	r3, [r7, #4]
 801190a:	681b      	ldr	r3, [r3, #0]
 801190c:	699b      	ldr	r3, [r3, #24]
 801190e:	2203      	movs	r2, #3
 8011910:	4013      	ands	r3, r2
 8011912:	d004      	beq.n	801191e <HAL_TIM_IRQHandler+0x4a>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->IC_CaptureCallback(htim);
#else
          HAL_TIM_IC_CaptureCallback(htim);
 8011914:	687b      	ldr	r3, [r7, #4]
 8011916:	0018      	movs	r0, r3
 8011918:	f000 f9d2 	bl	8011cc0 <HAL_TIM_IC_CaptureCallback>
 801191c:	e007      	b.n	801192e <HAL_TIM_IRQHandler+0x5a>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->OC_DelayElapsedCallback(htim);
          htim->PWM_PulseFinishedCallback(htim);
#else
          HAL_TIM_OC_DelayElapsedCallback(htim);
 801191e:	687b      	ldr	r3, [r7, #4]
 8011920:	0018      	movs	r0, r3
 8011922:	f7f4 fad1 	bl	8005ec8 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8011926:	687b      	ldr	r3, [r7, #4]
 8011928:	0018      	movs	r0, r3
 801192a:	f000 f9d1 	bl	8011cd0 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 801192e:	687b      	ldr	r3, [r7, #4]
 8011930:	2200      	movs	r2, #0
 8011932:	761a      	strb	r2, [r3, #24]
      }
    }
  }
  /* Capture compare 2 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8011934:	687b      	ldr	r3, [r7, #4]
 8011936:	681b      	ldr	r3, [r3, #0]
 8011938:	691b      	ldr	r3, [r3, #16]
 801193a:	2204      	movs	r2, #4
 801193c:	4013      	ands	r3, r2
 801193e:	2b04      	cmp	r3, #4
 8011940:	d125      	bne.n	801198e <HAL_TIM_IRQHandler+0xba>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 8011942:	687b      	ldr	r3, [r7, #4]
 8011944:	681b      	ldr	r3, [r3, #0]
 8011946:	68db      	ldr	r3, [r3, #12]
 8011948:	2204      	movs	r2, #4
 801194a:	4013      	ands	r3, r2
 801194c:	2b04      	cmp	r3, #4
 801194e:	d11e      	bne.n	801198e <HAL_TIM_IRQHandler+0xba>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8011950:	687b      	ldr	r3, [r7, #4]
 8011952:	681b      	ldr	r3, [r3, #0]
 8011954:	2205      	movs	r2, #5
 8011956:	4252      	negs	r2, r2
 8011958:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 801195a:	687b      	ldr	r3, [r7, #4]
 801195c:	2202      	movs	r2, #2
 801195e:	761a      	strb	r2, [r3, #24]
      /* Input capture event */
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8011960:	687b      	ldr	r3, [r7, #4]
 8011962:	681b      	ldr	r3, [r3, #0]
 8011964:	699a      	ldr	r2, [r3, #24]
 8011966:	23c0      	movs	r3, #192	; 0xc0
 8011968:	009b      	lsls	r3, r3, #2
 801196a:	4013      	ands	r3, r2
 801196c:	d004      	beq.n	8011978 <HAL_TIM_IRQHandler+0xa4>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 801196e:	687b      	ldr	r3, [r7, #4]
 8011970:	0018      	movs	r0, r3
 8011972:	f000 f9a5 	bl	8011cc0 <HAL_TIM_IC_CaptureCallback>
 8011976:	e007      	b.n	8011988 <HAL_TIM_IRQHandler+0xb4>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8011978:	687b      	ldr	r3, [r7, #4]
 801197a:	0018      	movs	r0, r3
 801197c:	f7f4 faa4 	bl	8005ec8 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8011980:	687b      	ldr	r3, [r7, #4]
 8011982:	0018      	movs	r0, r3
 8011984:	f000 f9a4 	bl	8011cd0 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8011988:	687b      	ldr	r3, [r7, #4]
 801198a:	2200      	movs	r2, #0
 801198c:	761a      	strb	r2, [r3, #24]
    }
  }
  /* Capture compare 3 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 801198e:	687b      	ldr	r3, [r7, #4]
 8011990:	681b      	ldr	r3, [r3, #0]
 8011992:	691b      	ldr	r3, [r3, #16]
 8011994:	2208      	movs	r2, #8
 8011996:	4013      	ands	r3, r2
 8011998:	2b08      	cmp	r3, #8
 801199a:	d124      	bne.n	80119e6 <HAL_TIM_IRQHandler+0x112>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 801199c:	687b      	ldr	r3, [r7, #4]
 801199e:	681b      	ldr	r3, [r3, #0]
 80119a0:	68db      	ldr	r3, [r3, #12]
 80119a2:	2208      	movs	r2, #8
 80119a4:	4013      	ands	r3, r2
 80119a6:	2b08      	cmp	r3, #8
 80119a8:	d11d      	bne.n	80119e6 <HAL_TIM_IRQHandler+0x112>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 80119aa:	687b      	ldr	r3, [r7, #4]
 80119ac:	681b      	ldr	r3, [r3, #0]
 80119ae:	2209      	movs	r2, #9
 80119b0:	4252      	negs	r2, r2
 80119b2:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 80119b4:	687b      	ldr	r3, [r7, #4]
 80119b6:	2204      	movs	r2, #4
 80119b8:	761a      	strb	r2, [r3, #24]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 80119ba:	687b      	ldr	r3, [r7, #4]
 80119bc:	681b      	ldr	r3, [r3, #0]
 80119be:	69db      	ldr	r3, [r3, #28]
 80119c0:	2203      	movs	r2, #3
 80119c2:	4013      	ands	r3, r2
 80119c4:	d004      	beq.n	80119d0 <HAL_TIM_IRQHandler+0xfc>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 80119c6:	687b      	ldr	r3, [r7, #4]
 80119c8:	0018      	movs	r0, r3
 80119ca:	f000 f979 	bl	8011cc0 <HAL_TIM_IC_CaptureCallback>
 80119ce:	e007      	b.n	80119e0 <HAL_TIM_IRQHandler+0x10c>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 80119d0:	687b      	ldr	r3, [r7, #4]
 80119d2:	0018      	movs	r0, r3
 80119d4:	f7f4 fa78 	bl	8005ec8 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 80119d8:	687b      	ldr	r3, [r7, #4]
 80119da:	0018      	movs	r0, r3
 80119dc:	f000 f978 	bl	8011cd0 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80119e0:	687b      	ldr	r3, [r7, #4]
 80119e2:	2200      	movs	r2, #0
 80119e4:	761a      	strb	r2, [r3, #24]
    }
  }
  /* Capture compare 4 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 80119e6:	687b      	ldr	r3, [r7, #4]
 80119e8:	681b      	ldr	r3, [r3, #0]
 80119ea:	691b      	ldr	r3, [r3, #16]
 80119ec:	2210      	movs	r2, #16
 80119ee:	4013      	ands	r3, r2
 80119f0:	2b10      	cmp	r3, #16
 80119f2:	d125      	bne.n	8011a40 <HAL_TIM_IRQHandler+0x16c>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 80119f4:	687b      	ldr	r3, [r7, #4]
 80119f6:	681b      	ldr	r3, [r3, #0]
 80119f8:	68db      	ldr	r3, [r3, #12]
 80119fa:	2210      	movs	r2, #16
 80119fc:	4013      	ands	r3, r2
 80119fe:	2b10      	cmp	r3, #16
 8011a00:	d11e      	bne.n	8011a40 <HAL_TIM_IRQHandler+0x16c>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8011a02:	687b      	ldr	r3, [r7, #4]
 8011a04:	681b      	ldr	r3, [r3, #0]
 8011a06:	2211      	movs	r2, #17
 8011a08:	4252      	negs	r2, r2
 8011a0a:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8011a0c:	687b      	ldr	r3, [r7, #4]
 8011a0e:	2208      	movs	r2, #8
 8011a10:	761a      	strb	r2, [r3, #24]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8011a12:	687b      	ldr	r3, [r7, #4]
 8011a14:	681b      	ldr	r3, [r3, #0]
 8011a16:	69da      	ldr	r2, [r3, #28]
 8011a18:	23c0      	movs	r3, #192	; 0xc0
 8011a1a:	009b      	lsls	r3, r3, #2
 8011a1c:	4013      	ands	r3, r2
 8011a1e:	d004      	beq.n	8011a2a <HAL_TIM_IRQHandler+0x156>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 8011a20:	687b      	ldr	r3, [r7, #4]
 8011a22:	0018      	movs	r0, r3
 8011a24:	f000 f94c 	bl	8011cc0 <HAL_TIM_IC_CaptureCallback>
 8011a28:	e007      	b.n	8011a3a <HAL_TIM_IRQHandler+0x166>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8011a2a:	687b      	ldr	r3, [r7, #4]
 8011a2c:	0018      	movs	r0, r3
 8011a2e:	f7f4 fa4b 	bl	8005ec8 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8011a32:	687b      	ldr	r3, [r7, #4]
 8011a34:	0018      	movs	r0, r3
 8011a36:	f000 f94b 	bl	8011cd0 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8011a3a:	687b      	ldr	r3, [r7, #4]
 8011a3c:	2200      	movs	r2, #0
 8011a3e:	761a      	strb	r2, [r3, #24]
    }
  }
  /* TIM Update event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8011a40:	687b      	ldr	r3, [r7, #4]
 8011a42:	681b      	ldr	r3, [r3, #0]
 8011a44:	691b      	ldr	r3, [r3, #16]
 8011a46:	2201      	movs	r2, #1
 8011a48:	4013      	ands	r3, r2
 8011a4a:	2b01      	cmp	r3, #1
 8011a4c:	d10f      	bne.n	8011a6e <HAL_TIM_IRQHandler+0x19a>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 8011a4e:	687b      	ldr	r3, [r7, #4]
 8011a50:	681b      	ldr	r3, [r3, #0]
 8011a52:	68db      	ldr	r3, [r3, #12]
 8011a54:	2201      	movs	r2, #1
 8011a56:	4013      	ands	r3, r2
 8011a58:	2b01      	cmp	r3, #1
 8011a5a:	d108      	bne.n	8011a6e <HAL_TIM_IRQHandler+0x19a>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8011a5c:	687b      	ldr	r3, [r7, #4]
 8011a5e:	681b      	ldr	r3, [r3, #0]
 8011a60:	2202      	movs	r2, #2
 8011a62:	4252      	negs	r2, r2
 8011a64:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->PeriodElapsedCallback(htim);
#else
      HAL_TIM_PeriodElapsedCallback(htim);
 8011a66:	687b      	ldr	r3, [r7, #4]
 8011a68:	0018      	movs	r0, r3
 8011a6a:	f000 f921 	bl	8011cb0 <HAL_TIM_PeriodElapsedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Trigger detection event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8011a6e:	687b      	ldr	r3, [r7, #4]
 8011a70:	681b      	ldr	r3, [r3, #0]
 8011a72:	691b      	ldr	r3, [r3, #16]
 8011a74:	2240      	movs	r2, #64	; 0x40
 8011a76:	4013      	ands	r3, r2
 8011a78:	2b40      	cmp	r3, #64	; 0x40
 8011a7a:	d10f      	bne.n	8011a9c <HAL_TIM_IRQHandler+0x1c8>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 8011a7c:	687b      	ldr	r3, [r7, #4]
 8011a7e:	681b      	ldr	r3, [r3, #0]
 8011a80:	68db      	ldr	r3, [r3, #12]
 8011a82:	2240      	movs	r2, #64	; 0x40
 8011a84:	4013      	ands	r3, r2
 8011a86:	2b40      	cmp	r3, #64	; 0x40
 8011a88:	d108      	bne.n	8011a9c <HAL_TIM_IRQHandler+0x1c8>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 8011a8a:	687b      	ldr	r3, [r7, #4]
 8011a8c:	681b      	ldr	r3, [r3, #0]
 8011a8e:	2241      	movs	r2, #65	; 0x41
 8011a90:	4252      	negs	r2, r2
 8011a92:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TriggerCallback(htim);
#else
      HAL_TIM_TriggerCallback(htim);
 8011a94:	687b      	ldr	r3, [r7, #4]
 8011a96:	0018      	movs	r0, r3
 8011a98:	f000 f922 	bl	8011ce0 <HAL_TIM_TriggerCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
}
 8011a9c:	46c0      	nop			; (mov r8, r8)
 8011a9e:	46bd      	mov	sp, r7
 8011aa0:	b002      	add	sp, #8
 8011aa2:	bd80      	pop	{r7, pc}

08011aa4 <HAL_TIM_OC_ConfigChannel>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim,
                                           TIM_OC_InitTypeDef *sConfig,
                                           uint32_t Channel)
{
 8011aa4:	b580      	push	{r7, lr}
 8011aa6:	b084      	sub	sp, #16
 8011aa8:	af00      	add	r7, sp, #0
 8011aaa:	60f8      	str	r0, [r7, #12]
 8011aac:	60b9      	str	r1, [r7, #8]
 8011aae:	607a      	str	r2, [r7, #4]
  assert_param(IS_TIM_CHANNELS(Channel));
  assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));

  /* Process Locked */
  __HAL_LOCK(htim);
 8011ab0:	68fb      	ldr	r3, [r7, #12]
 8011ab2:	2238      	movs	r2, #56	; 0x38
 8011ab4:	5c9b      	ldrb	r3, [r3, r2]
 8011ab6:	2b01      	cmp	r3, #1
 8011ab8:	d101      	bne.n	8011abe <HAL_TIM_OC_ConfigChannel+0x1a>
 8011aba:	2302      	movs	r3, #2
 8011abc:	e03c      	b.n	8011b38 <HAL_TIM_OC_ConfigChannel+0x94>
 8011abe:	68fb      	ldr	r3, [r7, #12]
 8011ac0:	2238      	movs	r2, #56	; 0x38
 8011ac2:	2101      	movs	r1, #1
 8011ac4:	5499      	strb	r1, [r3, r2]

  htim->State = HAL_TIM_STATE_BUSY;
 8011ac6:	68fb      	ldr	r3, [r7, #12]
 8011ac8:	2239      	movs	r2, #57	; 0x39
 8011aca:	2102      	movs	r1, #2
 8011acc:	5499      	strb	r1, [r3, r2]

  switch (Channel)
 8011ace:	687b      	ldr	r3, [r7, #4]
 8011ad0:	2b04      	cmp	r3, #4
 8011ad2:	d010      	beq.n	8011af6 <HAL_TIM_OC_ConfigChannel+0x52>
 8011ad4:	d802      	bhi.n	8011adc <HAL_TIM_OC_ConfigChannel+0x38>
 8011ad6:	2b00      	cmp	r3, #0
 8011ad8:	d005      	beq.n	8011ae6 <HAL_TIM_OC_ConfigChannel+0x42>
      TIM_OC4_SetConfig(htim->Instance, sConfig);
      break;
    }

    default:
      break;
 8011ada:	e024      	b.n	8011b26 <HAL_TIM_OC_ConfigChannel+0x82>
  switch (Channel)
 8011adc:	2b08      	cmp	r3, #8
 8011ade:	d012      	beq.n	8011b06 <HAL_TIM_OC_ConfigChannel+0x62>
 8011ae0:	2b0c      	cmp	r3, #12
 8011ae2:	d018      	beq.n	8011b16 <HAL_TIM_OC_ConfigChannel+0x72>
      break;
 8011ae4:	e01f      	b.n	8011b26 <HAL_TIM_OC_ConfigChannel+0x82>
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 8011ae6:	68fb      	ldr	r3, [r7, #12]
 8011ae8:	681b      	ldr	r3, [r3, #0]
 8011aea:	68ba      	ldr	r2, [r7, #8]
 8011aec:	0011      	movs	r1, r2
 8011aee:	0018      	movs	r0, r3
 8011af0:	f000 f95c 	bl	8011dac <TIM_OC1_SetConfig>
      break;
 8011af4:	e017      	b.n	8011b26 <HAL_TIM_OC_ConfigChannel+0x82>
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 8011af6:	68fb      	ldr	r3, [r7, #12]
 8011af8:	681b      	ldr	r3, [r3, #0]
 8011afa:	68ba      	ldr	r2, [r7, #8]
 8011afc:	0011      	movs	r1, r2
 8011afe:	0018      	movs	r0, r3
 8011b00:	f000 f990 	bl	8011e24 <TIM_OC2_SetConfig>
      break;
 8011b04:	e00f      	b.n	8011b26 <HAL_TIM_OC_ConfigChannel+0x82>
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 8011b06:	68fb      	ldr	r3, [r7, #12]
 8011b08:	681b      	ldr	r3, [r3, #0]
 8011b0a:	68ba      	ldr	r2, [r7, #8]
 8011b0c:	0011      	movs	r1, r2
 8011b0e:	0018      	movs	r0, r3
 8011b10:	f000 f9ca 	bl	8011ea8 <TIM_OC3_SetConfig>
      break;
 8011b14:	e007      	b.n	8011b26 <HAL_TIM_OC_ConfigChannel+0x82>
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 8011b16:	68fb      	ldr	r3, [r7, #12]
 8011b18:	681b      	ldr	r3, [r3, #0]
 8011b1a:	68ba      	ldr	r2, [r7, #8]
 8011b1c:	0011      	movs	r1, r2
 8011b1e:	0018      	movs	r0, r3
 8011b20:	f000 fa02 	bl	8011f28 <TIM_OC4_SetConfig>
      break;
 8011b24:	46c0      	nop			; (mov r8, r8)
  }

  htim->State = HAL_TIM_STATE_READY;
 8011b26:	68fb      	ldr	r3, [r7, #12]
 8011b28:	2239      	movs	r2, #57	; 0x39
 8011b2a:	2101      	movs	r1, #1
 8011b2c:	5499      	strb	r1, [r3, r2]

  __HAL_UNLOCK(htim);
 8011b2e:	68fb      	ldr	r3, [r7, #12]
 8011b30:	2238      	movs	r2, #56	; 0x38
 8011b32:	2100      	movs	r1, #0
 8011b34:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 8011b36:	2300      	movs	r3, #0
}
 8011b38:	0018      	movs	r0, r3
 8011b3a:	46bd      	mov	sp, r7
 8011b3c:	b004      	add	sp, #16
 8011b3e:	bd80      	pop	{r7, pc}

08011b40 <HAL_TIM_PWM_ConfigChannel>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim,
                                            TIM_OC_InitTypeDef *sConfig,
                                            uint32_t Channel)
{
 8011b40:	b580      	push	{r7, lr}
 8011b42:	b084      	sub	sp, #16
 8011b44:	af00      	add	r7, sp, #0
 8011b46:	60f8      	str	r0, [r7, #12]
 8011b48:	60b9      	str	r1, [r7, #8]
 8011b4a:	607a      	str	r2, [r7, #4]
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));

  /* Process Locked */
  __HAL_LOCK(htim);
 8011b4c:	68fb      	ldr	r3, [r7, #12]
 8011b4e:	2238      	movs	r2, #56	; 0x38
 8011b50:	5c9b      	ldrb	r3, [r3, r2]
 8011b52:	2b01      	cmp	r3, #1
 8011b54:	d101      	bne.n	8011b5a <HAL_TIM_PWM_ConfigChannel+0x1a>
 8011b56:	2302      	movs	r3, #2
 8011b58:	e0a4      	b.n	8011ca4 <HAL_TIM_PWM_ConfigChannel+0x164>
 8011b5a:	68fb      	ldr	r3, [r7, #12]
 8011b5c:	2238      	movs	r2, #56	; 0x38
 8011b5e:	2101      	movs	r1, #1
 8011b60:	5499      	strb	r1, [r3, r2]

  htim->State = HAL_TIM_STATE_BUSY;
 8011b62:	68fb      	ldr	r3, [r7, #12]
 8011b64:	2239      	movs	r2, #57	; 0x39
 8011b66:	2102      	movs	r1, #2
 8011b68:	5499      	strb	r1, [r3, r2]

  switch (Channel)
 8011b6a:	687b      	ldr	r3, [r7, #4]
 8011b6c:	2b04      	cmp	r3, #4
 8011b6e:	d029      	beq.n	8011bc4 <HAL_TIM_PWM_ConfigChannel+0x84>
 8011b70:	d802      	bhi.n	8011b78 <HAL_TIM_PWM_ConfigChannel+0x38>
 8011b72:	2b00      	cmp	r3, #0
 8011b74:	d005      	beq.n	8011b82 <HAL_TIM_PWM_ConfigChannel+0x42>
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
      break;
    }

    default:
      break;
 8011b76:	e08c      	b.n	8011c92 <HAL_TIM_PWM_ConfigChannel+0x152>
  switch (Channel)
 8011b78:	2b08      	cmp	r3, #8
 8011b7a:	d046      	beq.n	8011c0a <HAL_TIM_PWM_ConfigChannel+0xca>
 8011b7c:	2b0c      	cmp	r3, #12
 8011b7e:	d065      	beq.n	8011c4c <HAL_TIM_PWM_ConfigChannel+0x10c>
      break;
 8011b80:	e087      	b.n	8011c92 <HAL_TIM_PWM_ConfigChannel+0x152>
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 8011b82:	68fb      	ldr	r3, [r7, #12]
 8011b84:	681b      	ldr	r3, [r3, #0]
 8011b86:	68ba      	ldr	r2, [r7, #8]
 8011b88:	0011      	movs	r1, r2
 8011b8a:	0018      	movs	r0, r3
 8011b8c:	f000 f90e 	bl	8011dac <TIM_OC1_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 8011b90:	68fb      	ldr	r3, [r7, #12]
 8011b92:	681b      	ldr	r3, [r3, #0]
 8011b94:	699a      	ldr	r2, [r3, #24]
 8011b96:	68fb      	ldr	r3, [r7, #12]
 8011b98:	681b      	ldr	r3, [r3, #0]
 8011b9a:	2108      	movs	r1, #8
 8011b9c:	430a      	orrs	r2, r1
 8011b9e:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 8011ba0:	68fb      	ldr	r3, [r7, #12]
 8011ba2:	681b      	ldr	r3, [r3, #0]
 8011ba4:	699a      	ldr	r2, [r3, #24]
 8011ba6:	68fb      	ldr	r3, [r7, #12]
 8011ba8:	681b      	ldr	r3, [r3, #0]
 8011baa:	2104      	movs	r1, #4
 8011bac:	438a      	bics	r2, r1
 8011bae:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 8011bb0:	68fb      	ldr	r3, [r7, #12]
 8011bb2:	681b      	ldr	r3, [r3, #0]
 8011bb4:	6999      	ldr	r1, [r3, #24]
 8011bb6:	68bb      	ldr	r3, [r7, #8]
 8011bb8:	68da      	ldr	r2, [r3, #12]
 8011bba:	68fb      	ldr	r3, [r7, #12]
 8011bbc:	681b      	ldr	r3, [r3, #0]
 8011bbe:	430a      	orrs	r2, r1
 8011bc0:	619a      	str	r2, [r3, #24]
      break;
 8011bc2:	e066      	b.n	8011c92 <HAL_TIM_PWM_ConfigChannel+0x152>
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 8011bc4:	68fb      	ldr	r3, [r7, #12]
 8011bc6:	681b      	ldr	r3, [r3, #0]
 8011bc8:	68ba      	ldr	r2, [r7, #8]
 8011bca:	0011      	movs	r1, r2
 8011bcc:	0018      	movs	r0, r3
 8011bce:	f000 f929 	bl	8011e24 <TIM_OC2_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 8011bd2:	68fb      	ldr	r3, [r7, #12]
 8011bd4:	681b      	ldr	r3, [r3, #0]
 8011bd6:	699a      	ldr	r2, [r3, #24]
 8011bd8:	68fb      	ldr	r3, [r7, #12]
 8011bda:	681b      	ldr	r3, [r3, #0]
 8011bdc:	2180      	movs	r1, #128	; 0x80
 8011bde:	0109      	lsls	r1, r1, #4
 8011be0:	430a      	orrs	r2, r1
 8011be2:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 8011be4:	68fb      	ldr	r3, [r7, #12]
 8011be6:	681b      	ldr	r3, [r3, #0]
 8011be8:	699a      	ldr	r2, [r3, #24]
 8011bea:	68fb      	ldr	r3, [r7, #12]
 8011bec:	681b      	ldr	r3, [r3, #0]
 8011bee:	492f      	ldr	r1, [pc, #188]	; (8011cac <HAL_TIM_PWM_ConfigChannel+0x16c>)
 8011bf0:	400a      	ands	r2, r1
 8011bf2:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 8011bf4:	68fb      	ldr	r3, [r7, #12]
 8011bf6:	681b      	ldr	r3, [r3, #0]
 8011bf8:	6999      	ldr	r1, [r3, #24]
 8011bfa:	68bb      	ldr	r3, [r7, #8]
 8011bfc:	68db      	ldr	r3, [r3, #12]
 8011bfe:	021a      	lsls	r2, r3, #8
 8011c00:	68fb      	ldr	r3, [r7, #12]
 8011c02:	681b      	ldr	r3, [r3, #0]
 8011c04:	430a      	orrs	r2, r1
 8011c06:	619a      	str	r2, [r3, #24]
      break;
 8011c08:	e043      	b.n	8011c92 <HAL_TIM_PWM_ConfigChannel+0x152>
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 8011c0a:	68fb      	ldr	r3, [r7, #12]
 8011c0c:	681b      	ldr	r3, [r3, #0]
 8011c0e:	68ba      	ldr	r2, [r7, #8]
 8011c10:	0011      	movs	r1, r2
 8011c12:	0018      	movs	r0, r3
 8011c14:	f000 f948 	bl	8011ea8 <TIM_OC3_SetConfig>
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 8011c18:	68fb      	ldr	r3, [r7, #12]
 8011c1a:	681b      	ldr	r3, [r3, #0]
 8011c1c:	69da      	ldr	r2, [r3, #28]
 8011c1e:	68fb      	ldr	r3, [r7, #12]
 8011c20:	681b      	ldr	r3, [r3, #0]
 8011c22:	2108      	movs	r1, #8
 8011c24:	430a      	orrs	r2, r1
 8011c26:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 8011c28:	68fb      	ldr	r3, [r7, #12]
 8011c2a:	681b      	ldr	r3, [r3, #0]
 8011c2c:	69da      	ldr	r2, [r3, #28]
 8011c2e:	68fb      	ldr	r3, [r7, #12]
 8011c30:	681b      	ldr	r3, [r3, #0]
 8011c32:	2104      	movs	r1, #4
 8011c34:	438a      	bics	r2, r1
 8011c36:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 8011c38:	68fb      	ldr	r3, [r7, #12]
 8011c3a:	681b      	ldr	r3, [r3, #0]
 8011c3c:	69d9      	ldr	r1, [r3, #28]
 8011c3e:	68bb      	ldr	r3, [r7, #8]
 8011c40:	68da      	ldr	r2, [r3, #12]
 8011c42:	68fb      	ldr	r3, [r7, #12]
 8011c44:	681b      	ldr	r3, [r3, #0]
 8011c46:	430a      	orrs	r2, r1
 8011c48:	61da      	str	r2, [r3, #28]
      break;
 8011c4a:	e022      	b.n	8011c92 <HAL_TIM_PWM_ConfigChannel+0x152>
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 8011c4c:	68fb      	ldr	r3, [r7, #12]
 8011c4e:	681b      	ldr	r3, [r3, #0]
 8011c50:	68ba      	ldr	r2, [r7, #8]
 8011c52:	0011      	movs	r1, r2
 8011c54:	0018      	movs	r0, r3
 8011c56:	f000 f967 	bl	8011f28 <TIM_OC4_SetConfig>
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 8011c5a:	68fb      	ldr	r3, [r7, #12]
 8011c5c:	681b      	ldr	r3, [r3, #0]
 8011c5e:	69da      	ldr	r2, [r3, #28]
 8011c60:	68fb      	ldr	r3, [r7, #12]
 8011c62:	681b      	ldr	r3, [r3, #0]
 8011c64:	2180      	movs	r1, #128	; 0x80
 8011c66:	0109      	lsls	r1, r1, #4
 8011c68:	430a      	orrs	r2, r1
 8011c6a:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 8011c6c:	68fb      	ldr	r3, [r7, #12]
 8011c6e:	681b      	ldr	r3, [r3, #0]
 8011c70:	69da      	ldr	r2, [r3, #28]
 8011c72:	68fb      	ldr	r3, [r7, #12]
 8011c74:	681b      	ldr	r3, [r3, #0]
 8011c76:	490d      	ldr	r1, [pc, #52]	; (8011cac <HAL_TIM_PWM_ConfigChannel+0x16c>)
 8011c78:	400a      	ands	r2, r1
 8011c7a:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 8011c7c:	68fb      	ldr	r3, [r7, #12]
 8011c7e:	681b      	ldr	r3, [r3, #0]
 8011c80:	69d9      	ldr	r1, [r3, #28]
 8011c82:	68bb      	ldr	r3, [r7, #8]
 8011c84:	68db      	ldr	r3, [r3, #12]
 8011c86:	021a      	lsls	r2, r3, #8
 8011c88:	68fb      	ldr	r3, [r7, #12]
 8011c8a:	681b      	ldr	r3, [r3, #0]
 8011c8c:	430a      	orrs	r2, r1
 8011c8e:	61da      	str	r2, [r3, #28]
      break;
 8011c90:	46c0      	nop			; (mov r8, r8)
  }

  htim->State = HAL_TIM_STATE_READY;
 8011c92:	68fb      	ldr	r3, [r7, #12]
 8011c94:	2239      	movs	r2, #57	; 0x39
 8011c96:	2101      	movs	r1, #1
 8011c98:	5499      	strb	r1, [r3, r2]

  __HAL_UNLOCK(htim);
 8011c9a:	68fb      	ldr	r3, [r7, #12]
 8011c9c:	2238      	movs	r2, #56	; 0x38
 8011c9e:	2100      	movs	r1, #0
 8011ca0:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 8011ca2:	2300      	movs	r3, #0
}
 8011ca4:	0018      	movs	r0, r3
 8011ca6:	46bd      	mov	sp, r7
 8011ca8:	b004      	add	sp, #16
 8011caa:	bd80      	pop	{r7, pc}
 8011cac:	fffffbff 	.word	0xfffffbff

08011cb0 <HAL_TIM_PeriodElapsedCallback>:
  * @brief  Period elapsed callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
 8011cb0:	b580      	push	{r7, lr}
 8011cb2:	b082      	sub	sp, #8
 8011cb4:	af00      	add	r7, sp, #0
 8011cb6:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PeriodElapsedCallback could be implemented in the user file
   */
}
 8011cb8:	46c0      	nop			; (mov r8, r8)
 8011cba:	46bd      	mov	sp, r7
 8011cbc:	b002      	add	sp, #8
 8011cbe:	bd80      	pop	{r7, pc}

08011cc0 <HAL_TIM_IC_CaptureCallback>:
  * @brief  Input Capture callback in non-blocking mode
  * @param  htim TIM IC handle
  * @retval None
  */
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
 8011cc0:	b580      	push	{r7, lr}
 8011cc2:	b082      	sub	sp, #8
 8011cc4:	af00      	add	r7, sp, #0
 8011cc6:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */
}
 8011cc8:	46c0      	nop			; (mov r8, r8)
 8011cca:	46bd      	mov	sp, r7
 8011ccc:	b002      	add	sp, #8
 8011cce:	bd80      	pop	{r7, pc}

08011cd0 <HAL_TIM_PWM_PulseFinishedCallback>:
  * @brief  PWM Pulse finished callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
{
 8011cd0:	b580      	push	{r7, lr}
 8011cd2:	b082      	sub	sp, #8
 8011cd4:	af00      	add	r7, sp, #0
 8011cd6:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   */
}
 8011cd8:	46c0      	nop			; (mov r8, r8)
 8011cda:	46bd      	mov	sp, r7
 8011cdc:	b002      	add	sp, #8
 8011cde:	bd80      	pop	{r7, pc}

08011ce0 <HAL_TIM_TriggerCallback>:
  * @brief  Hall Trigger detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
{
 8011ce0:	b580      	push	{r7, lr}
 8011ce2:	b082      	sub	sp, #8
 8011ce4:	af00      	add	r7, sp, #0
 8011ce6:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */
}
 8011ce8:	46c0      	nop			; (mov r8, r8)
 8011cea:	46bd      	mov	sp, r7
 8011cec:	b002      	add	sp, #8
 8011cee:	bd80      	pop	{r7, pc}

08011cf0 <TIM_Base_SetConfig>:
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
 8011cf0:	b580      	push	{r7, lr}
 8011cf2:	b084      	sub	sp, #16
 8011cf4:	af00      	add	r7, sp, #0
 8011cf6:	6078      	str	r0, [r7, #4]
 8011cf8:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
 8011cfa:	687b      	ldr	r3, [r7, #4]
 8011cfc:	681b      	ldr	r3, [r3, #0]
 8011cfe:	60fb      	str	r3, [r7, #12]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8011d00:	687a      	ldr	r2, [r7, #4]
 8011d02:	2380      	movs	r3, #128	; 0x80
 8011d04:	05db      	lsls	r3, r3, #23
 8011d06:	429a      	cmp	r2, r3
 8011d08:	d00b      	beq.n	8011d22 <TIM_Base_SetConfig+0x32>
 8011d0a:	687b      	ldr	r3, [r7, #4]
 8011d0c:	4a23      	ldr	r2, [pc, #140]	; (8011d9c <TIM_Base_SetConfig+0xac>)
 8011d0e:	4293      	cmp	r3, r2
 8011d10:	d007      	beq.n	8011d22 <TIM_Base_SetConfig+0x32>
 8011d12:	687b      	ldr	r3, [r7, #4]
 8011d14:	4a22      	ldr	r2, [pc, #136]	; (8011da0 <TIM_Base_SetConfig+0xb0>)
 8011d16:	4293      	cmp	r3, r2
 8011d18:	d003      	beq.n	8011d22 <TIM_Base_SetConfig+0x32>
 8011d1a:	687b      	ldr	r3, [r7, #4]
 8011d1c:	4a21      	ldr	r2, [pc, #132]	; (8011da4 <TIM_Base_SetConfig+0xb4>)
 8011d1e:	4293      	cmp	r3, r2
 8011d20:	d108      	bne.n	8011d34 <TIM_Base_SetConfig+0x44>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8011d22:	68fb      	ldr	r3, [r7, #12]
 8011d24:	2270      	movs	r2, #112	; 0x70
 8011d26:	4393      	bics	r3, r2
 8011d28:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= Structure->CounterMode;
 8011d2a:	683b      	ldr	r3, [r7, #0]
 8011d2c:	685b      	ldr	r3, [r3, #4]
 8011d2e:	68fa      	ldr	r2, [r7, #12]
 8011d30:	4313      	orrs	r3, r2
 8011d32:	60fb      	str	r3, [r7, #12]
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8011d34:	687a      	ldr	r2, [r7, #4]
 8011d36:	2380      	movs	r3, #128	; 0x80
 8011d38:	05db      	lsls	r3, r3, #23
 8011d3a:	429a      	cmp	r2, r3
 8011d3c:	d00b      	beq.n	8011d56 <TIM_Base_SetConfig+0x66>
 8011d3e:	687b      	ldr	r3, [r7, #4]
 8011d40:	4a16      	ldr	r2, [pc, #88]	; (8011d9c <TIM_Base_SetConfig+0xac>)
 8011d42:	4293      	cmp	r3, r2
 8011d44:	d007      	beq.n	8011d56 <TIM_Base_SetConfig+0x66>
 8011d46:	687b      	ldr	r3, [r7, #4]
 8011d48:	4a15      	ldr	r2, [pc, #84]	; (8011da0 <TIM_Base_SetConfig+0xb0>)
 8011d4a:	4293      	cmp	r3, r2
 8011d4c:	d003      	beq.n	8011d56 <TIM_Base_SetConfig+0x66>
 8011d4e:	687b      	ldr	r3, [r7, #4]
 8011d50:	4a14      	ldr	r2, [pc, #80]	; (8011da4 <TIM_Base_SetConfig+0xb4>)
 8011d52:	4293      	cmp	r3, r2
 8011d54:	d108      	bne.n	8011d68 <TIM_Base_SetConfig+0x78>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 8011d56:	68fb      	ldr	r3, [r7, #12]
 8011d58:	4a13      	ldr	r2, [pc, #76]	; (8011da8 <TIM_Base_SetConfig+0xb8>)
 8011d5a:	4013      	ands	r3, r2
 8011d5c:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8011d5e:	683b      	ldr	r3, [r7, #0]
 8011d60:	68db      	ldr	r3, [r3, #12]
 8011d62:	68fa      	ldr	r2, [r7, #12]
 8011d64:	4313      	orrs	r3, r2
 8011d66:	60fb      	str	r3, [r7, #12]
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8011d68:	68fb      	ldr	r3, [r7, #12]
 8011d6a:	2280      	movs	r2, #128	; 0x80
 8011d6c:	4393      	bics	r3, r2
 8011d6e:	001a      	movs	r2, r3
 8011d70:	683b      	ldr	r3, [r7, #0]
 8011d72:	691b      	ldr	r3, [r3, #16]
 8011d74:	4313      	orrs	r3, r2
 8011d76:	60fb      	str	r3, [r7, #12]

  TIMx->CR1 = tmpcr1;
 8011d78:	687b      	ldr	r3, [r7, #4]
 8011d7a:	68fa      	ldr	r2, [r7, #12]
 8011d7c:	601a      	str	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8011d7e:	683b      	ldr	r3, [r7, #0]
 8011d80:	689a      	ldr	r2, [r3, #8]
 8011d82:	687b      	ldr	r3, [r7, #4]
 8011d84:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 8011d86:	683b      	ldr	r3, [r7, #0]
 8011d88:	681a      	ldr	r2, [r3, #0]
 8011d8a:	687b      	ldr	r3, [r7, #4]
 8011d8c:	629a      	str	r2, [r3, #40]	; 0x28

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 8011d8e:	687b      	ldr	r3, [r7, #4]
 8011d90:	2201      	movs	r2, #1
 8011d92:	615a      	str	r2, [r3, #20]
}
 8011d94:	46c0      	nop			; (mov r8, r8)
 8011d96:	46bd      	mov	sp, r7
 8011d98:	b004      	add	sp, #16
 8011d9a:	bd80      	pop	{r7, pc}
 8011d9c:	40000400 	.word	0x40000400
 8011da0:	40010800 	.word	0x40010800
 8011da4:	40011400 	.word	0x40011400
 8011da8:	fffffcff 	.word	0xfffffcff

08011dac <TIM_OC1_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8011dac:	b580      	push	{r7, lr}
 8011dae:	b086      	sub	sp, #24
 8011db0:	af00      	add	r7, sp, #0
 8011db2:	6078      	str	r0, [r7, #4]
 8011db4:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8011db6:	687b      	ldr	r3, [r7, #4]
 8011db8:	6a1b      	ldr	r3, [r3, #32]
 8011dba:	2201      	movs	r2, #1
 8011dbc:	4393      	bics	r3, r2
 8011dbe:	001a      	movs	r2, r3
 8011dc0:	687b      	ldr	r3, [r7, #4]
 8011dc2:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8011dc4:	687b      	ldr	r3, [r7, #4]
 8011dc6:	6a1b      	ldr	r3, [r3, #32]
 8011dc8:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8011dca:	687b      	ldr	r3, [r7, #4]
 8011dcc:	685b      	ldr	r3, [r3, #4]
 8011dce:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8011dd0:	687b      	ldr	r3, [r7, #4]
 8011dd2:	699b      	ldr	r3, [r3, #24]
 8011dd4:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
 8011dd6:	68fb      	ldr	r3, [r7, #12]
 8011dd8:	2270      	movs	r2, #112	; 0x70
 8011dda:	4393      	bics	r3, r2
 8011ddc:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 8011dde:	68fb      	ldr	r3, [r7, #12]
 8011de0:	2203      	movs	r2, #3
 8011de2:	4393      	bics	r3, r2
 8011de4:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8011de6:	683b      	ldr	r3, [r7, #0]
 8011de8:	681b      	ldr	r3, [r3, #0]
 8011dea:	68fa      	ldr	r2, [r7, #12]
 8011dec:	4313      	orrs	r3, r2
 8011dee:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
 8011df0:	697b      	ldr	r3, [r7, #20]
 8011df2:	2202      	movs	r2, #2
 8011df4:	4393      	bics	r3, r2
 8011df6:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 8011df8:	683b      	ldr	r3, [r7, #0]
 8011dfa:	689b      	ldr	r3, [r3, #8]
 8011dfc:	697a      	ldr	r2, [r7, #20]
 8011dfe:	4313      	orrs	r3, r2
 8011e00:	617b      	str	r3, [r7, #20]

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8011e02:	687b      	ldr	r3, [r7, #4]
 8011e04:	693a      	ldr	r2, [r7, #16]
 8011e06:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8011e08:	687b      	ldr	r3, [r7, #4]
 8011e0a:	68fa      	ldr	r2, [r7, #12]
 8011e0c:	619a      	str	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 8011e0e:	683b      	ldr	r3, [r7, #0]
 8011e10:	685a      	ldr	r2, [r3, #4]
 8011e12:	687b      	ldr	r3, [r7, #4]
 8011e14:	635a      	str	r2, [r3, #52]	; 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8011e16:	687b      	ldr	r3, [r7, #4]
 8011e18:	697a      	ldr	r2, [r7, #20]
 8011e1a:	621a      	str	r2, [r3, #32]
}
 8011e1c:	46c0      	nop			; (mov r8, r8)
 8011e1e:	46bd      	mov	sp, r7
 8011e20:	b006      	add	sp, #24
 8011e22:	bd80      	pop	{r7, pc}

08011e24 <TIM_OC2_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
static void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8011e24:	b580      	push	{r7, lr}
 8011e26:	b086      	sub	sp, #24
 8011e28:	af00      	add	r7, sp, #0
 8011e2a:	6078      	str	r0, [r7, #4]
 8011e2c:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8011e2e:	687b      	ldr	r3, [r7, #4]
 8011e30:	6a1b      	ldr	r3, [r3, #32]
 8011e32:	2210      	movs	r2, #16
 8011e34:	4393      	bics	r3, r2
 8011e36:	001a      	movs	r2, r3
 8011e38:	687b      	ldr	r3, [r7, #4]
 8011e3a:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8011e3c:	687b      	ldr	r3, [r7, #4]
 8011e3e:	6a1b      	ldr	r3, [r3, #32]
 8011e40:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8011e42:	687b      	ldr	r3, [r7, #4]
 8011e44:	685b      	ldr	r3, [r3, #4]
 8011e46:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8011e48:	687b      	ldr	r3, [r7, #4]
 8011e4a:	699b      	ldr	r3, [r3, #24]
 8011e4c:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR1_OC2M;
 8011e4e:	68fb      	ldr	r3, [r7, #12]
 8011e50:	4a13      	ldr	r2, [pc, #76]	; (8011ea0 <TIM_OC2_SetConfig+0x7c>)
 8011e52:	4013      	ands	r3, r2
 8011e54:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 8011e56:	68fb      	ldr	r3, [r7, #12]
 8011e58:	4a12      	ldr	r2, [pc, #72]	; (8011ea4 <TIM_OC2_SetConfig+0x80>)
 8011e5a:	4013      	ands	r3, r2
 8011e5c:	60fb      	str	r3, [r7, #12]

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8011e5e:	683b      	ldr	r3, [r7, #0]
 8011e60:	681b      	ldr	r3, [r3, #0]
 8011e62:	021b      	lsls	r3, r3, #8
 8011e64:	68fa      	ldr	r2, [r7, #12]
 8011e66:	4313      	orrs	r3, r2
 8011e68:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
 8011e6a:	697b      	ldr	r3, [r7, #20]
 8011e6c:	2220      	movs	r2, #32
 8011e6e:	4393      	bics	r3, r2
 8011e70:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4U);
 8011e72:	683b      	ldr	r3, [r7, #0]
 8011e74:	689b      	ldr	r3, [r3, #8]
 8011e76:	011b      	lsls	r3, r3, #4
 8011e78:	697a      	ldr	r2, [r7, #20]
 8011e7a:	4313      	orrs	r3, r2
 8011e7c:	617b      	str	r3, [r7, #20]

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8011e7e:	687b      	ldr	r3, [r7, #4]
 8011e80:	693a      	ldr	r2, [r7, #16]
 8011e82:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8011e84:	687b      	ldr	r3, [r7, #4]
 8011e86:	68fa      	ldr	r2, [r7, #12]
 8011e88:	619a      	str	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR2 = OC_Config->Pulse;
 8011e8a:	683b      	ldr	r3, [r7, #0]
 8011e8c:	685a      	ldr	r2, [r3, #4]
 8011e8e:	687b      	ldr	r3, [r7, #4]
 8011e90:	639a      	str	r2, [r3, #56]	; 0x38

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8011e92:	687b      	ldr	r3, [r7, #4]
 8011e94:	697a      	ldr	r2, [r7, #20]
 8011e96:	621a      	str	r2, [r3, #32]
}
 8011e98:	46c0      	nop			; (mov r8, r8)
 8011e9a:	46bd      	mov	sp, r7
 8011e9c:	b006      	add	sp, #24
 8011e9e:	bd80      	pop	{r7, pc}
 8011ea0:	ffff8fff 	.word	0xffff8fff
 8011ea4:	fffffcff 	.word	0xfffffcff

08011ea8 <TIM_OC3_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8011ea8:	b580      	push	{r7, lr}
 8011eaa:	b086      	sub	sp, #24
 8011eac:	af00      	add	r7, sp, #0
 8011eae:	6078      	str	r0, [r7, #4]
 8011eb0:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8011eb2:	687b      	ldr	r3, [r7, #4]
 8011eb4:	6a1b      	ldr	r3, [r3, #32]
 8011eb6:	4a1a      	ldr	r2, [pc, #104]	; (8011f20 <TIM_OC3_SetConfig+0x78>)
 8011eb8:	401a      	ands	r2, r3
 8011eba:	687b      	ldr	r3, [r7, #4]
 8011ebc:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8011ebe:	687b      	ldr	r3, [r7, #4]
 8011ec0:	6a1b      	ldr	r3, [r3, #32]
 8011ec2:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8011ec4:	687b      	ldr	r3, [r7, #4]
 8011ec6:	685b      	ldr	r3, [r3, #4]
 8011ec8:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8011eca:	687b      	ldr	r3, [r7, #4]
 8011ecc:	69db      	ldr	r3, [r3, #28]
 8011ece:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
 8011ed0:	68fb      	ldr	r3, [r7, #12]
 8011ed2:	2270      	movs	r2, #112	; 0x70
 8011ed4:	4393      	bics	r3, r2
 8011ed6:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8011ed8:	68fb      	ldr	r3, [r7, #12]
 8011eda:	2203      	movs	r2, #3
 8011edc:	4393      	bics	r3, r2
 8011ede:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8011ee0:	683b      	ldr	r3, [r7, #0]
 8011ee2:	681b      	ldr	r3, [r3, #0]
 8011ee4:	68fa      	ldr	r2, [r7, #12]
 8011ee6:	4313      	orrs	r3, r2
 8011ee8:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
 8011eea:	697b      	ldr	r3, [r7, #20]
 8011eec:	4a0d      	ldr	r2, [pc, #52]	; (8011f24 <TIM_OC3_SetConfig+0x7c>)
 8011eee:	4013      	ands	r3, r2
 8011ef0:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
 8011ef2:	683b      	ldr	r3, [r7, #0]
 8011ef4:	689b      	ldr	r3, [r3, #8]
 8011ef6:	021b      	lsls	r3, r3, #8
 8011ef8:	697a      	ldr	r2, [r7, #20]
 8011efa:	4313      	orrs	r3, r2
 8011efc:	617b      	str	r3, [r7, #20]

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8011efe:	687b      	ldr	r3, [r7, #4]
 8011f00:	693a      	ldr	r2, [r7, #16]
 8011f02:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8011f04:	687b      	ldr	r3, [r7, #4]
 8011f06:	68fa      	ldr	r2, [r7, #12]
 8011f08:	61da      	str	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 8011f0a:	683b      	ldr	r3, [r7, #0]
 8011f0c:	685a      	ldr	r2, [r3, #4]
 8011f0e:	687b      	ldr	r3, [r7, #4]
 8011f10:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8011f12:	687b      	ldr	r3, [r7, #4]
 8011f14:	697a      	ldr	r2, [r7, #20]
 8011f16:	621a      	str	r2, [r3, #32]
}
 8011f18:	46c0      	nop			; (mov r8, r8)
 8011f1a:	46bd      	mov	sp, r7
 8011f1c:	b006      	add	sp, #24
 8011f1e:	bd80      	pop	{r7, pc}
 8011f20:	fffffeff 	.word	0xfffffeff
 8011f24:	fffffdff 	.word	0xfffffdff

08011f28 <TIM_OC4_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8011f28:	b580      	push	{r7, lr}
 8011f2a:	b086      	sub	sp, #24
 8011f2c:	af00      	add	r7, sp, #0
 8011f2e:	6078      	str	r0, [r7, #4]
 8011f30:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8011f32:	687b      	ldr	r3, [r7, #4]
 8011f34:	6a1b      	ldr	r3, [r3, #32]
 8011f36:	4a1b      	ldr	r2, [pc, #108]	; (8011fa4 <TIM_OC4_SetConfig+0x7c>)
 8011f38:	401a      	ands	r2, r3
 8011f3a:	687b      	ldr	r3, [r7, #4]
 8011f3c:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8011f3e:	687b      	ldr	r3, [r7, #4]
 8011f40:	6a1b      	ldr	r3, [r3, #32]
 8011f42:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8011f44:	687b      	ldr	r3, [r7, #4]
 8011f46:	685b      	ldr	r3, [r3, #4]
 8011f48:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8011f4a:	687b      	ldr	r3, [r7, #4]
 8011f4c:	69db      	ldr	r3, [r3, #28]
 8011f4e:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
 8011f50:	68fb      	ldr	r3, [r7, #12]
 8011f52:	4a15      	ldr	r2, [pc, #84]	; (8011fa8 <TIM_OC4_SetConfig+0x80>)
 8011f54:	4013      	ands	r3, r2
 8011f56:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 8011f58:	68fb      	ldr	r3, [r7, #12]
 8011f5a:	4a14      	ldr	r2, [pc, #80]	; (8011fac <TIM_OC4_SetConfig+0x84>)
 8011f5c:	4013      	ands	r3, r2
 8011f5e:	60fb      	str	r3, [r7, #12]

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8011f60:	683b      	ldr	r3, [r7, #0]
 8011f62:	681b      	ldr	r3, [r3, #0]
 8011f64:	021b      	lsls	r3, r3, #8
 8011f66:	68fa      	ldr	r2, [r7, #12]
 8011f68:	4313      	orrs	r3, r2
 8011f6a:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
 8011f6c:	697b      	ldr	r3, [r7, #20]
 8011f6e:	4a10      	ldr	r2, [pc, #64]	; (8011fb0 <TIM_OC4_SetConfig+0x88>)
 8011f70:	4013      	ands	r3, r2
 8011f72:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 8011f74:	683b      	ldr	r3, [r7, #0]
 8011f76:	689b      	ldr	r3, [r3, #8]
 8011f78:	031b      	lsls	r3, r3, #12
 8011f7a:	697a      	ldr	r2, [r7, #20]
 8011f7c:	4313      	orrs	r3, r2
 8011f7e:	617b      	str	r3, [r7, #20]

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8011f80:	687b      	ldr	r3, [r7, #4]
 8011f82:	693a      	ldr	r2, [r7, #16]
 8011f84:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8011f86:	687b      	ldr	r3, [r7, #4]
 8011f88:	68fa      	ldr	r2, [r7, #12]
 8011f8a:	61da      	str	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 8011f8c:	683b      	ldr	r3, [r7, #0]
 8011f8e:	685a      	ldr	r2, [r3, #4]
 8011f90:	687b      	ldr	r3, [r7, #4]
 8011f92:	641a      	str	r2, [r3, #64]	; 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8011f94:	687b      	ldr	r3, [r7, #4]
 8011f96:	697a      	ldr	r2, [r7, #20]
 8011f98:	621a      	str	r2, [r3, #32]
}
 8011f9a:	46c0      	nop			; (mov r8, r8)
 8011f9c:	46bd      	mov	sp, r7
 8011f9e:	b006      	add	sp, #24
 8011fa0:	bd80      	pop	{r7, pc}
 8011fa2:	46c0      	nop			; (mov r8, r8)
 8011fa4:	ffffefff 	.word	0xffffefff
 8011fa8:	ffff8fff 	.word	0xffff8fff
 8011fac:	fffffcff 	.word	0xfffffcff
 8011fb0:	ffffdfff 	.word	0xffffdfff

08011fb4 <TIM_CCxChannelCmd>:
  * @param  ChannelState specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_DISABLE.
  * @retval None
  */
static void TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState)
{
 8011fb4:	b580      	push	{r7, lr}
 8011fb6:	b086      	sub	sp, #24
 8011fb8:	af00      	add	r7, sp, #0
 8011fba:	60f8      	str	r0, [r7, #12]
 8011fbc:	60b9      	str	r1, [r7, #8]
 8011fbe:	607a      	str	r2, [r7, #4]

  /* Check the parameters */
  assert_param(IS_TIM_CC1_INSTANCE(TIMx));
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
 8011fc0:	68bb      	ldr	r3, [r7, #8]
 8011fc2:	221f      	movs	r2, #31
 8011fc4:	4013      	ands	r3, r2
 8011fc6:	2201      	movs	r2, #1
 8011fc8:	409a      	lsls	r2, r3
 8011fca:	0013      	movs	r3, r2
 8011fcc:	617b      	str	r3, [r7, #20]

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
 8011fce:	68fb      	ldr	r3, [r7, #12]
 8011fd0:	6a1b      	ldr	r3, [r3, #32]
 8011fd2:	697a      	ldr	r2, [r7, #20]
 8011fd4:	43d2      	mvns	r2, r2
 8011fd6:	401a      	ands	r2, r3
 8011fd8:	68fb      	ldr	r3, [r7, #12]
 8011fda:	621a      	str	r2, [r3, #32]

  /* Set or reset the CCxE Bit */
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
 8011fdc:	68fb      	ldr	r3, [r7, #12]
 8011fde:	6a1a      	ldr	r2, [r3, #32]
 8011fe0:	68bb      	ldr	r3, [r7, #8]
 8011fe2:	211f      	movs	r1, #31
 8011fe4:	400b      	ands	r3, r1
 8011fe6:	6879      	ldr	r1, [r7, #4]
 8011fe8:	4099      	lsls	r1, r3
 8011fea:	000b      	movs	r3, r1
 8011fec:	431a      	orrs	r2, r3
 8011fee:	68fb      	ldr	r3, [r7, #12]
 8011ff0:	621a      	str	r2, [r3, #32]
}
 8011ff2:	46c0      	nop			; (mov r8, r8)
 8011ff4:	46bd      	mov	sp, r7
 8011ff6:	b006      	add	sp, #24
 8011ff8:	bd80      	pop	{r7, pc}

08011ffa <HAL_TIMEx_MasterConfigSynchronization>:
  *         mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
                                                        TIM_MasterConfigTypeDef *sMasterConfig)
{
 8011ffa:	b580      	push	{r7, lr}
 8011ffc:	b084      	sub	sp, #16
 8011ffe:	af00      	add	r7, sp, #0
 8012000:	6078      	str	r0, [r7, #4]
 8012002:	6039      	str	r1, [r7, #0]
  assert_param(IS_TIM_SYNCHRO_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 8012004:	687b      	ldr	r3, [r7, #4]
 8012006:	2238      	movs	r2, #56	; 0x38
 8012008:	5c9b      	ldrb	r3, [r3, r2]
 801200a:	2b01      	cmp	r3, #1
 801200c:	d101      	bne.n	8012012 <HAL_TIMEx_MasterConfigSynchronization+0x18>
 801200e:	2302      	movs	r3, #2
 8012010:	e032      	b.n	8012078 <HAL_TIMEx_MasterConfigSynchronization+0x7e>
 8012012:	687b      	ldr	r3, [r7, #4]
 8012014:	2238      	movs	r2, #56	; 0x38
 8012016:	2101      	movs	r1, #1
 8012018:	5499      	strb	r1, [r3, r2]

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;
 801201a:	687b      	ldr	r3, [r7, #4]
 801201c:	2239      	movs	r2, #57	; 0x39
 801201e:	2102      	movs	r1, #2
 8012020:	5499      	strb	r1, [r3, r2]

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 8012022:	687b      	ldr	r3, [r7, #4]
 8012024:	681b      	ldr	r3, [r3, #0]
 8012026:	685b      	ldr	r3, [r3, #4]
 8012028:	60fb      	str	r3, [r7, #12]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
 801202a:	687b      	ldr	r3, [r7, #4]
 801202c:	681b      	ldr	r3, [r3, #0]
 801202e:	689b      	ldr	r3, [r3, #8]
 8012030:	60bb      	str	r3, [r7, #8]

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
 8012032:	68fb      	ldr	r3, [r7, #12]
 8012034:	2270      	movs	r2, #112	; 0x70
 8012036:	4393      	bics	r3, r2
 8012038:	60fb      	str	r3, [r7, #12]
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 801203a:	683b      	ldr	r3, [r7, #0]
 801203c:	681b      	ldr	r3, [r3, #0]
 801203e:	68fa      	ldr	r2, [r7, #12]
 8012040:	4313      	orrs	r3, r2
 8012042:	60fb      	str	r3, [r7, #12]

  /* Reset the MSM Bit */
  tmpsmcr &= ~TIM_SMCR_MSM;
 8012044:	68bb      	ldr	r3, [r7, #8]
 8012046:	2280      	movs	r2, #128	; 0x80
 8012048:	4393      	bics	r3, r2
 801204a:	60bb      	str	r3, [r7, #8]
  /* Set master mode */
  tmpsmcr |= sMasterConfig->MasterSlaveMode;
 801204c:	683b      	ldr	r3, [r7, #0]
 801204e:	685b      	ldr	r3, [r3, #4]
 8012050:	68ba      	ldr	r2, [r7, #8]
 8012052:	4313      	orrs	r3, r2
 8012054:	60bb      	str	r3, [r7, #8]

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 8012056:	687b      	ldr	r3, [r7, #4]
 8012058:	681b      	ldr	r3, [r3, #0]
 801205a:	68fa      	ldr	r2, [r7, #12]
 801205c:	605a      	str	r2, [r3, #4]

  /* Update TIMx SMCR */
  htim->Instance->SMCR = tmpsmcr;
 801205e:	687b      	ldr	r3, [r7, #4]
 8012060:	681b      	ldr	r3, [r3, #0]
 8012062:	68ba      	ldr	r2, [r7, #8]
 8012064:	609a      	str	r2, [r3, #8]

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 8012066:	687b      	ldr	r3, [r7, #4]
 8012068:	2239      	movs	r2, #57	; 0x39
 801206a:	2101      	movs	r1, #1
 801206c:	5499      	strb	r1, [r3, r2]

  __HAL_UNLOCK(htim);
 801206e:	687b      	ldr	r3, [r7, #4]
 8012070:	2238      	movs	r2, #56	; 0x38
 8012072:	2100      	movs	r1, #0
 8012074:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 8012076:	2300      	movs	r3, #0
}
 8012078:	0018      	movs	r0, r3
 801207a:	46bd      	mov	sp, r7
 801207c:	b004      	add	sp, #16
 801207e:	bd80      	pop	{r7, pc}

08012080 <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 8012080:	b580      	push	{r7, lr}
 8012082:	b082      	sub	sp, #8
 8012084:	af00      	add	r7, sp, #0
 8012086:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
 8012088:	687b      	ldr	r3, [r7, #4]
 801208a:	2b00      	cmp	r3, #0
 801208c:	d101      	bne.n	8012092 <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 801208e:	2301      	movs	r3, #1
 8012090:	e044      	b.n	801211c <HAL_UART_Init+0x9c>
  {
    /* Check the parameters */
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
  }

  if (huart->gState == HAL_UART_STATE_RESET)
 8012092:	687b      	ldr	r3, [r7, #4]
 8012094:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8012096:	2b00      	cmp	r3, #0
 8012098:	d107      	bne.n	80120aa <HAL_UART_Init+0x2a>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 801209a:	687b      	ldr	r3, [r7, #4]
 801209c:	2270      	movs	r2, #112	; 0x70
 801209e:	2100      	movs	r1, #0
 80120a0:	5499      	strb	r1, [r3, r2]

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 80120a2:	687b      	ldr	r3, [r7, #4]
 80120a4:	0018      	movs	r0, r3
 80120a6:	f7f4 f845 	bl	8006134 <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
 80120aa:	687b      	ldr	r3, [r7, #4]
 80120ac:	2224      	movs	r2, #36	; 0x24
 80120ae:	675a      	str	r2, [r3, #116]	; 0x74

  /* Disable the Peripheral */
  __HAL_UART_DISABLE(huart);
 80120b0:	687b      	ldr	r3, [r7, #4]
 80120b2:	681b      	ldr	r3, [r3, #0]
 80120b4:	681a      	ldr	r2, [r3, #0]
 80120b6:	687b      	ldr	r3, [r7, #4]
 80120b8:	681b      	ldr	r3, [r3, #0]
 80120ba:	2101      	movs	r1, #1
 80120bc:	438a      	bics	r2, r1
 80120be:	601a      	str	r2, [r3, #0]

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
 80120c0:	687b      	ldr	r3, [r7, #4]
 80120c2:	0018      	movs	r0, r3
 80120c4:	f000 fac6 	bl	8012654 <UART_SetConfig>
 80120c8:	0003      	movs	r3, r0
 80120ca:	2b01      	cmp	r3, #1
 80120cc:	d101      	bne.n	80120d2 <HAL_UART_Init+0x52>
  {
    return HAL_ERROR;
 80120ce:	2301      	movs	r3, #1
 80120d0:	e024      	b.n	801211c <HAL_UART_Init+0x9c>
  }

  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 80120d2:	687b      	ldr	r3, [r7, #4]
 80120d4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80120d6:	2b00      	cmp	r3, #0
 80120d8:	d003      	beq.n	80120e2 <HAL_UART_Init+0x62>
  {
    UART_AdvFeatureConfig(huart);
 80120da:	687b      	ldr	r3, [r7, #4]
 80120dc:	0018      	movs	r0, r3
 80120de:	f000 fded 	bl	8012cbc <UART_AdvFeatureConfig>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 80120e2:	687b      	ldr	r3, [r7, #4]
 80120e4:	681b      	ldr	r3, [r3, #0]
 80120e6:	685a      	ldr	r2, [r3, #4]
 80120e8:	687b      	ldr	r3, [r7, #4]
 80120ea:	681b      	ldr	r3, [r3, #0]
 80120ec:	490d      	ldr	r1, [pc, #52]	; (8012124 <HAL_UART_Init+0xa4>)
 80120ee:	400a      	ands	r2, r1
 80120f0:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 80120f2:	687b      	ldr	r3, [r7, #4]
 80120f4:	681b      	ldr	r3, [r3, #0]
 80120f6:	689a      	ldr	r2, [r3, #8]
 80120f8:	687b      	ldr	r3, [r7, #4]
 80120fa:	681b      	ldr	r3, [r3, #0]
 80120fc:	212a      	movs	r1, #42	; 0x2a
 80120fe:	438a      	bics	r2, r1
 8012100:	609a      	str	r2, [r3, #8]

  /* Enable the Peripheral */
  __HAL_UART_ENABLE(huart);
 8012102:	687b      	ldr	r3, [r7, #4]
 8012104:	681b      	ldr	r3, [r3, #0]
 8012106:	681a      	ldr	r2, [r3, #0]
 8012108:	687b      	ldr	r3, [r7, #4]
 801210a:	681b      	ldr	r3, [r3, #0]
 801210c:	2101      	movs	r1, #1
 801210e:	430a      	orrs	r2, r1
 8012110:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
 8012112:	687b      	ldr	r3, [r7, #4]
 8012114:	0018      	movs	r0, r3
 8012116:	f000 fe85 	bl	8012e24 <UART_CheckIdleState>
 801211a:	0003      	movs	r3, r0
}
 801211c:	0018      	movs	r0, r3
 801211e:	46bd      	mov	sp, r7
 8012120:	b002      	add	sp, #8
 8012122:	bd80      	pop	{r7, pc}
 8012124:	ffffb7ff 	.word	0xffffb7ff

08012128 <HAL_UART_Transmit>:
  * @param Size    Amount of data to be sent.
  * @param Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8012128:	b580      	push	{r7, lr}
 801212a:	b08a      	sub	sp, #40	; 0x28
 801212c:	af02      	add	r7, sp, #8
 801212e:	60f8      	str	r0, [r7, #12]
 8012130:	60b9      	str	r1, [r7, #8]
 8012132:	603b      	str	r3, [r7, #0]
 8012134:	1dbb      	adds	r3, r7, #6
 8012136:	801a      	strh	r2, [r3, #0]
  uint8_t  *pdata8bits;
  uint16_t *pdata16bits;
  uint32_t tickstart;

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 8012138:	68fb      	ldr	r3, [r7, #12]
 801213a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 801213c:	2b20      	cmp	r3, #32
 801213e:	d000      	beq.n	8012142 <HAL_UART_Transmit+0x1a>
 8012140:	e094      	b.n	801226c <HAL_UART_Transmit+0x144>
  {
    if ((pData == NULL) || (Size == 0U))
 8012142:	68bb      	ldr	r3, [r7, #8]
 8012144:	2b00      	cmp	r3, #0
 8012146:	d003      	beq.n	8012150 <HAL_UART_Transmit+0x28>
 8012148:	1dbb      	adds	r3, r7, #6
 801214a:	881b      	ldrh	r3, [r3, #0]
 801214c:	2b00      	cmp	r3, #0
 801214e:	d101      	bne.n	8012154 <HAL_UART_Transmit+0x2c>
    {
      return  HAL_ERROR;
 8012150:	2301      	movs	r3, #1
 8012152:	e08c      	b.n	801226e <HAL_UART_Transmit+0x146>
    }

    /* In case of 9bits/No Parity transfer, pData buffer provided as input parameter
       should be aligned on a u16 frontier, as data to be filled into TDR will be
       handled through a u16 cast. */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8012154:	68fb      	ldr	r3, [r7, #12]
 8012156:	689a      	ldr	r2, [r3, #8]
 8012158:	2380      	movs	r3, #128	; 0x80
 801215a:	015b      	lsls	r3, r3, #5
 801215c:	429a      	cmp	r2, r3
 801215e:	d109      	bne.n	8012174 <HAL_UART_Transmit+0x4c>
 8012160:	68fb      	ldr	r3, [r7, #12]
 8012162:	691b      	ldr	r3, [r3, #16]
 8012164:	2b00      	cmp	r3, #0
 8012166:	d105      	bne.n	8012174 <HAL_UART_Transmit+0x4c>
    {
      if ((((uint32_t)pData) & 1) != 0)
 8012168:	68bb      	ldr	r3, [r7, #8]
 801216a:	2201      	movs	r2, #1
 801216c:	4013      	ands	r3, r2
 801216e:	d001      	beq.n	8012174 <HAL_UART_Transmit+0x4c>
      {
        return  HAL_ERROR;
 8012170:	2301      	movs	r3, #1
 8012172:	e07c      	b.n	801226e <HAL_UART_Transmit+0x146>
      }
    }

    /* Process Locked */
    __HAL_LOCK(huart);
 8012174:	68fb      	ldr	r3, [r7, #12]
 8012176:	2270      	movs	r2, #112	; 0x70
 8012178:	5c9b      	ldrb	r3, [r3, r2]
 801217a:	2b01      	cmp	r3, #1
 801217c:	d101      	bne.n	8012182 <HAL_UART_Transmit+0x5a>
 801217e:	2302      	movs	r3, #2
 8012180:	e075      	b.n	801226e <HAL_UART_Transmit+0x146>
 8012182:	68fb      	ldr	r3, [r7, #12]
 8012184:	2270      	movs	r2, #112	; 0x70
 8012186:	2101      	movs	r1, #1
 8012188:	5499      	strb	r1, [r3, r2]

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 801218a:	68fb      	ldr	r3, [r7, #12]
 801218c:	2200      	movs	r2, #0
 801218e:	67da      	str	r2, [r3, #124]	; 0x7c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8012190:	68fb      	ldr	r3, [r7, #12]
 8012192:	2221      	movs	r2, #33	; 0x21
 8012194:	675a      	str	r2, [r3, #116]	; 0x74

    /* Init tickstart for timeout managment*/
    tickstart = HAL_GetTick();
 8012196:	f7fd f9a3 	bl	800f4e0 <HAL_GetTick>
 801219a:	0003      	movs	r3, r0
 801219c:	617b      	str	r3, [r7, #20]

    huart->TxXferSize  = Size;
 801219e:	68fb      	ldr	r3, [r7, #12]
 80121a0:	1dba      	adds	r2, r7, #6
 80121a2:	2150      	movs	r1, #80	; 0x50
 80121a4:	8812      	ldrh	r2, [r2, #0]
 80121a6:	525a      	strh	r2, [r3, r1]
    huart->TxXferCount = Size;
 80121a8:	68fb      	ldr	r3, [r7, #12]
 80121aa:	1dba      	adds	r2, r7, #6
 80121ac:	2152      	movs	r1, #82	; 0x52
 80121ae:	8812      	ldrh	r2, [r2, #0]
 80121b0:	525a      	strh	r2, [r3, r1]

        /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80121b2:	68fb      	ldr	r3, [r7, #12]
 80121b4:	689a      	ldr	r2, [r3, #8]
 80121b6:	2380      	movs	r3, #128	; 0x80
 80121b8:	015b      	lsls	r3, r3, #5
 80121ba:	429a      	cmp	r2, r3
 80121bc:	d108      	bne.n	80121d0 <HAL_UART_Transmit+0xa8>
 80121be:	68fb      	ldr	r3, [r7, #12]
 80121c0:	691b      	ldr	r3, [r3, #16]
 80121c2:	2b00      	cmp	r3, #0
 80121c4:	d104      	bne.n	80121d0 <HAL_UART_Transmit+0xa8>
    {
      pdata8bits  = NULL;
 80121c6:	2300      	movs	r3, #0
 80121c8:	61fb      	str	r3, [r7, #28]
      pdata16bits = (uint16_t *) pData;
 80121ca:	68bb      	ldr	r3, [r7, #8]
 80121cc:	61bb      	str	r3, [r7, #24]
 80121ce:	e003      	b.n	80121d8 <HAL_UART_Transmit+0xb0>
    }
    else
    {
      pdata8bits  = pData;
 80121d0:	68bb      	ldr	r3, [r7, #8]
 80121d2:	61fb      	str	r3, [r7, #28]
      pdata16bits = NULL;
 80121d4:	2300      	movs	r3, #0
 80121d6:	61bb      	str	r3, [r7, #24]
    }

    while (huart->TxXferCount > 0U)
 80121d8:	e02c      	b.n	8012234 <HAL_UART_Transmit+0x10c>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 80121da:	697a      	ldr	r2, [r7, #20]
 80121dc:	68f8      	ldr	r0, [r7, #12]
 80121de:	683b      	ldr	r3, [r7, #0]
 80121e0:	9300      	str	r3, [sp, #0]
 80121e2:	0013      	movs	r3, r2
 80121e4:	2200      	movs	r2, #0
 80121e6:	2180      	movs	r1, #128	; 0x80
 80121e8:	f000 fe62 	bl	8012eb0 <UART_WaitOnFlagUntilTimeout>
 80121ec:	1e03      	subs	r3, r0, #0
 80121ee:	d001      	beq.n	80121f4 <HAL_UART_Transmit+0xcc>
      {
        return HAL_TIMEOUT;
 80121f0:	2303      	movs	r3, #3
 80121f2:	e03c      	b.n	801226e <HAL_UART_Transmit+0x146>
      }
      if (pdata8bits == NULL)
 80121f4:	69fb      	ldr	r3, [r7, #28]
 80121f6:	2b00      	cmp	r3, #0
 80121f8:	d10b      	bne.n	8012212 <HAL_UART_Transmit+0xea>
      {
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 80121fa:	69bb      	ldr	r3, [r7, #24]
 80121fc:	881b      	ldrh	r3, [r3, #0]
 80121fe:	001a      	movs	r2, r3
 8012200:	68fb      	ldr	r3, [r7, #12]
 8012202:	681b      	ldr	r3, [r3, #0]
 8012204:	05d2      	lsls	r2, r2, #23
 8012206:	0dd2      	lsrs	r2, r2, #23
 8012208:	629a      	str	r2, [r3, #40]	; 0x28
        pdata16bits++;
 801220a:	69bb      	ldr	r3, [r7, #24]
 801220c:	3302      	adds	r3, #2
 801220e:	61bb      	str	r3, [r7, #24]
 8012210:	e007      	b.n	8012222 <HAL_UART_Transmit+0xfa>
      }
      else
      {
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 8012212:	69fb      	ldr	r3, [r7, #28]
 8012214:	781a      	ldrb	r2, [r3, #0]
 8012216:	68fb      	ldr	r3, [r7, #12]
 8012218:	681b      	ldr	r3, [r3, #0]
 801221a:	629a      	str	r2, [r3, #40]	; 0x28
        pdata8bits++;
 801221c:	69fb      	ldr	r3, [r7, #28]
 801221e:	3301      	adds	r3, #1
 8012220:	61fb      	str	r3, [r7, #28]
      }
      huart->TxXferCount--;
 8012222:	68fb      	ldr	r3, [r7, #12]
 8012224:	2252      	movs	r2, #82	; 0x52
 8012226:	5a9b      	ldrh	r3, [r3, r2]
 8012228:	b29b      	uxth	r3, r3
 801222a:	3b01      	subs	r3, #1
 801222c:	b299      	uxth	r1, r3
 801222e:	68fb      	ldr	r3, [r7, #12]
 8012230:	2252      	movs	r2, #82	; 0x52
 8012232:	5299      	strh	r1, [r3, r2]
    while (huart->TxXferCount > 0U)
 8012234:	68fb      	ldr	r3, [r7, #12]
 8012236:	2252      	movs	r2, #82	; 0x52
 8012238:	5a9b      	ldrh	r3, [r3, r2]
 801223a:	b29b      	uxth	r3, r3
 801223c:	2b00      	cmp	r3, #0
 801223e:	d1cc      	bne.n	80121da <HAL_UART_Transmit+0xb2>
    }

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 8012240:	697a      	ldr	r2, [r7, #20]
 8012242:	68f8      	ldr	r0, [r7, #12]
 8012244:	683b      	ldr	r3, [r7, #0]
 8012246:	9300      	str	r3, [sp, #0]
 8012248:	0013      	movs	r3, r2
 801224a:	2200      	movs	r2, #0
 801224c:	2140      	movs	r1, #64	; 0x40
 801224e:	f000 fe2f 	bl	8012eb0 <UART_WaitOnFlagUntilTimeout>
 8012252:	1e03      	subs	r3, r0, #0
 8012254:	d001      	beq.n	801225a <HAL_UART_Transmit+0x132>
    {
      return HAL_TIMEOUT;
 8012256:	2303      	movs	r3, #3
 8012258:	e009      	b.n	801226e <HAL_UART_Transmit+0x146>
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
 801225a:	68fb      	ldr	r3, [r7, #12]
 801225c:	2220      	movs	r2, #32
 801225e:	675a      	str	r2, [r3, #116]	; 0x74

    /* Process Unlocked */
    __HAL_UNLOCK(huart);
 8012260:	68fb      	ldr	r3, [r7, #12]
 8012262:	2270      	movs	r2, #112	; 0x70
 8012264:	2100      	movs	r1, #0
 8012266:	5499      	strb	r1, [r3, r2]

    return HAL_OK;
 8012268:	2300      	movs	r3, #0
 801226a:	e000      	b.n	801226e <HAL_UART_Transmit+0x146>
  }
  else
  {
    return HAL_BUSY;
 801226c:	2302      	movs	r3, #2
  }
}
 801226e:	0018      	movs	r0, r3
 8012270:	46bd      	mov	sp, r7
 8012272:	b008      	add	sp, #32
 8012274:	bd80      	pop	{r7, pc}
	...

08012278 <HAL_UART_Receive_IT>:
  * @param pData Pointer to data buffer.
  * @param Size  Amount of data to be received.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 8012278:	b580      	push	{r7, lr}
 801227a:	b084      	sub	sp, #16
 801227c:	af00      	add	r7, sp, #0
 801227e:	60f8      	str	r0, [r7, #12]
 8012280:	60b9      	str	r1, [r7, #8]
 8012282:	1dbb      	adds	r3, r7, #6
 8012284:	801a      	strh	r2, [r3, #0]
  /* Check that a Rx process is not already ongoing */
  if (huart->RxState == HAL_UART_STATE_READY)
 8012286:	68fb      	ldr	r3, [r7, #12]
 8012288:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 801228a:	2b20      	cmp	r3, #32
 801228c:	d000      	beq.n	8012290 <HAL_UART_Receive_IT+0x18>
 801228e:	e09f      	b.n	80123d0 <HAL_UART_Receive_IT+0x158>
  {
    if ((pData == NULL) || (Size == 0U))
 8012290:	68bb      	ldr	r3, [r7, #8]
 8012292:	2b00      	cmp	r3, #0
 8012294:	d003      	beq.n	801229e <HAL_UART_Receive_IT+0x26>
 8012296:	1dbb      	adds	r3, r7, #6
 8012298:	881b      	ldrh	r3, [r3, #0]
 801229a:	2b00      	cmp	r3, #0
 801229c:	d101      	bne.n	80122a2 <HAL_UART_Receive_IT+0x2a>
    {
      return HAL_ERROR;
 801229e:	2301      	movs	r3, #1
 80122a0:	e097      	b.n	80123d2 <HAL_UART_Receive_IT+0x15a>
    }

    /* In case of 9bits/No Parity transfer, pData buffer provided as input parameter
       should be aligned on a u16 frontier, as data to be received from RDR will be
       handled through a u16 cast. */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80122a2:	68fb      	ldr	r3, [r7, #12]
 80122a4:	689a      	ldr	r2, [r3, #8]
 80122a6:	2380      	movs	r3, #128	; 0x80
 80122a8:	015b      	lsls	r3, r3, #5
 80122aa:	429a      	cmp	r2, r3
 80122ac:	d109      	bne.n	80122c2 <HAL_UART_Receive_IT+0x4a>
 80122ae:	68fb      	ldr	r3, [r7, #12]
 80122b0:	691b      	ldr	r3, [r3, #16]
 80122b2:	2b00      	cmp	r3, #0
 80122b4:	d105      	bne.n	80122c2 <HAL_UART_Receive_IT+0x4a>
    {
      if ((((uint32_t)pData) & 1) != 0)
 80122b6:	68bb      	ldr	r3, [r7, #8]
 80122b8:	2201      	movs	r2, #1
 80122ba:	4013      	ands	r3, r2
 80122bc:	d001      	beq.n	80122c2 <HAL_UART_Receive_IT+0x4a>
      {
        return  HAL_ERROR;
 80122be:	2301      	movs	r3, #1
 80122c0:	e087      	b.n	80123d2 <HAL_UART_Receive_IT+0x15a>
      }
    }

    /* Process Locked */
    __HAL_LOCK(huart);
 80122c2:	68fb      	ldr	r3, [r7, #12]
 80122c4:	2270      	movs	r2, #112	; 0x70
 80122c6:	5c9b      	ldrb	r3, [r3, r2]
 80122c8:	2b01      	cmp	r3, #1
 80122ca:	d101      	bne.n	80122d0 <HAL_UART_Receive_IT+0x58>
 80122cc:	2302      	movs	r3, #2
 80122ce:	e080      	b.n	80123d2 <HAL_UART_Receive_IT+0x15a>
 80122d0:	68fb      	ldr	r3, [r7, #12]
 80122d2:	2270      	movs	r2, #112	; 0x70
 80122d4:	2101      	movs	r1, #1
 80122d6:	5499      	strb	r1, [r3, r2]

    huart->pRxBuffPtr  = pData;
 80122d8:	68fb      	ldr	r3, [r7, #12]
 80122da:	68ba      	ldr	r2, [r7, #8]
 80122dc:	655a      	str	r2, [r3, #84]	; 0x54
    huart->RxXferSize  = Size;
 80122de:	68fb      	ldr	r3, [r7, #12]
 80122e0:	1dba      	adds	r2, r7, #6
 80122e2:	2158      	movs	r1, #88	; 0x58
 80122e4:	8812      	ldrh	r2, [r2, #0]
 80122e6:	525a      	strh	r2, [r3, r1]
    huart->RxXferCount = Size;
 80122e8:	68fb      	ldr	r3, [r7, #12]
 80122ea:	1dba      	adds	r2, r7, #6
 80122ec:	215a      	movs	r1, #90	; 0x5a
 80122ee:	8812      	ldrh	r2, [r2, #0]
 80122f0:	525a      	strh	r2, [r3, r1]
    huart->RxISR       = NULL;
 80122f2:	68fb      	ldr	r3, [r7, #12]
 80122f4:	2200      	movs	r2, #0
 80122f6:	661a      	str	r2, [r3, #96]	; 0x60

    /* Computation of UART mask to apply to RDR register */
    UART_MASK_COMPUTATION(huart);
 80122f8:	68fb      	ldr	r3, [r7, #12]
 80122fa:	689a      	ldr	r2, [r3, #8]
 80122fc:	2380      	movs	r3, #128	; 0x80
 80122fe:	015b      	lsls	r3, r3, #5
 8012300:	429a      	cmp	r2, r3
 8012302:	d10d      	bne.n	8012320 <HAL_UART_Receive_IT+0xa8>
 8012304:	68fb      	ldr	r3, [r7, #12]
 8012306:	691b      	ldr	r3, [r3, #16]
 8012308:	2b00      	cmp	r3, #0
 801230a:	d104      	bne.n	8012316 <HAL_UART_Receive_IT+0x9e>
 801230c:	68fb      	ldr	r3, [r7, #12]
 801230e:	225c      	movs	r2, #92	; 0x5c
 8012310:	4932      	ldr	r1, [pc, #200]	; (80123dc <HAL_UART_Receive_IT+0x164>)
 8012312:	5299      	strh	r1, [r3, r2]
 8012314:	e02e      	b.n	8012374 <HAL_UART_Receive_IT+0xfc>
 8012316:	68fb      	ldr	r3, [r7, #12]
 8012318:	225c      	movs	r2, #92	; 0x5c
 801231a:	21ff      	movs	r1, #255	; 0xff
 801231c:	5299      	strh	r1, [r3, r2]
 801231e:	e029      	b.n	8012374 <HAL_UART_Receive_IT+0xfc>
 8012320:	68fb      	ldr	r3, [r7, #12]
 8012322:	689b      	ldr	r3, [r3, #8]
 8012324:	2b00      	cmp	r3, #0
 8012326:	d10d      	bne.n	8012344 <HAL_UART_Receive_IT+0xcc>
 8012328:	68fb      	ldr	r3, [r7, #12]
 801232a:	691b      	ldr	r3, [r3, #16]
 801232c:	2b00      	cmp	r3, #0
 801232e:	d104      	bne.n	801233a <HAL_UART_Receive_IT+0xc2>
 8012330:	68fb      	ldr	r3, [r7, #12]
 8012332:	225c      	movs	r2, #92	; 0x5c
 8012334:	21ff      	movs	r1, #255	; 0xff
 8012336:	5299      	strh	r1, [r3, r2]
 8012338:	e01c      	b.n	8012374 <HAL_UART_Receive_IT+0xfc>
 801233a:	68fb      	ldr	r3, [r7, #12]
 801233c:	225c      	movs	r2, #92	; 0x5c
 801233e:	217f      	movs	r1, #127	; 0x7f
 8012340:	5299      	strh	r1, [r3, r2]
 8012342:	e017      	b.n	8012374 <HAL_UART_Receive_IT+0xfc>
 8012344:	68fb      	ldr	r3, [r7, #12]
 8012346:	689a      	ldr	r2, [r3, #8]
 8012348:	2380      	movs	r3, #128	; 0x80
 801234a:	055b      	lsls	r3, r3, #21
 801234c:	429a      	cmp	r2, r3
 801234e:	d10d      	bne.n	801236c <HAL_UART_Receive_IT+0xf4>
 8012350:	68fb      	ldr	r3, [r7, #12]
 8012352:	691b      	ldr	r3, [r3, #16]
 8012354:	2b00      	cmp	r3, #0
 8012356:	d104      	bne.n	8012362 <HAL_UART_Receive_IT+0xea>
 8012358:	68fb      	ldr	r3, [r7, #12]
 801235a:	225c      	movs	r2, #92	; 0x5c
 801235c:	217f      	movs	r1, #127	; 0x7f
 801235e:	5299      	strh	r1, [r3, r2]
 8012360:	e008      	b.n	8012374 <HAL_UART_Receive_IT+0xfc>
 8012362:	68fb      	ldr	r3, [r7, #12]
 8012364:	225c      	movs	r2, #92	; 0x5c
 8012366:	213f      	movs	r1, #63	; 0x3f
 8012368:	5299      	strh	r1, [r3, r2]
 801236a:	e003      	b.n	8012374 <HAL_UART_Receive_IT+0xfc>
 801236c:	68fb      	ldr	r3, [r7, #12]
 801236e:	225c      	movs	r2, #92	; 0x5c
 8012370:	2100      	movs	r1, #0
 8012372:	5299      	strh	r1, [r3, r2]

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8012374:	68fb      	ldr	r3, [r7, #12]
 8012376:	2200      	movs	r2, #0
 8012378:	67da      	str	r2, [r3, #124]	; 0x7c
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 801237a:	68fb      	ldr	r3, [r7, #12]
 801237c:	2222      	movs	r2, #34	; 0x22
 801237e:	679a      	str	r2, [r3, #120]	; 0x78

    /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8012380:	68fb      	ldr	r3, [r7, #12]
 8012382:	681b      	ldr	r3, [r3, #0]
 8012384:	689a      	ldr	r2, [r3, #8]
 8012386:	68fb      	ldr	r3, [r7, #12]
 8012388:	681b      	ldr	r3, [r3, #0]
 801238a:	2101      	movs	r1, #1
 801238c:	430a      	orrs	r2, r1
 801238e:	609a      	str	r2, [r3, #8]

    /* Set the Rx ISR function pointer according to the data word length */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8012390:	68fb      	ldr	r3, [r7, #12]
 8012392:	689a      	ldr	r2, [r3, #8]
 8012394:	2380      	movs	r3, #128	; 0x80
 8012396:	015b      	lsls	r3, r3, #5
 8012398:	429a      	cmp	r2, r3
 801239a:	d107      	bne.n	80123ac <HAL_UART_Receive_IT+0x134>
 801239c:	68fb      	ldr	r3, [r7, #12]
 801239e:	691b      	ldr	r3, [r3, #16]
 80123a0:	2b00      	cmp	r3, #0
 80123a2:	d103      	bne.n	80123ac <HAL_UART_Receive_IT+0x134>
    {
      huart->RxISR = UART_RxISR_16BIT;
 80123a4:	68fb      	ldr	r3, [r7, #12]
 80123a6:	4a0e      	ldr	r2, [pc, #56]	; (80123e0 <HAL_UART_Receive_IT+0x168>)
 80123a8:	661a      	str	r2, [r3, #96]	; 0x60
 80123aa:	e002      	b.n	80123b2 <HAL_UART_Receive_IT+0x13a>
    }
    else
    {
      huart->RxISR = UART_RxISR_8BIT;
 80123ac:	68fb      	ldr	r3, [r7, #12]
 80123ae:	4a0d      	ldr	r2, [pc, #52]	; (80123e4 <HAL_UART_Receive_IT+0x16c>)
 80123b0:	661a      	str	r2, [r3, #96]	; 0x60
    }

    /* Process Unlocked */
    __HAL_UNLOCK(huart);
 80123b2:	68fb      	ldr	r3, [r7, #12]
 80123b4:	2270      	movs	r2, #112	; 0x70
 80123b6:	2100      	movs	r1, #0
 80123b8:	5499      	strb	r1, [r3, r2]

    /* Enable the UART Parity Error interrupt and Data Register Not Empty interrupt */
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
 80123ba:	68fb      	ldr	r3, [r7, #12]
 80123bc:	681b      	ldr	r3, [r3, #0]
 80123be:	681a      	ldr	r2, [r3, #0]
 80123c0:	68fb      	ldr	r3, [r7, #12]
 80123c2:	681b      	ldr	r3, [r3, #0]
 80123c4:	2190      	movs	r1, #144	; 0x90
 80123c6:	0049      	lsls	r1, r1, #1
 80123c8:	430a      	orrs	r2, r1
 80123ca:	601a      	str	r2, [r3, #0]

    return HAL_OK;
 80123cc:	2300      	movs	r3, #0
 80123ce:	e000      	b.n	80123d2 <HAL_UART_Receive_IT+0x15a>
  }
  else
  {
    return HAL_BUSY;
 80123d0:	2302      	movs	r3, #2
  }
}
 80123d2:	0018      	movs	r0, r3
 80123d4:	46bd      	mov	sp, r7
 80123d6:	b004      	add	sp, #16
 80123d8:	bd80      	pop	{r7, pc}
 80123da:	46c0      	nop			; (mov r8, r8)
 80123dc:	000001ff 	.word	0x000001ff
 80123e0:	080130a5 	.word	0x080130a5
 80123e4:	08012fe9 	.word	0x08012fe9

080123e8 <HAL_UART_IRQHandler>:
  * @brief Handle UART interrupt request.
  * @param huart UART handle.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
 80123e8:	b580      	push	{r7, lr}
 80123ea:	b088      	sub	sp, #32
 80123ec:	af00      	add	r7, sp, #0
 80123ee:	6078      	str	r0, [r7, #4]
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 80123f0:	687b      	ldr	r3, [r7, #4]
 80123f2:	681b      	ldr	r3, [r3, #0]
 80123f4:	69db      	ldr	r3, [r3, #28]
 80123f6:	61fb      	str	r3, [r7, #28]
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 80123f8:	687b      	ldr	r3, [r7, #4]
 80123fa:	681b      	ldr	r3, [r3, #0]
 80123fc:	681b      	ldr	r3, [r3, #0]
 80123fe:	61bb      	str	r3, [r7, #24]
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 8012400:	687b      	ldr	r3, [r7, #4]
 8012402:	681b      	ldr	r3, [r3, #0]
 8012404:	689b      	ldr	r3, [r3, #8]
 8012406:	617b      	str	r3, [r7, #20]

  uint32_t errorflags;
  uint32_t errorcode;

  /* If no error occurs */
  errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE));
 8012408:	69fb      	ldr	r3, [r7, #28]
 801240a:	220f      	movs	r2, #15
 801240c:	4013      	ands	r3, r2
 801240e:	613b      	str	r3, [r7, #16]
  if (errorflags == 0U)
 8012410:	693b      	ldr	r3, [r7, #16]
 8012412:	2b00      	cmp	r3, #0
 8012414:	d112      	bne.n	801243c <HAL_UART_IRQHandler+0x54>
  {
    /* UART in mode Receiver ---------------------------------------------------*/
    if (((isrflags & USART_ISR_RXNE) != 0U)
 8012416:	69fb      	ldr	r3, [r7, #28]
 8012418:	2220      	movs	r2, #32
 801241a:	4013      	ands	r3, r2
 801241c:	d00e      	beq.n	801243c <HAL_UART_IRQHandler+0x54>
        && ((cr1its & USART_CR1_RXNEIE) != 0U))
 801241e:	69bb      	ldr	r3, [r7, #24]
 8012420:	2220      	movs	r2, #32
 8012422:	4013      	ands	r3, r2
 8012424:	d00a      	beq.n	801243c <HAL_UART_IRQHandler+0x54>
    {
      if (huart->RxISR != NULL)
 8012426:	687b      	ldr	r3, [r7, #4]
 8012428:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 801242a:	2b00      	cmp	r3, #0
 801242c:	d100      	bne.n	8012430 <HAL_UART_IRQHandler+0x48>
 801242e:	e0f6      	b.n	801261e <HAL_UART_IRQHandler+0x236>
      {
        huart->RxISR(huart);
 8012430:	687b      	ldr	r3, [r7, #4]
 8012432:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8012434:	687a      	ldr	r2, [r7, #4]
 8012436:	0010      	movs	r0, r2
 8012438:	4798      	blx	r3
      }
      return;
 801243a:	e0f0      	b.n	801261e <HAL_UART_IRQHandler+0x236>
    }
  }

  /* If some errors occur */
  if ((errorflags != 0U)
 801243c:	693b      	ldr	r3, [r7, #16]
 801243e:	2b00      	cmp	r3, #0
 8012440:	d100      	bne.n	8012444 <HAL_UART_IRQHandler+0x5c>
 8012442:	e0b8      	b.n	80125b6 <HAL_UART_IRQHandler+0x1ce>
      && (((cr3its & USART_CR3_EIE) != 0U)
 8012444:	697b      	ldr	r3, [r7, #20]
 8012446:	2201      	movs	r2, #1
 8012448:	4013      	ands	r3, r2
 801244a:	d105      	bne.n	8012458 <HAL_UART_IRQHandler+0x70>
          || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != 0U)))
 801244c:	69ba      	ldr	r2, [r7, #24]
 801244e:	2390      	movs	r3, #144	; 0x90
 8012450:	005b      	lsls	r3, r3, #1
 8012452:	4013      	ands	r3, r2
 8012454:	d100      	bne.n	8012458 <HAL_UART_IRQHandler+0x70>
 8012456:	e0ae      	b.n	80125b6 <HAL_UART_IRQHandler+0x1ce>
  {
    /* UART parity error interrupt occurred -------------------------------------*/
    if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 8012458:	69fb      	ldr	r3, [r7, #28]
 801245a:	2201      	movs	r2, #1
 801245c:	4013      	ands	r3, r2
 801245e:	d00e      	beq.n	801247e <HAL_UART_IRQHandler+0x96>
 8012460:	69ba      	ldr	r2, [r7, #24]
 8012462:	2380      	movs	r3, #128	; 0x80
 8012464:	005b      	lsls	r3, r3, #1
 8012466:	4013      	ands	r3, r2
 8012468:	d009      	beq.n	801247e <HAL_UART_IRQHandler+0x96>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 801246a:	687b      	ldr	r3, [r7, #4]
 801246c:	681b      	ldr	r3, [r3, #0]
 801246e:	2201      	movs	r2, #1
 8012470:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_PE;
 8012472:	687b      	ldr	r3, [r7, #4]
 8012474:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8012476:	2201      	movs	r2, #1
 8012478:	431a      	orrs	r2, r3
 801247a:	687b      	ldr	r3, [r7, #4]
 801247c:	67da      	str	r2, [r3, #124]	; 0x7c
    }

    /* UART frame error interrupt occurred --------------------------------------*/
    if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 801247e:	69fb      	ldr	r3, [r7, #28]
 8012480:	2202      	movs	r2, #2
 8012482:	4013      	ands	r3, r2
 8012484:	d00d      	beq.n	80124a2 <HAL_UART_IRQHandler+0xba>
 8012486:	697b      	ldr	r3, [r7, #20]
 8012488:	2201      	movs	r2, #1
 801248a:	4013      	ands	r3, r2
 801248c:	d009      	beq.n	80124a2 <HAL_UART_IRQHandler+0xba>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 801248e:	687b      	ldr	r3, [r7, #4]
 8012490:	681b      	ldr	r3, [r3, #0]
 8012492:	2202      	movs	r2, #2
 8012494:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_FE;
 8012496:	687b      	ldr	r3, [r7, #4]
 8012498:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 801249a:	2204      	movs	r2, #4
 801249c:	431a      	orrs	r2, r3
 801249e:	687b      	ldr	r3, [r7, #4]
 80124a0:	67da      	str	r2, [r3, #124]	; 0x7c
    }

    /* UART noise error interrupt occurred --------------------------------------*/
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80124a2:	69fb      	ldr	r3, [r7, #28]
 80124a4:	2204      	movs	r2, #4
 80124a6:	4013      	ands	r3, r2
 80124a8:	d00d      	beq.n	80124c6 <HAL_UART_IRQHandler+0xde>
 80124aa:	697b      	ldr	r3, [r7, #20]
 80124ac:	2201      	movs	r2, #1
 80124ae:	4013      	ands	r3, r2
 80124b0:	d009      	beq.n	80124c6 <HAL_UART_IRQHandler+0xde>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 80124b2:	687b      	ldr	r3, [r7, #4]
 80124b4:	681b      	ldr	r3, [r3, #0]
 80124b6:	2204      	movs	r2, #4
 80124b8:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_NE;
 80124ba:	687b      	ldr	r3, [r7, #4]
 80124bc:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 80124be:	2202      	movs	r2, #2
 80124c0:	431a      	orrs	r2, r3
 80124c2:	687b      	ldr	r3, [r7, #4]
 80124c4:	67da      	str	r2, [r3, #124]	; 0x7c
    }

    /* UART Over-Run interrupt occurred -----------------------------------------*/
    if (((isrflags & USART_ISR_ORE) != 0U)
 80124c6:	69fb      	ldr	r3, [r7, #28]
 80124c8:	2208      	movs	r2, #8
 80124ca:	4013      	ands	r3, r2
 80124cc:	d011      	beq.n	80124f2 <HAL_UART_IRQHandler+0x10a>
        && (((cr1its & USART_CR1_RXNEIE) != 0U) ||
 80124ce:	69bb      	ldr	r3, [r7, #24]
 80124d0:	2220      	movs	r2, #32
 80124d2:	4013      	ands	r3, r2
 80124d4:	d103      	bne.n	80124de <HAL_UART_IRQHandler+0xf6>
            ((cr3its & USART_CR3_EIE) != 0U)))
 80124d6:	697b      	ldr	r3, [r7, #20]
 80124d8:	2201      	movs	r2, #1
 80124da:	4013      	ands	r3, r2
        && (((cr1its & USART_CR1_RXNEIE) != 0U) ||
 80124dc:	d009      	beq.n	80124f2 <HAL_UART_IRQHandler+0x10a>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 80124de:	687b      	ldr	r3, [r7, #4]
 80124e0:	681b      	ldr	r3, [r3, #0]
 80124e2:	2208      	movs	r2, #8
 80124e4:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 80124e6:	687b      	ldr	r3, [r7, #4]
 80124e8:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 80124ea:	2208      	movs	r2, #8
 80124ec:	431a      	orrs	r2, r3
 80124ee:	687b      	ldr	r3, [r7, #4]
 80124f0:	67da      	str	r2, [r3, #124]	; 0x7c
    }

    /* Call UART Error Call back function if need be --------------------------*/
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 80124f2:	687b      	ldr	r3, [r7, #4]
 80124f4:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 80124f6:	2b00      	cmp	r3, #0
 80124f8:	d100      	bne.n	80124fc <HAL_UART_IRQHandler+0x114>
 80124fa:	e092      	b.n	8012622 <HAL_UART_IRQHandler+0x23a>
    {
      /* UART in mode Receiver ---------------------------------------------------*/
      if (((isrflags & USART_ISR_RXNE) != 0U)
 80124fc:	69fb      	ldr	r3, [r7, #28]
 80124fe:	2220      	movs	r2, #32
 8012500:	4013      	ands	r3, r2
 8012502:	d00c      	beq.n	801251e <HAL_UART_IRQHandler+0x136>
          && ((cr1its & USART_CR1_RXNEIE) != 0U))
 8012504:	69bb      	ldr	r3, [r7, #24]
 8012506:	2220      	movs	r2, #32
 8012508:	4013      	ands	r3, r2
 801250a:	d008      	beq.n	801251e <HAL_UART_IRQHandler+0x136>
      {
        if (huart->RxISR != NULL)
 801250c:	687b      	ldr	r3, [r7, #4]
 801250e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8012510:	2b00      	cmp	r3, #0
 8012512:	d004      	beq.n	801251e <HAL_UART_IRQHandler+0x136>
        {
          huart->RxISR(huart);
 8012514:	687b      	ldr	r3, [r7, #4]
 8012516:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8012518:	687a      	ldr	r2, [r7, #4]
 801251a:	0010      	movs	r0, r2
 801251c:	4798      	blx	r3
        }
      }

      /* If Overrun error occurs, or if any error occurs in DMA mode reception,
         consider error as blocking */
      errorcode = huart->ErrorCode;
 801251e:	687b      	ldr	r3, [r7, #4]
 8012520:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8012522:	60fb      	str	r3, [r7, #12]
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 8012524:	687b      	ldr	r3, [r7, #4]
 8012526:	681b      	ldr	r3, [r3, #0]
 8012528:	689b      	ldr	r3, [r3, #8]
 801252a:	2240      	movs	r2, #64	; 0x40
 801252c:	4013      	ands	r3, r2
 801252e:	2b40      	cmp	r3, #64	; 0x40
 8012530:	d003      	beq.n	801253a <HAL_UART_IRQHandler+0x152>
          ((errorcode & HAL_UART_ERROR_ORE) != 0U))
 8012532:	68fb      	ldr	r3, [r7, #12]
 8012534:	2208      	movs	r2, #8
 8012536:	4013      	ands	r3, r2
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 8012538:	d033      	beq.n	80125a2 <HAL_UART_IRQHandler+0x1ba>
      {
        /* Blocking error : transfer is aborted
           Set the UART state ready to be able to start again the process,
           Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
        UART_EndRxTransfer(huart);
 801253a:	687b      	ldr	r3, [r7, #4]
 801253c:	0018      	movs	r0, r3
 801253e:	f000 fd01 	bl	8012f44 <UART_EndRxTransfer>

        /* Disable the UART DMA Rx request if enabled */
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8012542:	687b      	ldr	r3, [r7, #4]
 8012544:	681b      	ldr	r3, [r3, #0]
 8012546:	689b      	ldr	r3, [r3, #8]
 8012548:	2240      	movs	r2, #64	; 0x40
 801254a:	4013      	ands	r3, r2
 801254c:	2b40      	cmp	r3, #64	; 0x40
 801254e:	d123      	bne.n	8012598 <HAL_UART_IRQHandler+0x1b0>
        {
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8012550:	687b      	ldr	r3, [r7, #4]
 8012552:	681b      	ldr	r3, [r3, #0]
 8012554:	689a      	ldr	r2, [r3, #8]
 8012556:	687b      	ldr	r3, [r7, #4]
 8012558:	681b      	ldr	r3, [r3, #0]
 801255a:	2140      	movs	r1, #64	; 0x40
 801255c:	438a      	bics	r2, r1
 801255e:	609a      	str	r2, [r3, #8]

          /* Abort the UART DMA Rx channel */
          if (huart->hdmarx != NULL)
 8012560:	687b      	ldr	r3, [r7, #4]
 8012562:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8012564:	2b00      	cmp	r3, #0
 8012566:	d012      	beq.n	801258e <HAL_UART_IRQHandler+0x1a6>
          {
            /* Set the UART DMA Abort callback :
               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 8012568:	687b      	ldr	r3, [r7, #4]
 801256a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 801256c:	4a30      	ldr	r2, [pc, #192]	; (8012630 <HAL_UART_IRQHandler+0x248>)
 801256e:	639a      	str	r2, [r3, #56]	; 0x38

            /* Abort DMA RX */
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 8012570:	687b      	ldr	r3, [r7, #4]
 8012572:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8012574:	0018      	movs	r0, r3
 8012576:	f7fd f909 	bl	800f78c <HAL_DMA_Abort_IT>
 801257a:	1e03      	subs	r3, r0, #0
 801257c:	d019      	beq.n	80125b2 <HAL_UART_IRQHandler+0x1ca>
            {
              /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 801257e:	687b      	ldr	r3, [r7, #4]
 8012580:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8012582:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8012584:	687b      	ldr	r3, [r7, #4]
 8012586:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8012588:	0018      	movs	r0, r3
 801258a:	4790      	blx	r2
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 801258c:	e011      	b.n	80125b2 <HAL_UART_IRQHandler+0x1ca>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
            /*Call registered error callback*/
            huart->ErrorCallback(huart);
#else
            /*Call legacy weak error callback*/
            HAL_UART_ErrorCallback(huart);
 801258e:	687b      	ldr	r3, [r7, #4]
 8012590:	0018      	movs	r0, r3
 8012592:	f000 f857 	bl	8012644 <HAL_UART_ErrorCallback>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8012596:	e00c      	b.n	80125b2 <HAL_UART_IRQHandler+0x1ca>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
          /*Call registered error callback*/
          huart->ErrorCallback(huart);
#else
          /*Call legacy weak error callback*/
          HAL_UART_ErrorCallback(huart);
 8012598:	687b      	ldr	r3, [r7, #4]
 801259a:	0018      	movs	r0, r3
 801259c:	f000 f852 	bl	8012644 <HAL_UART_ErrorCallback>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 80125a0:	e007      	b.n	80125b2 <HAL_UART_IRQHandler+0x1ca>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered error callback*/
        huart->ErrorCallback(huart);
#else
        /*Call legacy weak error callback*/
        HAL_UART_ErrorCallback(huart);
 80125a2:	687b      	ldr	r3, [r7, #4]
 80125a4:	0018      	movs	r0, r3
 80125a6:	f000 f84d 	bl	8012644 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 80125aa:	687b      	ldr	r3, [r7, #4]
 80125ac:	2200      	movs	r2, #0
 80125ae:	67da      	str	r2, [r3, #124]	; 0x7c
      }
    }
    return;
 80125b0:	e037      	b.n	8012622 <HAL_UART_IRQHandler+0x23a>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 80125b2:	46c0      	nop			; (mov r8, r8)
    return;
 80125b4:	e035      	b.n	8012622 <HAL_UART_IRQHandler+0x23a>

  } /* End if some error occurs */

  /* UART wakeup from Stop mode interrupt occurred ---------------------------*/
  if (((isrflags & USART_ISR_WUF) != 0U) && ((cr3its & USART_CR3_WUFIE) != 0U))
 80125b6:	69fa      	ldr	r2, [r7, #28]
 80125b8:	2380      	movs	r3, #128	; 0x80
 80125ba:	035b      	lsls	r3, r3, #13
 80125bc:	4013      	ands	r3, r2
 80125be:	d00e      	beq.n	80125de <HAL_UART_IRQHandler+0x1f6>
 80125c0:	697a      	ldr	r2, [r7, #20]
 80125c2:	2380      	movs	r3, #128	; 0x80
 80125c4:	03db      	lsls	r3, r3, #15
 80125c6:	4013      	ands	r3, r2
 80125c8:	d009      	beq.n	80125de <HAL_UART_IRQHandler+0x1f6>
  {
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
 80125ca:	687b      	ldr	r3, [r7, #4]
 80125cc:	681b      	ldr	r3, [r3, #0]
 80125ce:	2280      	movs	r2, #128	; 0x80
 80125d0:	0352      	lsls	r2, r2, #13
 80125d2:	621a      	str	r2, [r3, #32]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    /* Call registered Wakeup Callback */
    huart->WakeupCallback(huart);
#else
    /* Call legacy weak Wakeup Callback */
    HAL_UARTEx_WakeupCallback(huart);
 80125d4:	687b      	ldr	r3, [r7, #4]
 80125d6:	0018      	movs	r0, r3
 80125d8:	f000 fdc2 	bl	8013160 <HAL_UARTEx_WakeupCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
    return;
 80125dc:	e024      	b.n	8012628 <HAL_UART_IRQHandler+0x240>
  }

  /* UART in mode Transmitter ------------------------------------------------*/
  if (((isrflags & USART_ISR_TXE) != 0U)
 80125de:	69fb      	ldr	r3, [r7, #28]
 80125e0:	2280      	movs	r2, #128	; 0x80
 80125e2:	4013      	ands	r3, r2
 80125e4:	d00d      	beq.n	8012602 <HAL_UART_IRQHandler+0x21a>
      && ((cr1its & USART_CR1_TXEIE) != 0U))
 80125e6:	69bb      	ldr	r3, [r7, #24]
 80125e8:	2280      	movs	r2, #128	; 0x80
 80125ea:	4013      	ands	r3, r2
 80125ec:	d009      	beq.n	8012602 <HAL_UART_IRQHandler+0x21a>
  {
    if (huart->TxISR != NULL)
 80125ee:	687b      	ldr	r3, [r7, #4]
 80125f0:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80125f2:	2b00      	cmp	r3, #0
 80125f4:	d017      	beq.n	8012626 <HAL_UART_IRQHandler+0x23e>
    {
      huart->TxISR(huart);
 80125f6:	687b      	ldr	r3, [r7, #4]
 80125f8:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80125fa:	687a      	ldr	r2, [r7, #4]
 80125fc:	0010      	movs	r0, r2
 80125fe:	4798      	blx	r3
    }
    return;
 8012600:	e011      	b.n	8012626 <HAL_UART_IRQHandler+0x23e>
  }

  /* UART in mode Transmitter (transmission end) -----------------------------*/
  if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))
 8012602:	69fb      	ldr	r3, [r7, #28]
 8012604:	2240      	movs	r2, #64	; 0x40
 8012606:	4013      	ands	r3, r2
 8012608:	d00e      	beq.n	8012628 <HAL_UART_IRQHandler+0x240>
 801260a:	69bb      	ldr	r3, [r7, #24]
 801260c:	2240      	movs	r2, #64	; 0x40
 801260e:	4013      	ands	r3, r2
 8012610:	d00a      	beq.n	8012628 <HAL_UART_IRQHandler+0x240>
  {
    UART_EndTransmit_IT(huart);
 8012612:	687b      	ldr	r3, [r7, #4]
 8012614:	0018      	movs	r0, r3
 8012616:	f000 fccc 	bl	8012fb2 <UART_EndTransmit_IT>
    return;
 801261a:	46c0      	nop			; (mov r8, r8)
 801261c:	e004      	b.n	8012628 <HAL_UART_IRQHandler+0x240>
      return;
 801261e:	46c0      	nop			; (mov r8, r8)
 8012620:	e002      	b.n	8012628 <HAL_UART_IRQHandler+0x240>
    return;
 8012622:	46c0      	nop			; (mov r8, r8)
 8012624:	e000      	b.n	8012628 <HAL_UART_IRQHandler+0x240>
    return;
 8012626:	46c0      	nop			; (mov r8, r8)
  }

}
 8012628:	46bd      	mov	sp, r7
 801262a:	b008      	add	sp, #32
 801262c:	bd80      	pop	{r7, pc}
 801262e:	46c0      	nop			; (mov r8, r8)
 8012630:	08012f85 	.word	0x08012f85

08012634 <HAL_UART_TxCpltCallback>:
  * @brief Tx Transfer completed callback.
  * @param huart UART handle.
  * @retval None
  */
__weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
 8012634:	b580      	push	{r7, lr}
 8012636:	b082      	sub	sp, #8
 8012638:	af00      	add	r7, sp, #0
 801263a:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_TxCpltCallback can be implemented in the user file.
   */
}
 801263c:	46c0      	nop			; (mov r8, r8)
 801263e:	46bd      	mov	sp, r7
 8012640:	b002      	add	sp, #8
 8012642:	bd80      	pop	{r7, pc}

08012644 <HAL_UART_ErrorCallback>:
  * @brief  UART error callback.
  * @param  huart UART handle.
  * @retval None
  */
__weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
 8012644:	b580      	push	{r7, lr}
 8012646:	b082      	sub	sp, #8
 8012648:	af00      	add	r7, sp, #0
 801264a:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_ErrorCallback can be implemented in the user file.
   */
}
 801264c:	46c0      	nop			; (mov r8, r8)
 801264e:	46bd      	mov	sp, r7
 8012650:	b002      	add	sp, #8
 8012652:	bd80      	pop	{r7, pc}

08012654 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 8012654:	b5b0      	push	{r4, r5, r7, lr}
 8012656:	b08e      	sub	sp, #56	; 0x38
 8012658:	af00      	add	r7, sp, #0
 801265a:	61f8      	str	r0, [r7, #28]
  uint32_t tmpreg;
  uint16_t brrtemp;
  UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
 801265c:	231b      	movs	r3, #27
 801265e:	2218      	movs	r2, #24
 8012660:	4694      	mov	ip, r2
 8012662:	44bc      	add	ip, r7
 8012664:	4463      	add	r3, ip
 8012666:	2210      	movs	r2, #16
 8012668:	701a      	strb	r2, [r3, #0]
  uint32_t usartdiv                   = 0x00000000U;
 801266a:	2300      	movs	r3, #0
 801266c:	62fb      	str	r3, [r7, #44]	; 0x2c
  HAL_StatusTypeDef ret               = HAL_OK;
 801266e:	2313      	movs	r3, #19
 8012670:	2218      	movs	r2, #24
 8012672:	4694      	mov	ip, r2
 8012674:	44bc      	add	ip, r7
 8012676:	4463      	add	r3, ip
 8012678:	2200      	movs	r2, #0
 801267a:	701a      	strb	r2, [r3, #0]
  uint32_t lpuart_ker_ck_pres         = 0x00000000U;
 801267c:	2300      	movs	r3, #0
 801267e:	627b      	str	r3, [r7, #36]	; 0x24
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8012680:	69fb      	ldr	r3, [r7, #28]
 8012682:	689a      	ldr	r2, [r3, #8]
 8012684:	69fb      	ldr	r3, [r7, #28]
 8012686:	691b      	ldr	r3, [r3, #16]
 8012688:	431a      	orrs	r2, r3
 801268a:	69fb      	ldr	r3, [r7, #28]
 801268c:	695b      	ldr	r3, [r3, #20]
 801268e:	431a      	orrs	r2, r3
 8012690:	69fb      	ldr	r3, [r7, #28]
 8012692:	69db      	ldr	r3, [r3, #28]
 8012694:	4313      	orrs	r3, r2
 8012696:	637b      	str	r3, [r7, #52]	; 0x34
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8012698:	69fb      	ldr	r3, [r7, #28]
 801269a:	681b      	ldr	r3, [r3, #0]
 801269c:	681b      	ldr	r3, [r3, #0]
 801269e:	4aca      	ldr	r2, [pc, #808]	; (80129c8 <UART_SetConfig+0x374>)
 80126a0:	4013      	ands	r3, r2
 80126a2:	0019      	movs	r1, r3
 80126a4:	69fb      	ldr	r3, [r7, #28]
 80126a6:	681b      	ldr	r3, [r3, #0]
 80126a8:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80126aa:	430a      	orrs	r2, r1
 80126ac:	601a      	str	r2, [r3, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80126ae:	69fb      	ldr	r3, [r7, #28]
 80126b0:	681b      	ldr	r3, [r3, #0]
 80126b2:	685b      	ldr	r3, [r3, #4]
 80126b4:	4ac5      	ldr	r2, [pc, #788]	; (80129cc <UART_SetConfig+0x378>)
 80126b6:	4013      	ands	r3, r2
 80126b8:	0019      	movs	r1, r3
 80126ba:	69fb      	ldr	r3, [r7, #28]
 80126bc:	68da      	ldr	r2, [r3, #12]
 80126be:	69fb      	ldr	r3, [r7, #28]
 80126c0:	681b      	ldr	r3, [r3, #0]
 80126c2:	430a      	orrs	r2, r1
 80126c4:	605a      	str	r2, [r3, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 80126c6:	69fb      	ldr	r3, [r7, #28]
 80126c8:	699b      	ldr	r3, [r3, #24]
 80126ca:	637b      	str	r3, [r7, #52]	; 0x34

  if (!(UART_INSTANCE_LOWPOWER(huart)))
 80126cc:	69fb      	ldr	r3, [r7, #28]
 80126ce:	681b      	ldr	r3, [r3, #0]
 80126d0:	4abf      	ldr	r2, [pc, #764]	; (80129d0 <UART_SetConfig+0x37c>)
 80126d2:	4293      	cmp	r3, r2
 80126d4:	d004      	beq.n	80126e0 <UART_SetConfig+0x8c>
  {
    tmpreg |= huart->Init.OneBitSampling;
 80126d6:	69fb      	ldr	r3, [r7, #28]
 80126d8:	6a1b      	ldr	r3, [r3, #32]
 80126da:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80126dc:	4313      	orrs	r3, r2
 80126de:	637b      	str	r3, [r7, #52]	; 0x34
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 80126e0:	69fb      	ldr	r3, [r7, #28]
 80126e2:	681b      	ldr	r3, [r3, #0]
 80126e4:	689b      	ldr	r3, [r3, #8]
 80126e6:	4abb      	ldr	r2, [pc, #748]	; (80129d4 <UART_SetConfig+0x380>)
 80126e8:	4013      	ands	r3, r2
 80126ea:	0019      	movs	r1, r3
 80126ec:	69fb      	ldr	r3, [r7, #28]
 80126ee:	681b      	ldr	r3, [r3, #0]
 80126f0:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80126f2:	430a      	orrs	r2, r1
 80126f4:	609a      	str	r2, [r3, #8]


  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 80126f6:	69fb      	ldr	r3, [r7, #28]
 80126f8:	681b      	ldr	r3, [r3, #0]
 80126fa:	4ab7      	ldr	r2, [pc, #732]	; (80129d8 <UART_SetConfig+0x384>)
 80126fc:	4293      	cmp	r3, r2
 80126fe:	d134      	bne.n	801276a <UART_SetConfig+0x116>
 8012700:	4bb6      	ldr	r3, [pc, #728]	; (80129dc <UART_SetConfig+0x388>)
 8012702:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8012704:	2203      	movs	r2, #3
 8012706:	4013      	ands	r3, r2
 8012708:	2b01      	cmp	r3, #1
 801270a:	d015      	beq.n	8012738 <UART_SetConfig+0xe4>
 801270c:	d304      	bcc.n	8012718 <UART_SetConfig+0xc4>
 801270e:	2b02      	cmp	r3, #2
 8012710:	d00a      	beq.n	8012728 <UART_SetConfig+0xd4>
 8012712:	2b03      	cmp	r3, #3
 8012714:	d018      	beq.n	8012748 <UART_SetConfig+0xf4>
 8012716:	e01f      	b.n	8012758 <UART_SetConfig+0x104>
 8012718:	231b      	movs	r3, #27
 801271a:	2218      	movs	r2, #24
 801271c:	4694      	mov	ip, r2
 801271e:	44bc      	add	ip, r7
 8012720:	4463      	add	r3, ip
 8012722:	2201      	movs	r2, #1
 8012724:	701a      	strb	r2, [r3, #0]
 8012726:	e0c5      	b.n	80128b4 <UART_SetConfig+0x260>
 8012728:	231b      	movs	r3, #27
 801272a:	2218      	movs	r2, #24
 801272c:	4694      	mov	ip, r2
 801272e:	44bc      	add	ip, r7
 8012730:	4463      	add	r3, ip
 8012732:	2202      	movs	r2, #2
 8012734:	701a      	strb	r2, [r3, #0]
 8012736:	e0bd      	b.n	80128b4 <UART_SetConfig+0x260>
 8012738:	231b      	movs	r3, #27
 801273a:	2218      	movs	r2, #24
 801273c:	4694      	mov	ip, r2
 801273e:	44bc      	add	ip, r7
 8012740:	4463      	add	r3, ip
 8012742:	2204      	movs	r2, #4
 8012744:	701a      	strb	r2, [r3, #0]
 8012746:	e0b5      	b.n	80128b4 <UART_SetConfig+0x260>
 8012748:	231b      	movs	r3, #27
 801274a:	2218      	movs	r2, #24
 801274c:	4694      	mov	ip, r2
 801274e:	44bc      	add	ip, r7
 8012750:	4463      	add	r3, ip
 8012752:	2208      	movs	r2, #8
 8012754:	701a      	strb	r2, [r3, #0]
 8012756:	e0ad      	b.n	80128b4 <UART_SetConfig+0x260>
 8012758:	231b      	movs	r3, #27
 801275a:	2218      	movs	r2, #24
 801275c:	4694      	mov	ip, r2
 801275e:	44bc      	add	ip, r7
 8012760:	4463      	add	r3, ip
 8012762:	2210      	movs	r2, #16
 8012764:	701a      	strb	r2, [r3, #0]
 8012766:	46c0      	nop			; (mov r8, r8)
 8012768:	e0a4      	b.n	80128b4 <UART_SetConfig+0x260>
 801276a:	69fb      	ldr	r3, [r7, #28]
 801276c:	681b      	ldr	r3, [r3, #0]
 801276e:	4a9c      	ldr	r2, [pc, #624]	; (80129e0 <UART_SetConfig+0x38c>)
 8012770:	4293      	cmp	r3, r2
 8012772:	d137      	bne.n	80127e4 <UART_SetConfig+0x190>
 8012774:	4b99      	ldr	r3, [pc, #612]	; (80129dc <UART_SetConfig+0x388>)
 8012776:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8012778:	220c      	movs	r2, #12
 801277a:	4013      	ands	r3, r2
 801277c:	2b04      	cmp	r3, #4
 801277e:	d018      	beq.n	80127b2 <UART_SetConfig+0x15e>
 8012780:	d802      	bhi.n	8012788 <UART_SetConfig+0x134>
 8012782:	2b00      	cmp	r3, #0
 8012784:	d005      	beq.n	8012792 <UART_SetConfig+0x13e>
 8012786:	e024      	b.n	80127d2 <UART_SetConfig+0x17e>
 8012788:	2b08      	cmp	r3, #8
 801278a:	d00a      	beq.n	80127a2 <UART_SetConfig+0x14e>
 801278c:	2b0c      	cmp	r3, #12
 801278e:	d018      	beq.n	80127c2 <UART_SetConfig+0x16e>
 8012790:	e01f      	b.n	80127d2 <UART_SetConfig+0x17e>
 8012792:	231b      	movs	r3, #27
 8012794:	2218      	movs	r2, #24
 8012796:	4694      	mov	ip, r2
 8012798:	44bc      	add	ip, r7
 801279a:	4463      	add	r3, ip
 801279c:	2200      	movs	r2, #0
 801279e:	701a      	strb	r2, [r3, #0]
 80127a0:	e088      	b.n	80128b4 <UART_SetConfig+0x260>
 80127a2:	231b      	movs	r3, #27
 80127a4:	2218      	movs	r2, #24
 80127a6:	4694      	mov	ip, r2
 80127a8:	44bc      	add	ip, r7
 80127aa:	4463      	add	r3, ip
 80127ac:	2202      	movs	r2, #2
 80127ae:	701a      	strb	r2, [r3, #0]
 80127b0:	e080      	b.n	80128b4 <UART_SetConfig+0x260>
 80127b2:	231b      	movs	r3, #27
 80127b4:	2218      	movs	r2, #24
 80127b6:	4694      	mov	ip, r2
 80127b8:	44bc      	add	ip, r7
 80127ba:	4463      	add	r3, ip
 80127bc:	2204      	movs	r2, #4
 80127be:	701a      	strb	r2, [r3, #0]
 80127c0:	e078      	b.n	80128b4 <UART_SetConfig+0x260>
 80127c2:	231b      	movs	r3, #27
 80127c4:	2218      	movs	r2, #24
 80127c6:	4694      	mov	ip, r2
 80127c8:	44bc      	add	ip, r7
 80127ca:	4463      	add	r3, ip
 80127cc:	2208      	movs	r2, #8
 80127ce:	701a      	strb	r2, [r3, #0]
 80127d0:	e070      	b.n	80128b4 <UART_SetConfig+0x260>
 80127d2:	231b      	movs	r3, #27
 80127d4:	2218      	movs	r2, #24
 80127d6:	4694      	mov	ip, r2
 80127d8:	44bc      	add	ip, r7
 80127da:	4463      	add	r3, ip
 80127dc:	2210      	movs	r2, #16
 80127de:	701a      	strb	r2, [r3, #0]
 80127e0:	46c0      	nop			; (mov r8, r8)
 80127e2:	e067      	b.n	80128b4 <UART_SetConfig+0x260>
 80127e4:	69fb      	ldr	r3, [r7, #28]
 80127e6:	681b      	ldr	r3, [r3, #0]
 80127e8:	4a7e      	ldr	r2, [pc, #504]	; (80129e4 <UART_SetConfig+0x390>)
 80127ea:	4293      	cmp	r3, r2
 80127ec:	d107      	bne.n	80127fe <UART_SetConfig+0x1aa>
 80127ee:	231b      	movs	r3, #27
 80127f0:	2218      	movs	r2, #24
 80127f2:	4694      	mov	ip, r2
 80127f4:	44bc      	add	ip, r7
 80127f6:	4463      	add	r3, ip
 80127f8:	2200      	movs	r2, #0
 80127fa:	701a      	strb	r2, [r3, #0]
 80127fc:	e05a      	b.n	80128b4 <UART_SetConfig+0x260>
 80127fe:	69fb      	ldr	r3, [r7, #28]
 8012800:	681b      	ldr	r3, [r3, #0]
 8012802:	4a79      	ldr	r2, [pc, #484]	; (80129e8 <UART_SetConfig+0x394>)
 8012804:	4293      	cmp	r3, r2
 8012806:	d107      	bne.n	8012818 <UART_SetConfig+0x1c4>
 8012808:	231b      	movs	r3, #27
 801280a:	2218      	movs	r2, #24
 801280c:	4694      	mov	ip, r2
 801280e:	44bc      	add	ip, r7
 8012810:	4463      	add	r3, ip
 8012812:	2200      	movs	r2, #0
 8012814:	701a      	strb	r2, [r3, #0]
 8012816:	e04d      	b.n	80128b4 <UART_SetConfig+0x260>
 8012818:	69fb      	ldr	r3, [r7, #28]
 801281a:	681b      	ldr	r3, [r3, #0]
 801281c:	4a6c      	ldr	r2, [pc, #432]	; (80129d0 <UART_SetConfig+0x37c>)
 801281e:	4293      	cmp	r3, r2
 8012820:	d141      	bne.n	80128a6 <UART_SetConfig+0x252>
 8012822:	4b6e      	ldr	r3, [pc, #440]	; (80129dc <UART_SetConfig+0x388>)
 8012824:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8012826:	23c0      	movs	r3, #192	; 0xc0
 8012828:	011b      	lsls	r3, r3, #4
 801282a:	4013      	ands	r3, r2
 801282c:	2280      	movs	r2, #128	; 0x80
 801282e:	00d2      	lsls	r2, r2, #3
 8012830:	4293      	cmp	r3, r2
 8012832:	d01f      	beq.n	8012874 <UART_SetConfig+0x220>
 8012834:	2280      	movs	r2, #128	; 0x80
 8012836:	00d2      	lsls	r2, r2, #3
 8012838:	4293      	cmp	r3, r2
 801283a:	d802      	bhi.n	8012842 <UART_SetConfig+0x1ee>
 801283c:	2b00      	cmp	r3, #0
 801283e:	d009      	beq.n	8012854 <UART_SetConfig+0x200>
 8012840:	e028      	b.n	8012894 <UART_SetConfig+0x240>
 8012842:	2280      	movs	r2, #128	; 0x80
 8012844:	0112      	lsls	r2, r2, #4
 8012846:	4293      	cmp	r3, r2
 8012848:	d00c      	beq.n	8012864 <UART_SetConfig+0x210>
 801284a:	22c0      	movs	r2, #192	; 0xc0
 801284c:	0112      	lsls	r2, r2, #4
 801284e:	4293      	cmp	r3, r2
 8012850:	d018      	beq.n	8012884 <UART_SetConfig+0x230>
 8012852:	e01f      	b.n	8012894 <UART_SetConfig+0x240>
 8012854:	231b      	movs	r3, #27
 8012856:	2218      	movs	r2, #24
 8012858:	4694      	mov	ip, r2
 801285a:	44bc      	add	ip, r7
 801285c:	4463      	add	r3, ip
 801285e:	2200      	movs	r2, #0
 8012860:	701a      	strb	r2, [r3, #0]
 8012862:	e027      	b.n	80128b4 <UART_SetConfig+0x260>
 8012864:	231b      	movs	r3, #27
 8012866:	2218      	movs	r2, #24
 8012868:	4694      	mov	ip, r2
 801286a:	44bc      	add	ip, r7
 801286c:	4463      	add	r3, ip
 801286e:	2202      	movs	r2, #2
 8012870:	701a      	strb	r2, [r3, #0]
 8012872:	e01f      	b.n	80128b4 <UART_SetConfig+0x260>
 8012874:	231b      	movs	r3, #27
 8012876:	2218      	movs	r2, #24
 8012878:	4694      	mov	ip, r2
 801287a:	44bc      	add	ip, r7
 801287c:	4463      	add	r3, ip
 801287e:	2204      	movs	r2, #4
 8012880:	701a      	strb	r2, [r3, #0]
 8012882:	e017      	b.n	80128b4 <UART_SetConfig+0x260>
 8012884:	231b      	movs	r3, #27
 8012886:	2218      	movs	r2, #24
 8012888:	4694      	mov	ip, r2
 801288a:	44bc      	add	ip, r7
 801288c:	4463      	add	r3, ip
 801288e:	2208      	movs	r2, #8
 8012890:	701a      	strb	r2, [r3, #0]
 8012892:	e00f      	b.n	80128b4 <UART_SetConfig+0x260>
 8012894:	231b      	movs	r3, #27
 8012896:	2218      	movs	r2, #24
 8012898:	4694      	mov	ip, r2
 801289a:	44bc      	add	ip, r7
 801289c:	4463      	add	r3, ip
 801289e:	2210      	movs	r2, #16
 80128a0:	701a      	strb	r2, [r3, #0]
 80128a2:	46c0      	nop			; (mov r8, r8)
 80128a4:	e006      	b.n	80128b4 <UART_SetConfig+0x260>
 80128a6:	231b      	movs	r3, #27
 80128a8:	2218      	movs	r2, #24
 80128aa:	4694      	mov	ip, r2
 80128ac:	44bc      	add	ip, r7
 80128ae:	4463      	add	r3, ip
 80128b0:	2210      	movs	r2, #16
 80128b2:	701a      	strb	r2, [r3, #0]

  /* Check LPUART instance */
  if (UART_INSTANCE_LOWPOWER(huart))
 80128b4:	69fb      	ldr	r3, [r7, #28]
 80128b6:	681b      	ldr	r3, [r3, #0]
 80128b8:	4a45      	ldr	r2, [pc, #276]	; (80129d0 <UART_SetConfig+0x37c>)
 80128ba:	4293      	cmp	r3, r2
 80128bc:	d000      	beq.n	80128c0 <UART_SetConfig+0x26c>
 80128be:	e09d      	b.n	80129fc <UART_SetConfig+0x3a8>
  {
    /* Retrieve frequency clock */
    switch (clocksource)
 80128c0:	231b      	movs	r3, #27
 80128c2:	2218      	movs	r2, #24
 80128c4:	4694      	mov	ip, r2
 80128c6:	44bc      	add	ip, r7
 80128c8:	4463      	add	r3, ip
 80128ca:	781b      	ldrb	r3, [r3, #0]
 80128cc:	2b02      	cmp	r3, #2
 80128ce:	d00d      	beq.n	80128ec <UART_SetConfig+0x298>
 80128d0:	dc02      	bgt.n	80128d8 <UART_SetConfig+0x284>
 80128d2:	2b00      	cmp	r3, #0
 80128d4:	d005      	beq.n	80128e2 <UART_SetConfig+0x28e>
 80128d6:	e01d      	b.n	8012914 <UART_SetConfig+0x2c0>
 80128d8:	2b04      	cmp	r3, #4
 80128da:	d012      	beq.n	8012902 <UART_SetConfig+0x2ae>
 80128dc:	2b08      	cmp	r3, #8
 80128de:	d015      	beq.n	801290c <UART_SetConfig+0x2b8>
 80128e0:	e018      	b.n	8012914 <UART_SetConfig+0x2c0>
    {
      case UART_CLOCKSOURCE_PCLK1:
        lpuart_ker_ck_pres = HAL_RCC_GetPCLK1Freq();
 80128e2:	f7fe fcdf 	bl	80112a4 <HAL_RCC_GetPCLK1Freq>
 80128e6:	0003      	movs	r3, r0
 80128e8:	627b      	str	r3, [r7, #36]	; 0x24
        break;
 80128ea:	e01b      	b.n	8012924 <UART_SetConfig+0x2d0>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 80128ec:	4b3b      	ldr	r3, [pc, #236]	; (80129dc <UART_SetConfig+0x388>)
 80128ee:	681b      	ldr	r3, [r3, #0]
 80128f0:	2210      	movs	r2, #16
 80128f2:	4013      	ands	r3, r2
 80128f4:	d002      	beq.n	80128fc <UART_SetConfig+0x2a8>
        {
          lpuart_ker_ck_pres = (uint32_t)(HSI_VALUE >> 2U);
 80128f6:	4b3d      	ldr	r3, [pc, #244]	; (80129ec <UART_SetConfig+0x398>)
 80128f8:	627b      	str	r3, [r7, #36]	; 0x24
        }
        else
        {
          lpuart_ker_ck_pres = (uint32_t)HSI_VALUE;
        }
        break;
 80128fa:	e013      	b.n	8012924 <UART_SetConfig+0x2d0>
          lpuart_ker_ck_pres = (uint32_t)HSI_VALUE;
 80128fc:	4b3c      	ldr	r3, [pc, #240]	; (80129f0 <UART_SetConfig+0x39c>)
 80128fe:	627b      	str	r3, [r7, #36]	; 0x24
        break;
 8012900:	e010      	b.n	8012924 <UART_SetConfig+0x2d0>
      case UART_CLOCKSOURCE_SYSCLK:
        lpuart_ker_ck_pres = HAL_RCC_GetSysClockFreq();
 8012902:	f7fe fc41 	bl	8011188 <HAL_RCC_GetSysClockFreq>
 8012906:	0003      	movs	r3, r0
 8012908:	627b      	str	r3, [r7, #36]	; 0x24
        break;
 801290a:	e00b      	b.n	8012924 <UART_SetConfig+0x2d0>
      case UART_CLOCKSOURCE_LSE:
        lpuart_ker_ck_pres = (uint32_t)LSE_VALUE;
 801290c:	2380      	movs	r3, #128	; 0x80
 801290e:	021b      	lsls	r3, r3, #8
 8012910:	627b      	str	r3, [r7, #36]	; 0x24
        break;
 8012912:	e007      	b.n	8012924 <UART_SetConfig+0x2d0>
      case UART_CLOCKSOURCE_UNDEFINED:
      default:
        ret = HAL_ERROR;
 8012914:	2313      	movs	r3, #19
 8012916:	2218      	movs	r2, #24
 8012918:	4694      	mov	ip, r2
 801291a:	44bc      	add	ip, r7
 801291c:	4463      	add	r3, ip
 801291e:	2201      	movs	r2, #1
 8012920:	701a      	strb	r2, [r3, #0]
        break;
 8012922:	46c0      	nop			; (mov r8, r8)
    }

    /* if proper clock source reported */
    if (lpuart_ker_ck_pres != 0U)
 8012924:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012926:	2b00      	cmp	r3, #0
 8012928:	d100      	bne.n	801292c <UART_SetConfig+0x2d8>
 801292a:	e1a6      	b.n	8012c7a <UART_SetConfig+0x626>
    {
      /* ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 801292c:	69fb      	ldr	r3, [r7, #28]
 801292e:	685a      	ldr	r2, [r3, #4]
 8012930:	0013      	movs	r3, r2
 8012932:	005b      	lsls	r3, r3, #1
 8012934:	189b      	adds	r3, r3, r2
 8012936:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8012938:	429a      	cmp	r2, r3
 801293a:	d305      	bcc.n	8012948 <UART_SetConfig+0x2f4>
          (lpuart_ker_ck_pres > (4096U * huart->Init.BaudRate)))
 801293c:	69fb      	ldr	r3, [r7, #28]
 801293e:	685b      	ldr	r3, [r3, #4]
 8012940:	031b      	lsls	r3, r3, #12
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8012942:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8012944:	429a      	cmp	r2, r3
 8012946:	d907      	bls.n	8012958 <UART_SetConfig+0x304>
      {
        ret = HAL_ERROR;
 8012948:	2313      	movs	r3, #19
 801294a:	2218      	movs	r2, #24
 801294c:	4694      	mov	ip, r2
 801294e:	44bc      	add	ip, r7
 8012950:	4463      	add	r3, ip
 8012952:	2201      	movs	r2, #1
 8012954:	701a      	strb	r2, [r3, #0]
 8012956:	e190      	b.n	8012c7a <UART_SetConfig+0x626>
      }
      else
      {
        usartdiv = (uint32_t)(UART_DIV_LPUART(lpuart_ker_ck_pres, huart->Init.BaudRate));
 8012958:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801295a:	613b      	str	r3, [r7, #16]
 801295c:	2300      	movs	r3, #0
 801295e:	617b      	str	r3, [r7, #20]
 8012960:	6939      	ldr	r1, [r7, #16]
 8012962:	697a      	ldr	r2, [r7, #20]
 8012964:	000b      	movs	r3, r1
 8012966:	0e1b      	lsrs	r3, r3, #24
 8012968:	0010      	movs	r0, r2
 801296a:	0205      	lsls	r5, r0, #8
 801296c:	431d      	orrs	r5, r3
 801296e:	000b      	movs	r3, r1
 8012970:	021c      	lsls	r4, r3, #8
 8012972:	69fb      	ldr	r3, [r7, #28]
 8012974:	685b      	ldr	r3, [r3, #4]
 8012976:	085b      	lsrs	r3, r3, #1
 8012978:	60bb      	str	r3, [r7, #8]
 801297a:	2300      	movs	r3, #0
 801297c:	60fb      	str	r3, [r7, #12]
 801297e:	68b8      	ldr	r0, [r7, #8]
 8012980:	68f9      	ldr	r1, [r7, #12]
 8012982:	1900      	adds	r0, r0, r4
 8012984:	4169      	adcs	r1, r5
 8012986:	69fb      	ldr	r3, [r7, #28]
 8012988:	685b      	ldr	r3, [r3, #4]
 801298a:	603b      	str	r3, [r7, #0]
 801298c:	2300      	movs	r3, #0
 801298e:	607b      	str	r3, [r7, #4]
 8012990:	683a      	ldr	r2, [r7, #0]
 8012992:	687b      	ldr	r3, [r7, #4]
 8012994:	f7ed fd7e 	bl	8000494 <__aeabi_uldivmod>
 8012998:	0003      	movs	r3, r0
 801299a:	000c      	movs	r4, r1
 801299c:	62fb      	str	r3, [r7, #44]	; 0x2c

        /* It is forbidden to write values lower than 0x300 in the LPUART_BRR register */
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 801299e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80129a0:	4a14      	ldr	r2, [pc, #80]	; (80129f4 <UART_SetConfig+0x3a0>)
 80129a2:	4293      	cmp	r3, r2
 80129a4:	d908      	bls.n	80129b8 <UART_SetConfig+0x364>
 80129a6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80129a8:	4a13      	ldr	r2, [pc, #76]	; (80129f8 <UART_SetConfig+0x3a4>)
 80129aa:	4293      	cmp	r3, r2
 80129ac:	d804      	bhi.n	80129b8 <UART_SetConfig+0x364>
        {
          huart->Instance->BRR = usartdiv;
 80129ae:	69fb      	ldr	r3, [r7, #28]
 80129b0:	681b      	ldr	r3, [r3, #0]
 80129b2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80129b4:	60da      	str	r2, [r3, #12]
 80129b6:	e160      	b.n	8012c7a <UART_SetConfig+0x626>
        }
        else
        {
          ret = HAL_ERROR;
 80129b8:	2313      	movs	r3, #19
 80129ba:	2218      	movs	r2, #24
 80129bc:	4694      	mov	ip, r2
 80129be:	44bc      	add	ip, r7
 80129c0:	4463      	add	r3, ip
 80129c2:	2201      	movs	r2, #1
 80129c4:	701a      	strb	r2, [r3, #0]
 80129c6:	e158      	b.n	8012c7a <UART_SetConfig+0x626>
 80129c8:	efff69f3 	.word	0xefff69f3
 80129cc:	ffffcfff 	.word	0xffffcfff
 80129d0:	40004800 	.word	0x40004800
 80129d4:	fffff4ff 	.word	0xfffff4ff
 80129d8:	40013800 	.word	0x40013800
 80129dc:	40021000 	.word	0x40021000
 80129e0:	40004400 	.word	0x40004400
 80129e4:	40004c00 	.word	0x40004c00
 80129e8:	40005000 	.word	0x40005000
 80129ec:	003d0900 	.word	0x003d0900
 80129f0:	00f42400 	.word	0x00f42400
 80129f4:	000002ff 	.word	0x000002ff
 80129f8:	000fffff 	.word	0x000fffff
        }
      } /*   if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) || (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate) )) */
    } /* if (lpuart_ker_ck_pres != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80129fc:	69fb      	ldr	r3, [r7, #28]
 80129fe:	69da      	ldr	r2, [r3, #28]
 8012a00:	2380      	movs	r3, #128	; 0x80
 8012a02:	021b      	lsls	r3, r3, #8
 8012a04:	429a      	cmp	r2, r3
 8012a06:	d000      	beq.n	8012a0a <UART_SetConfig+0x3b6>
 8012a08:	e0a9      	b.n	8012b5e <UART_SetConfig+0x50a>
  {
    switch (clocksource)
 8012a0a:	231b      	movs	r3, #27
 8012a0c:	2218      	movs	r2, #24
 8012a0e:	4694      	mov	ip, r2
 8012a10:	44bc      	add	ip, r7
 8012a12:	4463      	add	r3, ip
 8012a14:	781b      	ldrb	r3, [r3, #0]
 8012a16:	2b08      	cmp	r3, #8
 8012a18:	d86d      	bhi.n	8012af6 <UART_SetConfig+0x4a2>
 8012a1a:	009a      	lsls	r2, r3, #2
 8012a1c:	4b9f      	ldr	r3, [pc, #636]	; (8012c9c <UART_SetConfig+0x648>)
 8012a1e:	18d3      	adds	r3, r2, r3
 8012a20:	681b      	ldr	r3, [r3, #0]
 8012a22:	469f      	mov	pc, r3
    {
      case UART_CLOCKSOURCE_PCLK1:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 8012a24:	f7fe fc3e 	bl	80112a4 <HAL_RCC_GetPCLK1Freq>
 8012a28:	0003      	movs	r3, r0
 8012a2a:	005a      	lsls	r2, r3, #1
 8012a2c:	69fb      	ldr	r3, [r7, #28]
 8012a2e:	685b      	ldr	r3, [r3, #4]
 8012a30:	085b      	lsrs	r3, r3, #1
 8012a32:	18d2      	adds	r2, r2, r3
 8012a34:	69fb      	ldr	r3, [r7, #28]
 8012a36:	685b      	ldr	r3, [r3, #4]
 8012a38:	0019      	movs	r1, r3
 8012a3a:	0010      	movs	r0, r2
 8012a3c:	f7ed fb76 	bl	800012c <__udivsi3>
 8012a40:	0003      	movs	r3, r0
 8012a42:	b29b      	uxth	r3, r3
 8012a44:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8012a46:	e05e      	b.n	8012b06 <UART_SetConfig+0x4b2>
      case UART_CLOCKSOURCE_PCLK2:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 8012a48:	f7fe fc42 	bl	80112d0 <HAL_RCC_GetPCLK2Freq>
 8012a4c:	0003      	movs	r3, r0
 8012a4e:	005a      	lsls	r2, r3, #1
 8012a50:	69fb      	ldr	r3, [r7, #28]
 8012a52:	685b      	ldr	r3, [r3, #4]
 8012a54:	085b      	lsrs	r3, r3, #1
 8012a56:	18d2      	adds	r2, r2, r3
 8012a58:	69fb      	ldr	r3, [r7, #28]
 8012a5a:	685b      	ldr	r3, [r3, #4]
 8012a5c:	0019      	movs	r1, r3
 8012a5e:	0010      	movs	r0, r2
 8012a60:	f7ed fb64 	bl	800012c <__udivsi3>
 8012a64:	0003      	movs	r3, r0
 8012a66:	b29b      	uxth	r3, r3
 8012a68:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8012a6a:	e04c      	b.n	8012b06 <UART_SetConfig+0x4b2>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8012a6c:	4b8c      	ldr	r3, [pc, #560]	; (8012ca0 <UART_SetConfig+0x64c>)
 8012a6e:	681b      	ldr	r3, [r3, #0]
 8012a70:	2210      	movs	r2, #16
 8012a72:	4013      	ands	r3, r2
 8012a74:	d00e      	beq.n	8012a94 <UART_SetConfig+0x440>
        {
          usartdiv = (uint16_t)(UART_DIV_SAMPLING8((HSI_VALUE >> 2U), huart->Init.BaudRate));
 8012a76:	69fb      	ldr	r3, [r7, #28]
 8012a78:	685b      	ldr	r3, [r3, #4]
 8012a7a:	085b      	lsrs	r3, r3, #1
 8012a7c:	4a89      	ldr	r2, [pc, #548]	; (8012ca4 <UART_SetConfig+0x650>)
 8012a7e:	189a      	adds	r2, r3, r2
 8012a80:	69fb      	ldr	r3, [r7, #28]
 8012a82:	685b      	ldr	r3, [r3, #4]
 8012a84:	0019      	movs	r1, r3
 8012a86:	0010      	movs	r0, r2
 8012a88:	f7ed fb50 	bl	800012c <__udivsi3>
 8012a8c:	0003      	movs	r3, r0
 8012a8e:	b29b      	uxth	r3, r3
 8012a90:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
        else
        {
          usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
        }
        break;
 8012a92:	e038      	b.n	8012b06 <UART_SetConfig+0x4b2>
          usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
 8012a94:	69fb      	ldr	r3, [r7, #28]
 8012a96:	685b      	ldr	r3, [r3, #4]
 8012a98:	085b      	lsrs	r3, r3, #1
 8012a9a:	4a83      	ldr	r2, [pc, #524]	; (8012ca8 <UART_SetConfig+0x654>)
 8012a9c:	189a      	adds	r2, r3, r2
 8012a9e:	69fb      	ldr	r3, [r7, #28]
 8012aa0:	685b      	ldr	r3, [r3, #4]
 8012aa2:	0019      	movs	r1, r3
 8012aa4:	0010      	movs	r0, r2
 8012aa6:	f7ed fb41 	bl	800012c <__udivsi3>
 8012aaa:	0003      	movs	r3, r0
 8012aac:	b29b      	uxth	r3, r3
 8012aae:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8012ab0:	e029      	b.n	8012b06 <UART_SetConfig+0x4b2>
      case UART_CLOCKSOURCE_SYSCLK:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 8012ab2:	f7fe fb69 	bl	8011188 <HAL_RCC_GetSysClockFreq>
 8012ab6:	0003      	movs	r3, r0
 8012ab8:	005a      	lsls	r2, r3, #1
 8012aba:	69fb      	ldr	r3, [r7, #28]
 8012abc:	685b      	ldr	r3, [r3, #4]
 8012abe:	085b      	lsrs	r3, r3, #1
 8012ac0:	18d2      	adds	r2, r2, r3
 8012ac2:	69fb      	ldr	r3, [r7, #28]
 8012ac4:	685b      	ldr	r3, [r3, #4]
 8012ac6:	0019      	movs	r1, r3
 8012ac8:	0010      	movs	r0, r2
 8012aca:	f7ed fb2f 	bl	800012c <__udivsi3>
 8012ace:	0003      	movs	r3, r0
 8012ad0:	b29b      	uxth	r3, r3
 8012ad2:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8012ad4:	e017      	b.n	8012b06 <UART_SetConfig+0x4b2>
      case UART_CLOCKSOURCE_LSE:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 8012ad6:	69fb      	ldr	r3, [r7, #28]
 8012ad8:	685b      	ldr	r3, [r3, #4]
 8012ada:	085b      	lsrs	r3, r3, #1
 8012adc:	2280      	movs	r2, #128	; 0x80
 8012ade:	0252      	lsls	r2, r2, #9
 8012ae0:	189a      	adds	r2, r3, r2
 8012ae2:	69fb      	ldr	r3, [r7, #28]
 8012ae4:	685b      	ldr	r3, [r3, #4]
 8012ae6:	0019      	movs	r1, r3
 8012ae8:	0010      	movs	r0, r2
 8012aea:	f7ed fb1f 	bl	800012c <__udivsi3>
 8012aee:	0003      	movs	r3, r0
 8012af0:	b29b      	uxth	r3, r3
 8012af2:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8012af4:	e007      	b.n	8012b06 <UART_SetConfig+0x4b2>
      case UART_CLOCKSOURCE_UNDEFINED:
      default:
        ret = HAL_ERROR;
 8012af6:	2313      	movs	r3, #19
 8012af8:	2218      	movs	r2, #24
 8012afa:	4694      	mov	ip, r2
 8012afc:	44bc      	add	ip, r7
 8012afe:	4463      	add	r3, ip
 8012b00:	2201      	movs	r2, #1
 8012b02:	701a      	strb	r2, [r3, #0]
        break;
 8012b04:	46c0      	nop			; (mov r8, r8)
    }

    /* USARTDIV must be greater than or equal to 0d16 */
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8012b06:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8012b08:	2b0f      	cmp	r3, #15
 8012b0a:	d920      	bls.n	8012b4e <UART_SetConfig+0x4fa>
 8012b0c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8012b0e:	4a67      	ldr	r2, [pc, #412]	; (8012cac <UART_SetConfig+0x658>)
 8012b10:	4293      	cmp	r3, r2
 8012b12:	d81c      	bhi.n	8012b4e <UART_SetConfig+0x4fa>
    {
      brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 8012b14:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8012b16:	b29a      	uxth	r2, r3
 8012b18:	200a      	movs	r0, #10
 8012b1a:	2418      	movs	r4, #24
 8012b1c:	193b      	adds	r3, r7, r4
 8012b1e:	181b      	adds	r3, r3, r0
 8012b20:	210f      	movs	r1, #15
 8012b22:	438a      	bics	r2, r1
 8012b24:	801a      	strh	r2, [r3, #0]
      brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8012b26:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8012b28:	085b      	lsrs	r3, r3, #1
 8012b2a:	b29b      	uxth	r3, r3
 8012b2c:	2207      	movs	r2, #7
 8012b2e:	4013      	ands	r3, r2
 8012b30:	b299      	uxth	r1, r3
 8012b32:	193b      	adds	r3, r7, r4
 8012b34:	181b      	adds	r3, r3, r0
 8012b36:	193a      	adds	r2, r7, r4
 8012b38:	1812      	adds	r2, r2, r0
 8012b3a:	8812      	ldrh	r2, [r2, #0]
 8012b3c:	430a      	orrs	r2, r1
 8012b3e:	801a      	strh	r2, [r3, #0]
      huart->Instance->BRR = brrtemp;
 8012b40:	69fb      	ldr	r3, [r7, #28]
 8012b42:	681b      	ldr	r3, [r3, #0]
 8012b44:	193a      	adds	r2, r7, r4
 8012b46:	1812      	adds	r2, r2, r0
 8012b48:	8812      	ldrh	r2, [r2, #0]
 8012b4a:	60da      	str	r2, [r3, #12]
 8012b4c:	e095      	b.n	8012c7a <UART_SetConfig+0x626>
    }
    else
    {
      ret = HAL_ERROR;
 8012b4e:	2313      	movs	r3, #19
 8012b50:	2218      	movs	r2, #24
 8012b52:	4694      	mov	ip, r2
 8012b54:	44bc      	add	ip, r7
 8012b56:	4463      	add	r3, ip
 8012b58:	2201      	movs	r2, #1
 8012b5a:	701a      	strb	r2, [r3, #0]
 8012b5c:	e08d      	b.n	8012c7a <UART_SetConfig+0x626>
    }
  }
  else
  {
    switch (clocksource)
 8012b5e:	231b      	movs	r3, #27
 8012b60:	2218      	movs	r2, #24
 8012b62:	4694      	mov	ip, r2
 8012b64:	44bc      	add	ip, r7
 8012b66:	4463      	add	r3, ip
 8012b68:	781b      	ldrb	r3, [r3, #0]
 8012b6a:	2b08      	cmp	r3, #8
 8012b6c:	d86a      	bhi.n	8012c44 <UART_SetConfig+0x5f0>
 8012b6e:	009a      	lsls	r2, r3, #2
 8012b70:	4b4f      	ldr	r3, [pc, #316]	; (8012cb0 <UART_SetConfig+0x65c>)
 8012b72:	18d3      	adds	r3, r2, r3
 8012b74:	681b      	ldr	r3, [r3, #0]
 8012b76:	469f      	mov	pc, r3
    {
      case UART_CLOCKSOURCE_PCLK1:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 8012b78:	f7fe fb94 	bl	80112a4 <HAL_RCC_GetPCLK1Freq>
 8012b7c:	0002      	movs	r2, r0
 8012b7e:	69fb      	ldr	r3, [r7, #28]
 8012b80:	685b      	ldr	r3, [r3, #4]
 8012b82:	085b      	lsrs	r3, r3, #1
 8012b84:	18d2      	adds	r2, r2, r3
 8012b86:	69fb      	ldr	r3, [r7, #28]
 8012b88:	685b      	ldr	r3, [r3, #4]
 8012b8a:	0019      	movs	r1, r3
 8012b8c:	0010      	movs	r0, r2
 8012b8e:	f7ed facd 	bl	800012c <__udivsi3>
 8012b92:	0003      	movs	r3, r0
 8012b94:	b29b      	uxth	r3, r3
 8012b96:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8012b98:	e05c      	b.n	8012c54 <UART_SetConfig+0x600>
      case UART_CLOCKSOURCE_PCLK2:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 8012b9a:	f7fe fb99 	bl	80112d0 <HAL_RCC_GetPCLK2Freq>
 8012b9e:	0002      	movs	r2, r0
 8012ba0:	69fb      	ldr	r3, [r7, #28]
 8012ba2:	685b      	ldr	r3, [r3, #4]
 8012ba4:	085b      	lsrs	r3, r3, #1
 8012ba6:	18d2      	adds	r2, r2, r3
 8012ba8:	69fb      	ldr	r3, [r7, #28]
 8012baa:	685b      	ldr	r3, [r3, #4]
 8012bac:	0019      	movs	r1, r3
 8012bae:	0010      	movs	r0, r2
 8012bb0:	f7ed fabc 	bl	800012c <__udivsi3>
 8012bb4:	0003      	movs	r3, r0
 8012bb6:	b29b      	uxth	r3, r3
 8012bb8:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8012bba:	e04b      	b.n	8012c54 <UART_SetConfig+0x600>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8012bbc:	4b38      	ldr	r3, [pc, #224]	; (8012ca0 <UART_SetConfig+0x64c>)
 8012bbe:	681b      	ldr	r3, [r3, #0]
 8012bc0:	2210      	movs	r2, #16
 8012bc2:	4013      	ands	r3, r2
 8012bc4:	d00e      	beq.n	8012be4 <UART_SetConfig+0x590>
        {
          usartdiv = (uint16_t)(UART_DIV_SAMPLING16((HSI_VALUE >> 2U), huart->Init.BaudRate));
 8012bc6:	69fb      	ldr	r3, [r7, #28]
 8012bc8:	685b      	ldr	r3, [r3, #4]
 8012bca:	085b      	lsrs	r3, r3, #1
 8012bcc:	4a39      	ldr	r2, [pc, #228]	; (8012cb4 <UART_SetConfig+0x660>)
 8012bce:	189a      	adds	r2, r3, r2
 8012bd0:	69fb      	ldr	r3, [r7, #28]
 8012bd2:	685b      	ldr	r3, [r3, #4]
 8012bd4:	0019      	movs	r1, r3
 8012bd6:	0010      	movs	r0, r2
 8012bd8:	f7ed faa8 	bl	800012c <__udivsi3>
 8012bdc:	0003      	movs	r3, r0
 8012bde:	b29b      	uxth	r3, r3
 8012be0:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
        else
        {
          usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
        }
        break;
 8012be2:	e037      	b.n	8012c54 <UART_SetConfig+0x600>
          usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
 8012be4:	69fb      	ldr	r3, [r7, #28]
 8012be6:	685b      	ldr	r3, [r3, #4]
 8012be8:	085b      	lsrs	r3, r3, #1
 8012bea:	4a33      	ldr	r2, [pc, #204]	; (8012cb8 <UART_SetConfig+0x664>)
 8012bec:	189a      	adds	r2, r3, r2
 8012bee:	69fb      	ldr	r3, [r7, #28]
 8012bf0:	685b      	ldr	r3, [r3, #4]
 8012bf2:	0019      	movs	r1, r3
 8012bf4:	0010      	movs	r0, r2
 8012bf6:	f7ed fa99 	bl	800012c <__udivsi3>
 8012bfa:	0003      	movs	r3, r0
 8012bfc:	b29b      	uxth	r3, r3
 8012bfe:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8012c00:	e028      	b.n	8012c54 <UART_SetConfig+0x600>
      case UART_CLOCKSOURCE_SYSCLK:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 8012c02:	f7fe fac1 	bl	8011188 <HAL_RCC_GetSysClockFreq>
 8012c06:	0002      	movs	r2, r0
 8012c08:	69fb      	ldr	r3, [r7, #28]
 8012c0a:	685b      	ldr	r3, [r3, #4]
 8012c0c:	085b      	lsrs	r3, r3, #1
 8012c0e:	18d2      	adds	r2, r2, r3
 8012c10:	69fb      	ldr	r3, [r7, #28]
 8012c12:	685b      	ldr	r3, [r3, #4]
 8012c14:	0019      	movs	r1, r3
 8012c16:	0010      	movs	r0, r2
 8012c18:	f7ed fa88 	bl	800012c <__udivsi3>
 8012c1c:	0003      	movs	r3, r0
 8012c1e:	b29b      	uxth	r3, r3
 8012c20:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8012c22:	e017      	b.n	8012c54 <UART_SetConfig+0x600>
      case UART_CLOCKSOURCE_LSE:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 8012c24:	69fb      	ldr	r3, [r7, #28]
 8012c26:	685b      	ldr	r3, [r3, #4]
 8012c28:	085b      	lsrs	r3, r3, #1
 8012c2a:	2280      	movs	r2, #128	; 0x80
 8012c2c:	0212      	lsls	r2, r2, #8
 8012c2e:	189a      	adds	r2, r3, r2
 8012c30:	69fb      	ldr	r3, [r7, #28]
 8012c32:	685b      	ldr	r3, [r3, #4]
 8012c34:	0019      	movs	r1, r3
 8012c36:	0010      	movs	r0, r2
 8012c38:	f7ed fa78 	bl	800012c <__udivsi3>
 8012c3c:	0003      	movs	r3, r0
 8012c3e:	b29b      	uxth	r3, r3
 8012c40:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8012c42:	e007      	b.n	8012c54 <UART_SetConfig+0x600>
      case UART_CLOCKSOURCE_UNDEFINED:
      default:
        ret = HAL_ERROR;
 8012c44:	2313      	movs	r3, #19
 8012c46:	2218      	movs	r2, #24
 8012c48:	4694      	mov	ip, r2
 8012c4a:	44bc      	add	ip, r7
 8012c4c:	4463      	add	r3, ip
 8012c4e:	2201      	movs	r2, #1
 8012c50:	701a      	strb	r2, [r3, #0]
        break;
 8012c52:	46c0      	nop			; (mov r8, r8)
    }

    /* USARTDIV must be greater than or equal to 0d16 */
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8012c54:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8012c56:	2b0f      	cmp	r3, #15
 8012c58:	d908      	bls.n	8012c6c <UART_SetConfig+0x618>
 8012c5a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8012c5c:	4a13      	ldr	r2, [pc, #76]	; (8012cac <UART_SetConfig+0x658>)
 8012c5e:	4293      	cmp	r3, r2
 8012c60:	d804      	bhi.n	8012c6c <UART_SetConfig+0x618>
    {
      huart->Instance->BRR = usartdiv;
 8012c62:	69fb      	ldr	r3, [r7, #28]
 8012c64:	681b      	ldr	r3, [r3, #0]
 8012c66:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8012c68:	60da      	str	r2, [r3, #12]
 8012c6a:	e006      	b.n	8012c7a <UART_SetConfig+0x626>
    }
    else
    {
      ret = HAL_ERROR;
 8012c6c:	2313      	movs	r3, #19
 8012c6e:	2218      	movs	r2, #24
 8012c70:	4694      	mov	ip, r2
 8012c72:	44bc      	add	ip, r7
 8012c74:	4463      	add	r3, ip
 8012c76:	2201      	movs	r2, #1
 8012c78:	701a      	strb	r2, [r3, #0]
    }
  }


  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 8012c7a:	69fb      	ldr	r3, [r7, #28]
 8012c7c:	2200      	movs	r2, #0
 8012c7e:	661a      	str	r2, [r3, #96]	; 0x60
  huart->TxISR = NULL;
 8012c80:	69fb      	ldr	r3, [r7, #28]
 8012c82:	2200      	movs	r2, #0
 8012c84:	665a      	str	r2, [r3, #100]	; 0x64

  return ret;
 8012c86:	2313      	movs	r3, #19
 8012c88:	2218      	movs	r2, #24
 8012c8a:	4694      	mov	ip, r2
 8012c8c:	44bc      	add	ip, r7
 8012c8e:	4463      	add	r3, ip
 8012c90:	781b      	ldrb	r3, [r3, #0]
}
 8012c92:	0018      	movs	r0, r3
 8012c94:	46bd      	mov	sp, r7
 8012c96:	b00e      	add	sp, #56	; 0x38
 8012c98:	bdb0      	pop	{r4, r5, r7, pc}
 8012c9a:	46c0      	nop			; (mov r8, r8)
 8012c9c:	080151b4 	.word	0x080151b4
 8012ca0:	40021000 	.word	0x40021000
 8012ca4:	007a1200 	.word	0x007a1200
 8012ca8:	01e84800 	.word	0x01e84800
 8012cac:	0000ffff 	.word	0x0000ffff
 8012cb0:	080151d8 	.word	0x080151d8
 8012cb4:	003d0900 	.word	0x003d0900
 8012cb8:	00f42400 	.word	0x00f42400

08012cbc <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
 8012cbc:	b580      	push	{r7, lr}
 8012cbe:	b082      	sub	sp, #8
 8012cc0:	af00      	add	r7, sp, #0
 8012cc2:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8012cc4:	687b      	ldr	r3, [r7, #4]
 8012cc6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8012cc8:	2201      	movs	r2, #1
 8012cca:	4013      	ands	r3, r2
 8012ccc:	d00b      	beq.n	8012ce6 <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 8012cce:	687b      	ldr	r3, [r7, #4]
 8012cd0:	681b      	ldr	r3, [r3, #0]
 8012cd2:	685b      	ldr	r3, [r3, #4]
 8012cd4:	4a4a      	ldr	r2, [pc, #296]	; (8012e00 <UART_AdvFeatureConfig+0x144>)
 8012cd6:	4013      	ands	r3, r2
 8012cd8:	0019      	movs	r1, r3
 8012cda:	687b      	ldr	r3, [r7, #4]
 8012cdc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8012cde:	687b      	ldr	r3, [r7, #4]
 8012ce0:	681b      	ldr	r3, [r3, #0]
 8012ce2:	430a      	orrs	r2, r1
 8012ce4:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 8012ce6:	687b      	ldr	r3, [r7, #4]
 8012ce8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8012cea:	2202      	movs	r2, #2
 8012cec:	4013      	ands	r3, r2
 8012cee:	d00b      	beq.n	8012d08 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 8012cf0:	687b      	ldr	r3, [r7, #4]
 8012cf2:	681b      	ldr	r3, [r3, #0]
 8012cf4:	685b      	ldr	r3, [r3, #4]
 8012cf6:	4a43      	ldr	r2, [pc, #268]	; (8012e04 <UART_AdvFeatureConfig+0x148>)
 8012cf8:	4013      	ands	r3, r2
 8012cfa:	0019      	movs	r1, r3
 8012cfc:	687b      	ldr	r3, [r7, #4]
 8012cfe:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8012d00:	687b      	ldr	r3, [r7, #4]
 8012d02:	681b      	ldr	r3, [r3, #0]
 8012d04:	430a      	orrs	r2, r1
 8012d06:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 8012d08:	687b      	ldr	r3, [r7, #4]
 8012d0a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8012d0c:	2204      	movs	r2, #4
 8012d0e:	4013      	ands	r3, r2
 8012d10:	d00b      	beq.n	8012d2a <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 8012d12:	687b      	ldr	r3, [r7, #4]
 8012d14:	681b      	ldr	r3, [r3, #0]
 8012d16:	685b      	ldr	r3, [r3, #4]
 8012d18:	4a3b      	ldr	r2, [pc, #236]	; (8012e08 <UART_AdvFeatureConfig+0x14c>)
 8012d1a:	4013      	ands	r3, r2
 8012d1c:	0019      	movs	r1, r3
 8012d1e:	687b      	ldr	r3, [r7, #4]
 8012d20:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8012d22:	687b      	ldr	r3, [r7, #4]
 8012d24:	681b      	ldr	r3, [r3, #0]
 8012d26:	430a      	orrs	r2, r1
 8012d28:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 8012d2a:	687b      	ldr	r3, [r7, #4]
 8012d2c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8012d2e:	2208      	movs	r2, #8
 8012d30:	4013      	ands	r3, r2
 8012d32:	d00b      	beq.n	8012d4c <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 8012d34:	687b      	ldr	r3, [r7, #4]
 8012d36:	681b      	ldr	r3, [r3, #0]
 8012d38:	685b      	ldr	r3, [r3, #4]
 8012d3a:	4a34      	ldr	r2, [pc, #208]	; (8012e0c <UART_AdvFeatureConfig+0x150>)
 8012d3c:	4013      	ands	r3, r2
 8012d3e:	0019      	movs	r1, r3
 8012d40:	687b      	ldr	r3, [r7, #4]
 8012d42:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8012d44:	687b      	ldr	r3, [r7, #4]
 8012d46:	681b      	ldr	r3, [r3, #0]
 8012d48:	430a      	orrs	r2, r1
 8012d4a:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 8012d4c:	687b      	ldr	r3, [r7, #4]
 8012d4e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8012d50:	2210      	movs	r2, #16
 8012d52:	4013      	ands	r3, r2
 8012d54:	d00b      	beq.n	8012d6e <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 8012d56:	687b      	ldr	r3, [r7, #4]
 8012d58:	681b      	ldr	r3, [r3, #0]
 8012d5a:	689b      	ldr	r3, [r3, #8]
 8012d5c:	4a2c      	ldr	r2, [pc, #176]	; (8012e10 <UART_AdvFeatureConfig+0x154>)
 8012d5e:	4013      	ands	r3, r2
 8012d60:	0019      	movs	r1, r3
 8012d62:	687b      	ldr	r3, [r7, #4]
 8012d64:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8012d66:	687b      	ldr	r3, [r7, #4]
 8012d68:	681b      	ldr	r3, [r3, #0]
 8012d6a:	430a      	orrs	r2, r1
 8012d6c:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 8012d6e:	687b      	ldr	r3, [r7, #4]
 8012d70:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8012d72:	2220      	movs	r2, #32
 8012d74:	4013      	ands	r3, r2
 8012d76:	d00b      	beq.n	8012d90 <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 8012d78:	687b      	ldr	r3, [r7, #4]
 8012d7a:	681b      	ldr	r3, [r3, #0]
 8012d7c:	689b      	ldr	r3, [r3, #8]
 8012d7e:	4a25      	ldr	r2, [pc, #148]	; (8012e14 <UART_AdvFeatureConfig+0x158>)
 8012d80:	4013      	ands	r3, r2
 8012d82:	0019      	movs	r1, r3
 8012d84:	687b      	ldr	r3, [r7, #4]
 8012d86:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8012d88:	687b      	ldr	r3, [r7, #4]
 8012d8a:	681b      	ldr	r3, [r3, #0]
 8012d8c:	430a      	orrs	r2, r1
 8012d8e:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 8012d90:	687b      	ldr	r3, [r7, #4]
 8012d92:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8012d94:	2240      	movs	r2, #64	; 0x40
 8012d96:	4013      	ands	r3, r2
 8012d98:	d01d      	beq.n	8012dd6 <UART_AdvFeatureConfig+0x11a>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8012d9a:	687b      	ldr	r3, [r7, #4]
 8012d9c:	681b      	ldr	r3, [r3, #0]
 8012d9e:	685b      	ldr	r3, [r3, #4]
 8012da0:	4a1d      	ldr	r2, [pc, #116]	; (8012e18 <UART_AdvFeatureConfig+0x15c>)
 8012da2:	4013      	ands	r3, r2
 8012da4:	0019      	movs	r1, r3
 8012da6:	687b      	ldr	r3, [r7, #4]
 8012da8:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8012daa:	687b      	ldr	r3, [r7, #4]
 8012dac:	681b      	ldr	r3, [r3, #0]
 8012dae:	430a      	orrs	r2, r1
 8012db0:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8012db2:	687b      	ldr	r3, [r7, #4]
 8012db4:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8012db6:	2380      	movs	r3, #128	; 0x80
 8012db8:	035b      	lsls	r3, r3, #13
 8012dba:	429a      	cmp	r2, r3
 8012dbc:	d10b      	bne.n	8012dd6 <UART_AdvFeatureConfig+0x11a>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 8012dbe:	687b      	ldr	r3, [r7, #4]
 8012dc0:	681b      	ldr	r3, [r3, #0]
 8012dc2:	685b      	ldr	r3, [r3, #4]
 8012dc4:	4a15      	ldr	r2, [pc, #84]	; (8012e1c <UART_AdvFeatureConfig+0x160>)
 8012dc6:	4013      	ands	r3, r2
 8012dc8:	0019      	movs	r1, r3
 8012dca:	687b      	ldr	r3, [r7, #4]
 8012dcc:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8012dce:	687b      	ldr	r3, [r7, #4]
 8012dd0:	681b      	ldr	r3, [r3, #0]
 8012dd2:	430a      	orrs	r2, r1
 8012dd4:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 8012dd6:	687b      	ldr	r3, [r7, #4]
 8012dd8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8012dda:	2280      	movs	r2, #128	; 0x80
 8012ddc:	4013      	ands	r3, r2
 8012dde:	d00b      	beq.n	8012df8 <UART_AdvFeatureConfig+0x13c>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 8012de0:	687b      	ldr	r3, [r7, #4]
 8012de2:	681b      	ldr	r3, [r3, #0]
 8012de4:	685b      	ldr	r3, [r3, #4]
 8012de6:	4a0e      	ldr	r2, [pc, #56]	; (8012e20 <UART_AdvFeatureConfig+0x164>)
 8012de8:	4013      	ands	r3, r2
 8012dea:	0019      	movs	r1, r3
 8012dec:	687b      	ldr	r3, [r7, #4]
 8012dee:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8012df0:	687b      	ldr	r3, [r7, #4]
 8012df2:	681b      	ldr	r3, [r3, #0]
 8012df4:	430a      	orrs	r2, r1
 8012df6:	605a      	str	r2, [r3, #4]
  }
}
 8012df8:	46c0      	nop			; (mov r8, r8)
 8012dfa:	46bd      	mov	sp, r7
 8012dfc:	b002      	add	sp, #8
 8012dfe:	bd80      	pop	{r7, pc}
 8012e00:	fffdffff 	.word	0xfffdffff
 8012e04:	fffeffff 	.word	0xfffeffff
 8012e08:	fffbffff 	.word	0xfffbffff
 8012e0c:	ffff7fff 	.word	0xffff7fff
 8012e10:	ffffefff 	.word	0xffffefff
 8012e14:	ffffdfff 	.word	0xffffdfff
 8012e18:	ffefffff 	.word	0xffefffff
 8012e1c:	ff9fffff 	.word	0xff9fffff
 8012e20:	fff7ffff 	.word	0xfff7ffff

08012e24 <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 8012e24:	b580      	push	{r7, lr}
 8012e26:	b086      	sub	sp, #24
 8012e28:	af02      	add	r7, sp, #8
 8012e2a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8012e2c:	687b      	ldr	r3, [r7, #4]
 8012e2e:	2200      	movs	r2, #0
 8012e30:	67da      	str	r2, [r3, #124]	; 0x7c

  /* Init tickstart for timeout managment*/
  tickstart = HAL_GetTick();
 8012e32:	f7fc fb55 	bl	800f4e0 <HAL_GetTick>
 8012e36:	0003      	movs	r3, r0
 8012e38:	60fb      	str	r3, [r7, #12]

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8012e3a:	687b      	ldr	r3, [r7, #4]
 8012e3c:	681b      	ldr	r3, [r3, #0]
 8012e3e:	681b      	ldr	r3, [r3, #0]
 8012e40:	2208      	movs	r2, #8
 8012e42:	4013      	ands	r3, r2
 8012e44:	2b08      	cmp	r3, #8
 8012e46:	d10d      	bne.n	8012e64 <UART_CheckIdleState+0x40>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8012e48:	68fa      	ldr	r2, [r7, #12]
 8012e4a:	2380      	movs	r3, #128	; 0x80
 8012e4c:	0399      	lsls	r1, r3, #14
 8012e4e:	6878      	ldr	r0, [r7, #4]
 8012e50:	4b16      	ldr	r3, [pc, #88]	; (8012eac <UART_CheckIdleState+0x88>)
 8012e52:	9300      	str	r3, [sp, #0]
 8012e54:	0013      	movs	r3, r2
 8012e56:	2200      	movs	r2, #0
 8012e58:	f000 f82a 	bl	8012eb0 <UART_WaitOnFlagUntilTimeout>
 8012e5c:	1e03      	subs	r3, r0, #0
 8012e5e:	d001      	beq.n	8012e64 <UART_CheckIdleState+0x40>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 8012e60:	2303      	movs	r3, #3
 8012e62:	e01f      	b.n	8012ea4 <UART_CheckIdleState+0x80>
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 8012e64:	687b      	ldr	r3, [r7, #4]
 8012e66:	681b      	ldr	r3, [r3, #0]
 8012e68:	681b      	ldr	r3, [r3, #0]
 8012e6a:	2204      	movs	r2, #4
 8012e6c:	4013      	ands	r3, r2
 8012e6e:	2b04      	cmp	r3, #4
 8012e70:	d10d      	bne.n	8012e8e <UART_CheckIdleState+0x6a>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8012e72:	68fa      	ldr	r2, [r7, #12]
 8012e74:	2380      	movs	r3, #128	; 0x80
 8012e76:	03d9      	lsls	r1, r3, #15
 8012e78:	6878      	ldr	r0, [r7, #4]
 8012e7a:	4b0c      	ldr	r3, [pc, #48]	; (8012eac <UART_CheckIdleState+0x88>)
 8012e7c:	9300      	str	r3, [sp, #0]
 8012e7e:	0013      	movs	r3, r2
 8012e80:	2200      	movs	r2, #0
 8012e82:	f000 f815 	bl	8012eb0 <UART_WaitOnFlagUntilTimeout>
 8012e86:	1e03      	subs	r3, r0, #0
 8012e88:	d001      	beq.n	8012e8e <UART_CheckIdleState+0x6a>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 8012e8a:	2303      	movs	r3, #3
 8012e8c:	e00a      	b.n	8012ea4 <UART_CheckIdleState+0x80>
    }
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
 8012e8e:	687b      	ldr	r3, [r7, #4]
 8012e90:	2220      	movs	r2, #32
 8012e92:	675a      	str	r2, [r3, #116]	; 0x74
  huart->RxState = HAL_UART_STATE_READY;
 8012e94:	687b      	ldr	r3, [r7, #4]
 8012e96:	2220      	movs	r2, #32
 8012e98:	679a      	str	r2, [r3, #120]	; 0x78

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 8012e9a:	687b      	ldr	r3, [r7, #4]
 8012e9c:	2270      	movs	r2, #112	; 0x70
 8012e9e:	2100      	movs	r1, #0
 8012ea0:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 8012ea2:	2300      	movs	r3, #0
}
 8012ea4:	0018      	movs	r0, r3
 8012ea6:	46bd      	mov	sp, r7
 8012ea8:	b004      	add	sp, #16
 8012eaa:	bd80      	pop	{r7, pc}
 8012eac:	01ffffff 	.word	0x01ffffff

08012eb0 <UART_WaitOnFlagUntilTimeout>:
  * @param Tickstart Tick start value
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
{
 8012eb0:	b580      	push	{r7, lr}
 8012eb2:	b084      	sub	sp, #16
 8012eb4:	af00      	add	r7, sp, #0
 8012eb6:	60f8      	str	r0, [r7, #12]
 8012eb8:	60b9      	str	r1, [r7, #8]
 8012eba:	603b      	str	r3, [r7, #0]
 8012ebc:	1dfb      	adds	r3, r7, #7
 8012ebe:	701a      	strb	r2, [r3, #0]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8012ec0:	e029      	b.n	8012f16 <UART_WaitOnFlagUntilTimeout+0x66>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 8012ec2:	69bb      	ldr	r3, [r7, #24]
 8012ec4:	3301      	adds	r3, #1
 8012ec6:	d026      	beq.n	8012f16 <UART_WaitOnFlagUntilTimeout+0x66>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8012ec8:	f7fc fb0a 	bl	800f4e0 <HAL_GetTick>
 8012ecc:	0002      	movs	r2, r0
 8012ece:	683b      	ldr	r3, [r7, #0]
 8012ed0:	1ad3      	subs	r3, r2, r3
 8012ed2:	69ba      	ldr	r2, [r7, #24]
 8012ed4:	429a      	cmp	r2, r3
 8012ed6:	d302      	bcc.n	8012ede <UART_WaitOnFlagUntilTimeout+0x2e>
 8012ed8:	69bb      	ldr	r3, [r7, #24]
 8012eda:	2b00      	cmp	r3, #0
 8012edc:	d11b      	bne.n	8012f16 <UART_WaitOnFlagUntilTimeout+0x66>
      {
        /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 8012ede:	68fb      	ldr	r3, [r7, #12]
 8012ee0:	681b      	ldr	r3, [r3, #0]
 8012ee2:	681a      	ldr	r2, [r3, #0]
 8012ee4:	68fb      	ldr	r3, [r7, #12]
 8012ee6:	681b      	ldr	r3, [r3, #0]
 8012ee8:	4915      	ldr	r1, [pc, #84]	; (8012f40 <UART_WaitOnFlagUntilTimeout+0x90>)
 8012eea:	400a      	ands	r2, r1
 8012eec:	601a      	str	r2, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8012eee:	68fb      	ldr	r3, [r7, #12]
 8012ef0:	681b      	ldr	r3, [r3, #0]
 8012ef2:	689a      	ldr	r2, [r3, #8]
 8012ef4:	68fb      	ldr	r3, [r7, #12]
 8012ef6:	681b      	ldr	r3, [r3, #0]
 8012ef8:	2101      	movs	r1, #1
 8012efa:	438a      	bics	r2, r1
 8012efc:	609a      	str	r2, [r3, #8]

        huart->gState = HAL_UART_STATE_READY;
 8012efe:	68fb      	ldr	r3, [r7, #12]
 8012f00:	2220      	movs	r2, #32
 8012f02:	675a      	str	r2, [r3, #116]	; 0x74
        huart->RxState = HAL_UART_STATE_READY;
 8012f04:	68fb      	ldr	r3, [r7, #12]
 8012f06:	2220      	movs	r2, #32
 8012f08:	679a      	str	r2, [r3, #120]	; 0x78

        /* Process Unlocked */
        __HAL_UNLOCK(huart);
 8012f0a:	68fb      	ldr	r3, [r7, #12]
 8012f0c:	2270      	movs	r2, #112	; 0x70
 8012f0e:	2100      	movs	r1, #0
 8012f10:	5499      	strb	r1, [r3, r2]

        return HAL_TIMEOUT;
 8012f12:	2303      	movs	r3, #3
 8012f14:	e00f      	b.n	8012f36 <UART_WaitOnFlagUntilTimeout+0x86>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8012f16:	68fb      	ldr	r3, [r7, #12]
 8012f18:	681b      	ldr	r3, [r3, #0]
 8012f1a:	69db      	ldr	r3, [r3, #28]
 8012f1c:	68ba      	ldr	r2, [r7, #8]
 8012f1e:	4013      	ands	r3, r2
 8012f20:	68ba      	ldr	r2, [r7, #8]
 8012f22:	1ad3      	subs	r3, r2, r3
 8012f24:	425a      	negs	r2, r3
 8012f26:	4153      	adcs	r3, r2
 8012f28:	b2db      	uxtb	r3, r3
 8012f2a:	001a      	movs	r2, r3
 8012f2c:	1dfb      	adds	r3, r7, #7
 8012f2e:	781b      	ldrb	r3, [r3, #0]
 8012f30:	429a      	cmp	r2, r3
 8012f32:	d0c6      	beq.n	8012ec2 <UART_WaitOnFlagUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
 8012f34:	2300      	movs	r3, #0
}
 8012f36:	0018      	movs	r0, r3
 8012f38:	46bd      	mov	sp, r7
 8012f3a:	b004      	add	sp, #16
 8012f3c:	bd80      	pop	{r7, pc}
 8012f3e:	46c0      	nop			; (mov r8, r8)
 8012f40:	fffffe5f 	.word	0xfffffe5f

08012f44 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 8012f44:	b580      	push	{r7, lr}
 8012f46:	b082      	sub	sp, #8
 8012f48:	af00      	add	r7, sp, #0
 8012f4a:	6078      	str	r0, [r7, #4]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8012f4c:	687b      	ldr	r3, [r7, #4]
 8012f4e:	681b      	ldr	r3, [r3, #0]
 8012f50:	681a      	ldr	r2, [r3, #0]
 8012f52:	687b      	ldr	r3, [r7, #4]
 8012f54:	681b      	ldr	r3, [r3, #0]
 8012f56:	490a      	ldr	r1, [pc, #40]	; (8012f80 <UART_EndRxTransfer+0x3c>)
 8012f58:	400a      	ands	r2, r1
 8012f5a:	601a      	str	r2, [r3, #0]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8012f5c:	687b      	ldr	r3, [r7, #4]
 8012f5e:	681b      	ldr	r3, [r3, #0]
 8012f60:	689a      	ldr	r2, [r3, #8]
 8012f62:	687b      	ldr	r3, [r7, #4]
 8012f64:	681b      	ldr	r3, [r3, #0]
 8012f66:	2101      	movs	r1, #1
 8012f68:	438a      	bics	r2, r1
 8012f6a:	609a      	str	r2, [r3, #8]

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 8012f6c:	687b      	ldr	r3, [r7, #4]
 8012f6e:	2220      	movs	r2, #32
 8012f70:	679a      	str	r2, [r3, #120]	; 0x78

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 8012f72:	687b      	ldr	r3, [r7, #4]
 8012f74:	2200      	movs	r2, #0
 8012f76:	661a      	str	r2, [r3, #96]	; 0x60
}
 8012f78:	46c0      	nop			; (mov r8, r8)
 8012f7a:	46bd      	mov	sp, r7
 8012f7c:	b002      	add	sp, #8
 8012f7e:	bd80      	pop	{r7, pc}
 8012f80:	fffffedf 	.word	0xfffffedf

08012f84 <UART_DMAAbortOnError>:
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */
static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 8012f84:	b580      	push	{r7, lr}
 8012f86:	b084      	sub	sp, #16
 8012f88:	af00      	add	r7, sp, #0
 8012f8a:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 8012f8c:	687b      	ldr	r3, [r7, #4]
 8012f8e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8012f90:	60fb      	str	r3, [r7, #12]
  huart->RxXferCount = 0U;
 8012f92:	68fb      	ldr	r3, [r7, #12]
 8012f94:	225a      	movs	r2, #90	; 0x5a
 8012f96:	2100      	movs	r1, #0
 8012f98:	5299      	strh	r1, [r3, r2]
  huart->TxXferCount = 0U;
 8012f9a:	68fb      	ldr	r3, [r7, #12]
 8012f9c:	2252      	movs	r2, #82	; 0x52
 8012f9e:	2100      	movs	r1, #0
 8012fa0:	5299      	strh	r1, [r3, r2]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 8012fa2:	68fb      	ldr	r3, [r7, #12]
 8012fa4:	0018      	movs	r0, r3
 8012fa6:	f7ff fb4d 	bl	8012644 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 8012faa:	46c0      	nop			; (mov r8, r8)
 8012fac:	46bd      	mov	sp, r7
 8012fae:	b004      	add	sp, #16
 8012fb0:	bd80      	pop	{r7, pc}

08012fb2 <UART_EndTransmit_IT>:
  * @param  huart pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
 8012fb2:	b580      	push	{r7, lr}
 8012fb4:	b082      	sub	sp, #8
 8012fb6:	af00      	add	r7, sp, #0
 8012fb8:	6078      	str	r0, [r7, #4]
  /* Disable the UART Transmit Complete Interrupt */
  CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8012fba:	687b      	ldr	r3, [r7, #4]
 8012fbc:	681b      	ldr	r3, [r3, #0]
 8012fbe:	681a      	ldr	r2, [r3, #0]
 8012fc0:	687b      	ldr	r3, [r7, #4]
 8012fc2:	681b      	ldr	r3, [r3, #0]
 8012fc4:	2140      	movs	r1, #64	; 0x40
 8012fc6:	438a      	bics	r2, r1
 8012fc8:	601a      	str	r2, [r3, #0]

  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 8012fca:	687b      	ldr	r3, [r7, #4]
 8012fcc:	2220      	movs	r2, #32
 8012fce:	675a      	str	r2, [r3, #116]	; 0x74

  /* Cleat TxISR function pointer */
  huart->TxISR = NULL;
 8012fd0:	687b      	ldr	r3, [r7, #4]
 8012fd2:	2200      	movs	r2, #0
 8012fd4:	665a      	str	r2, [r3, #100]	; 0x64
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx complete callback*/
  huart->TxCpltCallback(huart);
#else
  /*Call legacy weak Tx complete callback*/
  HAL_UART_TxCpltCallback(huart);
 8012fd6:	687b      	ldr	r3, [r7, #4]
 8012fd8:	0018      	movs	r0, r3
 8012fda:	f7ff fb2b 	bl	8012634 <HAL_UART_TxCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 8012fde:	46c0      	nop			; (mov r8, r8)
 8012fe0:	46bd      	mov	sp, r7
 8012fe2:	b002      	add	sp, #8
 8012fe4:	bd80      	pop	{r7, pc}
	...

08012fe8 <UART_RxISR_8BIT>:
  * @brief RX interrrupt handler for 7 or 8 bits data word length .
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_8BIT(UART_HandleTypeDef *huart)
{
 8012fe8:	b580      	push	{r7, lr}
 8012fea:	b084      	sub	sp, #16
 8012fec:	af00      	add	r7, sp, #0
 8012fee:	6078      	str	r0, [r7, #4]
  uint16_t uhMask = huart->Mask;
 8012ff0:	230e      	movs	r3, #14
 8012ff2:	18fb      	adds	r3, r7, r3
 8012ff4:	687a      	ldr	r2, [r7, #4]
 8012ff6:	215c      	movs	r1, #92	; 0x5c
 8012ff8:	5a52      	ldrh	r2, [r2, r1]
 8012ffa:	801a      	strh	r2, [r3, #0]
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8012ffc:	687b      	ldr	r3, [r7, #4]
 8012ffe:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8013000:	2b22      	cmp	r3, #34	; 0x22
 8013002:	d140      	bne.n	8013086 <UART_RxISR_8BIT+0x9e>
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8013004:	687b      	ldr	r3, [r7, #4]
 8013006:	681b      	ldr	r3, [r3, #0]
 8013008:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 801300a:	210c      	movs	r1, #12
 801300c:	187b      	adds	r3, r7, r1
 801300e:	801a      	strh	r2, [r3, #0]
    *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 8013010:	187b      	adds	r3, r7, r1
 8013012:	881b      	ldrh	r3, [r3, #0]
 8013014:	b2da      	uxtb	r2, r3
 8013016:	230e      	movs	r3, #14
 8013018:	18fb      	adds	r3, r7, r3
 801301a:	881b      	ldrh	r3, [r3, #0]
 801301c:	b2d9      	uxtb	r1, r3
 801301e:	687b      	ldr	r3, [r7, #4]
 8013020:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8013022:	400a      	ands	r2, r1
 8013024:	b2d2      	uxtb	r2, r2
 8013026:	701a      	strb	r2, [r3, #0]
    huart->pRxBuffPtr++;
 8013028:	687b      	ldr	r3, [r7, #4]
 801302a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801302c:	1c5a      	adds	r2, r3, #1
 801302e:	687b      	ldr	r3, [r7, #4]
 8013030:	655a      	str	r2, [r3, #84]	; 0x54
    huart->RxXferCount--;
 8013032:	687b      	ldr	r3, [r7, #4]
 8013034:	225a      	movs	r2, #90	; 0x5a
 8013036:	5a9b      	ldrh	r3, [r3, r2]
 8013038:	b29b      	uxth	r3, r3
 801303a:	3b01      	subs	r3, #1
 801303c:	b299      	uxth	r1, r3
 801303e:	687b      	ldr	r3, [r7, #4]
 8013040:	225a      	movs	r2, #90	; 0x5a
 8013042:	5299      	strh	r1, [r3, r2]

    if (huart->RxXferCount == 0U)
 8013044:	687b      	ldr	r3, [r7, #4]
 8013046:	225a      	movs	r2, #90	; 0x5a
 8013048:	5a9b      	ldrh	r3, [r3, r2]
 801304a:	b29b      	uxth	r3, r3
 801304c:	2b00      	cmp	r3, #0
 801304e:	d122      	bne.n	8013096 <UART_RxISR_8BIT+0xae>
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupts */
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8013050:	687b      	ldr	r3, [r7, #4]
 8013052:	681b      	ldr	r3, [r3, #0]
 8013054:	681a      	ldr	r2, [r3, #0]
 8013056:	687b      	ldr	r3, [r7, #4]
 8013058:	681b      	ldr	r3, [r3, #0]
 801305a:	4911      	ldr	r1, [pc, #68]	; (80130a0 <UART_RxISR_8BIT+0xb8>)
 801305c:	400a      	ands	r2, r1
 801305e:	601a      	str	r2, [r3, #0]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8013060:	687b      	ldr	r3, [r7, #4]
 8013062:	681b      	ldr	r3, [r3, #0]
 8013064:	689a      	ldr	r2, [r3, #8]
 8013066:	687b      	ldr	r3, [r7, #4]
 8013068:	681b      	ldr	r3, [r3, #0]
 801306a:	2101      	movs	r1, #1
 801306c:	438a      	bics	r2, r1
 801306e:	609a      	str	r2, [r3, #8]

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 8013070:	687b      	ldr	r3, [r7, #4]
 8013072:	2220      	movs	r2, #32
 8013074:	679a      	str	r2, [r3, #120]	; 0x78

      /* Clear RxISR function pointer */
      huart->RxISR = NULL;
 8013076:	687b      	ldr	r3, [r7, #4]
 8013078:	2200      	movs	r2, #0
 801307a:	661a      	str	r2, [r3, #96]	; 0x60
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
      /*Call registered Rx complete callback*/
      huart->RxCpltCallback(huart);
#else
      /*Call legacy weak Rx complete callback*/
      HAL_UART_RxCpltCallback(huart);
 801307c:	687b      	ldr	r3, [r7, #4]
 801307e:	0018      	movs	r0, r3
 8013080:	f7f1 ff68 	bl	8004f54 <HAL_UART_RxCpltCallback>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 8013084:	e007      	b.n	8013096 <UART_RxISR_8BIT+0xae>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8013086:	687b      	ldr	r3, [r7, #4]
 8013088:	681b      	ldr	r3, [r3, #0]
 801308a:	699a      	ldr	r2, [r3, #24]
 801308c:	687b      	ldr	r3, [r7, #4]
 801308e:	681b      	ldr	r3, [r3, #0]
 8013090:	2108      	movs	r1, #8
 8013092:	430a      	orrs	r2, r1
 8013094:	619a      	str	r2, [r3, #24]
}
 8013096:	46c0      	nop			; (mov r8, r8)
 8013098:	46bd      	mov	sp, r7
 801309a:	b004      	add	sp, #16
 801309c:	bd80      	pop	{r7, pc}
 801309e:	46c0      	nop			; (mov r8, r8)
 80130a0:	fffffedf 	.word	0xfffffedf

080130a4 <UART_RxISR_16BIT>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_16BIT(UART_HandleTypeDef *huart)
{
 80130a4:	b580      	push	{r7, lr}
 80130a6:	b084      	sub	sp, #16
 80130a8:	af00      	add	r7, sp, #0
 80130aa:	6078      	str	r0, [r7, #4]
  uint16_t *tmp;
  uint16_t uhMask = huart->Mask;
 80130ac:	230e      	movs	r3, #14
 80130ae:	18fb      	adds	r3, r7, r3
 80130b0:	687a      	ldr	r2, [r7, #4]
 80130b2:	215c      	movs	r1, #92	; 0x5c
 80130b4:	5a52      	ldrh	r2, [r2, r1]
 80130b6:	801a      	strh	r2, [r3, #0]
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 80130b8:	687b      	ldr	r3, [r7, #4]
 80130ba:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80130bc:	2b22      	cmp	r3, #34	; 0x22
 80130be:	d140      	bne.n	8013142 <UART_RxISR_16BIT+0x9e>
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 80130c0:	687b      	ldr	r3, [r7, #4]
 80130c2:	681b      	ldr	r3, [r3, #0]
 80130c4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80130c6:	210c      	movs	r1, #12
 80130c8:	187b      	adds	r3, r7, r1
 80130ca:	801a      	strh	r2, [r3, #0]
    tmp = (uint16_t *) huart->pRxBuffPtr ;
 80130cc:	687b      	ldr	r3, [r7, #4]
 80130ce:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80130d0:	60bb      	str	r3, [r7, #8]
    *tmp = (uint16_t)(uhdata & uhMask);
 80130d2:	187b      	adds	r3, r7, r1
 80130d4:	220e      	movs	r2, #14
 80130d6:	18ba      	adds	r2, r7, r2
 80130d8:	881b      	ldrh	r3, [r3, #0]
 80130da:	8812      	ldrh	r2, [r2, #0]
 80130dc:	4013      	ands	r3, r2
 80130de:	b29a      	uxth	r2, r3
 80130e0:	68bb      	ldr	r3, [r7, #8]
 80130e2:	801a      	strh	r2, [r3, #0]
    huart->pRxBuffPtr += 2U;
 80130e4:	687b      	ldr	r3, [r7, #4]
 80130e6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80130e8:	1c9a      	adds	r2, r3, #2
 80130ea:	687b      	ldr	r3, [r7, #4]
 80130ec:	655a      	str	r2, [r3, #84]	; 0x54
    huart->RxXferCount--;
 80130ee:	687b      	ldr	r3, [r7, #4]
 80130f0:	225a      	movs	r2, #90	; 0x5a
 80130f2:	5a9b      	ldrh	r3, [r3, r2]
 80130f4:	b29b      	uxth	r3, r3
 80130f6:	3b01      	subs	r3, #1
 80130f8:	b299      	uxth	r1, r3
 80130fa:	687b      	ldr	r3, [r7, #4]
 80130fc:	225a      	movs	r2, #90	; 0x5a
 80130fe:	5299      	strh	r1, [r3, r2]

    if (huart->RxXferCount == 0U)
 8013100:	687b      	ldr	r3, [r7, #4]
 8013102:	225a      	movs	r2, #90	; 0x5a
 8013104:	5a9b      	ldrh	r3, [r3, r2]
 8013106:	b29b      	uxth	r3, r3
 8013108:	2b00      	cmp	r3, #0
 801310a:	d122      	bne.n	8013152 <UART_RxISR_16BIT+0xae>
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 801310c:	687b      	ldr	r3, [r7, #4]
 801310e:	681b      	ldr	r3, [r3, #0]
 8013110:	681a      	ldr	r2, [r3, #0]
 8013112:	687b      	ldr	r3, [r7, #4]
 8013114:	681b      	ldr	r3, [r3, #0]
 8013116:	4911      	ldr	r1, [pc, #68]	; (801315c <UART_RxISR_16BIT+0xb8>)
 8013118:	400a      	ands	r2, r1
 801311a:	601a      	str	r2, [r3, #0]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 801311c:	687b      	ldr	r3, [r7, #4]
 801311e:	681b      	ldr	r3, [r3, #0]
 8013120:	689a      	ldr	r2, [r3, #8]
 8013122:	687b      	ldr	r3, [r7, #4]
 8013124:	681b      	ldr	r3, [r3, #0]
 8013126:	2101      	movs	r1, #1
 8013128:	438a      	bics	r2, r1
 801312a:	609a      	str	r2, [r3, #8]

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 801312c:	687b      	ldr	r3, [r7, #4]
 801312e:	2220      	movs	r2, #32
 8013130:	679a      	str	r2, [r3, #120]	; 0x78

      /* Clear RxISR function pointer */
      huart->RxISR = NULL;
 8013132:	687b      	ldr	r3, [r7, #4]
 8013134:	2200      	movs	r2, #0
 8013136:	661a      	str	r2, [r3, #96]	; 0x60
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
      /*Call registered Rx complete callback*/
      huart->RxCpltCallback(huart);
#else
      /*Call legacy weak Rx complete callback*/
      HAL_UART_RxCpltCallback(huart);
 8013138:	687b      	ldr	r3, [r7, #4]
 801313a:	0018      	movs	r0, r3
 801313c:	f7f1 ff0a 	bl	8004f54 <HAL_UART_RxCpltCallback>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 8013140:	e007      	b.n	8013152 <UART_RxISR_16BIT+0xae>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8013142:	687b      	ldr	r3, [r7, #4]
 8013144:	681b      	ldr	r3, [r3, #0]
 8013146:	699a      	ldr	r2, [r3, #24]
 8013148:	687b      	ldr	r3, [r7, #4]
 801314a:	681b      	ldr	r3, [r3, #0]
 801314c:	2108      	movs	r1, #8
 801314e:	430a      	orrs	r2, r1
 8013150:	619a      	str	r2, [r3, #24]
}
 8013152:	46c0      	nop			; (mov r8, r8)
 8013154:	46bd      	mov	sp, r7
 8013156:	b004      	add	sp, #16
 8013158:	bd80      	pop	{r7, pc}
 801315a:	46c0      	nop			; (mov r8, r8)
 801315c:	fffffedf 	.word	0xfffffedf

08013160 <HAL_UARTEx_WakeupCallback>:
  * @brief UART wakeup from Stop mode callback.
  * @param huart UART handle.
  * @retval None
  */
__weak void HAL_UARTEx_WakeupCallback(UART_HandleTypeDef *huart)
{
 8013160:	b580      	push	{r7, lr}
 8013162:	b082      	sub	sp, #8
 8013164:	af00      	add	r7, sp, #0
 8013166:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_WakeupCallback can be implemented in the user file.
   */
}
 8013168:	46c0      	nop			; (mov r8, r8)
 801316a:	46bd      	mov	sp, r7
 801316c:	b002      	add	sp, #8
 801316e:	bd80      	pop	{r7, pc}

08013170 <__errno>:
 8013170:	4b01      	ldr	r3, [pc, #4]	; (8013178 <__errno+0x8>)
 8013172:	6818      	ldr	r0, [r3, #0]
 8013174:	4770      	bx	lr
 8013176:	46c0      	nop			; (mov r8, r8)
 8013178:	20000268 	.word	0x20000268

0801317c <__libc_init_array>:
 801317c:	b570      	push	{r4, r5, r6, lr}
 801317e:	2600      	movs	r6, #0
 8013180:	4d0c      	ldr	r5, [pc, #48]	; (80131b4 <__libc_init_array+0x38>)
 8013182:	4c0d      	ldr	r4, [pc, #52]	; (80131b8 <__libc_init_array+0x3c>)
 8013184:	1b64      	subs	r4, r4, r5
 8013186:	10a4      	asrs	r4, r4, #2
 8013188:	42a6      	cmp	r6, r4
 801318a:	d109      	bne.n	80131a0 <__libc_init_array+0x24>
 801318c:	2600      	movs	r6, #0
 801318e:	f001 fd95 	bl	8014cbc <_init>
 8013192:	4d0a      	ldr	r5, [pc, #40]	; (80131bc <__libc_init_array+0x40>)
 8013194:	4c0a      	ldr	r4, [pc, #40]	; (80131c0 <__libc_init_array+0x44>)
 8013196:	1b64      	subs	r4, r4, r5
 8013198:	10a4      	asrs	r4, r4, #2
 801319a:	42a6      	cmp	r6, r4
 801319c:	d105      	bne.n	80131aa <__libc_init_array+0x2e>
 801319e:	bd70      	pop	{r4, r5, r6, pc}
 80131a0:	00b3      	lsls	r3, r6, #2
 80131a2:	58eb      	ldr	r3, [r5, r3]
 80131a4:	4798      	blx	r3
 80131a6:	3601      	adds	r6, #1
 80131a8:	e7ee      	b.n	8013188 <__libc_init_array+0xc>
 80131aa:	00b3      	lsls	r3, r6, #2
 80131ac:	58eb      	ldr	r3, [r5, r3]
 80131ae:	4798      	blx	r3
 80131b0:	3601      	adds	r6, #1
 80131b2:	e7f2      	b.n	801319a <__libc_init_array+0x1e>
 80131b4:	08015430 	.word	0x08015430
 80131b8:	08015430 	.word	0x08015430
 80131bc:	08015430 	.word	0x08015430
 80131c0:	08015434 	.word	0x08015434

080131c4 <memcpy>:
 80131c4:	2300      	movs	r3, #0
 80131c6:	b510      	push	{r4, lr}
 80131c8:	429a      	cmp	r2, r3
 80131ca:	d100      	bne.n	80131ce <memcpy+0xa>
 80131cc:	bd10      	pop	{r4, pc}
 80131ce:	5ccc      	ldrb	r4, [r1, r3]
 80131d0:	54c4      	strb	r4, [r0, r3]
 80131d2:	3301      	adds	r3, #1
 80131d4:	e7f8      	b.n	80131c8 <memcpy+0x4>

080131d6 <memset>:
 80131d6:	0003      	movs	r3, r0
 80131d8:	1812      	adds	r2, r2, r0
 80131da:	4293      	cmp	r3, r2
 80131dc:	d100      	bne.n	80131e0 <memset+0xa>
 80131de:	4770      	bx	lr
 80131e0:	7019      	strb	r1, [r3, #0]
 80131e2:	3301      	adds	r3, #1
 80131e4:	e7f9      	b.n	80131da <memset+0x4>

080131e6 <__cvt>:
 80131e6:	b5f0      	push	{r4, r5, r6, r7, lr}
 80131e8:	b08b      	sub	sp, #44	; 0x2c
 80131ea:	0014      	movs	r4, r2
 80131ec:	1e1d      	subs	r5, r3, #0
 80131ee:	9912      	ldr	r1, [sp, #72]	; 0x48
 80131f0:	da53      	bge.n	801329a <__cvt+0xb4>
 80131f2:	2480      	movs	r4, #128	; 0x80
 80131f4:	0624      	lsls	r4, r4, #24
 80131f6:	191b      	adds	r3, r3, r4
 80131f8:	001d      	movs	r5, r3
 80131fa:	0014      	movs	r4, r2
 80131fc:	232d      	movs	r3, #45	; 0x2d
 80131fe:	700b      	strb	r3, [r1, #0]
 8013200:	2320      	movs	r3, #32
 8013202:	9e14      	ldr	r6, [sp, #80]	; 0x50
 8013204:	2203      	movs	r2, #3
 8013206:	439e      	bics	r6, r3
 8013208:	2e46      	cmp	r6, #70	; 0x46
 801320a:	d007      	beq.n	801321c <__cvt+0x36>
 801320c:	0033      	movs	r3, r6
 801320e:	3b45      	subs	r3, #69	; 0x45
 8013210:	4259      	negs	r1, r3
 8013212:	414b      	adcs	r3, r1
 8013214:	9910      	ldr	r1, [sp, #64]	; 0x40
 8013216:	3a01      	subs	r2, #1
 8013218:	18cb      	adds	r3, r1, r3
 801321a:	9310      	str	r3, [sp, #64]	; 0x40
 801321c:	ab09      	add	r3, sp, #36	; 0x24
 801321e:	9304      	str	r3, [sp, #16]
 8013220:	ab08      	add	r3, sp, #32
 8013222:	9303      	str	r3, [sp, #12]
 8013224:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8013226:	9200      	str	r2, [sp, #0]
 8013228:	9302      	str	r3, [sp, #8]
 801322a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801322c:	0022      	movs	r2, r4
 801322e:	9301      	str	r3, [sp, #4]
 8013230:	002b      	movs	r3, r5
 8013232:	f000 fbc9 	bl	80139c8 <_dtoa_r>
 8013236:	0007      	movs	r7, r0
 8013238:	2e47      	cmp	r6, #71	; 0x47
 801323a:	d102      	bne.n	8013242 <__cvt+0x5c>
 801323c:	9b11      	ldr	r3, [sp, #68]	; 0x44
 801323e:	07db      	lsls	r3, r3, #31
 8013240:	d524      	bpl.n	801328c <__cvt+0xa6>
 8013242:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8013244:	18fb      	adds	r3, r7, r3
 8013246:	9307      	str	r3, [sp, #28]
 8013248:	2e46      	cmp	r6, #70	; 0x46
 801324a:	d114      	bne.n	8013276 <__cvt+0x90>
 801324c:	783b      	ldrb	r3, [r7, #0]
 801324e:	2b30      	cmp	r3, #48	; 0x30
 8013250:	d10c      	bne.n	801326c <__cvt+0x86>
 8013252:	2200      	movs	r2, #0
 8013254:	2300      	movs	r3, #0
 8013256:	0020      	movs	r0, r4
 8013258:	0029      	movs	r1, r5
 801325a:	f7ed f8ed 	bl	8000438 <__aeabi_dcmpeq>
 801325e:	2800      	cmp	r0, #0
 8013260:	d104      	bne.n	801326c <__cvt+0x86>
 8013262:	2301      	movs	r3, #1
 8013264:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8013266:	1a9b      	subs	r3, r3, r2
 8013268:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 801326a:	6013      	str	r3, [r2, #0]
 801326c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801326e:	9a07      	ldr	r2, [sp, #28]
 8013270:	681b      	ldr	r3, [r3, #0]
 8013272:	18d3      	adds	r3, r2, r3
 8013274:	9307      	str	r3, [sp, #28]
 8013276:	2200      	movs	r2, #0
 8013278:	2300      	movs	r3, #0
 801327a:	0020      	movs	r0, r4
 801327c:	0029      	movs	r1, r5
 801327e:	f7ed f8db 	bl	8000438 <__aeabi_dcmpeq>
 8013282:	2230      	movs	r2, #48	; 0x30
 8013284:	2800      	cmp	r0, #0
 8013286:	d00d      	beq.n	80132a4 <__cvt+0xbe>
 8013288:	9b07      	ldr	r3, [sp, #28]
 801328a:	9309      	str	r3, [sp, #36]	; 0x24
 801328c:	0038      	movs	r0, r7
 801328e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8013290:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8013292:	1bdb      	subs	r3, r3, r7
 8013294:	6013      	str	r3, [r2, #0]
 8013296:	b00b      	add	sp, #44	; 0x2c
 8013298:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801329a:	2300      	movs	r3, #0
 801329c:	e7af      	b.n	80131fe <__cvt+0x18>
 801329e:	1c59      	adds	r1, r3, #1
 80132a0:	9109      	str	r1, [sp, #36]	; 0x24
 80132a2:	701a      	strb	r2, [r3, #0]
 80132a4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80132a6:	9907      	ldr	r1, [sp, #28]
 80132a8:	428b      	cmp	r3, r1
 80132aa:	d3f8      	bcc.n	801329e <__cvt+0xb8>
 80132ac:	e7ee      	b.n	801328c <__cvt+0xa6>

080132ae <__exponent>:
 80132ae:	b5f0      	push	{r4, r5, r6, r7, lr}
 80132b0:	1c83      	adds	r3, r0, #2
 80132b2:	b085      	sub	sp, #20
 80132b4:	9301      	str	r3, [sp, #4]
 80132b6:	0006      	movs	r6, r0
 80132b8:	000c      	movs	r4, r1
 80132ba:	7002      	strb	r2, [r0, #0]
 80132bc:	232b      	movs	r3, #43	; 0x2b
 80132be:	2900      	cmp	r1, #0
 80132c0:	da01      	bge.n	80132c6 <__exponent+0x18>
 80132c2:	232d      	movs	r3, #45	; 0x2d
 80132c4:	424c      	negs	r4, r1
 80132c6:	7073      	strb	r3, [r6, #1]
 80132c8:	2c09      	cmp	r4, #9
 80132ca:	dd22      	ble.n	8013312 <__exponent+0x64>
 80132cc:	ab02      	add	r3, sp, #8
 80132ce:	1ddd      	adds	r5, r3, #7
 80132d0:	0020      	movs	r0, r4
 80132d2:	210a      	movs	r1, #10
 80132d4:	f7ed f89a 	bl	800040c <__aeabi_idivmod>
 80132d8:	1e6f      	subs	r7, r5, #1
 80132da:	3130      	adds	r1, #48	; 0x30
 80132dc:	7039      	strb	r1, [r7, #0]
 80132de:	0020      	movs	r0, r4
 80132e0:	210a      	movs	r1, #10
 80132e2:	f7ec ffad 	bl	8000240 <__divsi3>
 80132e6:	0004      	movs	r4, r0
 80132e8:	2809      	cmp	r0, #9
 80132ea:	dc0b      	bgt.n	8013304 <__exponent+0x56>
 80132ec:	3d02      	subs	r5, #2
 80132ee:	3430      	adds	r4, #48	; 0x30
 80132f0:	9b01      	ldr	r3, [sp, #4]
 80132f2:	702c      	strb	r4, [r5, #0]
 80132f4:	aa02      	add	r2, sp, #8
 80132f6:	3207      	adds	r2, #7
 80132f8:	0018      	movs	r0, r3
 80132fa:	42aa      	cmp	r2, r5
 80132fc:	d804      	bhi.n	8013308 <__exponent+0x5a>
 80132fe:	1b80      	subs	r0, r0, r6
 8013300:	b005      	add	sp, #20
 8013302:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8013304:	003d      	movs	r5, r7
 8013306:	e7e3      	b.n	80132d0 <__exponent+0x22>
 8013308:	782a      	ldrb	r2, [r5, #0]
 801330a:	3501      	adds	r5, #1
 801330c:	701a      	strb	r2, [r3, #0]
 801330e:	3301      	adds	r3, #1
 8013310:	e7f0      	b.n	80132f4 <__exponent+0x46>
 8013312:	2330      	movs	r3, #48	; 0x30
 8013314:	18e4      	adds	r4, r4, r3
 8013316:	70b3      	strb	r3, [r6, #2]
 8013318:	1d30      	adds	r0, r6, #4
 801331a:	70f4      	strb	r4, [r6, #3]
 801331c:	e7ef      	b.n	80132fe <__exponent+0x50>
	...

08013320 <_printf_float>:
 8013320:	b5f0      	push	{r4, r5, r6, r7, lr}
 8013322:	b095      	sub	sp, #84	; 0x54
 8013324:	000c      	movs	r4, r1
 8013326:	920a      	str	r2, [sp, #40]	; 0x28
 8013328:	930b      	str	r3, [sp, #44]	; 0x2c
 801332a:	9d1a      	ldr	r5, [sp, #104]	; 0x68
 801332c:	9009      	str	r0, [sp, #36]	; 0x24
 801332e:	f001 f92b 	bl	8014588 <_localeconv_r>
 8013332:	6803      	ldr	r3, [r0, #0]
 8013334:	0018      	movs	r0, r3
 8013336:	930c      	str	r3, [sp, #48]	; 0x30
 8013338:	f7ec fee6 	bl	8000108 <strlen>
 801333c:	2300      	movs	r3, #0
 801333e:	9312      	str	r3, [sp, #72]	; 0x48
 8013340:	6823      	ldr	r3, [r4, #0]
 8013342:	900e      	str	r0, [sp, #56]	; 0x38
 8013344:	930d      	str	r3, [sp, #52]	; 0x34
 8013346:	990d      	ldr	r1, [sp, #52]	; 0x34
 8013348:	7e27      	ldrb	r7, [r4, #24]
 801334a:	682b      	ldr	r3, [r5, #0]
 801334c:	2207      	movs	r2, #7
 801334e:	05c9      	lsls	r1, r1, #23
 8013350:	d545      	bpl.n	80133de <_printf_float+0xbe>
 8013352:	189b      	adds	r3, r3, r2
 8013354:	4393      	bics	r3, r2
 8013356:	001a      	movs	r2, r3
 8013358:	3208      	adds	r2, #8
 801335a:	602a      	str	r2, [r5, #0]
 801335c:	681a      	ldr	r2, [r3, #0]
 801335e:	685b      	ldr	r3, [r3, #4]
 8013360:	64a2      	str	r2, [r4, #72]	; 0x48
 8013362:	64e3      	str	r3, [r4, #76]	; 0x4c
 8013364:	2201      	movs	r2, #1
 8013366:	6ce5      	ldr	r5, [r4, #76]	; 0x4c
 8013368:	6ca6      	ldr	r6, [r4, #72]	; 0x48
 801336a:	006b      	lsls	r3, r5, #1
 801336c:	085b      	lsrs	r3, r3, #1
 801336e:	930f      	str	r3, [sp, #60]	; 0x3c
 8013370:	4252      	negs	r2, r2
 8013372:	4bac      	ldr	r3, [pc, #688]	; (8013624 <_printf_float+0x304>)
 8013374:	0030      	movs	r0, r6
 8013376:	990f      	ldr	r1, [sp, #60]	; 0x3c
 8013378:	f7ef fb6a 	bl	8002a50 <__aeabi_dcmpun>
 801337c:	2800      	cmp	r0, #0
 801337e:	d130      	bne.n	80133e2 <_printf_float+0xc2>
 8013380:	2201      	movs	r2, #1
 8013382:	4ba8      	ldr	r3, [pc, #672]	; (8013624 <_printf_float+0x304>)
 8013384:	4252      	negs	r2, r2
 8013386:	0030      	movs	r0, r6
 8013388:	990f      	ldr	r1, [sp, #60]	; 0x3c
 801338a:	f7ed f865 	bl	8000458 <__aeabi_dcmple>
 801338e:	2800      	cmp	r0, #0
 8013390:	d127      	bne.n	80133e2 <_printf_float+0xc2>
 8013392:	2200      	movs	r2, #0
 8013394:	2300      	movs	r3, #0
 8013396:	0030      	movs	r0, r6
 8013398:	0029      	movs	r1, r5
 801339a:	f7ed f853 	bl	8000444 <__aeabi_dcmplt>
 801339e:	2800      	cmp	r0, #0
 80133a0:	d003      	beq.n	80133aa <_printf_float+0x8a>
 80133a2:	0023      	movs	r3, r4
 80133a4:	222d      	movs	r2, #45	; 0x2d
 80133a6:	3343      	adds	r3, #67	; 0x43
 80133a8:	701a      	strb	r2, [r3, #0]
 80133aa:	4d9f      	ldr	r5, [pc, #636]	; (8013628 <_printf_float+0x308>)
 80133ac:	2f47      	cmp	r7, #71	; 0x47
 80133ae:	d800      	bhi.n	80133b2 <_printf_float+0x92>
 80133b0:	4d9e      	ldr	r5, [pc, #632]	; (801362c <_printf_float+0x30c>)
 80133b2:	2303      	movs	r3, #3
 80133b4:	2600      	movs	r6, #0
 80133b6:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80133b8:	6123      	str	r3, [r4, #16]
 80133ba:	3301      	adds	r3, #1
 80133bc:	439a      	bics	r2, r3
 80133be:	6022      	str	r2, [r4, #0]
 80133c0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80133c2:	aa13      	add	r2, sp, #76	; 0x4c
 80133c4:	9300      	str	r3, [sp, #0]
 80133c6:	0021      	movs	r1, r4
 80133c8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80133ca:	9809      	ldr	r0, [sp, #36]	; 0x24
 80133cc:	f000 f9f4 	bl	80137b8 <_printf_common>
 80133d0:	1c43      	adds	r3, r0, #1
 80133d2:	d000      	beq.n	80133d6 <_printf_float+0xb6>
 80133d4:	e093      	b.n	80134fe <_printf_float+0x1de>
 80133d6:	2001      	movs	r0, #1
 80133d8:	4240      	negs	r0, r0
 80133da:	b015      	add	sp, #84	; 0x54
 80133dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80133de:	3307      	adds	r3, #7
 80133e0:	e7b8      	b.n	8013354 <_printf_float+0x34>
 80133e2:	0032      	movs	r2, r6
 80133e4:	002b      	movs	r3, r5
 80133e6:	0030      	movs	r0, r6
 80133e8:	0029      	movs	r1, r5
 80133ea:	f7ef fb31 	bl	8002a50 <__aeabi_dcmpun>
 80133ee:	2800      	cmp	r0, #0
 80133f0:	d004      	beq.n	80133fc <_printf_float+0xdc>
 80133f2:	4d8f      	ldr	r5, [pc, #572]	; (8013630 <_printf_float+0x310>)
 80133f4:	2f47      	cmp	r7, #71	; 0x47
 80133f6:	d8dc      	bhi.n	80133b2 <_printf_float+0x92>
 80133f8:	4d8e      	ldr	r5, [pc, #568]	; (8013634 <_printf_float+0x314>)
 80133fa:	e7da      	b.n	80133b2 <_printf_float+0x92>
 80133fc:	2380      	movs	r3, #128	; 0x80
 80133fe:	990d      	ldr	r1, [sp, #52]	; 0x34
 8013400:	6862      	ldr	r2, [r4, #4]
 8013402:	00db      	lsls	r3, r3, #3
 8013404:	430b      	orrs	r3, r1
 8013406:	1c51      	adds	r1, r2, #1
 8013408:	d143      	bne.n	8013492 <_printf_float+0x172>
 801340a:	3207      	adds	r2, #7
 801340c:	6062      	str	r2, [r4, #4]
 801340e:	aa12      	add	r2, sp, #72	; 0x48
 8013410:	2100      	movs	r1, #0
 8013412:	9205      	str	r2, [sp, #20]
 8013414:	aa11      	add	r2, sp, #68	; 0x44
 8013416:	9203      	str	r2, [sp, #12]
 8013418:	2223      	movs	r2, #35	; 0x23
 801341a:	6023      	str	r3, [r4, #0]
 801341c:	9106      	str	r1, [sp, #24]
 801341e:	9301      	str	r3, [sp, #4]
 8013420:	a908      	add	r1, sp, #32
 8013422:	6863      	ldr	r3, [r4, #4]
 8013424:	1852      	adds	r2, r2, r1
 8013426:	9202      	str	r2, [sp, #8]
 8013428:	9300      	str	r3, [sp, #0]
 801342a:	0032      	movs	r2, r6
 801342c:	002b      	movs	r3, r5
 801342e:	9704      	str	r7, [sp, #16]
 8013430:	9809      	ldr	r0, [sp, #36]	; 0x24
 8013432:	f7ff fed8 	bl	80131e6 <__cvt>
 8013436:	2320      	movs	r3, #32
 8013438:	003a      	movs	r2, r7
 801343a:	0005      	movs	r5, r0
 801343c:	439a      	bics	r2, r3
 801343e:	2a47      	cmp	r2, #71	; 0x47
 8013440:	d107      	bne.n	8013452 <_printf_float+0x132>
 8013442:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8013444:	1cda      	adds	r2, r3, #3
 8013446:	db02      	blt.n	801344e <_printf_float+0x12e>
 8013448:	6862      	ldr	r2, [r4, #4]
 801344a:	4293      	cmp	r3, r2
 801344c:	dd45      	ble.n	80134da <_printf_float+0x1ba>
 801344e:	3f02      	subs	r7, #2
 8013450:	b2ff      	uxtb	r7, r7
 8013452:	9911      	ldr	r1, [sp, #68]	; 0x44
 8013454:	2f65      	cmp	r7, #101	; 0x65
 8013456:	d825      	bhi.n	80134a4 <_printf_float+0x184>
 8013458:	0020      	movs	r0, r4
 801345a:	3901      	subs	r1, #1
 801345c:	003a      	movs	r2, r7
 801345e:	3050      	adds	r0, #80	; 0x50
 8013460:	9111      	str	r1, [sp, #68]	; 0x44
 8013462:	f7ff ff24 	bl	80132ae <__exponent>
 8013466:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8013468:	0006      	movs	r6, r0
 801346a:	1813      	adds	r3, r2, r0
 801346c:	6123      	str	r3, [r4, #16]
 801346e:	2a01      	cmp	r2, #1
 8013470:	dc02      	bgt.n	8013478 <_printf_float+0x158>
 8013472:	6822      	ldr	r2, [r4, #0]
 8013474:	07d2      	lsls	r2, r2, #31
 8013476:	d501      	bpl.n	801347c <_printf_float+0x15c>
 8013478:	3301      	adds	r3, #1
 801347a:	6123      	str	r3, [r4, #16]
 801347c:	2323      	movs	r3, #35	; 0x23
 801347e:	aa08      	add	r2, sp, #32
 8013480:	189b      	adds	r3, r3, r2
 8013482:	781b      	ldrb	r3, [r3, #0]
 8013484:	2b00      	cmp	r3, #0
 8013486:	d09b      	beq.n	80133c0 <_printf_float+0xa0>
 8013488:	0023      	movs	r3, r4
 801348a:	222d      	movs	r2, #45	; 0x2d
 801348c:	3343      	adds	r3, #67	; 0x43
 801348e:	701a      	strb	r2, [r3, #0]
 8013490:	e796      	b.n	80133c0 <_printf_float+0xa0>
 8013492:	2f67      	cmp	r7, #103	; 0x67
 8013494:	d100      	bne.n	8013498 <_printf_float+0x178>
 8013496:	e176      	b.n	8013786 <_printf_float+0x466>
 8013498:	2f47      	cmp	r7, #71	; 0x47
 801349a:	d1b8      	bne.n	801340e <_printf_float+0xee>
 801349c:	2a00      	cmp	r2, #0
 801349e:	d1b6      	bne.n	801340e <_printf_float+0xee>
 80134a0:	2201      	movs	r2, #1
 80134a2:	e7b3      	b.n	801340c <_printf_float+0xec>
 80134a4:	2f66      	cmp	r7, #102	; 0x66
 80134a6:	d119      	bne.n	80134dc <_printf_float+0x1bc>
 80134a8:	6863      	ldr	r3, [r4, #4]
 80134aa:	2900      	cmp	r1, #0
 80134ac:	dd0c      	ble.n	80134c8 <_printf_float+0x1a8>
 80134ae:	6121      	str	r1, [r4, #16]
 80134b0:	2b00      	cmp	r3, #0
 80134b2:	d102      	bne.n	80134ba <_printf_float+0x19a>
 80134b4:	6822      	ldr	r2, [r4, #0]
 80134b6:	07d2      	lsls	r2, r2, #31
 80134b8:	d502      	bpl.n	80134c0 <_printf_float+0x1a0>
 80134ba:	3301      	adds	r3, #1
 80134bc:	185b      	adds	r3, r3, r1
 80134be:	6123      	str	r3, [r4, #16]
 80134c0:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80134c2:	2600      	movs	r6, #0
 80134c4:	65a3      	str	r3, [r4, #88]	; 0x58
 80134c6:	e7d9      	b.n	801347c <_printf_float+0x15c>
 80134c8:	2b00      	cmp	r3, #0
 80134ca:	d103      	bne.n	80134d4 <_printf_float+0x1b4>
 80134cc:	2201      	movs	r2, #1
 80134ce:	6821      	ldr	r1, [r4, #0]
 80134d0:	4211      	tst	r1, r2
 80134d2:	d000      	beq.n	80134d6 <_printf_float+0x1b6>
 80134d4:	1c9a      	adds	r2, r3, #2
 80134d6:	6122      	str	r2, [r4, #16]
 80134d8:	e7f2      	b.n	80134c0 <_printf_float+0x1a0>
 80134da:	2767      	movs	r7, #103	; 0x67
 80134dc:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80134de:	9a12      	ldr	r2, [sp, #72]	; 0x48
 80134e0:	4293      	cmp	r3, r2
 80134e2:	db05      	blt.n	80134f0 <_printf_float+0x1d0>
 80134e4:	6822      	ldr	r2, [r4, #0]
 80134e6:	6123      	str	r3, [r4, #16]
 80134e8:	07d2      	lsls	r2, r2, #31
 80134ea:	d5e9      	bpl.n	80134c0 <_printf_float+0x1a0>
 80134ec:	3301      	adds	r3, #1
 80134ee:	e7e6      	b.n	80134be <_printf_float+0x19e>
 80134f0:	2101      	movs	r1, #1
 80134f2:	2b00      	cmp	r3, #0
 80134f4:	dc01      	bgt.n	80134fa <_printf_float+0x1da>
 80134f6:	1849      	adds	r1, r1, r1
 80134f8:	1ac9      	subs	r1, r1, r3
 80134fa:	1852      	adds	r2, r2, r1
 80134fc:	e7eb      	b.n	80134d6 <_printf_float+0x1b6>
 80134fe:	6822      	ldr	r2, [r4, #0]
 8013500:	0553      	lsls	r3, r2, #21
 8013502:	d408      	bmi.n	8013516 <_printf_float+0x1f6>
 8013504:	6923      	ldr	r3, [r4, #16]
 8013506:	002a      	movs	r2, r5
 8013508:	990a      	ldr	r1, [sp, #40]	; 0x28
 801350a:	9809      	ldr	r0, [sp, #36]	; 0x24
 801350c:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 801350e:	47a8      	blx	r5
 8013510:	1c43      	adds	r3, r0, #1
 8013512:	d129      	bne.n	8013568 <_printf_float+0x248>
 8013514:	e75f      	b.n	80133d6 <_printf_float+0xb6>
 8013516:	2f65      	cmp	r7, #101	; 0x65
 8013518:	d800      	bhi.n	801351c <_printf_float+0x1fc>
 801351a:	e0e0      	b.n	80136de <_printf_float+0x3be>
 801351c:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 801351e:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
 8013520:	2200      	movs	r2, #0
 8013522:	2300      	movs	r3, #0
 8013524:	f7ec ff88 	bl	8000438 <__aeabi_dcmpeq>
 8013528:	2800      	cmp	r0, #0
 801352a:	d034      	beq.n	8013596 <_printf_float+0x276>
 801352c:	2301      	movs	r3, #1
 801352e:	4a42      	ldr	r2, [pc, #264]	; (8013638 <_printf_float+0x318>)
 8013530:	990a      	ldr	r1, [sp, #40]	; 0x28
 8013532:	9809      	ldr	r0, [sp, #36]	; 0x24
 8013534:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8013536:	47a8      	blx	r5
 8013538:	1c43      	adds	r3, r0, #1
 801353a:	d100      	bne.n	801353e <_printf_float+0x21e>
 801353c:	e74b      	b.n	80133d6 <_printf_float+0xb6>
 801353e:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8013540:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8013542:	4293      	cmp	r3, r2
 8013544:	db02      	blt.n	801354c <_printf_float+0x22c>
 8013546:	6823      	ldr	r3, [r4, #0]
 8013548:	07db      	lsls	r3, r3, #31
 801354a:	d50d      	bpl.n	8013568 <_printf_float+0x248>
 801354c:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 801354e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8013550:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8013552:	990a      	ldr	r1, [sp, #40]	; 0x28
 8013554:	9809      	ldr	r0, [sp, #36]	; 0x24
 8013556:	47a8      	blx	r5
 8013558:	2500      	movs	r5, #0
 801355a:	1c43      	adds	r3, r0, #1
 801355c:	d100      	bne.n	8013560 <_printf_float+0x240>
 801355e:	e73a      	b.n	80133d6 <_printf_float+0xb6>
 8013560:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8013562:	3b01      	subs	r3, #1
 8013564:	42ab      	cmp	r3, r5
 8013566:	dc0a      	bgt.n	801357e <_printf_float+0x25e>
 8013568:	6823      	ldr	r3, [r4, #0]
 801356a:	079b      	lsls	r3, r3, #30
 801356c:	d500      	bpl.n	8013570 <_printf_float+0x250>
 801356e:	e108      	b.n	8013782 <_printf_float+0x462>
 8013570:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8013572:	68e0      	ldr	r0, [r4, #12]
 8013574:	4298      	cmp	r0, r3
 8013576:	db00      	blt.n	801357a <_printf_float+0x25a>
 8013578:	e72f      	b.n	80133da <_printf_float+0xba>
 801357a:	0018      	movs	r0, r3
 801357c:	e72d      	b.n	80133da <_printf_float+0xba>
 801357e:	0022      	movs	r2, r4
 8013580:	2301      	movs	r3, #1
 8013582:	321a      	adds	r2, #26
 8013584:	990a      	ldr	r1, [sp, #40]	; 0x28
 8013586:	9809      	ldr	r0, [sp, #36]	; 0x24
 8013588:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 801358a:	47b0      	blx	r6
 801358c:	1c43      	adds	r3, r0, #1
 801358e:	d100      	bne.n	8013592 <_printf_float+0x272>
 8013590:	e721      	b.n	80133d6 <_printf_float+0xb6>
 8013592:	3501      	adds	r5, #1
 8013594:	e7e4      	b.n	8013560 <_printf_float+0x240>
 8013596:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8013598:	2b00      	cmp	r3, #0
 801359a:	dc2d      	bgt.n	80135f8 <_printf_float+0x2d8>
 801359c:	2301      	movs	r3, #1
 801359e:	4a26      	ldr	r2, [pc, #152]	; (8013638 <_printf_float+0x318>)
 80135a0:	990a      	ldr	r1, [sp, #40]	; 0x28
 80135a2:	9809      	ldr	r0, [sp, #36]	; 0x24
 80135a4:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 80135a6:	47b0      	blx	r6
 80135a8:	1c43      	adds	r3, r0, #1
 80135aa:	d100      	bne.n	80135ae <_printf_float+0x28e>
 80135ac:	e713      	b.n	80133d6 <_printf_float+0xb6>
 80135ae:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80135b0:	2b00      	cmp	r3, #0
 80135b2:	d105      	bne.n	80135c0 <_printf_float+0x2a0>
 80135b4:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80135b6:	2b00      	cmp	r3, #0
 80135b8:	d102      	bne.n	80135c0 <_printf_float+0x2a0>
 80135ba:	6823      	ldr	r3, [r4, #0]
 80135bc:	07db      	lsls	r3, r3, #31
 80135be:	d5d3      	bpl.n	8013568 <_printf_float+0x248>
 80135c0:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 80135c2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80135c4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80135c6:	990a      	ldr	r1, [sp, #40]	; 0x28
 80135c8:	9809      	ldr	r0, [sp, #36]	; 0x24
 80135ca:	47b0      	blx	r6
 80135cc:	2600      	movs	r6, #0
 80135ce:	1c43      	adds	r3, r0, #1
 80135d0:	d100      	bne.n	80135d4 <_printf_float+0x2b4>
 80135d2:	e700      	b.n	80133d6 <_printf_float+0xb6>
 80135d4:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80135d6:	425b      	negs	r3, r3
 80135d8:	42b3      	cmp	r3, r6
 80135da:	dc01      	bgt.n	80135e0 <_printf_float+0x2c0>
 80135dc:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80135de:	e792      	b.n	8013506 <_printf_float+0x1e6>
 80135e0:	0022      	movs	r2, r4
 80135e2:	2301      	movs	r3, #1
 80135e4:	321a      	adds	r2, #26
 80135e6:	990a      	ldr	r1, [sp, #40]	; 0x28
 80135e8:	9809      	ldr	r0, [sp, #36]	; 0x24
 80135ea:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 80135ec:	47b8      	blx	r7
 80135ee:	1c43      	adds	r3, r0, #1
 80135f0:	d100      	bne.n	80135f4 <_printf_float+0x2d4>
 80135f2:	e6f0      	b.n	80133d6 <_printf_float+0xb6>
 80135f4:	3601      	adds	r6, #1
 80135f6:	e7ed      	b.n	80135d4 <_printf_float+0x2b4>
 80135f8:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80135fa:	9f12      	ldr	r7, [sp, #72]	; 0x48
 80135fc:	429f      	cmp	r7, r3
 80135fe:	dd00      	ble.n	8013602 <_printf_float+0x2e2>
 8013600:	001f      	movs	r7, r3
 8013602:	2f00      	cmp	r7, #0
 8013604:	dd08      	ble.n	8013618 <_printf_float+0x2f8>
 8013606:	003b      	movs	r3, r7
 8013608:	002a      	movs	r2, r5
 801360a:	990a      	ldr	r1, [sp, #40]	; 0x28
 801360c:	9809      	ldr	r0, [sp, #36]	; 0x24
 801360e:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 8013610:	47b0      	blx	r6
 8013612:	1c43      	adds	r3, r0, #1
 8013614:	d100      	bne.n	8013618 <_printf_float+0x2f8>
 8013616:	e6de      	b.n	80133d6 <_printf_float+0xb6>
 8013618:	2300      	movs	r3, #0
 801361a:	930d      	str	r3, [sp, #52]	; 0x34
 801361c:	43fb      	mvns	r3, r7
 801361e:	17db      	asrs	r3, r3, #31
 8013620:	930f      	str	r3, [sp, #60]	; 0x3c
 8013622:	e018      	b.n	8013656 <_printf_float+0x336>
 8013624:	7fefffff 	.word	0x7fefffff
 8013628:	08015200 	.word	0x08015200
 801362c:	080151fc 	.word	0x080151fc
 8013630:	08015208 	.word	0x08015208
 8013634:	08015204 	.word	0x08015204
 8013638:	0801520c 	.word	0x0801520c
 801363c:	0022      	movs	r2, r4
 801363e:	2301      	movs	r3, #1
 8013640:	321a      	adds	r2, #26
 8013642:	990a      	ldr	r1, [sp, #40]	; 0x28
 8013644:	9809      	ldr	r0, [sp, #36]	; 0x24
 8013646:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 8013648:	47b0      	blx	r6
 801364a:	1c43      	adds	r3, r0, #1
 801364c:	d100      	bne.n	8013650 <_printf_float+0x330>
 801364e:	e6c2      	b.n	80133d6 <_printf_float+0xb6>
 8013650:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8013652:	3301      	adds	r3, #1
 8013654:	930d      	str	r3, [sp, #52]	; 0x34
 8013656:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8013658:	6da6      	ldr	r6, [r4, #88]	; 0x58
 801365a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 801365c:	403b      	ands	r3, r7
 801365e:	1af3      	subs	r3, r6, r3
 8013660:	4293      	cmp	r3, r2
 8013662:	dceb      	bgt.n	801363c <_printf_float+0x31c>
 8013664:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8013666:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8013668:	19ad      	adds	r5, r5, r6
 801366a:	4293      	cmp	r3, r2
 801366c:	db10      	blt.n	8013690 <_printf_float+0x370>
 801366e:	6823      	ldr	r3, [r4, #0]
 8013670:	07db      	lsls	r3, r3, #31
 8013672:	d40d      	bmi.n	8013690 <_printf_float+0x370>
 8013674:	9f12      	ldr	r7, [sp, #72]	; 0x48
 8013676:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8013678:	1bbe      	subs	r6, r7, r6
 801367a:	1aff      	subs	r7, r7, r3
 801367c:	42b7      	cmp	r7, r6
 801367e:	dd00      	ble.n	8013682 <_printf_float+0x362>
 8013680:	0037      	movs	r7, r6
 8013682:	2f00      	cmp	r7, #0
 8013684:	dc0d      	bgt.n	80136a2 <_printf_float+0x382>
 8013686:	43fe      	mvns	r6, r7
 8013688:	17f3      	asrs	r3, r6, #31
 801368a:	2500      	movs	r5, #0
 801368c:	930c      	str	r3, [sp, #48]	; 0x30
 801368e:	e01c      	b.n	80136ca <_printf_float+0x3aa>
 8013690:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8013692:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8013694:	990a      	ldr	r1, [sp, #40]	; 0x28
 8013696:	9809      	ldr	r0, [sp, #36]	; 0x24
 8013698:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 801369a:	47b8      	blx	r7
 801369c:	1c43      	adds	r3, r0, #1
 801369e:	d1e9      	bne.n	8013674 <_printf_float+0x354>
 80136a0:	e699      	b.n	80133d6 <_printf_float+0xb6>
 80136a2:	003b      	movs	r3, r7
 80136a4:	002a      	movs	r2, r5
 80136a6:	990a      	ldr	r1, [sp, #40]	; 0x28
 80136a8:	9809      	ldr	r0, [sp, #36]	; 0x24
 80136aa:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 80136ac:	47a8      	blx	r5
 80136ae:	1c43      	adds	r3, r0, #1
 80136b0:	d1e9      	bne.n	8013686 <_printf_float+0x366>
 80136b2:	e690      	b.n	80133d6 <_printf_float+0xb6>
 80136b4:	0022      	movs	r2, r4
 80136b6:	2301      	movs	r3, #1
 80136b8:	321a      	adds	r2, #26
 80136ba:	990a      	ldr	r1, [sp, #40]	; 0x28
 80136bc:	9809      	ldr	r0, [sp, #36]	; 0x24
 80136be:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 80136c0:	47b0      	blx	r6
 80136c2:	1c43      	adds	r3, r0, #1
 80136c4:	d100      	bne.n	80136c8 <_printf_float+0x3a8>
 80136c6:	e686      	b.n	80133d6 <_printf_float+0xb6>
 80136c8:	3501      	adds	r5, #1
 80136ca:	9a11      	ldr	r2, [sp, #68]	; 0x44
 80136cc:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80136ce:	990c      	ldr	r1, [sp, #48]	; 0x30
 80136d0:	1a9b      	subs	r3, r3, r2
 80136d2:	003a      	movs	r2, r7
 80136d4:	400a      	ands	r2, r1
 80136d6:	1a9b      	subs	r3, r3, r2
 80136d8:	42ab      	cmp	r3, r5
 80136da:	dceb      	bgt.n	80136b4 <_printf_float+0x394>
 80136dc:	e744      	b.n	8013568 <_printf_float+0x248>
 80136de:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80136e0:	2b01      	cmp	r3, #1
 80136e2:	dc02      	bgt.n	80136ea <_printf_float+0x3ca>
 80136e4:	2301      	movs	r3, #1
 80136e6:	421a      	tst	r2, r3
 80136e8:	d032      	beq.n	8013750 <_printf_float+0x430>
 80136ea:	2301      	movs	r3, #1
 80136ec:	002a      	movs	r2, r5
 80136ee:	990a      	ldr	r1, [sp, #40]	; 0x28
 80136f0:	9809      	ldr	r0, [sp, #36]	; 0x24
 80136f2:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 80136f4:	47b8      	blx	r7
 80136f6:	1c43      	adds	r3, r0, #1
 80136f8:	d100      	bne.n	80136fc <_printf_float+0x3dc>
 80136fa:	e66c      	b.n	80133d6 <_printf_float+0xb6>
 80136fc:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80136fe:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8013700:	990a      	ldr	r1, [sp, #40]	; 0x28
 8013702:	9809      	ldr	r0, [sp, #36]	; 0x24
 8013704:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 8013706:	3501      	adds	r5, #1
 8013708:	47b8      	blx	r7
 801370a:	1c43      	adds	r3, r0, #1
 801370c:	d100      	bne.n	8013710 <_printf_float+0x3f0>
 801370e:	e662      	b.n	80133d6 <_printf_float+0xb6>
 8013710:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 8013712:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
 8013714:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8013716:	2200      	movs	r2, #0
 8013718:	1e5f      	subs	r7, r3, #1
 801371a:	2300      	movs	r3, #0
 801371c:	f7ec fe8c 	bl	8000438 <__aeabi_dcmpeq>
 8013720:	003b      	movs	r3, r7
 8013722:	2800      	cmp	r0, #0
 8013724:	d014      	beq.n	8013750 <_printf_float+0x430>
 8013726:	2500      	movs	r5, #0
 8013728:	e00a      	b.n	8013740 <_printf_float+0x420>
 801372a:	0022      	movs	r2, r4
 801372c:	2301      	movs	r3, #1
 801372e:	321a      	adds	r2, #26
 8013730:	990a      	ldr	r1, [sp, #40]	; 0x28
 8013732:	9809      	ldr	r0, [sp, #36]	; 0x24
 8013734:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 8013736:	47b8      	blx	r7
 8013738:	1c43      	adds	r3, r0, #1
 801373a:	d100      	bne.n	801373e <_printf_float+0x41e>
 801373c:	e64b      	b.n	80133d6 <_printf_float+0xb6>
 801373e:	3501      	adds	r5, #1
 8013740:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8013742:	3b01      	subs	r3, #1
 8013744:	42ab      	cmp	r3, r5
 8013746:	dcf0      	bgt.n	801372a <_printf_float+0x40a>
 8013748:	0022      	movs	r2, r4
 801374a:	0033      	movs	r3, r6
 801374c:	3250      	adds	r2, #80	; 0x50
 801374e:	e6db      	b.n	8013508 <_printf_float+0x1e8>
 8013750:	002a      	movs	r2, r5
 8013752:	990a      	ldr	r1, [sp, #40]	; 0x28
 8013754:	9809      	ldr	r0, [sp, #36]	; 0x24
 8013756:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8013758:	47a8      	blx	r5
 801375a:	1c43      	adds	r3, r0, #1
 801375c:	d1f4      	bne.n	8013748 <_printf_float+0x428>
 801375e:	e63a      	b.n	80133d6 <_printf_float+0xb6>
 8013760:	0022      	movs	r2, r4
 8013762:	2301      	movs	r3, #1
 8013764:	3219      	adds	r2, #25
 8013766:	990a      	ldr	r1, [sp, #40]	; 0x28
 8013768:	9809      	ldr	r0, [sp, #36]	; 0x24
 801376a:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 801376c:	47b0      	blx	r6
 801376e:	1c43      	adds	r3, r0, #1
 8013770:	d100      	bne.n	8013774 <_printf_float+0x454>
 8013772:	e630      	b.n	80133d6 <_printf_float+0xb6>
 8013774:	3501      	adds	r5, #1
 8013776:	68e3      	ldr	r3, [r4, #12]
 8013778:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 801377a:	1a9b      	subs	r3, r3, r2
 801377c:	42ab      	cmp	r3, r5
 801377e:	dcef      	bgt.n	8013760 <_printf_float+0x440>
 8013780:	e6f6      	b.n	8013570 <_printf_float+0x250>
 8013782:	2500      	movs	r5, #0
 8013784:	e7f7      	b.n	8013776 <_printf_float+0x456>
 8013786:	2a00      	cmp	r2, #0
 8013788:	d100      	bne.n	801378c <_printf_float+0x46c>
 801378a:	e689      	b.n	80134a0 <_printf_float+0x180>
 801378c:	2100      	movs	r1, #0
 801378e:	9106      	str	r1, [sp, #24]
 8013790:	a912      	add	r1, sp, #72	; 0x48
 8013792:	9105      	str	r1, [sp, #20]
 8013794:	a911      	add	r1, sp, #68	; 0x44
 8013796:	9103      	str	r1, [sp, #12]
 8013798:	2123      	movs	r1, #35	; 0x23
 801379a:	a808      	add	r0, sp, #32
 801379c:	1809      	adds	r1, r1, r0
 801379e:	6023      	str	r3, [r4, #0]
 80137a0:	9301      	str	r3, [sp, #4]
 80137a2:	9200      	str	r2, [sp, #0]
 80137a4:	002b      	movs	r3, r5
 80137a6:	9704      	str	r7, [sp, #16]
 80137a8:	9102      	str	r1, [sp, #8]
 80137aa:	0032      	movs	r2, r6
 80137ac:	9809      	ldr	r0, [sp, #36]	; 0x24
 80137ae:	f7ff fd1a 	bl	80131e6 <__cvt>
 80137b2:	0005      	movs	r5, r0
 80137b4:	e645      	b.n	8013442 <_printf_float+0x122>
 80137b6:	46c0      	nop			; (mov r8, r8)

080137b8 <_printf_common>:
 80137b8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80137ba:	0015      	movs	r5, r2
 80137bc:	9301      	str	r3, [sp, #4]
 80137be:	688a      	ldr	r2, [r1, #8]
 80137c0:	690b      	ldr	r3, [r1, #16]
 80137c2:	9000      	str	r0, [sp, #0]
 80137c4:	000c      	movs	r4, r1
 80137c6:	4293      	cmp	r3, r2
 80137c8:	da00      	bge.n	80137cc <_printf_common+0x14>
 80137ca:	0013      	movs	r3, r2
 80137cc:	0022      	movs	r2, r4
 80137ce:	602b      	str	r3, [r5, #0]
 80137d0:	3243      	adds	r2, #67	; 0x43
 80137d2:	7812      	ldrb	r2, [r2, #0]
 80137d4:	2a00      	cmp	r2, #0
 80137d6:	d001      	beq.n	80137dc <_printf_common+0x24>
 80137d8:	3301      	adds	r3, #1
 80137da:	602b      	str	r3, [r5, #0]
 80137dc:	6823      	ldr	r3, [r4, #0]
 80137de:	069b      	lsls	r3, r3, #26
 80137e0:	d502      	bpl.n	80137e8 <_printf_common+0x30>
 80137e2:	682b      	ldr	r3, [r5, #0]
 80137e4:	3302      	adds	r3, #2
 80137e6:	602b      	str	r3, [r5, #0]
 80137e8:	2706      	movs	r7, #6
 80137ea:	6823      	ldr	r3, [r4, #0]
 80137ec:	401f      	ands	r7, r3
 80137ee:	d027      	beq.n	8013840 <_printf_common+0x88>
 80137f0:	0023      	movs	r3, r4
 80137f2:	3343      	adds	r3, #67	; 0x43
 80137f4:	781b      	ldrb	r3, [r3, #0]
 80137f6:	1e5a      	subs	r2, r3, #1
 80137f8:	4193      	sbcs	r3, r2
 80137fa:	6822      	ldr	r2, [r4, #0]
 80137fc:	0692      	lsls	r2, r2, #26
 80137fe:	d430      	bmi.n	8013862 <_printf_common+0xaa>
 8013800:	0022      	movs	r2, r4
 8013802:	9901      	ldr	r1, [sp, #4]
 8013804:	3243      	adds	r2, #67	; 0x43
 8013806:	9800      	ldr	r0, [sp, #0]
 8013808:	9e08      	ldr	r6, [sp, #32]
 801380a:	47b0      	blx	r6
 801380c:	1c43      	adds	r3, r0, #1
 801380e:	d025      	beq.n	801385c <_printf_common+0xa4>
 8013810:	2306      	movs	r3, #6
 8013812:	6820      	ldr	r0, [r4, #0]
 8013814:	682a      	ldr	r2, [r5, #0]
 8013816:	68e1      	ldr	r1, [r4, #12]
 8013818:	4003      	ands	r3, r0
 801381a:	2500      	movs	r5, #0
 801381c:	2b04      	cmp	r3, #4
 801381e:	d103      	bne.n	8013828 <_printf_common+0x70>
 8013820:	1a8d      	subs	r5, r1, r2
 8013822:	43eb      	mvns	r3, r5
 8013824:	17db      	asrs	r3, r3, #31
 8013826:	401d      	ands	r5, r3
 8013828:	68a3      	ldr	r3, [r4, #8]
 801382a:	6922      	ldr	r2, [r4, #16]
 801382c:	4293      	cmp	r3, r2
 801382e:	dd01      	ble.n	8013834 <_printf_common+0x7c>
 8013830:	1a9b      	subs	r3, r3, r2
 8013832:	18ed      	adds	r5, r5, r3
 8013834:	2700      	movs	r7, #0
 8013836:	42bd      	cmp	r5, r7
 8013838:	d120      	bne.n	801387c <_printf_common+0xc4>
 801383a:	2000      	movs	r0, #0
 801383c:	e010      	b.n	8013860 <_printf_common+0xa8>
 801383e:	3701      	adds	r7, #1
 8013840:	68e3      	ldr	r3, [r4, #12]
 8013842:	682a      	ldr	r2, [r5, #0]
 8013844:	1a9b      	subs	r3, r3, r2
 8013846:	42bb      	cmp	r3, r7
 8013848:	ddd2      	ble.n	80137f0 <_printf_common+0x38>
 801384a:	0022      	movs	r2, r4
 801384c:	2301      	movs	r3, #1
 801384e:	3219      	adds	r2, #25
 8013850:	9901      	ldr	r1, [sp, #4]
 8013852:	9800      	ldr	r0, [sp, #0]
 8013854:	9e08      	ldr	r6, [sp, #32]
 8013856:	47b0      	blx	r6
 8013858:	1c43      	adds	r3, r0, #1
 801385a:	d1f0      	bne.n	801383e <_printf_common+0x86>
 801385c:	2001      	movs	r0, #1
 801385e:	4240      	negs	r0, r0
 8013860:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8013862:	2030      	movs	r0, #48	; 0x30
 8013864:	18e1      	adds	r1, r4, r3
 8013866:	3143      	adds	r1, #67	; 0x43
 8013868:	7008      	strb	r0, [r1, #0]
 801386a:	0021      	movs	r1, r4
 801386c:	1c5a      	adds	r2, r3, #1
 801386e:	3145      	adds	r1, #69	; 0x45
 8013870:	7809      	ldrb	r1, [r1, #0]
 8013872:	18a2      	adds	r2, r4, r2
 8013874:	3243      	adds	r2, #67	; 0x43
 8013876:	3302      	adds	r3, #2
 8013878:	7011      	strb	r1, [r2, #0]
 801387a:	e7c1      	b.n	8013800 <_printf_common+0x48>
 801387c:	0022      	movs	r2, r4
 801387e:	2301      	movs	r3, #1
 8013880:	321a      	adds	r2, #26
 8013882:	9901      	ldr	r1, [sp, #4]
 8013884:	9800      	ldr	r0, [sp, #0]
 8013886:	9e08      	ldr	r6, [sp, #32]
 8013888:	47b0      	blx	r6
 801388a:	1c43      	adds	r3, r0, #1
 801388c:	d0e6      	beq.n	801385c <_printf_common+0xa4>
 801388e:	3701      	adds	r7, #1
 8013890:	e7d1      	b.n	8013836 <_printf_common+0x7e>

08013892 <strncpy>:
 8013892:	b530      	push	{r4, r5, lr}
 8013894:	0005      	movs	r5, r0
 8013896:	2a00      	cmp	r2, #0
 8013898:	d100      	bne.n	801389c <strncpy+0xa>
 801389a:	bd30      	pop	{r4, r5, pc}
 801389c:	780c      	ldrb	r4, [r1, #0]
 801389e:	3a01      	subs	r2, #1
 80138a0:	1c6b      	adds	r3, r5, #1
 80138a2:	702c      	strb	r4, [r5, #0]
 80138a4:	3101      	adds	r1, #1
 80138a6:	2c00      	cmp	r4, #0
 80138a8:	d105      	bne.n	80138b6 <strncpy+0x24>
 80138aa:	189a      	adds	r2, r3, r2
 80138ac:	429a      	cmp	r2, r3
 80138ae:	d0f4      	beq.n	801389a <strncpy+0x8>
 80138b0:	701c      	strb	r4, [r3, #0]
 80138b2:	3301      	adds	r3, #1
 80138b4:	e7fa      	b.n	80138ac <strncpy+0x1a>
 80138b6:	001d      	movs	r5, r3
 80138b8:	e7ed      	b.n	8013896 <strncpy+0x4>

080138ba <quorem>:
 80138ba:	b5f0      	push	{r4, r5, r6, r7, lr}
 80138bc:	6903      	ldr	r3, [r0, #16]
 80138be:	690c      	ldr	r4, [r1, #16]
 80138c0:	b089      	sub	sp, #36	; 0x24
 80138c2:	0007      	movs	r7, r0
 80138c4:	9105      	str	r1, [sp, #20]
 80138c6:	2600      	movs	r6, #0
 80138c8:	42a3      	cmp	r3, r4
 80138ca:	db65      	blt.n	8013998 <quorem+0xde>
 80138cc:	000b      	movs	r3, r1
 80138ce:	3c01      	subs	r4, #1
 80138d0:	3314      	adds	r3, #20
 80138d2:	00a5      	lsls	r5, r4, #2
 80138d4:	9303      	str	r3, [sp, #12]
 80138d6:	195b      	adds	r3, r3, r5
 80138d8:	9304      	str	r3, [sp, #16]
 80138da:	0003      	movs	r3, r0
 80138dc:	3314      	adds	r3, #20
 80138de:	9302      	str	r3, [sp, #8]
 80138e0:	195d      	adds	r5, r3, r5
 80138e2:	9b04      	ldr	r3, [sp, #16]
 80138e4:	6828      	ldr	r0, [r5, #0]
 80138e6:	681b      	ldr	r3, [r3, #0]
 80138e8:	1c59      	adds	r1, r3, #1
 80138ea:	9301      	str	r3, [sp, #4]
 80138ec:	f7ec fc1e 	bl	800012c <__udivsi3>
 80138f0:	9001      	str	r0, [sp, #4]
 80138f2:	42b0      	cmp	r0, r6
 80138f4:	d029      	beq.n	801394a <quorem+0x90>
 80138f6:	9b03      	ldr	r3, [sp, #12]
 80138f8:	9802      	ldr	r0, [sp, #8]
 80138fa:	469c      	mov	ip, r3
 80138fc:	9606      	str	r6, [sp, #24]
 80138fe:	4662      	mov	r2, ip
 8013900:	ca08      	ldmia	r2!, {r3}
 8013902:	4694      	mov	ip, r2
 8013904:	9a01      	ldr	r2, [sp, #4]
 8013906:	b299      	uxth	r1, r3
 8013908:	4351      	muls	r1, r2
 801390a:	0c1b      	lsrs	r3, r3, #16
 801390c:	4353      	muls	r3, r2
 801390e:	1989      	adds	r1, r1, r6
 8013910:	0c0a      	lsrs	r2, r1, #16
 8013912:	189b      	adds	r3, r3, r2
 8013914:	9307      	str	r3, [sp, #28]
 8013916:	0c1e      	lsrs	r6, r3, #16
 8013918:	6803      	ldr	r3, [r0, #0]
 801391a:	b289      	uxth	r1, r1
 801391c:	b29a      	uxth	r2, r3
 801391e:	9b06      	ldr	r3, [sp, #24]
 8013920:	18d2      	adds	r2, r2, r3
 8013922:	6803      	ldr	r3, [r0, #0]
 8013924:	1a52      	subs	r2, r2, r1
 8013926:	0c19      	lsrs	r1, r3, #16
 8013928:	466b      	mov	r3, sp
 801392a:	8b9b      	ldrh	r3, [r3, #28]
 801392c:	1acb      	subs	r3, r1, r3
 801392e:	1411      	asrs	r1, r2, #16
 8013930:	185b      	adds	r3, r3, r1
 8013932:	1419      	asrs	r1, r3, #16
 8013934:	b292      	uxth	r2, r2
 8013936:	041b      	lsls	r3, r3, #16
 8013938:	431a      	orrs	r2, r3
 801393a:	9b04      	ldr	r3, [sp, #16]
 801393c:	9106      	str	r1, [sp, #24]
 801393e:	c004      	stmia	r0!, {r2}
 8013940:	4563      	cmp	r3, ip
 8013942:	d2dc      	bcs.n	80138fe <quorem+0x44>
 8013944:	682b      	ldr	r3, [r5, #0]
 8013946:	2b00      	cmp	r3, #0
 8013948:	d02d      	beq.n	80139a6 <quorem+0xec>
 801394a:	9905      	ldr	r1, [sp, #20]
 801394c:	0038      	movs	r0, r7
 801394e:	f001 f845 	bl	80149dc <__mcmp>
 8013952:	2800      	cmp	r0, #0
 8013954:	db1f      	blt.n	8013996 <quorem+0xdc>
 8013956:	2500      	movs	r5, #0
 8013958:	9b01      	ldr	r3, [sp, #4]
 801395a:	9802      	ldr	r0, [sp, #8]
 801395c:	3301      	adds	r3, #1
 801395e:	9903      	ldr	r1, [sp, #12]
 8013960:	9301      	str	r3, [sp, #4]
 8013962:	6802      	ldr	r2, [r0, #0]
 8013964:	c908      	ldmia	r1!, {r3}
 8013966:	b292      	uxth	r2, r2
 8013968:	1955      	adds	r5, r2, r5
 801396a:	b29a      	uxth	r2, r3
 801396c:	1aaa      	subs	r2, r5, r2
 801396e:	6805      	ldr	r5, [r0, #0]
 8013970:	0c1b      	lsrs	r3, r3, #16
 8013972:	0c2d      	lsrs	r5, r5, #16
 8013974:	1aeb      	subs	r3, r5, r3
 8013976:	1415      	asrs	r5, r2, #16
 8013978:	195b      	adds	r3, r3, r5
 801397a:	141d      	asrs	r5, r3, #16
 801397c:	b292      	uxth	r2, r2
 801397e:	041b      	lsls	r3, r3, #16
 8013980:	4313      	orrs	r3, r2
 8013982:	c008      	stmia	r0!, {r3}
 8013984:	9b04      	ldr	r3, [sp, #16]
 8013986:	428b      	cmp	r3, r1
 8013988:	d2eb      	bcs.n	8013962 <quorem+0xa8>
 801398a:	9a02      	ldr	r2, [sp, #8]
 801398c:	00a3      	lsls	r3, r4, #2
 801398e:	18d3      	adds	r3, r2, r3
 8013990:	681a      	ldr	r2, [r3, #0]
 8013992:	2a00      	cmp	r2, #0
 8013994:	d011      	beq.n	80139ba <quorem+0x100>
 8013996:	9e01      	ldr	r6, [sp, #4]
 8013998:	0030      	movs	r0, r6
 801399a:	b009      	add	sp, #36	; 0x24
 801399c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801399e:	682b      	ldr	r3, [r5, #0]
 80139a0:	2b00      	cmp	r3, #0
 80139a2:	d104      	bne.n	80139ae <quorem+0xf4>
 80139a4:	3c01      	subs	r4, #1
 80139a6:	9b02      	ldr	r3, [sp, #8]
 80139a8:	3d04      	subs	r5, #4
 80139aa:	42ab      	cmp	r3, r5
 80139ac:	d3f7      	bcc.n	801399e <quorem+0xe4>
 80139ae:	613c      	str	r4, [r7, #16]
 80139b0:	e7cb      	b.n	801394a <quorem+0x90>
 80139b2:	681a      	ldr	r2, [r3, #0]
 80139b4:	2a00      	cmp	r2, #0
 80139b6:	d104      	bne.n	80139c2 <quorem+0x108>
 80139b8:	3c01      	subs	r4, #1
 80139ba:	9a02      	ldr	r2, [sp, #8]
 80139bc:	3b04      	subs	r3, #4
 80139be:	429a      	cmp	r2, r3
 80139c0:	d3f7      	bcc.n	80139b2 <quorem+0xf8>
 80139c2:	613c      	str	r4, [r7, #16]
 80139c4:	e7e7      	b.n	8013996 <quorem+0xdc>
	...

080139c8 <_dtoa_r>:
 80139c8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80139ca:	0016      	movs	r6, r2
 80139cc:	001f      	movs	r7, r3
 80139ce:	6a44      	ldr	r4, [r0, #36]	; 0x24
 80139d0:	b09b      	sub	sp, #108	; 0x6c
 80139d2:	9002      	str	r0, [sp, #8]
 80139d4:	9d23      	ldr	r5, [sp, #140]	; 0x8c
 80139d6:	9606      	str	r6, [sp, #24]
 80139d8:	9707      	str	r7, [sp, #28]
 80139da:	2c00      	cmp	r4, #0
 80139dc:	d108      	bne.n	80139f0 <_dtoa_r+0x28>
 80139de:	2010      	movs	r0, #16
 80139e0:	f000 fdde 	bl	80145a0 <malloc>
 80139e4:	9b02      	ldr	r3, [sp, #8]
 80139e6:	6258      	str	r0, [r3, #36]	; 0x24
 80139e8:	6044      	str	r4, [r0, #4]
 80139ea:	6084      	str	r4, [r0, #8]
 80139ec:	6004      	str	r4, [r0, #0]
 80139ee:	60c4      	str	r4, [r0, #12]
 80139f0:	9b02      	ldr	r3, [sp, #8]
 80139f2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80139f4:	6819      	ldr	r1, [r3, #0]
 80139f6:	2900      	cmp	r1, #0
 80139f8:	d00b      	beq.n	8013a12 <_dtoa_r+0x4a>
 80139fa:	685a      	ldr	r2, [r3, #4]
 80139fc:	2301      	movs	r3, #1
 80139fe:	4093      	lsls	r3, r2
 8013a00:	604a      	str	r2, [r1, #4]
 8013a02:	608b      	str	r3, [r1, #8]
 8013a04:	9802      	ldr	r0, [sp, #8]
 8013a06:	f000 fe0d 	bl	8014624 <_Bfree>
 8013a0a:	2200      	movs	r2, #0
 8013a0c:	9b02      	ldr	r3, [sp, #8]
 8013a0e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8013a10:	601a      	str	r2, [r3, #0]
 8013a12:	2f00      	cmp	r7, #0
 8013a14:	da20      	bge.n	8013a58 <_dtoa_r+0x90>
 8013a16:	2301      	movs	r3, #1
 8013a18:	602b      	str	r3, [r5, #0]
 8013a1a:	007b      	lsls	r3, r7, #1
 8013a1c:	085b      	lsrs	r3, r3, #1
 8013a1e:	9307      	str	r3, [sp, #28]
 8013a20:	9c07      	ldr	r4, [sp, #28]
 8013a22:	4bb2      	ldr	r3, [pc, #712]	; (8013cec <_dtoa_r+0x324>)
 8013a24:	0022      	movs	r2, r4
 8013a26:	9317      	str	r3, [sp, #92]	; 0x5c
 8013a28:	401a      	ands	r2, r3
 8013a2a:	429a      	cmp	r2, r3
 8013a2c:	d117      	bne.n	8013a5e <_dtoa_r+0x96>
 8013a2e:	4bb0      	ldr	r3, [pc, #704]	; (8013cf0 <_dtoa_r+0x328>)
 8013a30:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8013a32:	6013      	str	r3, [r2, #0]
 8013a34:	9b06      	ldr	r3, [sp, #24]
 8013a36:	2b00      	cmp	r3, #0
 8013a38:	d103      	bne.n	8013a42 <_dtoa_r+0x7a>
 8013a3a:	0324      	lsls	r4, r4, #12
 8013a3c:	d101      	bne.n	8013a42 <_dtoa_r+0x7a>
 8013a3e:	f000 fd87 	bl	8014550 <_dtoa_r+0xb88>
 8013a42:	4bac      	ldr	r3, [pc, #688]	; (8013cf4 <_dtoa_r+0x32c>)
 8013a44:	9a24      	ldr	r2, [sp, #144]	; 0x90
 8013a46:	9308      	str	r3, [sp, #32]
 8013a48:	2a00      	cmp	r2, #0
 8013a4a:	d002      	beq.n	8013a52 <_dtoa_r+0x8a>
 8013a4c:	4baa      	ldr	r3, [pc, #680]	; (8013cf8 <_dtoa_r+0x330>)
 8013a4e:	9a24      	ldr	r2, [sp, #144]	; 0x90
 8013a50:	6013      	str	r3, [r2, #0]
 8013a52:	9808      	ldr	r0, [sp, #32]
 8013a54:	b01b      	add	sp, #108	; 0x6c
 8013a56:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8013a58:	2300      	movs	r3, #0
 8013a5a:	602b      	str	r3, [r5, #0]
 8013a5c:	e7e0      	b.n	8013a20 <_dtoa_r+0x58>
 8013a5e:	9e06      	ldr	r6, [sp, #24]
 8013a60:	9f07      	ldr	r7, [sp, #28]
 8013a62:	2200      	movs	r2, #0
 8013a64:	2300      	movs	r3, #0
 8013a66:	0030      	movs	r0, r6
 8013a68:	0039      	movs	r1, r7
 8013a6a:	f7ec fce5 	bl	8000438 <__aeabi_dcmpeq>
 8013a6e:	1e05      	subs	r5, r0, #0
 8013a70:	d00b      	beq.n	8013a8a <_dtoa_r+0xc2>
 8013a72:	2301      	movs	r3, #1
 8013a74:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8013a76:	6013      	str	r3, [r2, #0]
 8013a78:	4ba0      	ldr	r3, [pc, #640]	; (8013cfc <_dtoa_r+0x334>)
 8013a7a:	9a24      	ldr	r2, [sp, #144]	; 0x90
 8013a7c:	9308      	str	r3, [sp, #32]
 8013a7e:	2a00      	cmp	r2, #0
 8013a80:	d0e7      	beq.n	8013a52 <_dtoa_r+0x8a>
 8013a82:	4a9f      	ldr	r2, [pc, #636]	; (8013d00 <_dtoa_r+0x338>)
 8013a84:	9924      	ldr	r1, [sp, #144]	; 0x90
 8013a86:	600a      	str	r2, [r1, #0]
 8013a88:	e7e3      	b.n	8013a52 <_dtoa_r+0x8a>
 8013a8a:	ab18      	add	r3, sp, #96	; 0x60
 8013a8c:	9301      	str	r3, [sp, #4]
 8013a8e:	ab19      	add	r3, sp, #100	; 0x64
 8013a90:	9300      	str	r3, [sp, #0]
 8013a92:	0032      	movs	r2, r6
 8013a94:	003b      	movs	r3, r7
 8013a96:	9802      	ldr	r0, [sp, #8]
 8013a98:	f001 f81e 	bl	8014ad8 <__d2b>
 8013a9c:	0063      	lsls	r3, r4, #1
 8013a9e:	9003      	str	r0, [sp, #12]
 8013aa0:	0d5b      	lsrs	r3, r3, #21
 8013aa2:	d074      	beq.n	8013b8e <_dtoa_r+0x1c6>
 8013aa4:	033a      	lsls	r2, r7, #12
 8013aa6:	4c97      	ldr	r4, [pc, #604]	; (8013d04 <_dtoa_r+0x33c>)
 8013aa8:	0b12      	lsrs	r2, r2, #12
 8013aaa:	4314      	orrs	r4, r2
 8013aac:	0021      	movs	r1, r4
 8013aae:	4a96      	ldr	r2, [pc, #600]	; (8013d08 <_dtoa_r+0x340>)
 8013ab0:	0030      	movs	r0, r6
 8013ab2:	9516      	str	r5, [sp, #88]	; 0x58
 8013ab4:	189e      	adds	r6, r3, r2
 8013ab6:	2200      	movs	r2, #0
 8013ab8:	4b94      	ldr	r3, [pc, #592]	; (8013d0c <_dtoa_r+0x344>)
 8013aba:	f7ee fc81 	bl	80023c0 <__aeabi_dsub>
 8013abe:	4a94      	ldr	r2, [pc, #592]	; (8013d10 <_dtoa_r+0x348>)
 8013ac0:	4b94      	ldr	r3, [pc, #592]	; (8013d14 <_dtoa_r+0x34c>)
 8013ac2:	f7ee fa0b 	bl	8001edc <__aeabi_dmul>
 8013ac6:	4a94      	ldr	r2, [pc, #592]	; (8013d18 <_dtoa_r+0x350>)
 8013ac8:	4b94      	ldr	r3, [pc, #592]	; (8013d1c <_dtoa_r+0x354>)
 8013aca:	f7ed fae1 	bl	8001090 <__aeabi_dadd>
 8013ace:	0004      	movs	r4, r0
 8013ad0:	0030      	movs	r0, r6
 8013ad2:	000d      	movs	r5, r1
 8013ad4:	f7ef f80e 	bl	8002af4 <__aeabi_i2d>
 8013ad8:	4a91      	ldr	r2, [pc, #580]	; (8013d20 <_dtoa_r+0x358>)
 8013ada:	4b92      	ldr	r3, [pc, #584]	; (8013d24 <_dtoa_r+0x35c>)
 8013adc:	f7ee f9fe 	bl	8001edc <__aeabi_dmul>
 8013ae0:	0002      	movs	r2, r0
 8013ae2:	000b      	movs	r3, r1
 8013ae4:	0020      	movs	r0, r4
 8013ae6:	0029      	movs	r1, r5
 8013ae8:	f7ed fad2 	bl	8001090 <__aeabi_dadd>
 8013aec:	0004      	movs	r4, r0
 8013aee:	000d      	movs	r5, r1
 8013af0:	f7ee ffca 	bl	8002a88 <__aeabi_d2iz>
 8013af4:	2200      	movs	r2, #0
 8013af6:	0007      	movs	r7, r0
 8013af8:	2300      	movs	r3, #0
 8013afa:	0020      	movs	r0, r4
 8013afc:	0029      	movs	r1, r5
 8013afe:	f7ec fca1 	bl	8000444 <__aeabi_dcmplt>
 8013b02:	2800      	cmp	r0, #0
 8013b04:	d009      	beq.n	8013b1a <_dtoa_r+0x152>
 8013b06:	0038      	movs	r0, r7
 8013b08:	f7ee fff4 	bl	8002af4 <__aeabi_i2d>
 8013b0c:	002b      	movs	r3, r5
 8013b0e:	0022      	movs	r2, r4
 8013b10:	f7ec fc92 	bl	8000438 <__aeabi_dcmpeq>
 8013b14:	4243      	negs	r3, r0
 8013b16:	4158      	adcs	r0, r3
 8013b18:	1a3f      	subs	r7, r7, r0
 8013b1a:	2301      	movs	r3, #1
 8013b1c:	9314      	str	r3, [sp, #80]	; 0x50
 8013b1e:	2f16      	cmp	r7, #22
 8013b20:	d80d      	bhi.n	8013b3e <_dtoa_r+0x176>
 8013b22:	4981      	ldr	r1, [pc, #516]	; (8013d28 <_dtoa_r+0x360>)
 8013b24:	00fb      	lsls	r3, r7, #3
 8013b26:	18c9      	adds	r1, r1, r3
 8013b28:	6808      	ldr	r0, [r1, #0]
 8013b2a:	6849      	ldr	r1, [r1, #4]
 8013b2c:	9a06      	ldr	r2, [sp, #24]
 8013b2e:	9b07      	ldr	r3, [sp, #28]
 8013b30:	f7ec fc9c 	bl	800046c <__aeabi_dcmpgt>
 8013b34:	2800      	cmp	r0, #0
 8013b36:	d046      	beq.n	8013bc6 <_dtoa_r+0x1fe>
 8013b38:	2300      	movs	r3, #0
 8013b3a:	3f01      	subs	r7, #1
 8013b3c:	9314      	str	r3, [sp, #80]	; 0x50
 8013b3e:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8013b40:	1b9e      	subs	r6, r3, r6
 8013b42:	2300      	movs	r3, #0
 8013b44:	930a      	str	r3, [sp, #40]	; 0x28
 8013b46:	0033      	movs	r3, r6
 8013b48:	3b01      	subs	r3, #1
 8013b4a:	930b      	str	r3, [sp, #44]	; 0x2c
 8013b4c:	d504      	bpl.n	8013b58 <_dtoa_r+0x190>
 8013b4e:	2301      	movs	r3, #1
 8013b50:	1b9b      	subs	r3, r3, r6
 8013b52:	930a      	str	r3, [sp, #40]	; 0x28
 8013b54:	2300      	movs	r3, #0
 8013b56:	930b      	str	r3, [sp, #44]	; 0x2c
 8013b58:	2f00      	cmp	r7, #0
 8013b5a:	db36      	blt.n	8013bca <_dtoa_r+0x202>
 8013b5c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8013b5e:	9711      	str	r7, [sp, #68]	; 0x44
 8013b60:	19db      	adds	r3, r3, r7
 8013b62:	930b      	str	r3, [sp, #44]	; 0x2c
 8013b64:	2300      	movs	r3, #0
 8013b66:	9304      	str	r3, [sp, #16]
 8013b68:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8013b6a:	2401      	movs	r4, #1
 8013b6c:	2b09      	cmp	r3, #9
 8013b6e:	d900      	bls.n	8013b72 <_dtoa_r+0x1aa>
 8013b70:	e084      	b.n	8013c7c <_dtoa_r+0x2b4>
 8013b72:	2b05      	cmp	r3, #5
 8013b74:	dd02      	ble.n	8013b7c <_dtoa_r+0x1b4>
 8013b76:	2400      	movs	r4, #0
 8013b78:	3b04      	subs	r3, #4
 8013b7a:	9320      	str	r3, [sp, #128]	; 0x80
 8013b7c:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8013b7e:	1e98      	subs	r0, r3, #2
 8013b80:	2803      	cmp	r0, #3
 8013b82:	d900      	bls.n	8013b86 <_dtoa_r+0x1be>
 8013b84:	e084      	b.n	8013c90 <_dtoa_r+0x2c8>
 8013b86:	f7ec fac7 	bl	8000118 <__gnu_thumb1_case_uqi>
 8013b8a:	7775      	.short	0x7775
 8013b8c:	6a28      	.short	0x6a28
 8013b8e:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8013b90:	9a19      	ldr	r2, [sp, #100]	; 0x64
 8013b92:	189e      	adds	r6, r3, r2
 8013b94:	4b65      	ldr	r3, [pc, #404]	; (8013d2c <_dtoa_r+0x364>)
 8013b96:	18f2      	adds	r2, r6, r3
 8013b98:	2a20      	cmp	r2, #32
 8013b9a:	dd0f      	ble.n	8013bbc <_dtoa_r+0x1f4>
 8013b9c:	2340      	movs	r3, #64	; 0x40
 8013b9e:	1a9b      	subs	r3, r3, r2
 8013ba0:	409c      	lsls	r4, r3
 8013ba2:	4b63      	ldr	r3, [pc, #396]	; (8013d30 <_dtoa_r+0x368>)
 8013ba4:	9806      	ldr	r0, [sp, #24]
 8013ba6:	18f3      	adds	r3, r6, r3
 8013ba8:	40d8      	lsrs	r0, r3
 8013baa:	4320      	orrs	r0, r4
 8013bac:	f7ee ffdc 	bl	8002b68 <__aeabi_ui2d>
 8013bb0:	2301      	movs	r3, #1
 8013bb2:	4c60      	ldr	r4, [pc, #384]	; (8013d34 <_dtoa_r+0x36c>)
 8013bb4:	3e01      	subs	r6, #1
 8013bb6:	1909      	adds	r1, r1, r4
 8013bb8:	9316      	str	r3, [sp, #88]	; 0x58
 8013bba:	e77c      	b.n	8013ab6 <_dtoa_r+0xee>
 8013bbc:	2320      	movs	r3, #32
 8013bbe:	9806      	ldr	r0, [sp, #24]
 8013bc0:	1a9b      	subs	r3, r3, r2
 8013bc2:	4098      	lsls	r0, r3
 8013bc4:	e7f2      	b.n	8013bac <_dtoa_r+0x1e4>
 8013bc6:	9014      	str	r0, [sp, #80]	; 0x50
 8013bc8:	e7b9      	b.n	8013b3e <_dtoa_r+0x176>
 8013bca:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8013bcc:	1bdb      	subs	r3, r3, r7
 8013bce:	930a      	str	r3, [sp, #40]	; 0x28
 8013bd0:	427b      	negs	r3, r7
 8013bd2:	9304      	str	r3, [sp, #16]
 8013bd4:	2300      	movs	r3, #0
 8013bd6:	9311      	str	r3, [sp, #68]	; 0x44
 8013bd8:	e7c6      	b.n	8013b68 <_dtoa_r+0x1a0>
 8013bda:	2301      	movs	r3, #1
 8013bdc:	930d      	str	r3, [sp, #52]	; 0x34
 8013bde:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8013be0:	2b00      	cmp	r3, #0
 8013be2:	dd59      	ble.n	8013c98 <_dtoa_r+0x2d0>
 8013be4:	930c      	str	r3, [sp, #48]	; 0x30
 8013be6:	9309      	str	r3, [sp, #36]	; 0x24
 8013be8:	9a02      	ldr	r2, [sp, #8]
 8013bea:	6a55      	ldr	r5, [r2, #36]	; 0x24
 8013bec:	2200      	movs	r2, #0
 8013bee:	606a      	str	r2, [r5, #4]
 8013bf0:	3204      	adds	r2, #4
 8013bf2:	0010      	movs	r0, r2
 8013bf4:	3014      	adds	r0, #20
 8013bf6:	6869      	ldr	r1, [r5, #4]
 8013bf8:	4298      	cmp	r0, r3
 8013bfa:	d952      	bls.n	8013ca2 <_dtoa_r+0x2da>
 8013bfc:	9802      	ldr	r0, [sp, #8]
 8013bfe:	f000 fcd9 	bl	80145b4 <_Balloc>
 8013c02:	9b02      	ldr	r3, [sp, #8]
 8013c04:	6028      	str	r0, [r5, #0]
 8013c06:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8013c08:	681b      	ldr	r3, [r3, #0]
 8013c0a:	9308      	str	r3, [sp, #32]
 8013c0c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8013c0e:	2b0e      	cmp	r3, #14
 8013c10:	d900      	bls.n	8013c14 <_dtoa_r+0x24c>
 8013c12:	e10a      	b.n	8013e2a <_dtoa_r+0x462>
 8013c14:	2c00      	cmp	r4, #0
 8013c16:	d100      	bne.n	8013c1a <_dtoa_r+0x252>
 8013c18:	e107      	b.n	8013e2a <_dtoa_r+0x462>
 8013c1a:	9b06      	ldr	r3, [sp, #24]
 8013c1c:	9c07      	ldr	r4, [sp, #28]
 8013c1e:	9312      	str	r3, [sp, #72]	; 0x48
 8013c20:	9413      	str	r4, [sp, #76]	; 0x4c
 8013c22:	2f00      	cmp	r7, #0
 8013c24:	dc00      	bgt.n	8013c28 <_dtoa_r+0x260>
 8013c26:	e089      	b.n	8013d3c <_dtoa_r+0x374>
 8013c28:	210f      	movs	r1, #15
 8013c2a:	003a      	movs	r2, r7
 8013c2c:	4b3e      	ldr	r3, [pc, #248]	; (8013d28 <_dtoa_r+0x360>)
 8013c2e:	400a      	ands	r2, r1
 8013c30:	00d2      	lsls	r2, r2, #3
 8013c32:	189b      	adds	r3, r3, r2
 8013c34:	681d      	ldr	r5, [r3, #0]
 8013c36:	685e      	ldr	r6, [r3, #4]
 8013c38:	2302      	movs	r3, #2
 8013c3a:	113c      	asrs	r4, r7, #4
 8013c3c:	930e      	str	r3, [sp, #56]	; 0x38
 8013c3e:	06e3      	lsls	r3, r4, #27
 8013c40:	d50b      	bpl.n	8013c5a <_dtoa_r+0x292>
 8013c42:	4b3d      	ldr	r3, [pc, #244]	; (8013d38 <_dtoa_r+0x370>)
 8013c44:	400c      	ands	r4, r1
 8013c46:	6a1a      	ldr	r2, [r3, #32]
 8013c48:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8013c4a:	9812      	ldr	r0, [sp, #72]	; 0x48
 8013c4c:	9913      	ldr	r1, [sp, #76]	; 0x4c
 8013c4e:	f7ed fd3b 	bl	80016c8 <__aeabi_ddiv>
 8013c52:	2303      	movs	r3, #3
 8013c54:	9006      	str	r0, [sp, #24]
 8013c56:	9107      	str	r1, [sp, #28]
 8013c58:	930e      	str	r3, [sp, #56]	; 0x38
 8013c5a:	2300      	movs	r3, #0
 8013c5c:	e03a      	b.n	8013cd4 <_dtoa_r+0x30c>
 8013c5e:	2301      	movs	r3, #1
 8013c60:	930d      	str	r3, [sp, #52]	; 0x34
 8013c62:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8013c64:	18fb      	adds	r3, r7, r3
 8013c66:	930c      	str	r3, [sp, #48]	; 0x30
 8013c68:	3301      	adds	r3, #1
 8013c6a:	9309      	str	r3, [sp, #36]	; 0x24
 8013c6c:	2b00      	cmp	r3, #0
 8013c6e:	dcbb      	bgt.n	8013be8 <_dtoa_r+0x220>
 8013c70:	2301      	movs	r3, #1
 8013c72:	e7b9      	b.n	8013be8 <_dtoa_r+0x220>
 8013c74:	2300      	movs	r3, #0
 8013c76:	e7b1      	b.n	8013bdc <_dtoa_r+0x214>
 8013c78:	2300      	movs	r3, #0
 8013c7a:	e7f1      	b.n	8013c60 <_dtoa_r+0x298>
 8013c7c:	2300      	movs	r3, #0
 8013c7e:	940d      	str	r4, [sp, #52]	; 0x34
 8013c80:	9320      	str	r3, [sp, #128]	; 0x80
 8013c82:	3b01      	subs	r3, #1
 8013c84:	2200      	movs	r2, #0
 8013c86:	930c      	str	r3, [sp, #48]	; 0x30
 8013c88:	9309      	str	r3, [sp, #36]	; 0x24
 8013c8a:	3313      	adds	r3, #19
 8013c8c:	9221      	str	r2, [sp, #132]	; 0x84
 8013c8e:	e7ab      	b.n	8013be8 <_dtoa_r+0x220>
 8013c90:	2301      	movs	r3, #1
 8013c92:	930d      	str	r3, [sp, #52]	; 0x34
 8013c94:	3b02      	subs	r3, #2
 8013c96:	e7f5      	b.n	8013c84 <_dtoa_r+0x2bc>
 8013c98:	2301      	movs	r3, #1
 8013c9a:	930c      	str	r3, [sp, #48]	; 0x30
 8013c9c:	9309      	str	r3, [sp, #36]	; 0x24
 8013c9e:	001a      	movs	r2, r3
 8013ca0:	e7f4      	b.n	8013c8c <_dtoa_r+0x2c4>
 8013ca2:	3101      	adds	r1, #1
 8013ca4:	6069      	str	r1, [r5, #4]
 8013ca6:	0052      	lsls	r2, r2, #1
 8013ca8:	e7a3      	b.n	8013bf2 <_dtoa_r+0x22a>
 8013caa:	2301      	movs	r3, #1
 8013cac:	421c      	tst	r4, r3
 8013cae:	d00e      	beq.n	8013cce <_dtoa_r+0x306>
 8013cb0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8013cb2:	4a21      	ldr	r2, [pc, #132]	; (8013d38 <_dtoa_r+0x370>)
 8013cb4:	3301      	adds	r3, #1
 8013cb6:	930e      	str	r3, [sp, #56]	; 0x38
 8013cb8:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8013cba:	0028      	movs	r0, r5
 8013cbc:	00db      	lsls	r3, r3, #3
 8013cbe:	189b      	adds	r3, r3, r2
 8013cc0:	0031      	movs	r1, r6
 8013cc2:	681a      	ldr	r2, [r3, #0]
 8013cc4:	685b      	ldr	r3, [r3, #4]
 8013cc6:	f7ee f909 	bl	8001edc <__aeabi_dmul>
 8013cca:	0005      	movs	r5, r0
 8013ccc:	000e      	movs	r6, r1
 8013cce:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8013cd0:	1064      	asrs	r4, r4, #1
 8013cd2:	3301      	adds	r3, #1
 8013cd4:	9310      	str	r3, [sp, #64]	; 0x40
 8013cd6:	2c00      	cmp	r4, #0
 8013cd8:	d1e7      	bne.n	8013caa <_dtoa_r+0x2e2>
 8013cda:	9806      	ldr	r0, [sp, #24]
 8013cdc:	9907      	ldr	r1, [sp, #28]
 8013cde:	002a      	movs	r2, r5
 8013ce0:	0033      	movs	r3, r6
 8013ce2:	f7ed fcf1 	bl	80016c8 <__aeabi_ddiv>
 8013ce6:	9006      	str	r0, [sp, #24]
 8013ce8:	9107      	str	r1, [sp, #28]
 8013cea:	e042      	b.n	8013d72 <_dtoa_r+0x3aa>
 8013cec:	7ff00000 	.word	0x7ff00000
 8013cf0:	0000270f 	.word	0x0000270f
 8013cf4:	08015217 	.word	0x08015217
 8013cf8:	0801521a 	.word	0x0801521a
 8013cfc:	0801520c 	.word	0x0801520c
 8013d00:	0801520d 	.word	0x0801520d
 8013d04:	3ff00000 	.word	0x3ff00000
 8013d08:	fffffc01 	.word	0xfffffc01
 8013d0c:	3ff80000 	.word	0x3ff80000
 8013d10:	636f4361 	.word	0x636f4361
 8013d14:	3fd287a7 	.word	0x3fd287a7
 8013d18:	8b60c8b3 	.word	0x8b60c8b3
 8013d1c:	3fc68a28 	.word	0x3fc68a28
 8013d20:	509f79fb 	.word	0x509f79fb
 8013d24:	3fd34413 	.word	0x3fd34413
 8013d28:	08015248 	.word	0x08015248
 8013d2c:	00000432 	.word	0x00000432
 8013d30:	00000412 	.word	0x00000412
 8013d34:	fe100000 	.word	0xfe100000
 8013d38:	08015220 	.word	0x08015220
 8013d3c:	2302      	movs	r3, #2
 8013d3e:	930e      	str	r3, [sp, #56]	; 0x38
 8013d40:	2f00      	cmp	r7, #0
 8013d42:	d016      	beq.n	8013d72 <_dtoa_r+0x3aa>
 8013d44:	9812      	ldr	r0, [sp, #72]	; 0x48
 8013d46:	9913      	ldr	r1, [sp, #76]	; 0x4c
 8013d48:	427c      	negs	r4, r7
 8013d4a:	330d      	adds	r3, #13
 8013d4c:	4023      	ands	r3, r4
 8013d4e:	4ace      	ldr	r2, [pc, #824]	; (8014088 <_dtoa_r+0x6c0>)
 8013d50:	00db      	lsls	r3, r3, #3
 8013d52:	18d3      	adds	r3, r2, r3
 8013d54:	681a      	ldr	r2, [r3, #0]
 8013d56:	685b      	ldr	r3, [r3, #4]
 8013d58:	f7ee f8c0 	bl	8001edc <__aeabi_dmul>
 8013d5c:	2300      	movs	r3, #0
 8013d5e:	2601      	movs	r6, #1
 8013d60:	001d      	movs	r5, r3
 8013d62:	9006      	str	r0, [sp, #24]
 8013d64:	9107      	str	r1, [sp, #28]
 8013d66:	1124      	asrs	r4, r4, #4
 8013d68:	2c00      	cmp	r4, #0
 8013d6a:	d000      	beq.n	8013d6e <_dtoa_r+0x3a6>
 8013d6c:	e08c      	b.n	8013e88 <_dtoa_r+0x4c0>
 8013d6e:	2b00      	cmp	r3, #0
 8013d70:	d1b9      	bne.n	8013ce6 <_dtoa_r+0x31e>
 8013d72:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8013d74:	2b00      	cmp	r3, #0
 8013d76:	d100      	bne.n	8013d7a <_dtoa_r+0x3b2>
 8013d78:	e096      	b.n	8013ea8 <_dtoa_r+0x4e0>
 8013d7a:	9c06      	ldr	r4, [sp, #24]
 8013d7c:	9d07      	ldr	r5, [sp, #28]
 8013d7e:	2200      	movs	r2, #0
 8013d80:	4bc2      	ldr	r3, [pc, #776]	; (801408c <_dtoa_r+0x6c4>)
 8013d82:	0020      	movs	r0, r4
 8013d84:	0029      	movs	r1, r5
 8013d86:	f7ec fb5d 	bl	8000444 <__aeabi_dcmplt>
 8013d8a:	2800      	cmp	r0, #0
 8013d8c:	d100      	bne.n	8013d90 <_dtoa_r+0x3c8>
 8013d8e:	e08b      	b.n	8013ea8 <_dtoa_r+0x4e0>
 8013d90:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8013d92:	2b00      	cmp	r3, #0
 8013d94:	d100      	bne.n	8013d98 <_dtoa_r+0x3d0>
 8013d96:	e087      	b.n	8013ea8 <_dtoa_r+0x4e0>
 8013d98:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8013d9a:	2b00      	cmp	r3, #0
 8013d9c:	dd41      	ble.n	8013e22 <_dtoa_r+0x45a>
 8013d9e:	4bbc      	ldr	r3, [pc, #752]	; (8014090 <_dtoa_r+0x6c8>)
 8013da0:	2200      	movs	r2, #0
 8013da2:	0020      	movs	r0, r4
 8013da4:	0029      	movs	r1, r5
 8013da6:	f7ee f899 	bl	8001edc <__aeabi_dmul>
 8013daa:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8013dac:	9006      	str	r0, [sp, #24]
 8013dae:	9107      	str	r1, [sp, #28]
 8013db0:	3301      	adds	r3, #1
 8013db2:	930e      	str	r3, [sp, #56]	; 0x38
 8013db4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8013db6:	1e7e      	subs	r6, r7, #1
 8013db8:	980e      	ldr	r0, [sp, #56]	; 0x38
 8013dba:	9310      	str	r3, [sp, #64]	; 0x40
 8013dbc:	f7ee fe9a 	bl	8002af4 <__aeabi_i2d>
 8013dc0:	9a06      	ldr	r2, [sp, #24]
 8013dc2:	9b07      	ldr	r3, [sp, #28]
 8013dc4:	f7ee f88a 	bl	8001edc <__aeabi_dmul>
 8013dc8:	2200      	movs	r2, #0
 8013dca:	4bb2      	ldr	r3, [pc, #712]	; (8014094 <_dtoa_r+0x6cc>)
 8013dcc:	f7ed f960 	bl	8001090 <__aeabi_dadd>
 8013dd0:	4ab1      	ldr	r2, [pc, #708]	; (8014098 <_dtoa_r+0x6d0>)
 8013dd2:	900e      	str	r0, [sp, #56]	; 0x38
 8013dd4:	910f      	str	r1, [sp, #60]	; 0x3c
 8013dd6:	9c0e      	ldr	r4, [sp, #56]	; 0x38
 8013dd8:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
 8013dda:	4694      	mov	ip, r2
 8013ddc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8013dde:	4463      	add	r3, ip
 8013de0:	9315      	str	r3, [sp, #84]	; 0x54
 8013de2:	001d      	movs	r5, r3
 8013de4:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8013de6:	2b00      	cmp	r3, #0
 8013de8:	d161      	bne.n	8013eae <_dtoa_r+0x4e6>
 8013dea:	9806      	ldr	r0, [sp, #24]
 8013dec:	9907      	ldr	r1, [sp, #28]
 8013dee:	2200      	movs	r2, #0
 8013df0:	4baa      	ldr	r3, [pc, #680]	; (801409c <_dtoa_r+0x6d4>)
 8013df2:	f7ee fae5 	bl	80023c0 <__aeabi_dsub>
 8013df6:	0022      	movs	r2, r4
 8013df8:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8013dfa:	9006      	str	r0, [sp, #24]
 8013dfc:	9107      	str	r1, [sp, #28]
 8013dfe:	f7ec fb35 	bl	800046c <__aeabi_dcmpgt>
 8013e02:	2800      	cmp	r0, #0
 8013e04:	d000      	beq.n	8013e08 <_dtoa_r+0x440>
 8013e06:	e2a8      	b.n	801435a <_dtoa_r+0x992>
 8013e08:	48a5      	ldr	r0, [pc, #660]	; (80140a0 <_dtoa_r+0x6d8>)
 8013e0a:	990f      	ldr	r1, [sp, #60]	; 0x3c
 8013e0c:	4684      	mov	ip, r0
 8013e0e:	4461      	add	r1, ip
 8013e10:	000b      	movs	r3, r1
 8013e12:	9806      	ldr	r0, [sp, #24]
 8013e14:	9907      	ldr	r1, [sp, #28]
 8013e16:	0022      	movs	r2, r4
 8013e18:	f7ec fb14 	bl	8000444 <__aeabi_dcmplt>
 8013e1c:	2800      	cmp	r0, #0
 8013e1e:	d000      	beq.n	8013e22 <_dtoa_r+0x45a>
 8013e20:	e295      	b.n	801434e <_dtoa_r+0x986>
 8013e22:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8013e24:	9c13      	ldr	r4, [sp, #76]	; 0x4c
 8013e26:	9306      	str	r3, [sp, #24]
 8013e28:	9407      	str	r4, [sp, #28]
 8013e2a:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8013e2c:	2b00      	cmp	r3, #0
 8013e2e:	da00      	bge.n	8013e32 <_dtoa_r+0x46a>
 8013e30:	e15c      	b.n	80140ec <_dtoa_r+0x724>
 8013e32:	2f0e      	cmp	r7, #14
 8013e34:	dd00      	ble.n	8013e38 <_dtoa_r+0x470>
 8013e36:	e159      	b.n	80140ec <_dtoa_r+0x724>
 8013e38:	4b93      	ldr	r3, [pc, #588]	; (8014088 <_dtoa_r+0x6c0>)
 8013e3a:	00fa      	lsls	r2, r7, #3
 8013e3c:	189b      	adds	r3, r3, r2
 8013e3e:	685c      	ldr	r4, [r3, #4]
 8013e40:	681b      	ldr	r3, [r3, #0]
 8013e42:	9304      	str	r3, [sp, #16]
 8013e44:	9405      	str	r4, [sp, #20]
 8013e46:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8013e48:	2b00      	cmp	r3, #0
 8013e4a:	db00      	blt.n	8013e4e <_dtoa_r+0x486>
 8013e4c:	e0d8      	b.n	8014000 <_dtoa_r+0x638>
 8013e4e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8013e50:	2b00      	cmp	r3, #0
 8013e52:	dd00      	ble.n	8013e56 <_dtoa_r+0x48e>
 8013e54:	e0d4      	b.n	8014000 <_dtoa_r+0x638>
 8013e56:	d000      	beq.n	8013e5a <_dtoa_r+0x492>
 8013e58:	e27d      	b.n	8014356 <_dtoa_r+0x98e>
 8013e5a:	9804      	ldr	r0, [sp, #16]
 8013e5c:	9905      	ldr	r1, [sp, #20]
 8013e5e:	2200      	movs	r2, #0
 8013e60:	4b8e      	ldr	r3, [pc, #568]	; (801409c <_dtoa_r+0x6d4>)
 8013e62:	f7ee f83b 	bl	8001edc <__aeabi_dmul>
 8013e66:	9a06      	ldr	r2, [sp, #24]
 8013e68:	9b07      	ldr	r3, [sp, #28]
 8013e6a:	f7ec fb09 	bl	8000480 <__aeabi_dcmpge>
 8013e6e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8013e70:	9304      	str	r3, [sp, #16]
 8013e72:	001e      	movs	r6, r3
 8013e74:	2800      	cmp	r0, #0
 8013e76:	d000      	beq.n	8013e7a <_dtoa_r+0x4b2>
 8013e78:	e24f      	b.n	801431a <_dtoa_r+0x952>
 8013e7a:	9b08      	ldr	r3, [sp, #32]
 8013e7c:	9a08      	ldr	r2, [sp, #32]
 8013e7e:	1c5d      	adds	r5, r3, #1
 8013e80:	2331      	movs	r3, #49	; 0x31
 8013e82:	3701      	adds	r7, #1
 8013e84:	7013      	strb	r3, [r2, #0]
 8013e86:	e24b      	b.n	8014320 <_dtoa_r+0x958>
 8013e88:	4234      	tst	r4, r6
 8013e8a:	d00a      	beq.n	8013ea2 <_dtoa_r+0x4da>
 8013e8c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8013e8e:	4a85      	ldr	r2, [pc, #532]	; (80140a4 <_dtoa_r+0x6dc>)
 8013e90:	3301      	adds	r3, #1
 8013e92:	930e      	str	r3, [sp, #56]	; 0x38
 8013e94:	00eb      	lsls	r3, r5, #3
 8013e96:	189b      	adds	r3, r3, r2
 8013e98:	681a      	ldr	r2, [r3, #0]
 8013e9a:	685b      	ldr	r3, [r3, #4]
 8013e9c:	f7ee f81e 	bl	8001edc <__aeabi_dmul>
 8013ea0:	0033      	movs	r3, r6
 8013ea2:	1064      	asrs	r4, r4, #1
 8013ea4:	3501      	adds	r5, #1
 8013ea6:	e75f      	b.n	8013d68 <_dtoa_r+0x3a0>
 8013ea8:	003e      	movs	r6, r7
 8013eaa:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8013eac:	e784      	b.n	8013db8 <_dtoa_r+0x3f0>
 8013eae:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8013eb0:	990d      	ldr	r1, [sp, #52]	; 0x34
 8013eb2:	1e5a      	subs	r2, r3, #1
 8013eb4:	4b74      	ldr	r3, [pc, #464]	; (8014088 <_dtoa_r+0x6c0>)
 8013eb6:	00d2      	lsls	r2, r2, #3
 8013eb8:	189b      	adds	r3, r3, r2
 8013eba:	681a      	ldr	r2, [r3, #0]
 8013ebc:	685b      	ldr	r3, [r3, #4]
 8013ebe:	2900      	cmp	r1, #0
 8013ec0:	d049      	beq.n	8013f56 <_dtoa_r+0x58e>
 8013ec2:	2000      	movs	r0, #0
 8013ec4:	4978      	ldr	r1, [pc, #480]	; (80140a8 <_dtoa_r+0x6e0>)
 8013ec6:	f7ed fbff 	bl	80016c8 <__aeabi_ddiv>
 8013eca:	002b      	movs	r3, r5
 8013ecc:	0022      	movs	r2, r4
 8013ece:	f7ee fa77 	bl	80023c0 <__aeabi_dsub>
 8013ed2:	9b08      	ldr	r3, [sp, #32]
 8013ed4:	900e      	str	r0, [sp, #56]	; 0x38
 8013ed6:	910f      	str	r1, [sp, #60]	; 0x3c
 8013ed8:	9315      	str	r3, [sp, #84]	; 0x54
 8013eda:	9806      	ldr	r0, [sp, #24]
 8013edc:	9907      	ldr	r1, [sp, #28]
 8013ede:	f7ee fdd3 	bl	8002a88 <__aeabi_d2iz>
 8013ee2:	0004      	movs	r4, r0
 8013ee4:	f7ee fe06 	bl	8002af4 <__aeabi_i2d>
 8013ee8:	0002      	movs	r2, r0
 8013eea:	000b      	movs	r3, r1
 8013eec:	9806      	ldr	r0, [sp, #24]
 8013eee:	9907      	ldr	r1, [sp, #28]
 8013ef0:	f7ee fa66 	bl	80023c0 <__aeabi_dsub>
 8013ef4:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8013ef6:	3430      	adds	r4, #48	; 0x30
 8013ef8:	1c5d      	adds	r5, r3, #1
 8013efa:	701c      	strb	r4, [r3, #0]
 8013efc:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8013efe:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8013f00:	9006      	str	r0, [sp, #24]
 8013f02:	9107      	str	r1, [sp, #28]
 8013f04:	f7ec fa9e 	bl	8000444 <__aeabi_dcmplt>
 8013f08:	2800      	cmp	r0, #0
 8013f0a:	d16c      	bne.n	8013fe6 <_dtoa_r+0x61e>
 8013f0c:	9a06      	ldr	r2, [sp, #24]
 8013f0e:	9b07      	ldr	r3, [sp, #28]
 8013f10:	2000      	movs	r0, #0
 8013f12:	495e      	ldr	r1, [pc, #376]	; (801408c <_dtoa_r+0x6c4>)
 8013f14:	f7ee fa54 	bl	80023c0 <__aeabi_dsub>
 8013f18:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8013f1a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8013f1c:	f7ec fa92 	bl	8000444 <__aeabi_dcmplt>
 8013f20:	2800      	cmp	r0, #0
 8013f22:	d000      	beq.n	8013f26 <_dtoa_r+0x55e>
 8013f24:	e0c3      	b.n	80140ae <_dtoa_r+0x6e6>
 8013f26:	9b08      	ldr	r3, [sp, #32]
 8013f28:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8013f2a:	1aeb      	subs	r3, r5, r3
 8013f2c:	429a      	cmp	r2, r3
 8013f2e:	dc00      	bgt.n	8013f32 <_dtoa_r+0x56a>
 8013f30:	e777      	b.n	8013e22 <_dtoa_r+0x45a>
 8013f32:	980e      	ldr	r0, [sp, #56]	; 0x38
 8013f34:	990f      	ldr	r1, [sp, #60]	; 0x3c
 8013f36:	2200      	movs	r2, #0
 8013f38:	4b55      	ldr	r3, [pc, #340]	; (8014090 <_dtoa_r+0x6c8>)
 8013f3a:	f7ed ffcf 	bl	8001edc <__aeabi_dmul>
 8013f3e:	2200      	movs	r2, #0
 8013f40:	900e      	str	r0, [sp, #56]	; 0x38
 8013f42:	910f      	str	r1, [sp, #60]	; 0x3c
 8013f44:	9806      	ldr	r0, [sp, #24]
 8013f46:	9907      	ldr	r1, [sp, #28]
 8013f48:	4b51      	ldr	r3, [pc, #324]	; (8014090 <_dtoa_r+0x6c8>)
 8013f4a:	f7ed ffc7 	bl	8001edc <__aeabi_dmul>
 8013f4e:	9515      	str	r5, [sp, #84]	; 0x54
 8013f50:	9006      	str	r0, [sp, #24]
 8013f52:	9107      	str	r1, [sp, #28]
 8013f54:	e7c1      	b.n	8013eda <_dtoa_r+0x512>
 8013f56:	0020      	movs	r0, r4
 8013f58:	0029      	movs	r1, r5
 8013f5a:	f7ed ffbf 	bl	8001edc <__aeabi_dmul>
 8013f5e:	9c08      	ldr	r4, [sp, #32]
 8013f60:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8013f62:	0023      	movs	r3, r4
 8013f64:	4694      	mov	ip, r2
 8013f66:	900e      	str	r0, [sp, #56]	; 0x38
 8013f68:	910f      	str	r1, [sp, #60]	; 0x3c
 8013f6a:	4463      	add	r3, ip
 8013f6c:	9315      	str	r3, [sp, #84]	; 0x54
 8013f6e:	9806      	ldr	r0, [sp, #24]
 8013f70:	9907      	ldr	r1, [sp, #28]
 8013f72:	f7ee fd89 	bl	8002a88 <__aeabi_d2iz>
 8013f76:	0005      	movs	r5, r0
 8013f78:	f7ee fdbc 	bl	8002af4 <__aeabi_i2d>
 8013f7c:	000b      	movs	r3, r1
 8013f7e:	0002      	movs	r2, r0
 8013f80:	9806      	ldr	r0, [sp, #24]
 8013f82:	9907      	ldr	r1, [sp, #28]
 8013f84:	f7ee fa1c 	bl	80023c0 <__aeabi_dsub>
 8013f88:	3530      	adds	r5, #48	; 0x30
 8013f8a:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8013f8c:	7025      	strb	r5, [r4, #0]
 8013f8e:	3401      	adds	r4, #1
 8013f90:	9006      	str	r0, [sp, #24]
 8013f92:	9107      	str	r1, [sp, #28]
 8013f94:	42a3      	cmp	r3, r4
 8013f96:	d12a      	bne.n	8013fee <_dtoa_r+0x626>
 8013f98:	980e      	ldr	r0, [sp, #56]	; 0x38
 8013f9a:	990f      	ldr	r1, [sp, #60]	; 0x3c
 8013f9c:	9a08      	ldr	r2, [sp, #32]
 8013f9e:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8013fa0:	4694      	mov	ip, r2
 8013fa2:	4463      	add	r3, ip
 8013fa4:	2200      	movs	r2, #0
 8013fa6:	001d      	movs	r5, r3
 8013fa8:	4b3f      	ldr	r3, [pc, #252]	; (80140a8 <_dtoa_r+0x6e0>)
 8013faa:	f7ed f871 	bl	8001090 <__aeabi_dadd>
 8013fae:	0002      	movs	r2, r0
 8013fb0:	000b      	movs	r3, r1
 8013fb2:	9806      	ldr	r0, [sp, #24]
 8013fb4:	9907      	ldr	r1, [sp, #28]
 8013fb6:	f7ec fa59 	bl	800046c <__aeabi_dcmpgt>
 8013fba:	2800      	cmp	r0, #0
 8013fbc:	d000      	beq.n	8013fc0 <_dtoa_r+0x5f8>
 8013fbe:	e076      	b.n	80140ae <_dtoa_r+0x6e6>
 8013fc0:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8013fc2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8013fc4:	2000      	movs	r0, #0
 8013fc6:	4938      	ldr	r1, [pc, #224]	; (80140a8 <_dtoa_r+0x6e0>)
 8013fc8:	f7ee f9fa 	bl	80023c0 <__aeabi_dsub>
 8013fcc:	0002      	movs	r2, r0
 8013fce:	000b      	movs	r3, r1
 8013fd0:	9806      	ldr	r0, [sp, #24]
 8013fd2:	9907      	ldr	r1, [sp, #28]
 8013fd4:	f7ec fa36 	bl	8000444 <__aeabi_dcmplt>
 8013fd8:	2800      	cmp	r0, #0
 8013fda:	d100      	bne.n	8013fde <_dtoa_r+0x616>
 8013fdc:	e721      	b.n	8013e22 <_dtoa_r+0x45a>
 8013fde:	1e6b      	subs	r3, r5, #1
 8013fe0:	781a      	ldrb	r2, [r3, #0]
 8013fe2:	2a30      	cmp	r2, #48	; 0x30
 8013fe4:	d001      	beq.n	8013fea <_dtoa_r+0x622>
 8013fe6:	0037      	movs	r7, r6
 8013fe8:	e03f      	b.n	801406a <_dtoa_r+0x6a2>
 8013fea:	001d      	movs	r5, r3
 8013fec:	e7f7      	b.n	8013fde <_dtoa_r+0x616>
 8013fee:	9806      	ldr	r0, [sp, #24]
 8013ff0:	9907      	ldr	r1, [sp, #28]
 8013ff2:	2200      	movs	r2, #0
 8013ff4:	4b26      	ldr	r3, [pc, #152]	; (8014090 <_dtoa_r+0x6c8>)
 8013ff6:	f7ed ff71 	bl	8001edc <__aeabi_dmul>
 8013ffa:	9006      	str	r0, [sp, #24]
 8013ffc:	9107      	str	r1, [sp, #28]
 8013ffe:	e7b6      	b.n	8013f6e <_dtoa_r+0x5a6>
 8014000:	9e08      	ldr	r6, [sp, #32]
 8014002:	9a04      	ldr	r2, [sp, #16]
 8014004:	9b05      	ldr	r3, [sp, #20]
 8014006:	9806      	ldr	r0, [sp, #24]
 8014008:	9907      	ldr	r1, [sp, #28]
 801400a:	f7ed fb5d 	bl	80016c8 <__aeabi_ddiv>
 801400e:	f7ee fd3b 	bl	8002a88 <__aeabi_d2iz>
 8014012:	0004      	movs	r4, r0
 8014014:	f7ee fd6e 	bl	8002af4 <__aeabi_i2d>
 8014018:	9a04      	ldr	r2, [sp, #16]
 801401a:	9b05      	ldr	r3, [sp, #20]
 801401c:	f7ed ff5e 	bl	8001edc <__aeabi_dmul>
 8014020:	0002      	movs	r2, r0
 8014022:	000b      	movs	r3, r1
 8014024:	9806      	ldr	r0, [sp, #24]
 8014026:	9907      	ldr	r1, [sp, #28]
 8014028:	f7ee f9ca 	bl	80023c0 <__aeabi_dsub>
 801402c:	0023      	movs	r3, r4
 801402e:	3330      	adds	r3, #48	; 0x30
 8014030:	7033      	strb	r3, [r6, #0]
 8014032:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8014034:	9b08      	ldr	r3, [sp, #32]
 8014036:	1c75      	adds	r5, r6, #1
 8014038:	1aeb      	subs	r3, r5, r3
 801403a:	429a      	cmp	r2, r3
 801403c:	d148      	bne.n	80140d0 <_dtoa_r+0x708>
 801403e:	0002      	movs	r2, r0
 8014040:	000b      	movs	r3, r1
 8014042:	f7ed f825 	bl	8001090 <__aeabi_dadd>
 8014046:	9a04      	ldr	r2, [sp, #16]
 8014048:	9b05      	ldr	r3, [sp, #20]
 801404a:	9006      	str	r0, [sp, #24]
 801404c:	9107      	str	r1, [sp, #28]
 801404e:	f7ec fa0d 	bl	800046c <__aeabi_dcmpgt>
 8014052:	2800      	cmp	r0, #0
 8014054:	d12a      	bne.n	80140ac <_dtoa_r+0x6e4>
 8014056:	9a04      	ldr	r2, [sp, #16]
 8014058:	9b05      	ldr	r3, [sp, #20]
 801405a:	9806      	ldr	r0, [sp, #24]
 801405c:	9907      	ldr	r1, [sp, #28]
 801405e:	f7ec f9eb 	bl	8000438 <__aeabi_dcmpeq>
 8014062:	2800      	cmp	r0, #0
 8014064:	d001      	beq.n	801406a <_dtoa_r+0x6a2>
 8014066:	07e3      	lsls	r3, r4, #31
 8014068:	d420      	bmi.n	80140ac <_dtoa_r+0x6e4>
 801406a:	9903      	ldr	r1, [sp, #12]
 801406c:	9802      	ldr	r0, [sp, #8]
 801406e:	f000 fad9 	bl	8014624 <_Bfree>
 8014072:	2300      	movs	r3, #0
 8014074:	702b      	strb	r3, [r5, #0]
 8014076:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8014078:	3701      	adds	r7, #1
 801407a:	601f      	str	r7, [r3, #0]
 801407c:	9b24      	ldr	r3, [sp, #144]	; 0x90
 801407e:	2b00      	cmp	r3, #0
 8014080:	d100      	bne.n	8014084 <_dtoa_r+0x6bc>
 8014082:	e4e6      	b.n	8013a52 <_dtoa_r+0x8a>
 8014084:	601d      	str	r5, [r3, #0]
 8014086:	e4e4      	b.n	8013a52 <_dtoa_r+0x8a>
 8014088:	08015248 	.word	0x08015248
 801408c:	3ff00000 	.word	0x3ff00000
 8014090:	40240000 	.word	0x40240000
 8014094:	401c0000 	.word	0x401c0000
 8014098:	fcc00000 	.word	0xfcc00000
 801409c:	40140000 	.word	0x40140000
 80140a0:	7cc00000 	.word	0x7cc00000
 80140a4:	08015220 	.word	0x08015220
 80140a8:	3fe00000 	.word	0x3fe00000
 80140ac:	003e      	movs	r6, r7
 80140ae:	1e6b      	subs	r3, r5, #1
 80140b0:	781a      	ldrb	r2, [r3, #0]
 80140b2:	2a39      	cmp	r2, #57	; 0x39
 80140b4:	d106      	bne.n	80140c4 <_dtoa_r+0x6fc>
 80140b6:	9a08      	ldr	r2, [sp, #32]
 80140b8:	429a      	cmp	r2, r3
 80140ba:	d107      	bne.n	80140cc <_dtoa_r+0x704>
 80140bc:	2330      	movs	r3, #48	; 0x30
 80140be:	7013      	strb	r3, [r2, #0]
 80140c0:	0013      	movs	r3, r2
 80140c2:	3601      	adds	r6, #1
 80140c4:	781a      	ldrb	r2, [r3, #0]
 80140c6:	3201      	adds	r2, #1
 80140c8:	701a      	strb	r2, [r3, #0]
 80140ca:	e78c      	b.n	8013fe6 <_dtoa_r+0x61e>
 80140cc:	001d      	movs	r5, r3
 80140ce:	e7ee      	b.n	80140ae <_dtoa_r+0x6e6>
 80140d0:	2200      	movs	r2, #0
 80140d2:	4ba4      	ldr	r3, [pc, #656]	; (8014364 <_dtoa_r+0x99c>)
 80140d4:	f7ed ff02 	bl	8001edc <__aeabi_dmul>
 80140d8:	2200      	movs	r2, #0
 80140da:	2300      	movs	r3, #0
 80140dc:	9006      	str	r0, [sp, #24]
 80140de:	9107      	str	r1, [sp, #28]
 80140e0:	002e      	movs	r6, r5
 80140e2:	f7ec f9a9 	bl	8000438 <__aeabi_dcmpeq>
 80140e6:	2800      	cmp	r0, #0
 80140e8:	d08b      	beq.n	8014002 <_dtoa_r+0x63a>
 80140ea:	e7be      	b.n	801406a <_dtoa_r+0x6a2>
 80140ec:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80140ee:	2a00      	cmp	r2, #0
 80140f0:	d100      	bne.n	80140f4 <_dtoa_r+0x72c>
 80140f2:	e0da      	b.n	80142aa <_dtoa_r+0x8e2>
 80140f4:	9a20      	ldr	r2, [sp, #128]	; 0x80
 80140f6:	2a01      	cmp	r2, #1
 80140f8:	dd00      	ble.n	80140fc <_dtoa_r+0x734>
 80140fa:	e0bd      	b.n	8014278 <_dtoa_r+0x8b0>
 80140fc:	9a16      	ldr	r2, [sp, #88]	; 0x58
 80140fe:	2a00      	cmp	r2, #0
 8014100:	d100      	bne.n	8014104 <_dtoa_r+0x73c>
 8014102:	e0b5      	b.n	8014270 <_dtoa_r+0x8a8>
 8014104:	4a98      	ldr	r2, [pc, #608]	; (8014368 <_dtoa_r+0x9a0>)
 8014106:	189b      	adds	r3, r3, r2
 8014108:	9d04      	ldr	r5, [sp, #16]
 801410a:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 801410c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801410e:	2101      	movs	r1, #1
 8014110:	18d2      	adds	r2, r2, r3
 8014112:	920a      	str	r2, [sp, #40]	; 0x28
 8014114:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8014116:	9802      	ldr	r0, [sp, #8]
 8014118:	18d3      	adds	r3, r2, r3
 801411a:	930b      	str	r3, [sp, #44]	; 0x2c
 801411c:	f000 fb22 	bl	8014764 <__i2b>
 8014120:	0006      	movs	r6, r0
 8014122:	2c00      	cmp	r4, #0
 8014124:	dd0e      	ble.n	8014144 <_dtoa_r+0x77c>
 8014126:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8014128:	2b00      	cmp	r3, #0
 801412a:	dd0b      	ble.n	8014144 <_dtoa_r+0x77c>
 801412c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801412e:	0023      	movs	r3, r4
 8014130:	4294      	cmp	r4, r2
 8014132:	dd00      	ble.n	8014136 <_dtoa_r+0x76e>
 8014134:	0013      	movs	r3, r2
 8014136:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8014138:	1ae4      	subs	r4, r4, r3
 801413a:	1ad2      	subs	r2, r2, r3
 801413c:	920a      	str	r2, [sp, #40]	; 0x28
 801413e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8014140:	1ad3      	subs	r3, r2, r3
 8014142:	930b      	str	r3, [sp, #44]	; 0x2c
 8014144:	9b04      	ldr	r3, [sp, #16]
 8014146:	2b00      	cmp	r3, #0
 8014148:	d01f      	beq.n	801418a <_dtoa_r+0x7c2>
 801414a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801414c:	2b00      	cmp	r3, #0
 801414e:	d100      	bne.n	8014152 <_dtoa_r+0x78a>
 8014150:	e0af      	b.n	80142b2 <_dtoa_r+0x8ea>
 8014152:	2d00      	cmp	r5, #0
 8014154:	d011      	beq.n	801417a <_dtoa_r+0x7b2>
 8014156:	0031      	movs	r1, r6
 8014158:	002a      	movs	r2, r5
 801415a:	9802      	ldr	r0, [sp, #8]
 801415c:	f000 fb9a 	bl	8014894 <__pow5mult>
 8014160:	9a03      	ldr	r2, [sp, #12]
 8014162:	0001      	movs	r1, r0
 8014164:	0006      	movs	r6, r0
 8014166:	9802      	ldr	r0, [sp, #8]
 8014168:	f000 fb05 	bl	8014776 <__multiply>
 801416c:	9903      	ldr	r1, [sp, #12]
 801416e:	9010      	str	r0, [sp, #64]	; 0x40
 8014170:	9802      	ldr	r0, [sp, #8]
 8014172:	f000 fa57 	bl	8014624 <_Bfree>
 8014176:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8014178:	9303      	str	r3, [sp, #12]
 801417a:	9b04      	ldr	r3, [sp, #16]
 801417c:	1b5a      	subs	r2, r3, r5
 801417e:	d004      	beq.n	801418a <_dtoa_r+0x7c2>
 8014180:	9903      	ldr	r1, [sp, #12]
 8014182:	9802      	ldr	r0, [sp, #8]
 8014184:	f000 fb86 	bl	8014894 <__pow5mult>
 8014188:	9003      	str	r0, [sp, #12]
 801418a:	2101      	movs	r1, #1
 801418c:	9802      	ldr	r0, [sp, #8]
 801418e:	f000 fae9 	bl	8014764 <__i2b>
 8014192:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8014194:	9004      	str	r0, [sp, #16]
 8014196:	2b00      	cmp	r3, #0
 8014198:	d100      	bne.n	801419c <_dtoa_r+0x7d4>
 801419a:	e1e3      	b.n	8014564 <_dtoa_r+0xb9c>
 801419c:	001a      	movs	r2, r3
 801419e:	0001      	movs	r1, r0
 80141a0:	9802      	ldr	r0, [sp, #8]
 80141a2:	f000 fb77 	bl	8014894 <__pow5mult>
 80141a6:	9b20      	ldr	r3, [sp, #128]	; 0x80
 80141a8:	9004      	str	r0, [sp, #16]
 80141aa:	2b01      	cmp	r3, #1
 80141ac:	dd00      	ble.n	80141b0 <_dtoa_r+0x7e8>
 80141ae:	e082      	b.n	80142b6 <_dtoa_r+0x8ee>
 80141b0:	2500      	movs	r5, #0
 80141b2:	9b06      	ldr	r3, [sp, #24]
 80141b4:	42ab      	cmp	r3, r5
 80141b6:	d10e      	bne.n	80141d6 <_dtoa_r+0x80e>
 80141b8:	9b07      	ldr	r3, [sp, #28]
 80141ba:	031b      	lsls	r3, r3, #12
 80141bc:	42ab      	cmp	r3, r5
 80141be:	d10a      	bne.n	80141d6 <_dtoa_r+0x80e>
 80141c0:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 80141c2:	9a07      	ldr	r2, [sp, #28]
 80141c4:	4213      	tst	r3, r2
 80141c6:	d006      	beq.n	80141d6 <_dtoa_r+0x80e>
 80141c8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80141ca:	3501      	adds	r5, #1
 80141cc:	3301      	adds	r3, #1
 80141ce:	930a      	str	r3, [sp, #40]	; 0x28
 80141d0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80141d2:	3301      	adds	r3, #1
 80141d4:	930b      	str	r3, [sp, #44]	; 0x2c
 80141d6:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80141d8:	2001      	movs	r0, #1
 80141da:	2b00      	cmp	r3, #0
 80141dc:	d16c      	bne.n	80142b8 <_dtoa_r+0x8f0>
 80141de:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80141e0:	1818      	adds	r0, r3, r0
 80141e2:	231f      	movs	r3, #31
 80141e4:	4018      	ands	r0, r3
 80141e6:	d07e      	beq.n	80142e6 <_dtoa_r+0x91e>
 80141e8:	3301      	adds	r3, #1
 80141ea:	1a1b      	subs	r3, r3, r0
 80141ec:	2b04      	cmp	r3, #4
 80141ee:	dd70      	ble.n	80142d2 <_dtoa_r+0x90a>
 80141f0:	231c      	movs	r3, #28
 80141f2:	1a18      	subs	r0, r3, r0
 80141f4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80141f6:	1824      	adds	r4, r4, r0
 80141f8:	181b      	adds	r3, r3, r0
 80141fa:	930a      	str	r3, [sp, #40]	; 0x28
 80141fc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80141fe:	181b      	adds	r3, r3, r0
 8014200:	930b      	str	r3, [sp, #44]	; 0x2c
 8014202:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8014204:	2b00      	cmp	r3, #0
 8014206:	dd05      	ble.n	8014214 <_dtoa_r+0x84c>
 8014208:	001a      	movs	r2, r3
 801420a:	9903      	ldr	r1, [sp, #12]
 801420c:	9802      	ldr	r0, [sp, #8]
 801420e:	f000 fb93 	bl	8014938 <__lshift>
 8014212:	9003      	str	r0, [sp, #12]
 8014214:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8014216:	2b00      	cmp	r3, #0
 8014218:	dd05      	ble.n	8014226 <_dtoa_r+0x85e>
 801421a:	001a      	movs	r2, r3
 801421c:	9904      	ldr	r1, [sp, #16]
 801421e:	9802      	ldr	r0, [sp, #8]
 8014220:	f000 fb8a 	bl	8014938 <__lshift>
 8014224:	9004      	str	r0, [sp, #16]
 8014226:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8014228:	2b00      	cmp	r3, #0
 801422a:	d05e      	beq.n	80142ea <_dtoa_r+0x922>
 801422c:	9904      	ldr	r1, [sp, #16]
 801422e:	9803      	ldr	r0, [sp, #12]
 8014230:	f000 fbd4 	bl	80149dc <__mcmp>
 8014234:	2800      	cmp	r0, #0
 8014236:	da58      	bge.n	80142ea <_dtoa_r+0x922>
 8014238:	2300      	movs	r3, #0
 801423a:	220a      	movs	r2, #10
 801423c:	9903      	ldr	r1, [sp, #12]
 801423e:	9802      	ldr	r0, [sp, #8]
 8014240:	f000 fa09 	bl	8014656 <__multadd>
 8014244:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8014246:	3f01      	subs	r7, #1
 8014248:	9003      	str	r0, [sp, #12]
 801424a:	2b00      	cmp	r3, #0
 801424c:	d100      	bne.n	8014250 <_dtoa_r+0x888>
 801424e:	e190      	b.n	8014572 <_dtoa_r+0xbaa>
 8014250:	2300      	movs	r3, #0
 8014252:	0031      	movs	r1, r6
 8014254:	220a      	movs	r2, #10
 8014256:	9802      	ldr	r0, [sp, #8]
 8014258:	f000 f9fd 	bl	8014656 <__multadd>
 801425c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801425e:	0006      	movs	r6, r0
 8014260:	2b00      	cmp	r3, #0
 8014262:	dd00      	ble.n	8014266 <_dtoa_r+0x89e>
 8014264:	e088      	b.n	8014378 <_dtoa_r+0x9b0>
 8014266:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8014268:	2b02      	cmp	r3, #2
 801426a:	dc00      	bgt.n	801426e <_dtoa_r+0x8a6>
 801426c:	e084      	b.n	8014378 <_dtoa_r+0x9b0>
 801426e:	e044      	b.n	80142fa <_dtoa_r+0x932>
 8014270:	2336      	movs	r3, #54	; 0x36
 8014272:	9a18      	ldr	r2, [sp, #96]	; 0x60
 8014274:	1a9b      	subs	r3, r3, r2
 8014276:	e747      	b.n	8014108 <_dtoa_r+0x740>
 8014278:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801427a:	1e5d      	subs	r5, r3, #1
 801427c:	9b04      	ldr	r3, [sp, #16]
 801427e:	42ab      	cmp	r3, r5
 8014280:	db08      	blt.n	8014294 <_dtoa_r+0x8cc>
 8014282:	1b5d      	subs	r5, r3, r5
 8014284:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8014286:	2b00      	cmp	r3, #0
 8014288:	da0c      	bge.n	80142a4 <_dtoa_r+0x8dc>
 801428a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801428c:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801428e:	1a9c      	subs	r4, r3, r2
 8014290:	2300      	movs	r3, #0
 8014292:	e73b      	b.n	801410c <_dtoa_r+0x744>
 8014294:	9b04      	ldr	r3, [sp, #16]
 8014296:	9504      	str	r5, [sp, #16]
 8014298:	1aea      	subs	r2, r5, r3
 801429a:	9b11      	ldr	r3, [sp, #68]	; 0x44
 801429c:	2500      	movs	r5, #0
 801429e:	189b      	adds	r3, r3, r2
 80142a0:	9311      	str	r3, [sp, #68]	; 0x44
 80142a2:	e7ef      	b.n	8014284 <_dtoa_r+0x8bc>
 80142a4:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 80142a6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80142a8:	e730      	b.n	801410c <_dtoa_r+0x744>
 80142aa:	9d04      	ldr	r5, [sp, #16]
 80142ac:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 80142ae:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 80142b0:	e737      	b.n	8014122 <_dtoa_r+0x75a>
 80142b2:	9a04      	ldr	r2, [sp, #16]
 80142b4:	e764      	b.n	8014180 <_dtoa_r+0x7b8>
 80142b6:	2500      	movs	r5, #0
 80142b8:	9b04      	ldr	r3, [sp, #16]
 80142ba:	9a04      	ldr	r2, [sp, #16]
 80142bc:	691b      	ldr	r3, [r3, #16]
 80142be:	9310      	str	r3, [sp, #64]	; 0x40
 80142c0:	3303      	adds	r3, #3
 80142c2:	009b      	lsls	r3, r3, #2
 80142c4:	18d3      	adds	r3, r2, r3
 80142c6:	6858      	ldr	r0, [r3, #4]
 80142c8:	f000 fa03 	bl	80146d2 <__hi0bits>
 80142cc:	2320      	movs	r3, #32
 80142ce:	1a18      	subs	r0, r3, r0
 80142d0:	e785      	b.n	80141de <_dtoa_r+0x816>
 80142d2:	2b04      	cmp	r3, #4
 80142d4:	d095      	beq.n	8014202 <_dtoa_r+0x83a>
 80142d6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80142d8:	331c      	adds	r3, #28
 80142da:	18d2      	adds	r2, r2, r3
 80142dc:	920a      	str	r2, [sp, #40]	; 0x28
 80142de:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80142e0:	18e4      	adds	r4, r4, r3
 80142e2:	18d3      	adds	r3, r2, r3
 80142e4:	e78c      	b.n	8014200 <_dtoa_r+0x838>
 80142e6:	0003      	movs	r3, r0
 80142e8:	e7f5      	b.n	80142d6 <_dtoa_r+0x90e>
 80142ea:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80142ec:	2b00      	cmp	r3, #0
 80142ee:	dc3d      	bgt.n	801436c <_dtoa_r+0x9a4>
 80142f0:	9b20      	ldr	r3, [sp, #128]	; 0x80
 80142f2:	2b02      	cmp	r3, #2
 80142f4:	dd3a      	ble.n	801436c <_dtoa_r+0x9a4>
 80142f6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80142f8:	930c      	str	r3, [sp, #48]	; 0x30
 80142fa:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80142fc:	2b00      	cmp	r3, #0
 80142fe:	d10c      	bne.n	801431a <_dtoa_r+0x952>
 8014300:	9904      	ldr	r1, [sp, #16]
 8014302:	2205      	movs	r2, #5
 8014304:	9802      	ldr	r0, [sp, #8]
 8014306:	f000 f9a6 	bl	8014656 <__multadd>
 801430a:	9004      	str	r0, [sp, #16]
 801430c:	0001      	movs	r1, r0
 801430e:	9803      	ldr	r0, [sp, #12]
 8014310:	f000 fb64 	bl	80149dc <__mcmp>
 8014314:	2800      	cmp	r0, #0
 8014316:	dd00      	ble.n	801431a <_dtoa_r+0x952>
 8014318:	e5af      	b.n	8013e7a <_dtoa_r+0x4b2>
 801431a:	9b21      	ldr	r3, [sp, #132]	; 0x84
 801431c:	9d08      	ldr	r5, [sp, #32]
 801431e:	43df      	mvns	r7, r3
 8014320:	2300      	movs	r3, #0
 8014322:	9309      	str	r3, [sp, #36]	; 0x24
 8014324:	9904      	ldr	r1, [sp, #16]
 8014326:	9802      	ldr	r0, [sp, #8]
 8014328:	f000 f97c 	bl	8014624 <_Bfree>
 801432c:	2e00      	cmp	r6, #0
 801432e:	d100      	bne.n	8014332 <_dtoa_r+0x96a>
 8014330:	e69b      	b.n	801406a <_dtoa_r+0x6a2>
 8014332:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8014334:	2b00      	cmp	r3, #0
 8014336:	d005      	beq.n	8014344 <_dtoa_r+0x97c>
 8014338:	42b3      	cmp	r3, r6
 801433a:	d003      	beq.n	8014344 <_dtoa_r+0x97c>
 801433c:	0019      	movs	r1, r3
 801433e:	9802      	ldr	r0, [sp, #8]
 8014340:	f000 f970 	bl	8014624 <_Bfree>
 8014344:	0031      	movs	r1, r6
 8014346:	9802      	ldr	r0, [sp, #8]
 8014348:	f000 f96c 	bl	8014624 <_Bfree>
 801434c:	e68d      	b.n	801406a <_dtoa_r+0x6a2>
 801434e:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8014350:	9304      	str	r3, [sp, #16]
 8014352:	001e      	movs	r6, r3
 8014354:	e7e1      	b.n	801431a <_dtoa_r+0x952>
 8014356:	2300      	movs	r3, #0
 8014358:	e7fa      	b.n	8014350 <_dtoa_r+0x988>
 801435a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801435c:	0037      	movs	r7, r6
 801435e:	9304      	str	r3, [sp, #16]
 8014360:	001e      	movs	r6, r3
 8014362:	e58a      	b.n	8013e7a <_dtoa_r+0x4b2>
 8014364:	40240000 	.word	0x40240000
 8014368:	00000433 	.word	0x00000433
 801436c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801436e:	2b00      	cmp	r3, #0
 8014370:	d100      	bne.n	8014374 <_dtoa_r+0x9ac>
 8014372:	e0b2      	b.n	80144da <_dtoa_r+0xb12>
 8014374:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8014376:	930c      	str	r3, [sp, #48]	; 0x30
 8014378:	2c00      	cmp	r4, #0
 801437a:	dd05      	ble.n	8014388 <_dtoa_r+0x9c0>
 801437c:	0031      	movs	r1, r6
 801437e:	0022      	movs	r2, r4
 8014380:	9802      	ldr	r0, [sp, #8]
 8014382:	f000 fad9 	bl	8014938 <__lshift>
 8014386:	0006      	movs	r6, r0
 8014388:	0030      	movs	r0, r6
 801438a:	2d00      	cmp	r5, #0
 801438c:	d011      	beq.n	80143b2 <_dtoa_r+0x9ea>
 801438e:	6871      	ldr	r1, [r6, #4]
 8014390:	9802      	ldr	r0, [sp, #8]
 8014392:	f000 f90f 	bl	80145b4 <_Balloc>
 8014396:	0031      	movs	r1, r6
 8014398:	0004      	movs	r4, r0
 801439a:	6933      	ldr	r3, [r6, #16]
 801439c:	310c      	adds	r1, #12
 801439e:	1c9a      	adds	r2, r3, #2
 80143a0:	0092      	lsls	r2, r2, #2
 80143a2:	300c      	adds	r0, #12
 80143a4:	f7fe ff0e 	bl	80131c4 <memcpy>
 80143a8:	2201      	movs	r2, #1
 80143aa:	0021      	movs	r1, r4
 80143ac:	9802      	ldr	r0, [sp, #8]
 80143ae:	f000 fac3 	bl	8014938 <__lshift>
 80143b2:	9609      	str	r6, [sp, #36]	; 0x24
 80143b4:	0006      	movs	r6, r0
 80143b6:	9b08      	ldr	r3, [sp, #32]
 80143b8:	930a      	str	r3, [sp, #40]	; 0x28
 80143ba:	9904      	ldr	r1, [sp, #16]
 80143bc:	9803      	ldr	r0, [sp, #12]
 80143be:	f7ff fa7c 	bl	80138ba <quorem>
 80143c2:	9909      	ldr	r1, [sp, #36]	; 0x24
 80143c4:	900d      	str	r0, [sp, #52]	; 0x34
 80143c6:	0004      	movs	r4, r0
 80143c8:	9803      	ldr	r0, [sp, #12]
 80143ca:	f000 fb07 	bl	80149dc <__mcmp>
 80143ce:	0032      	movs	r2, r6
 80143d0:	9010      	str	r0, [sp, #64]	; 0x40
 80143d2:	9904      	ldr	r1, [sp, #16]
 80143d4:	9802      	ldr	r0, [sp, #8]
 80143d6:	f000 fb1b 	bl	8014a10 <__mdiff>
 80143da:	2301      	movs	r3, #1
 80143dc:	930b      	str	r3, [sp, #44]	; 0x2c
 80143de:	68c3      	ldr	r3, [r0, #12]
 80143e0:	3430      	adds	r4, #48	; 0x30
 80143e2:	0005      	movs	r5, r0
 80143e4:	2b00      	cmp	r3, #0
 80143e6:	d104      	bne.n	80143f2 <_dtoa_r+0xa2a>
 80143e8:	0001      	movs	r1, r0
 80143ea:	9803      	ldr	r0, [sp, #12]
 80143ec:	f000 faf6 	bl	80149dc <__mcmp>
 80143f0:	900b      	str	r0, [sp, #44]	; 0x2c
 80143f2:	0029      	movs	r1, r5
 80143f4:	9802      	ldr	r0, [sp, #8]
 80143f6:	f000 f915 	bl	8014624 <_Bfree>
 80143fa:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80143fc:	9a20      	ldr	r2, [sp, #128]	; 0x80
 80143fe:	4313      	orrs	r3, r2
 8014400:	d10e      	bne.n	8014420 <_dtoa_r+0xa58>
 8014402:	9a06      	ldr	r2, [sp, #24]
 8014404:	3301      	adds	r3, #1
 8014406:	4213      	tst	r3, r2
 8014408:	d10a      	bne.n	8014420 <_dtoa_r+0xa58>
 801440a:	2c39      	cmp	r4, #57	; 0x39
 801440c:	d026      	beq.n	801445c <_dtoa_r+0xa94>
 801440e:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8014410:	2b00      	cmp	r3, #0
 8014412:	dd01      	ble.n	8014418 <_dtoa_r+0xa50>
 8014414:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 8014416:	3431      	adds	r4, #49	; 0x31
 8014418:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801441a:	1c5d      	adds	r5, r3, #1
 801441c:	701c      	strb	r4, [r3, #0]
 801441e:	e781      	b.n	8014324 <_dtoa_r+0x95c>
 8014420:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8014422:	2b00      	cmp	r3, #0
 8014424:	db07      	blt.n	8014436 <_dtoa_r+0xa6e>
 8014426:	001d      	movs	r5, r3
 8014428:	9b20      	ldr	r3, [sp, #128]	; 0x80
 801442a:	431d      	orrs	r5, r3
 801442c:	d122      	bne.n	8014474 <_dtoa_r+0xaac>
 801442e:	2301      	movs	r3, #1
 8014430:	9a06      	ldr	r2, [sp, #24]
 8014432:	4213      	tst	r3, r2
 8014434:	d11e      	bne.n	8014474 <_dtoa_r+0xaac>
 8014436:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8014438:	2b00      	cmp	r3, #0
 801443a:	dded      	ble.n	8014418 <_dtoa_r+0xa50>
 801443c:	9903      	ldr	r1, [sp, #12]
 801443e:	2201      	movs	r2, #1
 8014440:	9802      	ldr	r0, [sp, #8]
 8014442:	f000 fa79 	bl	8014938 <__lshift>
 8014446:	9904      	ldr	r1, [sp, #16]
 8014448:	9003      	str	r0, [sp, #12]
 801444a:	f000 fac7 	bl	80149dc <__mcmp>
 801444e:	2800      	cmp	r0, #0
 8014450:	dc02      	bgt.n	8014458 <_dtoa_r+0xa90>
 8014452:	d1e1      	bne.n	8014418 <_dtoa_r+0xa50>
 8014454:	07e3      	lsls	r3, r4, #31
 8014456:	d5df      	bpl.n	8014418 <_dtoa_r+0xa50>
 8014458:	2c39      	cmp	r4, #57	; 0x39
 801445a:	d1db      	bne.n	8014414 <_dtoa_r+0xa4c>
 801445c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801445e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8014460:	1c5d      	adds	r5, r3, #1
 8014462:	2339      	movs	r3, #57	; 0x39
 8014464:	7013      	strb	r3, [r2, #0]
 8014466:	1e6b      	subs	r3, r5, #1
 8014468:	781a      	ldrb	r2, [r3, #0]
 801446a:	2a39      	cmp	r2, #57	; 0x39
 801446c:	d067      	beq.n	801453e <_dtoa_r+0xb76>
 801446e:	3201      	adds	r2, #1
 8014470:	701a      	strb	r2, [r3, #0]
 8014472:	e757      	b.n	8014324 <_dtoa_r+0x95c>
 8014474:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8014476:	1c5d      	adds	r5, r3, #1
 8014478:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801447a:	2b00      	cmp	r3, #0
 801447c:	dd04      	ble.n	8014488 <_dtoa_r+0xac0>
 801447e:	2c39      	cmp	r4, #57	; 0x39
 8014480:	d0ec      	beq.n	801445c <_dtoa_r+0xa94>
 8014482:	3401      	adds	r4, #1
 8014484:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8014486:	e7c9      	b.n	801441c <_dtoa_r+0xa54>
 8014488:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801448a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801448c:	701c      	strb	r4, [r3, #0]
 801448e:	9b08      	ldr	r3, [sp, #32]
 8014490:	1aeb      	subs	r3, r5, r3
 8014492:	4293      	cmp	r3, r2
 8014494:	d03e      	beq.n	8014514 <_dtoa_r+0xb4c>
 8014496:	2300      	movs	r3, #0
 8014498:	220a      	movs	r2, #10
 801449a:	9903      	ldr	r1, [sp, #12]
 801449c:	9802      	ldr	r0, [sp, #8]
 801449e:	f000 f8da 	bl	8014656 <__multadd>
 80144a2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80144a4:	9003      	str	r0, [sp, #12]
 80144a6:	42b3      	cmp	r3, r6
 80144a8:	d109      	bne.n	80144be <_dtoa_r+0xaf6>
 80144aa:	2300      	movs	r3, #0
 80144ac:	220a      	movs	r2, #10
 80144ae:	9909      	ldr	r1, [sp, #36]	; 0x24
 80144b0:	9802      	ldr	r0, [sp, #8]
 80144b2:	f000 f8d0 	bl	8014656 <__multadd>
 80144b6:	9009      	str	r0, [sp, #36]	; 0x24
 80144b8:	0006      	movs	r6, r0
 80144ba:	950a      	str	r5, [sp, #40]	; 0x28
 80144bc:	e77d      	b.n	80143ba <_dtoa_r+0x9f2>
 80144be:	9909      	ldr	r1, [sp, #36]	; 0x24
 80144c0:	2300      	movs	r3, #0
 80144c2:	220a      	movs	r2, #10
 80144c4:	9802      	ldr	r0, [sp, #8]
 80144c6:	f000 f8c6 	bl	8014656 <__multadd>
 80144ca:	2300      	movs	r3, #0
 80144cc:	9009      	str	r0, [sp, #36]	; 0x24
 80144ce:	220a      	movs	r2, #10
 80144d0:	0031      	movs	r1, r6
 80144d2:	9802      	ldr	r0, [sp, #8]
 80144d4:	f000 f8bf 	bl	8014656 <__multadd>
 80144d8:	e7ee      	b.n	80144b8 <_dtoa_r+0xaf0>
 80144da:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80144dc:	930c      	str	r3, [sp, #48]	; 0x30
 80144de:	9b08      	ldr	r3, [sp, #32]
 80144e0:	9306      	str	r3, [sp, #24]
 80144e2:	9904      	ldr	r1, [sp, #16]
 80144e4:	9803      	ldr	r0, [sp, #12]
 80144e6:	f7ff f9e8 	bl	80138ba <quorem>
 80144ea:	9b06      	ldr	r3, [sp, #24]
 80144ec:	3030      	adds	r0, #48	; 0x30
 80144ee:	1c5d      	adds	r5, r3, #1
 80144f0:	7018      	strb	r0, [r3, #0]
 80144f2:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80144f4:	9b08      	ldr	r3, [sp, #32]
 80144f6:	0004      	movs	r4, r0
 80144f8:	1aeb      	subs	r3, r5, r3
 80144fa:	429a      	cmp	r2, r3
 80144fc:	dd08      	ble.n	8014510 <_dtoa_r+0xb48>
 80144fe:	2300      	movs	r3, #0
 8014500:	220a      	movs	r2, #10
 8014502:	9903      	ldr	r1, [sp, #12]
 8014504:	9802      	ldr	r0, [sp, #8]
 8014506:	f000 f8a6 	bl	8014656 <__multadd>
 801450a:	9506      	str	r5, [sp, #24]
 801450c:	9003      	str	r0, [sp, #12]
 801450e:	e7e8      	b.n	80144e2 <_dtoa_r+0xb1a>
 8014510:	2300      	movs	r3, #0
 8014512:	9309      	str	r3, [sp, #36]	; 0x24
 8014514:	9903      	ldr	r1, [sp, #12]
 8014516:	2201      	movs	r2, #1
 8014518:	9802      	ldr	r0, [sp, #8]
 801451a:	f000 fa0d 	bl	8014938 <__lshift>
 801451e:	9904      	ldr	r1, [sp, #16]
 8014520:	9003      	str	r0, [sp, #12]
 8014522:	f000 fa5b 	bl	80149dc <__mcmp>
 8014526:	2800      	cmp	r0, #0
 8014528:	dc9d      	bgt.n	8014466 <_dtoa_r+0xa9e>
 801452a:	d101      	bne.n	8014530 <_dtoa_r+0xb68>
 801452c:	07e3      	lsls	r3, r4, #31
 801452e:	d49a      	bmi.n	8014466 <_dtoa_r+0xa9e>
 8014530:	1e6b      	subs	r3, r5, #1
 8014532:	781a      	ldrb	r2, [r3, #0]
 8014534:	2a30      	cmp	r2, #48	; 0x30
 8014536:	d000      	beq.n	801453a <_dtoa_r+0xb72>
 8014538:	e6f4      	b.n	8014324 <_dtoa_r+0x95c>
 801453a:	001d      	movs	r5, r3
 801453c:	e7f8      	b.n	8014530 <_dtoa_r+0xb68>
 801453e:	9a08      	ldr	r2, [sp, #32]
 8014540:	429a      	cmp	r2, r3
 8014542:	d103      	bne.n	801454c <_dtoa_r+0xb84>
 8014544:	2331      	movs	r3, #49	; 0x31
 8014546:	3701      	adds	r7, #1
 8014548:	7013      	strb	r3, [r2, #0]
 801454a:	e6eb      	b.n	8014324 <_dtoa_r+0x95c>
 801454c:	001d      	movs	r5, r3
 801454e:	e78a      	b.n	8014466 <_dtoa_r+0xa9e>
 8014550:	4b0b      	ldr	r3, [pc, #44]	; (8014580 <_dtoa_r+0xbb8>)
 8014552:	9a24      	ldr	r2, [sp, #144]	; 0x90
 8014554:	9308      	str	r3, [sp, #32]
 8014556:	4b0b      	ldr	r3, [pc, #44]	; (8014584 <_dtoa_r+0xbbc>)
 8014558:	2a00      	cmp	r2, #0
 801455a:	d001      	beq.n	8014560 <_dtoa_r+0xb98>
 801455c:	f7ff fa77 	bl	8013a4e <_dtoa_r+0x86>
 8014560:	f7ff fa77 	bl	8013a52 <_dtoa_r+0x8a>
 8014564:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8014566:	2b01      	cmp	r3, #1
 8014568:	dc00      	bgt.n	801456c <_dtoa_r+0xba4>
 801456a:	e621      	b.n	80141b0 <_dtoa_r+0x7e8>
 801456c:	9d11      	ldr	r5, [sp, #68]	; 0x44
 801456e:	2001      	movs	r0, #1
 8014570:	e635      	b.n	80141de <_dtoa_r+0x816>
 8014572:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8014574:	2b00      	cmp	r3, #0
 8014576:	dcb2      	bgt.n	80144de <_dtoa_r+0xb16>
 8014578:	9b20      	ldr	r3, [sp, #128]	; 0x80
 801457a:	2b02      	cmp	r3, #2
 801457c:	ddaf      	ble.n	80144de <_dtoa_r+0xb16>
 801457e:	e6bc      	b.n	80142fa <_dtoa_r+0x932>
 8014580:	0801520e 	.word	0x0801520e
 8014584:	08015216 	.word	0x08015216

08014588 <_localeconv_r>:
 8014588:	4b03      	ldr	r3, [pc, #12]	; (8014598 <_localeconv_r+0x10>)
 801458a:	681b      	ldr	r3, [r3, #0]
 801458c:	6a18      	ldr	r0, [r3, #32]
 801458e:	2800      	cmp	r0, #0
 8014590:	d100      	bne.n	8014594 <_localeconv_r+0xc>
 8014592:	4802      	ldr	r0, [pc, #8]	; (801459c <_localeconv_r+0x14>)
 8014594:	30f0      	adds	r0, #240	; 0xf0
 8014596:	4770      	bx	lr
 8014598:	20000268 	.word	0x20000268
 801459c:	200002cc 	.word	0x200002cc

080145a0 <malloc>:
 80145a0:	b510      	push	{r4, lr}
 80145a2:	4b03      	ldr	r3, [pc, #12]	; (80145b0 <malloc+0x10>)
 80145a4:	0001      	movs	r1, r0
 80145a6:	6818      	ldr	r0, [r3, #0]
 80145a8:	f000 faf8 	bl	8014b9c <_malloc_r>
 80145ac:	bd10      	pop	{r4, pc}
 80145ae:	46c0      	nop			; (mov r8, r8)
 80145b0:	20000268 	.word	0x20000268

080145b4 <_Balloc>:
 80145b4:	b570      	push	{r4, r5, r6, lr}
 80145b6:	6a46      	ldr	r6, [r0, #36]	; 0x24
 80145b8:	0004      	movs	r4, r0
 80145ba:	000d      	movs	r5, r1
 80145bc:	2e00      	cmp	r6, #0
 80145be:	d107      	bne.n	80145d0 <_Balloc+0x1c>
 80145c0:	2010      	movs	r0, #16
 80145c2:	f7ff ffed 	bl	80145a0 <malloc>
 80145c6:	6260      	str	r0, [r4, #36]	; 0x24
 80145c8:	6046      	str	r6, [r0, #4]
 80145ca:	6086      	str	r6, [r0, #8]
 80145cc:	6006      	str	r6, [r0, #0]
 80145ce:	60c6      	str	r6, [r0, #12]
 80145d0:	6a66      	ldr	r6, [r4, #36]	; 0x24
 80145d2:	68f3      	ldr	r3, [r6, #12]
 80145d4:	2b00      	cmp	r3, #0
 80145d6:	d013      	beq.n	8014600 <_Balloc+0x4c>
 80145d8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80145da:	00aa      	lsls	r2, r5, #2
 80145dc:	68db      	ldr	r3, [r3, #12]
 80145de:	189b      	adds	r3, r3, r2
 80145e0:	6818      	ldr	r0, [r3, #0]
 80145e2:	2800      	cmp	r0, #0
 80145e4:	d118      	bne.n	8014618 <_Balloc+0x64>
 80145e6:	2101      	movs	r1, #1
 80145e8:	000e      	movs	r6, r1
 80145ea:	40ae      	lsls	r6, r5
 80145ec:	1d72      	adds	r2, r6, #5
 80145ee:	0092      	lsls	r2, r2, #2
 80145f0:	0020      	movs	r0, r4
 80145f2:	f000 fac5 	bl	8014b80 <_calloc_r>
 80145f6:	2800      	cmp	r0, #0
 80145f8:	d00c      	beq.n	8014614 <_Balloc+0x60>
 80145fa:	6045      	str	r5, [r0, #4]
 80145fc:	6086      	str	r6, [r0, #8]
 80145fe:	e00d      	b.n	801461c <_Balloc+0x68>
 8014600:	2221      	movs	r2, #33	; 0x21
 8014602:	2104      	movs	r1, #4
 8014604:	0020      	movs	r0, r4
 8014606:	f000 fabb 	bl	8014b80 <_calloc_r>
 801460a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 801460c:	60f0      	str	r0, [r6, #12]
 801460e:	68db      	ldr	r3, [r3, #12]
 8014610:	2b00      	cmp	r3, #0
 8014612:	d1e1      	bne.n	80145d8 <_Balloc+0x24>
 8014614:	2000      	movs	r0, #0
 8014616:	bd70      	pop	{r4, r5, r6, pc}
 8014618:	6802      	ldr	r2, [r0, #0]
 801461a:	601a      	str	r2, [r3, #0]
 801461c:	2300      	movs	r3, #0
 801461e:	6103      	str	r3, [r0, #16]
 8014620:	60c3      	str	r3, [r0, #12]
 8014622:	e7f8      	b.n	8014616 <_Balloc+0x62>

08014624 <_Bfree>:
 8014624:	b570      	push	{r4, r5, r6, lr}
 8014626:	6a44      	ldr	r4, [r0, #36]	; 0x24
 8014628:	0006      	movs	r6, r0
 801462a:	000d      	movs	r5, r1
 801462c:	2c00      	cmp	r4, #0
 801462e:	d107      	bne.n	8014640 <_Bfree+0x1c>
 8014630:	2010      	movs	r0, #16
 8014632:	f7ff ffb5 	bl	80145a0 <malloc>
 8014636:	6270      	str	r0, [r6, #36]	; 0x24
 8014638:	6044      	str	r4, [r0, #4]
 801463a:	6084      	str	r4, [r0, #8]
 801463c:	6004      	str	r4, [r0, #0]
 801463e:	60c4      	str	r4, [r0, #12]
 8014640:	2d00      	cmp	r5, #0
 8014642:	d007      	beq.n	8014654 <_Bfree+0x30>
 8014644:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8014646:	686a      	ldr	r2, [r5, #4]
 8014648:	68db      	ldr	r3, [r3, #12]
 801464a:	0092      	lsls	r2, r2, #2
 801464c:	189b      	adds	r3, r3, r2
 801464e:	681a      	ldr	r2, [r3, #0]
 8014650:	602a      	str	r2, [r5, #0]
 8014652:	601d      	str	r5, [r3, #0]
 8014654:	bd70      	pop	{r4, r5, r6, pc}

08014656 <__multadd>:
 8014656:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8014658:	001e      	movs	r6, r3
 801465a:	2314      	movs	r3, #20
 801465c:	469c      	mov	ip, r3
 801465e:	0007      	movs	r7, r0
 8014660:	000c      	movs	r4, r1
 8014662:	2000      	movs	r0, #0
 8014664:	690d      	ldr	r5, [r1, #16]
 8014666:	448c      	add	ip, r1
 8014668:	4663      	mov	r3, ip
 801466a:	681b      	ldr	r3, [r3, #0]
 801466c:	3001      	adds	r0, #1
 801466e:	b299      	uxth	r1, r3
 8014670:	4663      	mov	r3, ip
 8014672:	681b      	ldr	r3, [r3, #0]
 8014674:	4351      	muls	r1, r2
 8014676:	0c1b      	lsrs	r3, r3, #16
 8014678:	4353      	muls	r3, r2
 801467a:	1989      	adds	r1, r1, r6
 801467c:	0c0e      	lsrs	r6, r1, #16
 801467e:	199b      	adds	r3, r3, r6
 8014680:	b289      	uxth	r1, r1
 8014682:	0c1e      	lsrs	r6, r3, #16
 8014684:	041b      	lsls	r3, r3, #16
 8014686:	185b      	adds	r3, r3, r1
 8014688:	4661      	mov	r1, ip
 801468a:	c108      	stmia	r1!, {r3}
 801468c:	468c      	mov	ip, r1
 801468e:	4285      	cmp	r5, r0
 8014690:	dcea      	bgt.n	8014668 <__multadd+0x12>
 8014692:	2e00      	cmp	r6, #0
 8014694:	d01b      	beq.n	80146ce <__multadd+0x78>
 8014696:	68a3      	ldr	r3, [r4, #8]
 8014698:	42ab      	cmp	r3, r5
 801469a:	dc12      	bgt.n	80146c2 <__multadd+0x6c>
 801469c:	6863      	ldr	r3, [r4, #4]
 801469e:	0038      	movs	r0, r7
 80146a0:	1c59      	adds	r1, r3, #1
 80146a2:	f7ff ff87 	bl	80145b4 <_Balloc>
 80146a6:	0021      	movs	r1, r4
 80146a8:	6923      	ldr	r3, [r4, #16]
 80146aa:	9001      	str	r0, [sp, #4]
 80146ac:	1c9a      	adds	r2, r3, #2
 80146ae:	0092      	lsls	r2, r2, #2
 80146b0:	310c      	adds	r1, #12
 80146b2:	300c      	adds	r0, #12
 80146b4:	f7fe fd86 	bl	80131c4 <memcpy>
 80146b8:	0021      	movs	r1, r4
 80146ba:	0038      	movs	r0, r7
 80146bc:	f7ff ffb2 	bl	8014624 <_Bfree>
 80146c0:	9c01      	ldr	r4, [sp, #4]
 80146c2:	1d2b      	adds	r3, r5, #4
 80146c4:	009b      	lsls	r3, r3, #2
 80146c6:	18e3      	adds	r3, r4, r3
 80146c8:	3501      	adds	r5, #1
 80146ca:	605e      	str	r6, [r3, #4]
 80146cc:	6125      	str	r5, [r4, #16]
 80146ce:	0020      	movs	r0, r4
 80146d0:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

080146d2 <__hi0bits>:
 80146d2:	0003      	movs	r3, r0
 80146d4:	0c02      	lsrs	r2, r0, #16
 80146d6:	2000      	movs	r0, #0
 80146d8:	4282      	cmp	r2, r0
 80146da:	d101      	bne.n	80146e0 <__hi0bits+0xe>
 80146dc:	041b      	lsls	r3, r3, #16
 80146de:	3010      	adds	r0, #16
 80146e0:	0e1a      	lsrs	r2, r3, #24
 80146e2:	d101      	bne.n	80146e8 <__hi0bits+0x16>
 80146e4:	3008      	adds	r0, #8
 80146e6:	021b      	lsls	r3, r3, #8
 80146e8:	0f1a      	lsrs	r2, r3, #28
 80146ea:	d101      	bne.n	80146f0 <__hi0bits+0x1e>
 80146ec:	3004      	adds	r0, #4
 80146ee:	011b      	lsls	r3, r3, #4
 80146f0:	0f9a      	lsrs	r2, r3, #30
 80146f2:	d101      	bne.n	80146f8 <__hi0bits+0x26>
 80146f4:	3002      	adds	r0, #2
 80146f6:	009b      	lsls	r3, r3, #2
 80146f8:	2b00      	cmp	r3, #0
 80146fa:	db03      	blt.n	8014704 <__hi0bits+0x32>
 80146fc:	3001      	adds	r0, #1
 80146fe:	005b      	lsls	r3, r3, #1
 8014700:	d400      	bmi.n	8014704 <__hi0bits+0x32>
 8014702:	2020      	movs	r0, #32
 8014704:	4770      	bx	lr

08014706 <__lo0bits>:
 8014706:	2207      	movs	r2, #7
 8014708:	6803      	ldr	r3, [r0, #0]
 801470a:	b510      	push	{r4, lr}
 801470c:	0001      	movs	r1, r0
 801470e:	401a      	ands	r2, r3
 8014710:	d00d      	beq.n	801472e <__lo0bits+0x28>
 8014712:	2401      	movs	r4, #1
 8014714:	2000      	movs	r0, #0
 8014716:	4223      	tst	r3, r4
 8014718:	d105      	bne.n	8014726 <__lo0bits+0x20>
 801471a:	3002      	adds	r0, #2
 801471c:	4203      	tst	r3, r0
 801471e:	d003      	beq.n	8014728 <__lo0bits+0x22>
 8014720:	40e3      	lsrs	r3, r4
 8014722:	0020      	movs	r0, r4
 8014724:	600b      	str	r3, [r1, #0]
 8014726:	bd10      	pop	{r4, pc}
 8014728:	089b      	lsrs	r3, r3, #2
 801472a:	600b      	str	r3, [r1, #0]
 801472c:	e7fb      	b.n	8014726 <__lo0bits+0x20>
 801472e:	b29c      	uxth	r4, r3
 8014730:	0010      	movs	r0, r2
 8014732:	2c00      	cmp	r4, #0
 8014734:	d101      	bne.n	801473a <__lo0bits+0x34>
 8014736:	2010      	movs	r0, #16
 8014738:	0c1b      	lsrs	r3, r3, #16
 801473a:	b2da      	uxtb	r2, r3
 801473c:	2a00      	cmp	r2, #0
 801473e:	d101      	bne.n	8014744 <__lo0bits+0x3e>
 8014740:	3008      	adds	r0, #8
 8014742:	0a1b      	lsrs	r3, r3, #8
 8014744:	071a      	lsls	r2, r3, #28
 8014746:	d101      	bne.n	801474c <__lo0bits+0x46>
 8014748:	3004      	adds	r0, #4
 801474a:	091b      	lsrs	r3, r3, #4
 801474c:	079a      	lsls	r2, r3, #30
 801474e:	d101      	bne.n	8014754 <__lo0bits+0x4e>
 8014750:	3002      	adds	r0, #2
 8014752:	089b      	lsrs	r3, r3, #2
 8014754:	07da      	lsls	r2, r3, #31
 8014756:	d4e8      	bmi.n	801472a <__lo0bits+0x24>
 8014758:	085b      	lsrs	r3, r3, #1
 801475a:	d001      	beq.n	8014760 <__lo0bits+0x5a>
 801475c:	3001      	adds	r0, #1
 801475e:	e7e4      	b.n	801472a <__lo0bits+0x24>
 8014760:	2020      	movs	r0, #32
 8014762:	e7e0      	b.n	8014726 <__lo0bits+0x20>

08014764 <__i2b>:
 8014764:	b510      	push	{r4, lr}
 8014766:	000c      	movs	r4, r1
 8014768:	2101      	movs	r1, #1
 801476a:	f7ff ff23 	bl	80145b4 <_Balloc>
 801476e:	2301      	movs	r3, #1
 8014770:	6144      	str	r4, [r0, #20]
 8014772:	6103      	str	r3, [r0, #16]
 8014774:	bd10      	pop	{r4, pc}

08014776 <__multiply>:
 8014776:	b5f0      	push	{r4, r5, r6, r7, lr}
 8014778:	690b      	ldr	r3, [r1, #16]
 801477a:	0014      	movs	r4, r2
 801477c:	6912      	ldr	r2, [r2, #16]
 801477e:	b089      	sub	sp, #36	; 0x24
 8014780:	000d      	movs	r5, r1
 8014782:	4293      	cmp	r3, r2
 8014784:	da01      	bge.n	801478a <__multiply+0x14>
 8014786:	0025      	movs	r5, r4
 8014788:	000c      	movs	r4, r1
 801478a:	692f      	ldr	r7, [r5, #16]
 801478c:	6926      	ldr	r6, [r4, #16]
 801478e:	6869      	ldr	r1, [r5, #4]
 8014790:	19bb      	adds	r3, r7, r6
 8014792:	9302      	str	r3, [sp, #8]
 8014794:	68ab      	ldr	r3, [r5, #8]
 8014796:	19ba      	adds	r2, r7, r6
 8014798:	4293      	cmp	r3, r2
 801479a:	da00      	bge.n	801479e <__multiply+0x28>
 801479c:	3101      	adds	r1, #1
 801479e:	f7ff ff09 	bl	80145b4 <_Balloc>
 80147a2:	0002      	movs	r2, r0
 80147a4:	19bb      	adds	r3, r7, r6
 80147a6:	3214      	adds	r2, #20
 80147a8:	009b      	lsls	r3, r3, #2
 80147aa:	18d3      	adds	r3, r2, r3
 80147ac:	469c      	mov	ip, r3
 80147ae:	2100      	movs	r1, #0
 80147b0:	0013      	movs	r3, r2
 80147b2:	9004      	str	r0, [sp, #16]
 80147b4:	4563      	cmp	r3, ip
 80147b6:	d31d      	bcc.n	80147f4 <__multiply+0x7e>
 80147b8:	3514      	adds	r5, #20
 80147ba:	00bf      	lsls	r7, r7, #2
 80147bc:	19eb      	adds	r3, r5, r7
 80147be:	3414      	adds	r4, #20
 80147c0:	00b6      	lsls	r6, r6, #2
 80147c2:	9305      	str	r3, [sp, #20]
 80147c4:	19a3      	adds	r3, r4, r6
 80147c6:	9503      	str	r5, [sp, #12]
 80147c8:	9401      	str	r4, [sp, #4]
 80147ca:	9307      	str	r3, [sp, #28]
 80147cc:	9b07      	ldr	r3, [sp, #28]
 80147ce:	9901      	ldr	r1, [sp, #4]
 80147d0:	4299      	cmp	r1, r3
 80147d2:	d311      	bcc.n	80147f8 <__multiply+0x82>
 80147d4:	9b02      	ldr	r3, [sp, #8]
 80147d6:	2b00      	cmp	r3, #0
 80147d8:	dd06      	ble.n	80147e8 <__multiply+0x72>
 80147da:	2304      	movs	r3, #4
 80147dc:	425b      	negs	r3, r3
 80147de:	449c      	add	ip, r3
 80147e0:	4663      	mov	r3, ip
 80147e2:	681b      	ldr	r3, [r3, #0]
 80147e4:	2b00      	cmp	r3, #0
 80147e6:	d051      	beq.n	801488c <__multiply+0x116>
 80147e8:	9b04      	ldr	r3, [sp, #16]
 80147ea:	9a02      	ldr	r2, [sp, #8]
 80147ec:	0018      	movs	r0, r3
 80147ee:	611a      	str	r2, [r3, #16]
 80147f0:	b009      	add	sp, #36	; 0x24
 80147f2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80147f4:	c302      	stmia	r3!, {r1}
 80147f6:	e7dd      	b.n	80147b4 <__multiply+0x3e>
 80147f8:	9b01      	ldr	r3, [sp, #4]
 80147fa:	681b      	ldr	r3, [r3, #0]
 80147fc:	b298      	uxth	r0, r3
 80147fe:	2800      	cmp	r0, #0
 8014800:	d01c      	beq.n	801483c <__multiply+0xc6>
 8014802:	0015      	movs	r5, r2
 8014804:	2600      	movs	r6, #0
 8014806:	9f03      	ldr	r7, [sp, #12]
 8014808:	cf02      	ldmia	r7!, {r1}
 801480a:	682c      	ldr	r4, [r5, #0]
 801480c:	b28b      	uxth	r3, r1
 801480e:	4343      	muls	r3, r0
 8014810:	0c09      	lsrs	r1, r1, #16
 8014812:	4341      	muls	r1, r0
 8014814:	b2a4      	uxth	r4, r4
 8014816:	191b      	adds	r3, r3, r4
 8014818:	199b      	adds	r3, r3, r6
 801481a:	000e      	movs	r6, r1
 801481c:	6829      	ldr	r1, [r5, #0]
 801481e:	9506      	str	r5, [sp, #24]
 8014820:	0c09      	lsrs	r1, r1, #16
 8014822:	1871      	adds	r1, r6, r1
 8014824:	0c1e      	lsrs	r6, r3, #16
 8014826:	1989      	adds	r1, r1, r6
 8014828:	0c0e      	lsrs	r6, r1, #16
 801482a:	b29b      	uxth	r3, r3
 801482c:	0409      	lsls	r1, r1, #16
 801482e:	430b      	orrs	r3, r1
 8014830:	c508      	stmia	r5!, {r3}
 8014832:	9b05      	ldr	r3, [sp, #20]
 8014834:	42bb      	cmp	r3, r7
 8014836:	d8e7      	bhi.n	8014808 <__multiply+0x92>
 8014838:	9b06      	ldr	r3, [sp, #24]
 801483a:	605e      	str	r6, [r3, #4]
 801483c:	9b01      	ldr	r3, [sp, #4]
 801483e:	681b      	ldr	r3, [r3, #0]
 8014840:	0c1d      	lsrs	r5, r3, #16
 8014842:	d01e      	beq.n	8014882 <__multiply+0x10c>
 8014844:	0010      	movs	r0, r2
 8014846:	2700      	movs	r7, #0
 8014848:	6813      	ldr	r3, [r2, #0]
 801484a:	9e03      	ldr	r6, [sp, #12]
 801484c:	6831      	ldr	r1, [r6, #0]
 801484e:	6804      	ldr	r4, [r0, #0]
 8014850:	b289      	uxth	r1, r1
 8014852:	4369      	muls	r1, r5
 8014854:	0c24      	lsrs	r4, r4, #16
 8014856:	1909      	adds	r1, r1, r4
 8014858:	19c9      	adds	r1, r1, r7
 801485a:	040f      	lsls	r7, r1, #16
 801485c:	b29b      	uxth	r3, r3
 801485e:	433b      	orrs	r3, r7
 8014860:	6003      	str	r3, [r0, #0]
 8014862:	ce80      	ldmia	r6!, {r7}
 8014864:	6843      	ldr	r3, [r0, #4]
 8014866:	0c3f      	lsrs	r7, r7, #16
 8014868:	436f      	muls	r7, r5
 801486a:	b29b      	uxth	r3, r3
 801486c:	18fb      	adds	r3, r7, r3
 801486e:	0c09      	lsrs	r1, r1, #16
 8014870:	185b      	adds	r3, r3, r1
 8014872:	9905      	ldr	r1, [sp, #20]
 8014874:	9006      	str	r0, [sp, #24]
 8014876:	0c1f      	lsrs	r7, r3, #16
 8014878:	3004      	adds	r0, #4
 801487a:	42b1      	cmp	r1, r6
 801487c:	d8e6      	bhi.n	801484c <__multiply+0xd6>
 801487e:	9906      	ldr	r1, [sp, #24]
 8014880:	604b      	str	r3, [r1, #4]
 8014882:	9b01      	ldr	r3, [sp, #4]
 8014884:	3204      	adds	r2, #4
 8014886:	3304      	adds	r3, #4
 8014888:	9301      	str	r3, [sp, #4]
 801488a:	e79f      	b.n	80147cc <__multiply+0x56>
 801488c:	9b02      	ldr	r3, [sp, #8]
 801488e:	3b01      	subs	r3, #1
 8014890:	9302      	str	r3, [sp, #8]
 8014892:	e79f      	b.n	80147d4 <__multiply+0x5e>

08014894 <__pow5mult>:
 8014894:	2303      	movs	r3, #3
 8014896:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8014898:	4013      	ands	r3, r2
 801489a:	0005      	movs	r5, r0
 801489c:	000e      	movs	r6, r1
 801489e:	0014      	movs	r4, r2
 80148a0:	2b00      	cmp	r3, #0
 80148a2:	d008      	beq.n	80148b6 <__pow5mult+0x22>
 80148a4:	4922      	ldr	r1, [pc, #136]	; (8014930 <__pow5mult+0x9c>)
 80148a6:	3b01      	subs	r3, #1
 80148a8:	009a      	lsls	r2, r3, #2
 80148aa:	5852      	ldr	r2, [r2, r1]
 80148ac:	2300      	movs	r3, #0
 80148ae:	0031      	movs	r1, r6
 80148b0:	f7ff fed1 	bl	8014656 <__multadd>
 80148b4:	0006      	movs	r6, r0
 80148b6:	10a3      	asrs	r3, r4, #2
 80148b8:	9301      	str	r3, [sp, #4]
 80148ba:	d036      	beq.n	801492a <__pow5mult+0x96>
 80148bc:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 80148be:	2c00      	cmp	r4, #0
 80148c0:	d107      	bne.n	80148d2 <__pow5mult+0x3e>
 80148c2:	2010      	movs	r0, #16
 80148c4:	f7ff fe6c 	bl	80145a0 <malloc>
 80148c8:	6268      	str	r0, [r5, #36]	; 0x24
 80148ca:	6044      	str	r4, [r0, #4]
 80148cc:	6084      	str	r4, [r0, #8]
 80148ce:	6004      	str	r4, [r0, #0]
 80148d0:	60c4      	str	r4, [r0, #12]
 80148d2:	6a6f      	ldr	r7, [r5, #36]	; 0x24
 80148d4:	68bc      	ldr	r4, [r7, #8]
 80148d6:	2c00      	cmp	r4, #0
 80148d8:	d107      	bne.n	80148ea <__pow5mult+0x56>
 80148da:	4916      	ldr	r1, [pc, #88]	; (8014934 <__pow5mult+0xa0>)
 80148dc:	0028      	movs	r0, r5
 80148de:	f7ff ff41 	bl	8014764 <__i2b>
 80148e2:	2300      	movs	r3, #0
 80148e4:	0004      	movs	r4, r0
 80148e6:	60b8      	str	r0, [r7, #8]
 80148e8:	6003      	str	r3, [r0, #0]
 80148ea:	2201      	movs	r2, #1
 80148ec:	9b01      	ldr	r3, [sp, #4]
 80148ee:	4213      	tst	r3, r2
 80148f0:	d00a      	beq.n	8014908 <__pow5mult+0x74>
 80148f2:	0031      	movs	r1, r6
 80148f4:	0022      	movs	r2, r4
 80148f6:	0028      	movs	r0, r5
 80148f8:	f7ff ff3d 	bl	8014776 <__multiply>
 80148fc:	0007      	movs	r7, r0
 80148fe:	0031      	movs	r1, r6
 8014900:	0028      	movs	r0, r5
 8014902:	f7ff fe8f 	bl	8014624 <_Bfree>
 8014906:	003e      	movs	r6, r7
 8014908:	9b01      	ldr	r3, [sp, #4]
 801490a:	105b      	asrs	r3, r3, #1
 801490c:	9301      	str	r3, [sp, #4]
 801490e:	d00c      	beq.n	801492a <__pow5mult+0x96>
 8014910:	6820      	ldr	r0, [r4, #0]
 8014912:	2800      	cmp	r0, #0
 8014914:	d107      	bne.n	8014926 <__pow5mult+0x92>
 8014916:	0022      	movs	r2, r4
 8014918:	0021      	movs	r1, r4
 801491a:	0028      	movs	r0, r5
 801491c:	f7ff ff2b 	bl	8014776 <__multiply>
 8014920:	2300      	movs	r3, #0
 8014922:	6020      	str	r0, [r4, #0]
 8014924:	6003      	str	r3, [r0, #0]
 8014926:	0004      	movs	r4, r0
 8014928:	e7df      	b.n	80148ea <__pow5mult+0x56>
 801492a:	0030      	movs	r0, r6
 801492c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 801492e:	46c0      	nop			; (mov r8, r8)
 8014930:	08015310 	.word	0x08015310
 8014934:	00000271 	.word	0x00000271

08014938 <__lshift>:
 8014938:	b5f0      	push	{r4, r5, r6, r7, lr}
 801493a:	000d      	movs	r5, r1
 801493c:	0017      	movs	r7, r2
 801493e:	692b      	ldr	r3, [r5, #16]
 8014940:	1154      	asrs	r4, r2, #5
 8014942:	b085      	sub	sp, #20
 8014944:	18e3      	adds	r3, r4, r3
 8014946:	9301      	str	r3, [sp, #4]
 8014948:	3301      	adds	r3, #1
 801494a:	9300      	str	r3, [sp, #0]
 801494c:	6849      	ldr	r1, [r1, #4]
 801494e:	68ab      	ldr	r3, [r5, #8]
 8014950:	9002      	str	r0, [sp, #8]
 8014952:	9a00      	ldr	r2, [sp, #0]
 8014954:	4293      	cmp	r3, r2
 8014956:	db35      	blt.n	80149c4 <__lshift+0x8c>
 8014958:	9802      	ldr	r0, [sp, #8]
 801495a:	f7ff fe2b 	bl	80145b4 <_Balloc>
 801495e:	2300      	movs	r3, #0
 8014960:	0002      	movs	r2, r0
 8014962:	0006      	movs	r6, r0
 8014964:	0019      	movs	r1, r3
 8014966:	3214      	adds	r2, #20
 8014968:	42a3      	cmp	r3, r4
 801496a:	db2e      	blt.n	80149ca <__lshift+0x92>
 801496c:	43e3      	mvns	r3, r4
 801496e:	17db      	asrs	r3, r3, #31
 8014970:	401c      	ands	r4, r3
 8014972:	002b      	movs	r3, r5
 8014974:	00a4      	lsls	r4, r4, #2
 8014976:	1914      	adds	r4, r2, r4
 8014978:	692a      	ldr	r2, [r5, #16]
 801497a:	3314      	adds	r3, #20
 801497c:	0092      	lsls	r2, r2, #2
 801497e:	189a      	adds	r2, r3, r2
 8014980:	4694      	mov	ip, r2
 8014982:	221f      	movs	r2, #31
 8014984:	4017      	ands	r7, r2
 8014986:	d024      	beq.n	80149d2 <__lshift+0x9a>
 8014988:	3201      	adds	r2, #1
 801498a:	1bd2      	subs	r2, r2, r7
 801498c:	9203      	str	r2, [sp, #12]
 801498e:	2200      	movs	r2, #0
 8014990:	6819      	ldr	r1, [r3, #0]
 8014992:	0020      	movs	r0, r4
 8014994:	40b9      	lsls	r1, r7
 8014996:	430a      	orrs	r2, r1
 8014998:	c404      	stmia	r4!, {r2}
 801499a:	cb04      	ldmia	r3!, {r2}
 801499c:	9903      	ldr	r1, [sp, #12]
 801499e:	40ca      	lsrs	r2, r1
 80149a0:	459c      	cmp	ip, r3
 80149a2:	d8f5      	bhi.n	8014990 <__lshift+0x58>
 80149a4:	6042      	str	r2, [r0, #4]
 80149a6:	2a00      	cmp	r2, #0
 80149a8:	d002      	beq.n	80149b0 <__lshift+0x78>
 80149aa:	9b01      	ldr	r3, [sp, #4]
 80149ac:	3302      	adds	r3, #2
 80149ae:	9300      	str	r3, [sp, #0]
 80149b0:	9b00      	ldr	r3, [sp, #0]
 80149b2:	9802      	ldr	r0, [sp, #8]
 80149b4:	3b01      	subs	r3, #1
 80149b6:	6133      	str	r3, [r6, #16]
 80149b8:	0029      	movs	r1, r5
 80149ba:	f7ff fe33 	bl	8014624 <_Bfree>
 80149be:	0030      	movs	r0, r6
 80149c0:	b005      	add	sp, #20
 80149c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80149c4:	3101      	adds	r1, #1
 80149c6:	005b      	lsls	r3, r3, #1
 80149c8:	e7c3      	b.n	8014952 <__lshift+0x1a>
 80149ca:	0098      	lsls	r0, r3, #2
 80149cc:	5011      	str	r1, [r2, r0]
 80149ce:	3301      	adds	r3, #1
 80149d0:	e7ca      	b.n	8014968 <__lshift+0x30>
 80149d2:	cb04      	ldmia	r3!, {r2}
 80149d4:	c404      	stmia	r4!, {r2}
 80149d6:	459c      	cmp	ip, r3
 80149d8:	d8fb      	bhi.n	80149d2 <__lshift+0x9a>
 80149da:	e7e9      	b.n	80149b0 <__lshift+0x78>

080149dc <__mcmp>:
 80149dc:	690a      	ldr	r2, [r1, #16]
 80149de:	6903      	ldr	r3, [r0, #16]
 80149e0:	b530      	push	{r4, r5, lr}
 80149e2:	1a9b      	subs	r3, r3, r2
 80149e4:	d10d      	bne.n	8014a02 <__mcmp+0x26>
 80149e6:	0092      	lsls	r2, r2, #2
 80149e8:	3014      	adds	r0, #20
 80149ea:	3114      	adds	r1, #20
 80149ec:	1884      	adds	r4, r0, r2
 80149ee:	1889      	adds	r1, r1, r2
 80149f0:	3c04      	subs	r4, #4
 80149f2:	3904      	subs	r1, #4
 80149f4:	6825      	ldr	r5, [r4, #0]
 80149f6:	680a      	ldr	r2, [r1, #0]
 80149f8:	4295      	cmp	r5, r2
 80149fa:	d004      	beq.n	8014a06 <__mcmp+0x2a>
 80149fc:	2301      	movs	r3, #1
 80149fe:	4295      	cmp	r5, r2
 8014a00:	d304      	bcc.n	8014a0c <__mcmp+0x30>
 8014a02:	0018      	movs	r0, r3
 8014a04:	bd30      	pop	{r4, r5, pc}
 8014a06:	42a0      	cmp	r0, r4
 8014a08:	d3f2      	bcc.n	80149f0 <__mcmp+0x14>
 8014a0a:	e7fa      	b.n	8014a02 <__mcmp+0x26>
 8014a0c:	425b      	negs	r3, r3
 8014a0e:	e7f8      	b.n	8014a02 <__mcmp+0x26>

08014a10 <__mdiff>:
 8014a10:	b5f0      	push	{r4, r5, r6, r7, lr}
 8014a12:	000d      	movs	r5, r1
 8014a14:	b085      	sub	sp, #20
 8014a16:	0007      	movs	r7, r0
 8014a18:	0011      	movs	r1, r2
 8014a1a:	0028      	movs	r0, r5
 8014a1c:	0014      	movs	r4, r2
 8014a1e:	f7ff ffdd 	bl	80149dc <__mcmp>
 8014a22:	1e06      	subs	r6, r0, #0
 8014a24:	d108      	bne.n	8014a38 <__mdiff+0x28>
 8014a26:	0001      	movs	r1, r0
 8014a28:	0038      	movs	r0, r7
 8014a2a:	f7ff fdc3 	bl	80145b4 <_Balloc>
 8014a2e:	2301      	movs	r3, #1
 8014a30:	6146      	str	r6, [r0, #20]
 8014a32:	6103      	str	r3, [r0, #16]
 8014a34:	b005      	add	sp, #20
 8014a36:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8014a38:	2301      	movs	r3, #1
 8014a3a:	9301      	str	r3, [sp, #4]
 8014a3c:	2800      	cmp	r0, #0
 8014a3e:	db04      	blt.n	8014a4a <__mdiff+0x3a>
 8014a40:	0023      	movs	r3, r4
 8014a42:	002c      	movs	r4, r5
 8014a44:	001d      	movs	r5, r3
 8014a46:	2300      	movs	r3, #0
 8014a48:	9301      	str	r3, [sp, #4]
 8014a4a:	6861      	ldr	r1, [r4, #4]
 8014a4c:	0038      	movs	r0, r7
 8014a4e:	f7ff fdb1 	bl	80145b4 <_Balloc>
 8014a52:	002f      	movs	r7, r5
 8014a54:	2200      	movs	r2, #0
 8014a56:	9b01      	ldr	r3, [sp, #4]
 8014a58:	6926      	ldr	r6, [r4, #16]
 8014a5a:	60c3      	str	r3, [r0, #12]
 8014a5c:	3414      	adds	r4, #20
 8014a5e:	00b3      	lsls	r3, r6, #2
 8014a60:	18e3      	adds	r3, r4, r3
 8014a62:	9302      	str	r3, [sp, #8]
 8014a64:	692b      	ldr	r3, [r5, #16]
 8014a66:	3714      	adds	r7, #20
 8014a68:	009b      	lsls	r3, r3, #2
 8014a6a:	18fb      	adds	r3, r7, r3
 8014a6c:	9303      	str	r3, [sp, #12]
 8014a6e:	0003      	movs	r3, r0
 8014a70:	4694      	mov	ip, r2
 8014a72:	3314      	adds	r3, #20
 8014a74:	cc20      	ldmia	r4!, {r5}
 8014a76:	cf04      	ldmia	r7!, {r2}
 8014a78:	9201      	str	r2, [sp, #4]
 8014a7a:	b2aa      	uxth	r2, r5
 8014a7c:	4494      	add	ip, r2
 8014a7e:	466a      	mov	r2, sp
 8014a80:	4661      	mov	r1, ip
 8014a82:	8892      	ldrh	r2, [r2, #4]
 8014a84:	0c2d      	lsrs	r5, r5, #16
 8014a86:	1a8a      	subs	r2, r1, r2
 8014a88:	9901      	ldr	r1, [sp, #4]
 8014a8a:	0c09      	lsrs	r1, r1, #16
 8014a8c:	1a69      	subs	r1, r5, r1
 8014a8e:	1415      	asrs	r5, r2, #16
 8014a90:	1949      	adds	r1, r1, r5
 8014a92:	140d      	asrs	r5, r1, #16
 8014a94:	b292      	uxth	r2, r2
 8014a96:	0409      	lsls	r1, r1, #16
 8014a98:	430a      	orrs	r2, r1
 8014a9a:	601a      	str	r2, [r3, #0]
 8014a9c:	9a03      	ldr	r2, [sp, #12]
 8014a9e:	46ac      	mov	ip, r5
 8014aa0:	3304      	adds	r3, #4
 8014aa2:	42ba      	cmp	r2, r7
 8014aa4:	d8e6      	bhi.n	8014a74 <__mdiff+0x64>
 8014aa6:	9902      	ldr	r1, [sp, #8]
 8014aa8:	001a      	movs	r2, r3
 8014aaa:	428c      	cmp	r4, r1
 8014aac:	d305      	bcc.n	8014aba <__mdiff+0xaa>
 8014aae:	3a04      	subs	r2, #4
 8014ab0:	6813      	ldr	r3, [r2, #0]
 8014ab2:	2b00      	cmp	r3, #0
 8014ab4:	d00e      	beq.n	8014ad4 <__mdiff+0xc4>
 8014ab6:	6106      	str	r6, [r0, #16]
 8014ab8:	e7bc      	b.n	8014a34 <__mdiff+0x24>
 8014aba:	cc04      	ldmia	r4!, {r2}
 8014abc:	b291      	uxth	r1, r2
 8014abe:	4461      	add	r1, ip
 8014ac0:	140d      	asrs	r5, r1, #16
 8014ac2:	0c12      	lsrs	r2, r2, #16
 8014ac4:	1952      	adds	r2, r2, r5
 8014ac6:	1415      	asrs	r5, r2, #16
 8014ac8:	b289      	uxth	r1, r1
 8014aca:	0412      	lsls	r2, r2, #16
 8014acc:	430a      	orrs	r2, r1
 8014ace:	46ac      	mov	ip, r5
 8014ad0:	c304      	stmia	r3!, {r2}
 8014ad2:	e7e8      	b.n	8014aa6 <__mdiff+0x96>
 8014ad4:	3e01      	subs	r6, #1
 8014ad6:	e7ea      	b.n	8014aae <__mdiff+0x9e>

08014ad8 <__d2b>:
 8014ad8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8014ada:	001d      	movs	r5, r3
 8014adc:	2101      	movs	r1, #1
 8014ade:	0014      	movs	r4, r2
 8014ae0:	9f08      	ldr	r7, [sp, #32]
 8014ae2:	f7ff fd67 	bl	80145b4 <_Balloc>
 8014ae6:	032b      	lsls	r3, r5, #12
 8014ae8:	006d      	lsls	r5, r5, #1
 8014aea:	0006      	movs	r6, r0
 8014aec:	0b1b      	lsrs	r3, r3, #12
 8014aee:	0d6d      	lsrs	r5, r5, #21
 8014af0:	d124      	bne.n	8014b3c <__d2b+0x64>
 8014af2:	9301      	str	r3, [sp, #4]
 8014af4:	2c00      	cmp	r4, #0
 8014af6:	d027      	beq.n	8014b48 <__d2b+0x70>
 8014af8:	4668      	mov	r0, sp
 8014afa:	9400      	str	r4, [sp, #0]
 8014afc:	f7ff fe03 	bl	8014706 <__lo0bits>
 8014b00:	9c00      	ldr	r4, [sp, #0]
 8014b02:	2800      	cmp	r0, #0
 8014b04:	d01e      	beq.n	8014b44 <__d2b+0x6c>
 8014b06:	9b01      	ldr	r3, [sp, #4]
 8014b08:	2120      	movs	r1, #32
 8014b0a:	001a      	movs	r2, r3
 8014b0c:	1a09      	subs	r1, r1, r0
 8014b0e:	408a      	lsls	r2, r1
 8014b10:	40c3      	lsrs	r3, r0
 8014b12:	4322      	orrs	r2, r4
 8014b14:	6172      	str	r2, [r6, #20]
 8014b16:	9301      	str	r3, [sp, #4]
 8014b18:	9c01      	ldr	r4, [sp, #4]
 8014b1a:	61b4      	str	r4, [r6, #24]
 8014b1c:	1e63      	subs	r3, r4, #1
 8014b1e:	419c      	sbcs	r4, r3
 8014b20:	3401      	adds	r4, #1
 8014b22:	6134      	str	r4, [r6, #16]
 8014b24:	2d00      	cmp	r5, #0
 8014b26:	d018      	beq.n	8014b5a <__d2b+0x82>
 8014b28:	4b12      	ldr	r3, [pc, #72]	; (8014b74 <__d2b+0x9c>)
 8014b2a:	18ed      	adds	r5, r5, r3
 8014b2c:	2335      	movs	r3, #53	; 0x35
 8014b2e:	182d      	adds	r5, r5, r0
 8014b30:	603d      	str	r5, [r7, #0]
 8014b32:	1a18      	subs	r0, r3, r0
 8014b34:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8014b36:	6018      	str	r0, [r3, #0]
 8014b38:	0030      	movs	r0, r6
 8014b3a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8014b3c:	2280      	movs	r2, #128	; 0x80
 8014b3e:	0352      	lsls	r2, r2, #13
 8014b40:	4313      	orrs	r3, r2
 8014b42:	e7d6      	b.n	8014af2 <__d2b+0x1a>
 8014b44:	6174      	str	r4, [r6, #20]
 8014b46:	e7e7      	b.n	8014b18 <__d2b+0x40>
 8014b48:	a801      	add	r0, sp, #4
 8014b4a:	f7ff fddc 	bl	8014706 <__lo0bits>
 8014b4e:	2401      	movs	r4, #1
 8014b50:	9b01      	ldr	r3, [sp, #4]
 8014b52:	6134      	str	r4, [r6, #16]
 8014b54:	6173      	str	r3, [r6, #20]
 8014b56:	3020      	adds	r0, #32
 8014b58:	e7e4      	b.n	8014b24 <__d2b+0x4c>
 8014b5a:	4b07      	ldr	r3, [pc, #28]	; (8014b78 <__d2b+0xa0>)
 8014b5c:	18c0      	adds	r0, r0, r3
 8014b5e:	4b07      	ldr	r3, [pc, #28]	; (8014b7c <__d2b+0xa4>)
 8014b60:	6038      	str	r0, [r7, #0]
 8014b62:	18e3      	adds	r3, r4, r3
 8014b64:	009b      	lsls	r3, r3, #2
 8014b66:	18f3      	adds	r3, r6, r3
 8014b68:	6958      	ldr	r0, [r3, #20]
 8014b6a:	f7ff fdb2 	bl	80146d2 <__hi0bits>
 8014b6e:	0164      	lsls	r4, r4, #5
 8014b70:	1a20      	subs	r0, r4, r0
 8014b72:	e7df      	b.n	8014b34 <__d2b+0x5c>
 8014b74:	fffffbcd 	.word	0xfffffbcd
 8014b78:	fffffbce 	.word	0xfffffbce
 8014b7c:	3fffffff 	.word	0x3fffffff

08014b80 <_calloc_r>:
 8014b80:	434a      	muls	r2, r1
 8014b82:	b570      	push	{r4, r5, r6, lr}
 8014b84:	0011      	movs	r1, r2
 8014b86:	0014      	movs	r4, r2
 8014b88:	f000 f808 	bl	8014b9c <_malloc_r>
 8014b8c:	1e05      	subs	r5, r0, #0
 8014b8e:	d003      	beq.n	8014b98 <_calloc_r+0x18>
 8014b90:	0022      	movs	r2, r4
 8014b92:	2100      	movs	r1, #0
 8014b94:	f7fe fb1f 	bl	80131d6 <memset>
 8014b98:	0028      	movs	r0, r5
 8014b9a:	bd70      	pop	{r4, r5, r6, pc}

08014b9c <_malloc_r>:
 8014b9c:	2303      	movs	r3, #3
 8014b9e:	b570      	push	{r4, r5, r6, lr}
 8014ba0:	1ccd      	adds	r5, r1, #3
 8014ba2:	439d      	bics	r5, r3
 8014ba4:	3508      	adds	r5, #8
 8014ba6:	0006      	movs	r6, r0
 8014ba8:	2d0c      	cmp	r5, #12
 8014baa:	d21e      	bcs.n	8014bea <_malloc_r+0x4e>
 8014bac:	250c      	movs	r5, #12
 8014bae:	42a9      	cmp	r1, r5
 8014bb0:	d81d      	bhi.n	8014bee <_malloc_r+0x52>
 8014bb2:	0030      	movs	r0, r6
 8014bb4:	f000 f874 	bl	8014ca0 <__malloc_lock>
 8014bb8:	4a25      	ldr	r2, [pc, #148]	; (8014c50 <_malloc_r+0xb4>)
 8014bba:	6814      	ldr	r4, [r2, #0]
 8014bbc:	0021      	movs	r1, r4
 8014bbe:	2900      	cmp	r1, #0
 8014bc0:	d119      	bne.n	8014bf6 <_malloc_r+0x5a>
 8014bc2:	4c24      	ldr	r4, [pc, #144]	; (8014c54 <_malloc_r+0xb8>)
 8014bc4:	6823      	ldr	r3, [r4, #0]
 8014bc6:	2b00      	cmp	r3, #0
 8014bc8:	d103      	bne.n	8014bd2 <_malloc_r+0x36>
 8014bca:	0030      	movs	r0, r6
 8014bcc:	f000 f844 	bl	8014c58 <_sbrk_r>
 8014bd0:	6020      	str	r0, [r4, #0]
 8014bd2:	0029      	movs	r1, r5
 8014bd4:	0030      	movs	r0, r6
 8014bd6:	f000 f83f 	bl	8014c58 <_sbrk_r>
 8014bda:	1c43      	adds	r3, r0, #1
 8014bdc:	d12b      	bne.n	8014c36 <_malloc_r+0x9a>
 8014bde:	230c      	movs	r3, #12
 8014be0:	0030      	movs	r0, r6
 8014be2:	6033      	str	r3, [r6, #0]
 8014be4:	f000 f85d 	bl	8014ca2 <__malloc_unlock>
 8014be8:	e003      	b.n	8014bf2 <_malloc_r+0x56>
 8014bea:	2d00      	cmp	r5, #0
 8014bec:	dadf      	bge.n	8014bae <_malloc_r+0x12>
 8014bee:	230c      	movs	r3, #12
 8014bf0:	6033      	str	r3, [r6, #0]
 8014bf2:	2000      	movs	r0, #0
 8014bf4:	bd70      	pop	{r4, r5, r6, pc}
 8014bf6:	680b      	ldr	r3, [r1, #0]
 8014bf8:	1b5b      	subs	r3, r3, r5
 8014bfa:	d419      	bmi.n	8014c30 <_malloc_r+0x94>
 8014bfc:	2b0b      	cmp	r3, #11
 8014bfe:	d903      	bls.n	8014c08 <_malloc_r+0x6c>
 8014c00:	600b      	str	r3, [r1, #0]
 8014c02:	18cc      	adds	r4, r1, r3
 8014c04:	6025      	str	r5, [r4, #0]
 8014c06:	e003      	b.n	8014c10 <_malloc_r+0x74>
 8014c08:	684b      	ldr	r3, [r1, #4]
 8014c0a:	428c      	cmp	r4, r1
 8014c0c:	d10d      	bne.n	8014c2a <_malloc_r+0x8e>
 8014c0e:	6013      	str	r3, [r2, #0]
 8014c10:	0030      	movs	r0, r6
 8014c12:	f000 f846 	bl	8014ca2 <__malloc_unlock>
 8014c16:	0020      	movs	r0, r4
 8014c18:	2207      	movs	r2, #7
 8014c1a:	300b      	adds	r0, #11
 8014c1c:	1d23      	adds	r3, r4, #4
 8014c1e:	4390      	bics	r0, r2
 8014c20:	1ac3      	subs	r3, r0, r3
 8014c22:	d0e7      	beq.n	8014bf4 <_malloc_r+0x58>
 8014c24:	425a      	negs	r2, r3
 8014c26:	50e2      	str	r2, [r4, r3]
 8014c28:	e7e4      	b.n	8014bf4 <_malloc_r+0x58>
 8014c2a:	6063      	str	r3, [r4, #4]
 8014c2c:	000c      	movs	r4, r1
 8014c2e:	e7ef      	b.n	8014c10 <_malloc_r+0x74>
 8014c30:	000c      	movs	r4, r1
 8014c32:	6849      	ldr	r1, [r1, #4]
 8014c34:	e7c3      	b.n	8014bbe <_malloc_r+0x22>
 8014c36:	2303      	movs	r3, #3
 8014c38:	1cc4      	adds	r4, r0, #3
 8014c3a:	439c      	bics	r4, r3
 8014c3c:	42a0      	cmp	r0, r4
 8014c3e:	d0e1      	beq.n	8014c04 <_malloc_r+0x68>
 8014c40:	1a21      	subs	r1, r4, r0
 8014c42:	0030      	movs	r0, r6
 8014c44:	f000 f808 	bl	8014c58 <_sbrk_r>
 8014c48:	1c43      	adds	r3, r0, #1
 8014c4a:	d1db      	bne.n	8014c04 <_malloc_r+0x68>
 8014c4c:	e7c7      	b.n	8014bde <_malloc_r+0x42>
 8014c4e:	46c0      	nop			; (mov r8, r8)
 8014c50:	20000468 	.word	0x20000468
 8014c54:	2000046c 	.word	0x2000046c

08014c58 <_sbrk_r>:
 8014c58:	2300      	movs	r3, #0
 8014c5a:	b570      	push	{r4, r5, r6, lr}
 8014c5c:	4c06      	ldr	r4, [pc, #24]	; (8014c78 <_sbrk_r+0x20>)
 8014c5e:	0005      	movs	r5, r0
 8014c60:	0008      	movs	r0, r1
 8014c62:	6023      	str	r3, [r4, #0]
 8014c64:	f7f1 f992 	bl	8005f8c <_sbrk>
 8014c68:	1c43      	adds	r3, r0, #1
 8014c6a:	d103      	bne.n	8014c74 <_sbrk_r+0x1c>
 8014c6c:	6823      	ldr	r3, [r4, #0]
 8014c6e:	2b00      	cmp	r3, #0
 8014c70:	d000      	beq.n	8014c74 <_sbrk_r+0x1c>
 8014c72:	602b      	str	r3, [r5, #0]
 8014c74:	bd70      	pop	{r4, r5, r6, pc}
 8014c76:	46c0      	nop			; (mov r8, r8)
 8014c78:	20003444 	.word	0x20003444

08014c7c <__ascii_mbtowc>:
 8014c7c:	b082      	sub	sp, #8
 8014c7e:	2900      	cmp	r1, #0
 8014c80:	d100      	bne.n	8014c84 <__ascii_mbtowc+0x8>
 8014c82:	a901      	add	r1, sp, #4
 8014c84:	1e10      	subs	r0, r2, #0
 8014c86:	d006      	beq.n	8014c96 <__ascii_mbtowc+0x1a>
 8014c88:	2b00      	cmp	r3, #0
 8014c8a:	d006      	beq.n	8014c9a <__ascii_mbtowc+0x1e>
 8014c8c:	7813      	ldrb	r3, [r2, #0]
 8014c8e:	600b      	str	r3, [r1, #0]
 8014c90:	7810      	ldrb	r0, [r2, #0]
 8014c92:	1e43      	subs	r3, r0, #1
 8014c94:	4198      	sbcs	r0, r3
 8014c96:	b002      	add	sp, #8
 8014c98:	4770      	bx	lr
 8014c9a:	2002      	movs	r0, #2
 8014c9c:	4240      	negs	r0, r0
 8014c9e:	e7fa      	b.n	8014c96 <__ascii_mbtowc+0x1a>

08014ca0 <__malloc_lock>:
 8014ca0:	4770      	bx	lr

08014ca2 <__malloc_unlock>:
 8014ca2:	4770      	bx	lr

08014ca4 <__ascii_wctomb>:
 8014ca4:	1e0b      	subs	r3, r1, #0
 8014ca6:	d004      	beq.n	8014cb2 <__ascii_wctomb+0xe>
 8014ca8:	2aff      	cmp	r2, #255	; 0xff
 8014caa:	d904      	bls.n	8014cb6 <__ascii_wctomb+0x12>
 8014cac:	238a      	movs	r3, #138	; 0x8a
 8014cae:	6003      	str	r3, [r0, #0]
 8014cb0:	3b8b      	subs	r3, #139	; 0x8b
 8014cb2:	0018      	movs	r0, r3
 8014cb4:	4770      	bx	lr
 8014cb6:	700a      	strb	r2, [r1, #0]
 8014cb8:	2301      	movs	r3, #1
 8014cba:	e7fa      	b.n	8014cb2 <__ascii_wctomb+0xe>

08014cbc <_init>:
 8014cbc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8014cbe:	46c0      	nop			; (mov r8, r8)
 8014cc0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8014cc2:	bc08      	pop	{r3}
 8014cc4:	469e      	mov	lr, r3
 8014cc6:	4770      	bx	lr

08014cc8 <_fini>:
 8014cc8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8014cca:	46c0      	nop			; (mov r8, r8)
 8014ccc:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8014cce:	bc08      	pop	{r3}
 8014cd0:	469e      	mov	lr, r3
 8014cd2:	4770      	bx	lr
